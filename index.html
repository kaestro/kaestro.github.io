<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/pages/index-3affe97b81430d2a.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Kaestro&#x27;s BlackSmith</h1><h1 class="project-subtitle">프로그래밍을 단련하고, 기록하는 공간</h1></header><main id="content" class="main-content"><div class="grid lg:grid-cols-2 grid-cols-1 gap-4"><div class="p-4 rounded-md"><h2 class="font-bold mb-4" style="color:black">추천 글</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">API Server For ChatApplication</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">re: 제로부터 시작하는 기술 블로그(1)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">지난 3개월을 돌아보며</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">저는 외로워서 퇴사를 했고, 이젠 아닙니다</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->8<!-- -->) in 추천 글</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">신변잡기</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">비어있는 공백기가 아니라 충만했던 탐색기(2)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">작고 소중한 28회의 클릭</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">비어있는 공백기가 아니라 충만했던 탐색기(1)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">정리를 통해 잠만 자는 공간에서 나로써 존재할 수 있는 공간으로</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">합격보다 소통을 목표로 하는 면접을 위하여(3)</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->14<!-- -->) in <!-- -->신변잡기</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">개발일지</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">ChatApplication Review(11)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">ChatApplication Review(10)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">re: 제로부터 시작하는 기술 블로그(3)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">re: 제로부터 시작하는 기술 블로그(2)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">re: 제로부터 시작하는 기술 블로그(1)</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->18<!-- -->) in <!-- -->개발일지</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">서평</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">스틱!</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">구글 엔지니어는 이렇게 일한다</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">가상 면접 사례로 배우는 대규모 시스템 설계 기초</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">데이터 중심 애플리케이션 설계</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->11<!-- -->) in <!-- -->서평</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">개발이야기</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">인체공학을 염두에 둔 내 pc용 책상 세팅(2)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">인체공학을 염두에 둔 내 pc용 책상 세팅(1)</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">docker mount: volume vs bind</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">Locust vs k6 - 부하 테스트 도구 선택</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->10<!-- -->) in <!-- -->개발이야기</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">게임이야기</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">게임은 어떻게 두려움을 통해 유저를 영웅으로 만드는가</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">전술을 수립하고 룸매치를 통해 최종 점검하자</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">인자작 없는 육성은 도박이다</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">200만원으로 우마무스메 12/15관을 달성한 비결</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">전투로 극복한 rpg의 한계</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->7<!-- -->) in <!-- -->게임이야기</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">디자인패턴</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">프록시 패턴</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">컴포지트 패턴</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">상태 패턴</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">반복자 패턴</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">템플릿 메소드 패턴</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->14<!-- -->) in <!-- -->디자인패턴</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">Algorithm</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">5월 2주차 알고리즘 문제</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">Graph</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">Introduction to Shortest Path algorithm</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">Bellman-ford algorithm</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">Dijkstra algorithm</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->13<!-- -->) in <!-- -->Algorithm</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">WeeklyPosts</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">5월 2주차 포스트</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">5월 1주차 포스트</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">4월 4주차 포스트</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">4월 3주차 포스트</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">4월 2주차 포스트</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->14<!-- -->) in <!-- -->WeeklyPosts</p></div><div class="p-4 rounded-md"><h2 class="font-bold mb-4">ETC</h2><hr class="mb-4 border-gray-300"/><div class="space-y-0"><p class="text-blue-500 hover:underline cursor-pointer !mb-0">최근 내 삶을 바꾼 제품들 총 6선</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">반항이 소멸하는 세상에서 가운데 손가락을 치켜세우는 소녀들</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">kubernetes 용어 정리</p><p class="text-blue-500 hover:underline cursor-pointer !mb-0">쿠버네티스 교과서</p></div><p class="mt-4 text-blue-500 hover:underline cursor-pointer font-bold">see all posts(<!-- -->4<!-- -->) in <!-- -->ETC</p></div></div><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/신변잡기">신변잡기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/서평">서평</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/게임이야기">게임이야기</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/ETC">ETC</a></li></ul></aside></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postsJson":[{"postName":"2024-05-04-최근 내 삶을 바꾼 제품들","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/etc/2024-05-04-최근 내 삶을 바꾼 제품들.md","category":"ETC","title":"최근 내 삶을 바꾼 제품들 총 6선","subtitle":"전구, AI에서 태블릿 pc까지","content":"\n### 목차\n\n- [개요](#개요)\n- [multiscreen block - 도둑맞은 집중력을 찾아서](#multiscreen-block---도둑맞은-집중력을-찾아서)\n- [샤오미 홈 다기능 충전식 데스크 램프 MJTD05YL - 형광등이 없는 밤을 팔다](#샤오미-홈-다기능-충전식-데스크-램프-mjtd05yl---형광등이-없는-밤을-팔다)\n- [ticktick - 자유롭게 정리하고 추적하는 일정 관리](#ticktick---자유롭게-정리하고-추적하는-일정-관리)\n- [copilot - 내 생각을 나보다 더 잘 알고 일을 마쳐두는 비서](#copilot---내-생각을-나보다-더-잘-알고-일을-마쳐두는-비서)\n- [보성 녹차 - 하루에 물을 1.5L씩 마시는 삶을 살게 되다](#보성-녹차---하루에-물을-15l씩-마시는-삶을-살게-되다)\n- [lenovo y700 2세대 - 카카오톡이 없는 7인치 만능 노트](#lenovo-y700-2세대---카카오톡이-없는-7인치-만능-노트)\n- [마치며](#마치며)\n\n---\n\n## 개요\n\n최근에 구매하거나 무료로 사용하고 있는 제품들에서 삶이 바뀌는 경험들을 한 것들이 있어 이를 공유하고, 가능하면 다른 분들은 어떤 것들을 사용하고 계신지 경험을 나누고 싶어 작성하게 됐습니다. 돈 받고 하는 광고면 좋을텐데 애석하게도 그 어느 물건도 금전을 제공받지 못한 순수한 제 주머니에서 나온 돈으로 구매해서 사용했습니다. 정리 순서는 무료부터 약 40만원대의 제품까지 가격순으로 정리했습니다.\n\n---\n\n## multiscreen block - 도둑맞은 집중력을 찾아서\n\n[공식 홈페이지](https://multiscreenblank.nookkin.com/)\n\n모니터 중 자신이 선택한 것이 검은색으로 바뀌는 프로그램입니다. 최근 집중력이 떨어진 것인지, 데스크톱에서 작업을 할 때 두 대의 모니터가 동시에 떠 있는 것이 방해가 될 때가 많아서 찾아 사용중인 어플리케이션입니다. 원래는 물리적인 방식으로 껐다 키면 이것 때문에 그래픽 카드에서 설정이 오고가고하는 딜레이도 있어 불편한 점이 꽤 많았어서 귀찮아 끄지 않을 때도 많았습니다. 사용한 이후로는 대부분의 경우에는 한 대의 모니터만을 사용하고 특별히 필요하다 싶을 때에만 두 대의 모니터를 사용하게 되어 집중력이 떨어지는 경우가 줄어들었습니다. 무료로 사용할 수 있으며, 사용법도 굉장히 간단합니다.\n\n---\n\n## 샤오미 홈 다기능 충전식 데스크 램프 MJTD05YL - 형광등이 없는 밤을 팔다\n\n![램프](https://image6.coupangcdn.com/image/vendor_inventory/1b74/7b08a9f5ad9c3d1ef0a668fecf6853e8a0e0ea421c86eebff02baf8b9064.jpg)\n\n형광등부터 시작해 수면등까지 총 4종류의 빛을 제공하는 이 램프의 특징은, 구 형태의 강력한 자석과 함께 사용 가능하단 점입니다. 이 때문에 사진에 보이는 것과 같이 스탠드에 꽂아서도 사실상 전방위로 회전 가틍하고, 침대와 같은 곳에 꽂아서 사용 가능한 클립도 있으며, 아예 거치하지 않고 손전등처럼 사용할 수 있습니다.\n\n이게 뭐가 그렇게 대단한 기능일까 싶었는데 실제로 사용해보니 이게 생긴 이후로 해가 떨어진 이후에 아예 형광등을 사용하지 않는 생활을 하는 것이 가능해졌습니다. 잠을 자는 흐름에 있어서 형광등과 같은 백색광에 적게 노출돼야한다는 말이 많은데, 실제로도 이를 이용하면서부터 수면 퀄리티가 꽤나 비약적으로 향상되는 것을 확인할 수 있었습니다.\n\n---\n\n## ticktick - 자유롭게 정리하고 추적하는 일정 관리\n\n[공식 홈페이지](https://ticktick.com/)\n\n어렸을 때 프랭플린 플래너를 쓰던 입장에서 이와 같이 내 일정을 자유롭게 관리할 수 있으면서, 디지털의 장점을 누릴 만한 일정 관리 어플리케이션은 없는가에 대해 많이 고민했었습니다. 그러던 중에 발견한 ticktick은 이 모든 것을 만족시켜주는 어플리케이션입니다. 무료로 사용할 수 있으며, 유료로 사용하면 더 많은 기능을 사용할 수 있습니다.\n\n이 어플리케이션의 장점은 다음 정도가 있습니다.\n\n1. 내가 생각한 것은 거의 다 되는 ux\n2. 다양한 플랫폼의 싱크 지원\n3. pomodoro, eisenhower matrix 등의 기능 지원\n4. 습관을 통한 자동 일정 추가\n5. 구글 캘린더와의 연동\n\n최근에 사용해 본 일정 관리 어플리케이션들 중에서 가장 만족스러운 어플리케이션이고, 이를 통해 생산성을 많이 향상시킬 수 있었습니다.\n\n---\n\n## copilot - 내 생각을 나보다 더 잘 알고 일을 마쳐두는 비서\n\n[공식 홈페이지](https://copilot.github.com/)\n\n사실 코파일럿을 사용하는 것의 장점은 다음 스크린 샷 하나면 다 설명이 되지 않나 싶습니다.\n\n![코파일럿 사용 예시](https://travis.media/images/2021/11/github-copilot-suggesting-array-function@2x.jpeg)\n\n내가 생각한 것들을 코드로 만들어내는 데 있어서 작성하려는 것을 나보다 한 발 앞서 미리 완성해놓고 대기하는 코파일럿은 가히 혁명적이고, vscode와 연동해서 사용하면 가져다주는 편의성은 다른 llm과 비교해 압도적입니다. 특히 copilot을 제대로 활용하기 위해서는 예시에서와 같이 컴퓨터가 아니라 '사람이 이해할 수 있을 법한' 네이밍을 사용해야 하기 때문에 단순히 코드 작성 시간이 줄어드는 것을 넘어서 코드의 가독성이 높아지는 것도 장점입니다.\n\n---\n\n## 보성 녹차 - 하루에 물을 1.5L씩 마시는 삶을 살게 되다\n\n요 근래 다이어트를 하면서 몸에 좋다는 물건들을 좀 찾다가 녹차가 효능이 있다는 이야기를 듣고 이참에 탄산 음료를 줄이고자 마시게 된 제품입니다. 이건 종류가 워낙 다양하고 섭취할 방법도 많으니 이미지는 첨부하지 않도록 하겠습니다.\n\n제가 음용중인 제품은 1.5L 페트병으로 녹차를 아예 우려서 주는 것인데, 이를 구매하기 시작한 이후로 1주일에 거의 꼬박꼬박 10 페트병을 마시고 있네요. 사실 어찌보면 장기적으로 봤을때 가장 비싼 물건입니다... 그래도 이 때문에 살이 빠지고 있는지는 모르겠지만 마시기 시작한 이후로 탄산 음료 섭취량이 줄어들었기 때문에 이것만으로도 만족스러운 효과를 느끼고 있습니다.\n\n---\n\n## lenovo y700 2세대 - 카카오톡이 없는 7인치 만능 노트\n\n![y700 2세대](https://encrypted-tbn0.gstatic.com/shopping?q=tbn:ANd9GcRrU5ofqgLSycb_EEDsEu361IqlTGj4jG1Ys4A9TyaMjxBpC9TexBfbpSkdqvEZ-7UnjaqA2SMonqGcSQMhmD1kYnOOFlLTjA32V_OYjCtE6HjSjOlui6gCUFZ-_mW0z4VUs7YPuuA\u0026usqp=CAc)\n\ne북리더를 e잉크 제품으로 읽는 것도 좋지만, 저는 웹싸이트에 작성된 글을 읽거나 태블릿으로 일기 작성 및 필기를 하는 등의 만능 노트로 사용할 가성비 좋은 물건이 필요했습니다. 그런 의미에서 본래는 게이밍을 목적으로 만들어진 기기이지만, 7인치라는 사이즈는 이동중에 사용하기에도 적당할 정도이기 때문에 제가 기존에 사용하던 10인치 이상의 태블릿을 사용할 때와 다른 만족감을 느낄 수 있었습니다.\n\n특히나 안드로이드 제품이기 때문에 카카오톡을 사용하지 못한다는 시점에서 책을 읽거나 할 때 집중력을 산만하게 만드는 요소가 줄어들어 더욱 만족스러운 사용 경험을 할 수 있었습니다. 게다가 전용 펜도 꽤나 유용하고 e 잉크 제품과는 달리 인터넷 서핑을 통해 정보를 찾을 때에도 사용이 용이하단 점이 굉장한 장점입니다.\n\n---\n\n## 마치며\n\n이상이 제 최근 삶을 가장 크게 바꿨다고 생각되는 구매/사용 목록 총 6가지였습니다. 혹시 읽으신 분들께서도 최근 구매한 물건이 일상을 크게 변화시킨 경험이 있으시면 댓글로 공유해주시면 꼭 한번 사용해보고 싶네요. 읽어주셔서 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"최근 내 삶을 바꾼 제품들 총 6선","subtitle":"전구, AI에서 태블릿 pc까지","date":"2024-05-04T00:00:00.000Z","categories":"ETC"}},{"postName":"2024-03-12-chatper2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/kubernetes/2024-03-12-chatper2.md","category":"ETC","title":"쿠버네티스 교과서","subtitle":"Chapter 2","content":"\n명령어 모음\n\n* kubectl exec: 파드 내부에서 명령어 실행\n* kubectl get pods: 파드 목록 조회\n* kubectl apply -f: YAML 파일로 리소스 생성\n* kubectl delete -f: YAML 파일로 리소스 삭제\n* kubectl port-forward: 로컬 포트로 포트 포워딩\n* kubectl run: 새로운 파드 생성\n* kubectl create deployment: 새로운 디플로이먼트 생성\n* kubectl logs: 파드 로그 조회\n\n=\u003e 플래시 카드 작성하는 것 생각해볼것\n","layout":"default","recommended":false,"data":{"title":"쿠버네티스 교과서","subtitle":"Chapter 2","date":"2024-03-14T00:00:00.000Z","layout":"default","categories":"ETC"}},{"postName":"2024-03-17-용어 정리","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/kubernetes/2024-03-17-용어 정리.md","category":"ETC","title":"kubernetes 용어 정리","subtitle":"pod, deploy, service, configmap","content":"\n## Pod\n\n* 쿠버네티스에서 가장 작은 배포 단위.\n* 하나 이상의 컨테이너로 구성될 수 있으며, 컨테이너는 동일한 호스트에서 실행된다.\n* 컨테이너는 동일한 네트워크 네임스페이스를 공유하며, 동일한 IP 주소와 포트 범위를 사용한다.\n\n## Deployment\n\n* 파드를 관리하는 리소스.\n* 파드를 생성하고 업데이트하며, 파드의 상태를 모니터링한다.\n* 파드의 수평적인 스케일링을 지원한다.\n* 파드에 문제가 발생하면 자동으로 복구한다.\n\n## Service\n\n* 파드의 네트워크 엔드포인트를 노출하는 리소스.\n* 클러스터 내부 또는 외부에서 파드에 접근할 수 있도록 IP 주소와 포트를 제공한다.\n* 클러스터 내부에서 사용 가능한 고유 도메인 이름을 제공한다.(DNS)\n\n* Service 타입\n  * ClusterIP: 클러스터 내부에서만 접근 가능한 서비스\n  * NodePort: 클러스터 외부에서 접근 가능한 서비스\n  * LoadBalancer: 클러스터 외부에서 접근 가능한 로드 밸런서 서비스\n  * ExternalName: 클러스터 내부에서 외부 서비스에 접근 가능한 서비스\n  * Headless: 클러스터 내부에서 파드의 IP 주소를 직접 사용할 수 있는 서비스\n  * Service Mesh: 서비스 메시를 사용하는 서비스\n  * ...\n\n## ConfigMap\n\n* kubectl create configmap\n* 파드에서 사용하는 환경 변수, 설정 파일 등을 저장하는 리소스.\n* 파드가 실행될 때 ConfigMap을 참조하여 환경 변수나 설정 파일을 사용할 수 있다.\n* 파드가 실행 중일 때 ConfigMap을 수정하면 파드가 자동으로 변경된 값을 사용할 수 있다.\n* ConfigMap을 사용하면 파드의 설정을 중앙에서 관리할 수 있다.\n","layout":"default","recommended":false,"data":{"title":"kubernetes 용어 정리","subtitle":"pod, deploy, service, configmap","date":"2024-03-17T00:00:00.000Z","layout":"default","categories":"ETC"}},{"postName":"2024-03-07-좋은 테스트에 대한 고민","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-07-좋은 테스트에 대한 고민.md","category":"개발이야기","title":"좋은 테스트에 대한 고민","subtitle":"구글 엔지니어는 이렇게 일한다를 읽으며","content":"\n## 목차\n\n0. 계기\n1. 단위 테스트에 적용하는 원칙\n2. 경험\n\n---\n\n## 계기\n\n최근 ChatApplication 프로젝트를 3주간 진행하면서 초기에 생각한 것과 다르게 프로젝트를 변경해야하는 일이 굉장히 자주 발생했습니다. Redis가 사실은 서버 한개에 대해서만 연결하는 모듈이었다든가, Manager 모듈이 단순히 raw한 연결 자체를 넘겨주는 등의 형태로 구현돼있단 사실들을 리뷰하는 단계에서 발견한 일 등 다 기억은 안 나지만 수도 없이 많았습니다.\n\n그래서 이런 코드들을 다 리팩토링하는 과정에서 처음에 했던 걱정은 '근데 이거 고치고 나서 동작하는지는 어떻게 확인하지?'였습니다. 다행히도 굉장히 운이 좋았던 것은 제가 그때까지 작성한 모든 코드들에 대한 unittest들이 있었기 때문에 이들에 대한 테스트를 통과시키는 것만으로도 굉장히 많은 것들을 확인할 수 있었습니다.\n\n즉, **테스트가 생산성과 속도를 높여주는 도구**라는 것을 깨닫는 경험을 했습니다.\n\n그런데 이와 별개로 ci/cd를 위해 github actions를 작성하고 테스트하는 과정에서 제가 작성한 테스트들을 이 시스템에 통합하는 것이 불가능하단 사실들을 알았습니다. 그리고 현재 제가 작성하고 있는 테스트들이 충분히 좋지 못한 테스트라는 생각을 하게 됐습니다.\n\n그렇다면 앞으로는 지금보다 더 좋은 테스트들을 작성하면 규모가 크고 오래 진행하는 프로젝트를 진행할 때 많은 도움을 받을 수 있겠다는 생각하게 됐습니다. 마침 요 근래 읽고 있는 책인 '구글 엔지니어는 이렇게 일한다'의 테스트 항목들에서 이에 대한 이야기들을 많이 하고 있고, 도움이 된다고 생각되어 이에 대한 정리 및 고민을 해보려고 합니다.\n\n---\n\n## 단위 테스트에 적용하는 원칙\n\n1. 유지보수하기 쉬워야 한다.\n2. 깨지기 쉬운 테스트가 되지 않아야 한다\n   - 버그가 없고 검증 대상 코드와 관련 없는 변경으로 인해 테스트가 실패하면 안된다.\n   - 공개 API를 이용해 테스트한다.\n   - 상호작용이 아니라 상태를 테스트하자.\n     - 상태: 기능 호출 이후에 시스템이 어떻게 변하는지\n     - 상호작용: 기능 호출 이후에 시스템이 어떤 행동을 하는지\n3. 명확한 테스트 작성하기\n   - 완전한 테스트를 작성하자.\n     - 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보가 본문에 있다.\n   - 간결한 테스트를 작성하자.\n     - 관련 없는 정보를 제거하자.\n   - 메서드가 아니라 행위를 테스트하자.\n     - given, when, then을 사용하자.\n        - given: 시스템의 설정\n        - when: 시스템이 수행할 작업\n        - then: 결과 검증\n    - 테스트에 논리를 넣지 말자.\n    - 실패 메시지를 명확하게 작성하자.\n4. DAMP: Descriptive And Meaningful Phrases\n    - 단순하고 명료하게 테스트를 작성하자.\n    - 테스트에서 다소의 중복은 괜찮다.\n\n---\n\n## 경험\n\n위와 같은 원칙들을 적용하면서 테스트를 작성하기 시작하다보니, 이전보다 나은 테스트를 작성할 수 있게 된 장점은 있었습니다. 그렇지만 동시에 어려움을 겪은 부분도 있습니다.\n\n제시한 원칙 중에 특히 **공개 API를 이용해 테스트한다**는 원칙 같은 경우 현재 CI/CD의 방법으로 git actions를 사용하는 중이고, 어플리케이션이 서버에 올라가있지 않은 상태여서 문제가 됐습니다. 로컬에서 서버를 띄우고 api에 요청을 보내는 것은 가능하지만, 이를 github actions에서 하는 것은 불가능했기 때문입니다.\n\n현재는 이 부분에서 테스트를 mock_tests, open_api_tests 두 가지로 분리하고 기존의 작성한 테스트들을 open_api_tests로 옮긴 뒤 검증하지 않게 해 두었습니다. 그리고 mock_tests를 추가로 작성하려고 생각 중입니다.\n\n오래 유지될 서비스의 측면에서 open_api_tests들을 결국 사용해야겠습니다만, 개발 비용 측면에서 이런 부분에 대한 고민이 들어가면 원칙은 항상 지키기 어렵다는 생각을 하게 됩니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"좋은 테스트에 대한 고민","subtitle":"구글 엔지니어는 이렇게 일한다를 읽으며","date":"2024-03-07T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-08-February Code Review copy","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-08-February Code Review copy.md","category":"개발이야기","title":"2월의 코드 복기","subtitle":"알고리즘, Go 문법","content":"\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/886b271b3be97d6af2af270d2754ebb8127f4d88\u003e\n\nbinary search tree가 있을 때, 이를 펴는 방법\n\n* 순회하고, 붙이고, 올려보내라\n\n```python\ndef inorder_traversal(node):\n  if node is None:\n    return\n\n  inorder_traversal(node.left)\n  self.current_node.right = node.val\n  self.current_node = self.current_node.right\n  inorder_traversal(node.right)\n```\n\n---\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/449fc65f0fbc29330042bb3b0153b16b0049a167\u003e\n\nstring을 element로 갖는 array를 입력받았을 때, 모든 element에 공통으로 들어간 character의 리스트를 구하는 문제. 중복을 허용하여 동일 character가 정답에 2번 이상 등장할 수도 있다.\n\n직접 count하는 방법, python dictionary의 \u0026 연산자를 이용하는 방법, set을 이용해서 정의역 자체를 줄인 뒤에 갯수를 count하고 객체는 최후에 만든다.\n\n* 연산을 하기 전에 대상을 줄인다.\n* 객체를 만드는 것은 최후에, 꼭 필요한 순간에만 한다.\n\n---\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/90c7db2c8ff37d1ddf24b0a187fbe85de7ddd380\u003e\n\n세 명의 아이에게 줄 사탕의 갯수와 한 아이에게 줄 수 있는 최대 사탕의 갯수가 주어졌을 때, 이를 나눠 줄 수 있는 경우의 수를 구하는 문제.\n\n* 최대 값에 제한이 있는 문제를 풀 때, 이를 합을 통해서 경우의 수를 만들지 않고 뺄셈을 통한 경우의 수 생성이 유리할 수 있다.\n\n---\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/77ec890aefcc049d6cc8f0d8437909e4b6bf72db\u003e\n\n* 값이 존재하는지 계속해서 확인할 경우, hashtable을 사용하자.\n* python의 set은 hashtable로 구현되어 있다.\n\n---\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/ea23a451316766fde8bfce5213a8e9e23781da50\u003e\n\n* sliding window\n\n---\n\nAwesome!\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/471f6fb0b0c8cba6890b13ca1fbce871dd05eada\u003e\n\n: list의 partial sum = 0 되는 구간을 삭제한 list를 구하는 문제.\n\n* accumulative sum이 key이고, 해당 sum이 나온 마지막 node가 value인 hashtable을 만든다.\n* 다시 accumulative sum을 순회하면서, 해당 sum이 나온 마지막 노드가 현재 노드보다 뒤에 있으면, 그 사이의 구간은 0이 된다.\n* currentNode.next = savedNode.next 로 중간 삭제\n\n---\n\n## \u003chttps://github.com/kaestro/algorithms_v3/commit/5309222eb2af9bb8cc830a05ebe554f870f2ffb3\u003e\n\n* backtracking\n\n---\n\n## \u003chttps://github.com/kaestro/weekly-reviews/blob/main/February/Code%20-%20Week%204th.md\u003e\n\n* Go와 관련한 전반적인 문법사항\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월의 코드 복기","subtitle":"알고리즘, Go 문법","date":"2024-03-08T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-12-시스템 설계 방법","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-12-시스템 설계 방법.md","category":"개발이야기","title":"시스템 설계 방법","subtitle":"설계 과정","content":"\n## 목차\n\n1. 서론\n2. 개요\n3. 설계 과정\n4. 결론\n\n---\n\n## 서론\n\n여러가지 요소들이 상호작용을 해서 동작하는 시스템을 작성하기 위해서 가장 먼저 해야 할 일들이 무엇인지에 대해 계획을 짜야합니다. 목표가 무엇인지부터 명확하게 정의하지 않으면, 어느 곳에도 도달하지 못하고 표류하게 될 것이기 때문입니다. 이런 목표를 달성하기 위해 계획을 세우는 시스템 설계 방법 중의 제가 사용하고 있는 **설계 과정**에 대해 이야기해보려고 합니다.\n\n최근에 채팅 어플리케이션 프로젝트를 진행하면서 '일단 시작하고 보자'라는 생각으로 프로그램을 작성하기 시작한 적이 있습니다. 그랬더니 한발짝 나아갈 때마다 내가 지금 이 프로그램을 작성하는 것이 나중에 시스템이 다 구성됐을 때 목표한 대로 작동할 지에 대해서 확신할 수 없었습니다. 이 때문에 뭔가를 작성할 때마다 그것이 옳은지 검토하는 과정을 거쳐야만 했습니다. 그리고 이에 따라 구상도 변경되면서 지속적인 수정이 필요했습니다.\n\n이러한 경험을 통해 프로그램을 작성하기 전에 시스템을 좀 더 체계적으로 설계하는 경험을 들어볼 기회가 있으면 비교적 적은 시행착오를 통해 목표한 시스템을 구현할 수 있을 것이라고 생각했습니다. 마침 이 때 추천받은 책이 **\"가상 면접 사례로 배우는 대규모 시스템 설계 기초\"**였습니다.\n\n읽다보니 이를 제가 진행중인 프로젝트에 적용하는 방식을 정리하는 것이 좋겠다는 생각이 들었고, 되도록 다른 사람과 공유하고 싶다는 생각이 들어 이렇게 글을 작성하게 되었습니다. 이 글이 저와 비슷한 고민을 하며 답을 찾는 분들에게 도움이 되었으면 좋겠습니다.\n\n---\n\n## 개요\n\n5가지 단계로 나눈 설계 과정을 제가 작성중인 ChatApplication의 예시를 들어 설명하고 있습니다. 해당 과정은 '요구사항 분석', '설계 범위 결정', '개략적인 설계', '상세 설계', '검토'로 나눌 수 있습니다.\n\n---\n\n## 설계 과정\n\n시스템을 설계하는 과정은 크게 5가지로 나눌 수 있습니다.\n\n```\n1. 요구사항 분석.\n2. 설계 범위 결정.\n3. 개략적인 설계.\n4. 상세 설계.\n5. 검토.\n```\n\n---\n\n### 요구사항 분석\n\n**요구사항을 분석**할 때는 우선 **문제를 정의**해야 합니다. 제가 작성중인 채팅 어플리케이션을 예시로 들자면 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 구체적으로 어떤 기능을 제공해야 하는가?\n* 목표로 하는 수용 가능 제품 사용자 수는 얼마나 되는가?\n* 주로 사용하는 기술 스택은 무엇인가?\n```\n\n이에 대해 저는 다음과 같은 답을 생각해냈습니다.\n\n```md\n* 로그인, 채팅방 개설, 채팅방 입장, 메시지 전송, 메시지 수신, 채팅방 삭제 등의 기능을 제공해야 합니다.\n* 사용자 수는 채팅방 당 최대 15,000명이라고 가정합니다.\n* 주로 사용하는 기술 스택은 go, postgresql, redis, docker, azure 등입니다.\n```\n\n기능들 같은 경우는 다른 채팅방에서 일반적으로 제공하는 기능들을 기준으로 가장 기본적이라고 생각하는 것들을 작성했습니다. 사용자 수는 steam 인기 게임 기준으로 100위에 드는 게임의 동시접속자가 15,000여 명인 것을 기준으로 잡았습니다. 기술 스택은 동시성, 안정성, 확장성과 같은 부분들을 고려해서 선택했습니다.\n\n---\n\n### 설계 범위 결정\n\n**설계 범위를 결정**할 때는 우선 설계의 목표를 설정해야 합니다. 제가 작성중인 채팅 어플리케이션을 예시로 들자면 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 당장 작성하기 시작할 수 있는 기능은 무엇인가?\n* 어떤 기능을 먼저 작성해야 하는가?\n* 그 중요도는 무엇을 기준으로 선정해야 하는가?\n```\n\n이에 대해 저는 다음과 같은 답을 생각해냈습니다.\n\n```md\n* 유저의 CRUD 기능을 먼저 작성하기 시작할 수 있습니다.\n* 채팅방에서 공용으로 사용하게 될 모듈인 DBManager, SessionManager 등을 먼저 작성해야 합니다.\n* 중요도는 이후에 변경이 있을 때 이를 검증할 수 있는 시스템과 다른 사람의 협업을 위한 시스템을 먼저 작성해야 합니다.\n```\n\n이래서 현재 가장 먼저 작성한 것은 **User CRUD API**인 login, logout, signup, delete 등의 기능입니다.\n\n채팅방에서 공용으로 사용할 모듈은 **재활용도**가 높기 때문에 우선도가 높다고 판단해서 DBManager, SessionManager, PasswordManager을 작성했습니다.\n\nunittest들을 작성하고, 이들을 **자동으로 검증**하기 위한 시스템으로 github action을 사용했습니다. 현재 github action은 소스 코드의 unittest 및 빌드를 자동으로 검증하고 있습니다.\n\n또한 서버에 올려서 동작을 확인하기위한 **containerization** 및 **orchestrization**에 대한 작업을 진행하는 중입니다.\n\n---\n\n### 개략적인 설계\n\n**개략적인 설계**는 일단 시작하기 위한 prototype이라 생각합니다. 제가 ChatApplication 프로젝트 readme에 작성한 개요와 같습니다. 제가 익숙한 기술스택 내에서 기능들에 어울린다고 가장 먼저 떠오르는 것들을 이용해서 작성했습니다.\n\n이에 따른 최초 제 ChatApplication의 개략적인 설계는 다음과 같습니다.\n\n```md\n메인 서버: go, gin\n유저 관리 DB: postgresql\n세션 관리: redis\n메시지 큐: redis\n채팅 데이터 DB: MongoDB\n사용 서버: Azure\n```\n\n이에 대한 설계는 현재 진행중이며, 이를 통해 어떤 문제가 발생하는지, 어떤 문제를 해결해야 하는지에 대한 경험을 쌓고 있습니다. 현재 **메시지 큐**로 **redis**를 사용하는 것이 적절하지 않아 **kafka**를 사용하는 부분에 대해 고민하고 있으며, 클라우드 서비스 같은 경우도 **gcp**로 이전을 고민하고 있습니다.\n\n---\n\n### 상세 설계 및 검토\n\n**상세 설계**는 개략적인 설계를 바탕으로 **구체적인 기능**들을 작성하는 것입니다. 이를 위해선 먼저 개략적인 설계를 바탕으로 작성한 기능들을 검토해야 합니다. 이를 위해선 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 15,000명이라는 사용자를 넘어선 인원이 채팅방에 들어왔을 때 어떤 일이 일어나야 하는가?\n* 유저 세션은 몇초 단위로 유지되어야 하고, 없어지는 경우에는 어떤 일이 일어나야 하는가?\n* 채팅방에 유저가 들어왔을 때 어느 정도까지 이전의 메시지를 볼 수 있어야 하는가?\n```\n\n이에 대한 부분들은 아직 명확하게 답을 내리지 못했고, **검토**의 과정을 포함해서 다른 사람의 의견을 참고하고자 해서 현재는 책을 읽고 다른 팀원을 모집해서 프로젝트를 진행하는 중입니다.\n\n---\n\n## 결론\n\n**시스템을 설계하는 과정**은 크게 다음 5가지로 나눌 수 있습니다. 요구사항 분석, 설계 범위 결정, 개략적인 설계, 상세 설계, 검토입니다.\n\n저는 해당 과정을 적용해서 진행하려는 채팅 어플리케이션을 설계하고 있는 중이며, 이를 통해 모자란 부분이 많지만 현재 프로젝트를 진행하고 있는 중입니다. 방향성이 틀린 부분이 있을 수 있지만, 방향을 일단 잡았기 때문에 이를 수정하는 것이 용이하고 앞으로도 계속해서 덜 틀린 방향으로 나아갈 수 있을 것이라 믿습니다. 그리고 그것이 설계 과정을 거치는 이유라고 생각합니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"시스템 설계 방법","subtitle":"설계 과정","date":"2024-03-12T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-13-Docker - 멀티 스테이지 빌드","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-13-Docker - 멀티 스테이지 빌드.md","category":"개발이야기","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","content":"\n해당 내용은 [쿠버네티스 교과서 부록](https://github.com/sixeyed/diamol)의 내용을 참고하여 작성하였습니다.\n\n---\n\n## 멀티 스테이지 빌드란\n\nDocker에서 **멀티 스테이지 빌드**는 여러개의 **FROM 명령어**를 사용하여 **여러개의 이미지**를 생성하는 방법입니다. 이를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다.\n\n다음 두 빌드 dockerfile을 비교해보겠습니다.\n\n---\n\n## 예시\n\n### 단일 스테이지 빌드\n\n```dockerfile\nFROM diamol/golang \n\nWORKDIR web\nCOPY index.html .\nCOPY main.go .\n\nRUN go build -o /web/server\nRUN chmod +x /web/server\n\nCMD [\"/web/server\"]\nENV USER=sixeyed\nEXPOSE 80\n```\n\n\n### 멀티 스테이지 빌드\n```dockerfile\nFROM diamol/golang AS builder\n\nCOPY main.go .\nRUN go build -o /server\nRUN chmod +x /server\n\n#app\nFROM diamol/base\n\nEXPOSE 80\nCMD [\"/web/server\"]\nENV USER=\"sixeyed\"\n\nWORKDIR web\nCOPY --from=builder /server .\nCOPY index.html .\n```\n\n둘은 동일한 go로 작성된 웹 서버를 빌드하는 dockerfile입니다. 하지만 두번째 dockerfile은 **멀티 스테이지 빌드**를 사용하여 빌드 **프로세스를 단순화하고 이미지 크기를 줄였습니다.** 해당 방법을 통해 대략 5.2GB의 크기였던 기존의 이미지는 260MB 수준으로 줄어들게 됩니다.\n\n처음으로 멀티 스테이지가 적용된 부분은 처음에 **FROM diamol/golang AS builder** 부분으로 여기에서 빌드를 수행했습니다.\n\n그 다음으로 멀티 스테이지가 적용된 부분은 **FROM diamol/base** 부분으로 여기에서 빌드가 완성된 실행 파일만을 web 디렉토리에 복사하여 사용했습니다.\n\n---\n\n## 결과\n\nDocker의 **멀티 스테이지 빌드**를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다. 또 불필요한 파일이 제거됐기 때문에 **공격 표면**이 줄어들어 **보안도 강화**됐습니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","date":"2024-03-13T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-19-Golang은 동시성이 어떤 점에서 유리한가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-19-Golang은 동시성이 어떤 점에서 유리한가.md","category":"개발이야기","title":"동시성(Concurrency)과 Golang","subtitle":"Golang은 진정 동시성을 처리하는 데 유리한가?","content":"\n## 개요\n\n컴퓨터에서 **여러 프로그램을 한꺼번에 처리**하는 방법 중에 **동시성**과 **병렬성**이 있다. **Golang**은 **동시성**을 처리하기에 용이하도록 설계한 언어로, 이를 위해 **Goroutine**, **Channel** 등의 기능을 제공한다. 해당 기능들 덕분에 Golang은 다른 언어에 비해 **동시성을 처리하는 데 유리하다**고 할 수 있다.\n\n---\n\n## 목차\n\n1. **동시성**이란: 병렬성 vs 동시성\n2. **기존**의 동시성 **처리 방법**: 멀티 태스킹, 스레드, context switching\n3. **Goroutine**: Go에서 스레드를 다루는 방법\n4. **Channel**: Goroutine 간의 통신\n5. **결론**: GoLang은 동시성 처리가 용이하게 설계됐고, **다른 언어에 없는 기능**을 통해 이를 실천하고 있다.\n6. **의문점**: 다른 언어들은 어떻게 동시성을 처리하는가?\n7. 참고자료\n\n---\n\n## 동시성이란\n\n### 병렬성 vs 동시성\n\n컴퓨터에서 **여러 작업**을 **동시**에 처리하는 방법에는 **병렬성**과 **동시성**이 있다. 이 때 병렬성과 동시성은 다음과 같이 정리할 수 있다.\n\n* 병렬성(Parallelism): 여러 일을 **한꺼번에 실행하는 방법**에 관한 것이다.\n* 동시성(Concurrency): 여러 일을 **한꺼번에 다루는 문제**에 관한 것이다.\n\n이 때 **병렬성**은 **여러 프로세서**가 **동시에** 여러 작업을 처리하는 것을 의미하고, **동시성**은 **하나의 프로세서**가 여러 작업을 **번갈아**가며 처리하는 것을 의미한다.[^1]\n\n#### 즉, Go가 동시성을 처리하는 데 유리하다면 작업 간에 **전환이 빠르다**는 것을 의미한다. 그리고 Go는 동시성을 처리하는 데 유리하게 **설계**된 언어이다[^3]\n\n---\n\n## 기존의 동시성 처리 방법\n\n* **멀티 태스킹**\n  * 여러 작업들을 **번갈아가며 처리**하는 것\n  * **시분할 시스템**을 통해 **CPU를 공유**하여 여러 작업을 처리한다.\n* **스레드**를 이용한 동시성 처리\n  * 스레드는 프로세스 내에서 **코드 실행**을 담당하는 **최소의 단위**이다.\n* **context switching**\n  * **스레드** 간에 **전환**을 하는 것\n  * **system call**을 통해 **커널**에 요청을 하여 스레드를 전환한다.\n  * system call은 **비용**이 많이 든다.\n\n---\n\n## Goroutine: Go에서 스레드를 다루는 방법\n\n* **goroutine**은 스레드가 아니라, **runtime scheduler**를 통해 관리된다.\n* **runtime scheduler**를 통해 **system call**을 더 **적게** 사용하고 동시성을 구현할 수 있다.\n* **system call 필요한 연산**이 생길 경우 발생하는 **blocking**은 runtime scheduler가 **다른 goroutine**으로 **context switching**해서 해결한다.[^2]\n\n---\n\n## Channel: Goroutine 간의 통신\n\n* **channel**은 **goroutine** 간에 **데이터를 주고 받는** 방법이다.\n* [할당하고 전달할 수 있는 1급 객체 값(first-class value)이다.](https://go.dev/doc/effective_go#chan_of_chan)\n  * [1급 객체란?](https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059)\n    * **변수/데이터**에 할당할 수 있다.\n    * 객체의 **인자(parameter)**로 사용할 수 있다.\n    * 객체의 **반환값(return value)**으로 사용할 수 있다.\n* 장점\n  * **동기화**를 위해 **mutex**를 사용하지 않아도 된다.\n  * *공유*가 아닌 **소유권 이전**이므로 **데이터 레이스**가 발생하지 않는다.\n  * **비동기**로 데이터를 주고 받을 수 있다.\n* 단점\n  * **데이터를 주고 받는 비용**이 발생한다.\n  * **성능**이 mutex에 비해 **떨어질 수 있다**\n\n| Channel | Mutex |\n| ------- | ----- |\n| 데이터의 소유권을 이전한다 | 캐시 |\n| 일의 단위를 나누어서 처리한다 | 상태 |\n| 비동기 결과를 소통한다 | 데이터를 공유한다 |\n\n---\n\n## 결론\n\n**GoLang**은 태생적으로 **동시성**을 처리하기에 효율적인 방법을 고안하여 만들어진 언어이다. 이를 위해 **Goroutine**과 **Channel**과 같은 기능을 제공하고 있다. 이 때문에 Golang이 **동시성을 처리하는 데 유리**하다고 할 수 있다.\n\n---\n\n## 의문점\n\n* **다른 언어**들은 어떻게 동시성을 처리하는가?\n* 어떤 점에서 이들은 Golang에 비해 동시성을 처리하는 것이 **불편**한가?\n\n---\n\n## 참고자료\n\n* [effective go - concurrency](https://go.dev/doc/effective_go#concurrency)\n* [Mutex or Channel](https://go.dev/wiki/MutexOrChannel)\n* [동시성을 구현하는 기술](https://deview.kr/data/deview/session/attach/1_Inside%20React%20(%E1%84%83%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF).pdf)\n* [Go에서 동시성이란](https://seung.tistory.com/entry/GoLang-Go%EC%97%90%EC%84%9C-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EB%9E%80)\n* [1급 객체란?](https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059)\n\n[^1]: [동시성과 병렬성의 개념 차이](https://velog.io/@kwontae1313/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4)\n[^2]: [Golang은 왜 동시성에 좋다고 할까](https://velog.io/@hyeok3011/Goroutine)\n[^3]: [Concurrency is not parallelism](https://go.dev/blog/waza-talk)\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","subtitle":"Golang은 진정 동시성을 처리하는 데 유리한가?","title":"동시성(Concurrency)과 Golang","date":"2024-03-19T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-04-21-k6 vs Locust","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-04-21-k6 vs Locust.md","category":"개발이야기","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","content":"\n## 개요\n\nChatApplication의 RestAPI 서버에 대한 MVP 개발 완료 및 예정해뒀던 정비가 어느 정도 끝나가고 있어, 이제는 부하 테스트를 작성해야 할 때가 왔다는 생각에 어떻게 하면 좋을지에 대해 고민을 하게 됐습니다.\n\n크게는 두 가지 방법을 생각했습니다. 시작부터 직접 부하 테스트를 작성하는 방법과 부하 테스트 도구를 사용하는 방법이 그것입니다. 그리고 부하 테스트 도구를 사용하는 것이 시간이 지나치게 오래 걸리고 메리트가 없다 싶으면 직접 부하 테스트를 작성하고, 그렇지 않다면 부하 테스트 도구를 사용하는 것이 좋겠다는 생각에 도달했습니다.\n\n이를 검토하기 위해 부하 테스트 도구로 주로 사용되는 오픈 소스 솔루션에 무엇이 있는지 찾아보고 그 중에 후보로 `Locust`, `k6`, `JMeter`를 고민하게 됐습니다.\n\n---\n\n## 기준 세우기\n\n비교하기에 앞서 어떤 도구를 내가 원하는 지에 대한 기준을 세워야 했고, 그 기준은 다음과 같았습니다.\n\n```plaintext\n1. 자유도가 높으며, 다양한 테스트 케이스를 작성할 수 있는가?\n2. websocket을 지원하는가?\n3. 부하 테스트 결과를 쉽게 분석할 수 있는가?\n4. 활발한 커뮤니티를 기반으로 유지보수가 잘 되고 있는가?\n5. 적당한 학습 부하를 통한 자극이 되는가?\n```\n\n각각의 기준을 선정한 이유는 다음과 같습니다.\n\n1. ChatApplication의 RestAPI 서버는 현재 작은 규모의 트래픽만을 다루지만, 여기에 더해 다양한 기술들을 장기간에 걸쳐 새로 도입하는 것을 목표로 하기 때문입니다.\n2. 채팅을 주 기능으로 설정했기 때문에 이에 대해서는 확실한 부하 테스트를 해야 하기 때문입니다.\n3. 어떤 부분이 병목이 되는지, 어떤 부분이 더 개선이 필요한지를 빠르게 파악할 수 있기 때문입니다.\n4. 활발한 커뮤니티가 있을 경우 제가 부딪히게 될 문제들을 빠르게 해결할 수 있으며 동시에 오픈 소스에 참여할 수 있는 기회도 늘어나기 때문입니다.\n5. 마지막으로 이 프로젝트는 장기간 동안 새로운 것을 배우면서 적용해나가는 것을 목표로 하고 있기 때문에 적당한 학습 부하를 통한 자극이 되어야 합니다.\n\n---\n\n## 후보군 선정\n\n`Locust`, `k6`, `JMeter`는 현재 가장 널리 쓰이는 부하 테스트 도구들 중 하나였기 때문에 우선적으로 후보군으로 선정했지만, JMeter의 경우에는 위의 기준에 부합하지 못하는 부분이 많다고 판단했습니다. 이는 JMeter는 GUI 기반의 도구이기 때문에 테스트 케이스를 작성하고 실행하는 데에 시간이 많이 소요되며, 제가 원하는 수준의 자유도를 제공하거나 학습 부하를 제공하지 못한다고 생각했기 때문입니다.\n\n따라서 `Locust`와 `k6`를 후보군으로 선정하게 됐습니다.\n\n---\n\n## Locust vs k6\n\n`Locust`는 파이썬으로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. 파이썬을 사용하기 때문에 파이썬에 익숙한 제가 자유도 높게 테스트 코드를 작성하기에 적합하고, github repository가 23.6k의 star를 받고 contributor가 274명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. websocket을 자체적으로 지원하지 않는 것은 python의 websocket 패키지를 사용하면 되기 때문에 큰 문제가 되지 않았습니다.\n\n`k6`는 Go로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. Go로 작성돼있기 때문에 Locust와 비교해 더 대규모의 부하 테스트를 수행할 수 있으며, websocket을 내부 로직으로 지원하기 때문에 채팅 서버에 대한 부하 테스트를 진행하기에 적합합니다. github repository가 23.3k의 star를 받고 contributor가 1400여명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. javascript를 사용하기 때문에 마침 javascript를 공부할 계기가 필요했던 저에게 충분한 학습 부하를 제공할 것이라는 생각이 들었습니다.\n\n---\n\n## k6를 선택하다\n\nlocust 역시 굉장히 잘 운영되고 있는 매력적인 도구였지만, 제가 정해 둔 기준들에서 대부분 k6가 우세했고 무엇보다 이를 계기로 javascript를 공부할 수 있는 기회가 될 것이라는 생각에 k6를 사용해서 부하 테스트를 진행하기로 결정했습니다. 이를 통해 ChatApplication의 RestAPI 서버에 대한 부하 테스트를 진행하고, 이를 통해 어떤 부분이 개선이 필요한지 파악하고 개선해나가는 것이 목표입니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","date":"2024-04-21T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-05-07-Docker mount","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-07-Docker mount.md","category":"개발이야기","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","content":"\n## 개요 - Docker mount란\n\n도커 컨테이너는 호스트와 별도로 파일 시스템을 가지고 있습니다. 이 파일 시스템은 컨테이너가 생성될 때 생성되며, 컨테이너가 종료되면 함께 삭제됩니다. 이 때문에 컨테이너가 종료되면 컨테이너 내부에 저장된 데이터는 모두 사라지게 됩니다. 이러한 문제를 해결하기 위해 도커는 컨테이너 내부의 파일 시스템을 호스트의 파일 시스템과 연결하는 방법을 제공합니다. 이를 도커 mount라고 합니다.\n\n도커 mount는 크게 두 가지 방법으로 구분됩니다. 하나는 볼륨(volume)을 사용하는 방법이고, 다른 하나는 바인드 마운트(bind mount)를 사용하는 방법입니다. 볼륨과 바인드 마운트는 각각 장단점이 있으며, 상황에 따라 적절한 방법을 선택해야 합니다.\n\n![docker mount](https://docs.docker.com/storage/images/types-of-mounts.webp?w=450\u0026h=300)\n\n---\n\n## 볼륨(volume)\n\n볼륨은 Docker가 관리하는 호스트 파일 시스템의 일부에 저장됩니다. Docker가 아닌 프로세스는 파일 시스템의 이 부분을 수정해서는 안되며,\n Docker에서 데이터를 유지하는 가장 좋은 방법이다.\n\n볼륨은 Docker에 의해 생성되고 관리됩니다. 명령을 사용하여 명시적으로 볼륨을 생성할 수 있습니다. 또는 Docker는 컨테이너나 서비스 생성\n 중에 볼륨을 생성할 수 있습니다.\n\n`docker volume create my-vol`\n\n특정 볼륨을 여러 컨테이너에 동시에 마운트하는 것도 가능합니다. 실행 중인 컨테이너가 볼륨을 사용하지 않더라도 Docker에서 계속 사용할 수\n 있으며, 자동으로 제거되지 않고 다음 명령을 사용하여 수동으로 제거해야 합니다.\n\n`docker volume prune my-vol`\n\n---\n\n## 바인드 마운트(bind mount)\n\n바인드 마운트는 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트하는 방식입니다. 바인드 마운트는 볼륨에 비해 기능이 제한되어 있지만 파일 또는 디렉터리는 호스트 시스템의 전체 경로로 참조되며 파일이나 디렉터리가 Docker 호스트에 이미 존재할 필요는 없습니다. 바인드 마운트는 빠르지만 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존하며 공식 문서에서는 볼륨을 사용하는 것을 권장합니다.\n\n---\n\n## 볼륨(volume) vs 바인드 마운트(bind mount)\n\n| 볼륨(volume) | 바인드 마운트(bind mount) |\n|---|---|\n| 호스트의 파일 시스템의 일부를 사용 | 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트 |\n| Docker가 관리 | Docker가 관리하지 않음 |\n| 볼륨을 여러 컨테이너에 동시에 마운트 가능 | 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존 |\n\n---\n\n## tmpfs 마운트\n\ntmpfs는 호스트의 메모리에 저장되는 가상 파일 시스템입니다. 컨테이너 수명 동안 컨테이너에서 비지속적 상태 또는 중요한 정보, 예를 들면 secrets, keys, tokens 등을 저장하는 데 사용됩니다. tmpfs는 컨테이너가 종료되면 삭제되므로 컨테이너가 종료되면 데이터가 사라지게 됩니다.\n\n---\n\n## 출처\n\n- [Docker Documentation](https://docs.docker.com/storage/)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","date":"2024-05-07T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-05-12-Desk setting(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting(2).md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 지난 이야기\n\n\u003chttps://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/05/12/Desk-setting.html\u003e\n에서 보실 수 있습니다. 이미지는 아래와 같고 주로 큼직큼직한 물건들 모니터, 스피커, 스위치, 팔 받침, 모니터 받침에\n대해 설명했습니다.\n\n이번에는 좀 더 작은 주변기기들에 대해 이야기해보려 합니다\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n---\n\n## 인체공학 키보드 microsoft ergonomic\n\n저는 피씨방에서 키보드 소리가 씨끄럽다는 이유로... 항의를 들어본 적이 있을 정도로 굉장히 키보드를 세게 두드리는\n편입니다. 대체 왜 그런지 모르겠습니다만 엔터키를 칠 때는 오른쪽 손을 들었다가 내려찍는 식으로 치는 경우도 굉장히\n잦았죠. 이제는 많이 고쳤고, 소리 자체도 작게 나는 것을 쓰기 위해 멤브레인 키보드를 쓰기는 합니다만 이런 습관\n때문에 키보드를 오래 쓰는 직업이란 것이 겹치면서 손목에 부담이 많이 갔습니다.\n\n이 때문에 사용하기 시작한 것이 인체공학 키보드이고 핵심은 손목은 손가락보다 높은 곳으로, 키보드가 방사형으로\n구성되어 있어 어깨가 자연스럽게 펴지는 키보드가 되는 것입니다. 본 모델은 뭐 워낙에 유명한 하드웨어 명가 마소의\nergonomic 제품으로 텐키리스이면서 텐키리스가 아닙니다. 텐키용 무선 키보드가 따로 있거든요.\n\n저 같은 경우는 n버튼을 오른 손으로 누른다는 점도 겹쳐서 인체공학 키보드를 쓰는 것에 금방 적응할 수 있었고,\n지금은 일반 키보드를 쓰면 자세가 불편해서 도저히 못 쓸 정도입니다. 이것이 아니라도 어깨, 손목 등에 부담이 많이\n가는 사무직이라면 인체공학 키보드를 사용해보는 것은 강추합니다.\n\n---\n\n## 트랙볼\n\n구매한 지 이제 이틀 된 트랙볼입니다. 원래는 인체공학 버티컬 마우스를 사용했구요. 그것도 굉장히 편해서 제가\n롤을 접게 만든 원흉 중 하나였습니다만(일반 마우스를 쓸 수 없는 몸이 돼버림) 이 역시도 손목이나 어깨에 부담이\n가는 것 같아서 이번에 아예 트랙볼로 바꿨습니다.\n\n제가 선택한 기준은 엄지로 좌클릭을 하고 검~약지로 스크롤을 할 수 있으면서 환불이 가능한 국내 제품이었습니다.\n일단은 만족하고 사용중인데 아직 게임과 같은 작업을 할 때는 조금 어색하긴 하네요. 일단 어깨를 전혀 쓰지 않는\n것과 손목도 거의 쓰지 않아 몸에 부담이 덜 간다는 느낌은 들고 있습니다.\n\n---\n\n## 모니터 암 - 이라 쓰고 태블릿 거치대라 부른다\n\n분명 구매할 때는 모니터 암으로 샀습니다만 모니터랑 호환이 안 돼서 한동안 노트북 거치대로 쓰다가 이제는 태블릿\n및 휴대폰, 펜슬 등 자석이 달린 물건을 고정하는 물건으로 주로 사용중입니다. 그리고 의외로 태블릿을 거치해두면\n책 읽을 때 굉장히 편리하단 장점이 있습니다.\n\n나중에 호환이 되는 모니터를 구하거나 하게 되면 모니터 암으로 사용할 생각입니다만 지금은 꽤 만족 중이네요.\n\n---\n\n## 샤오미 무선 램프\n\n전에 요즘 [바꾼 물건 6선](https://kaestro.github.io/etc/2024/05/04/%EC%B5%9C%EA%B7%BC-%EB%82%B4-%EC%82%B6%EC%9D%84-%EB%B0%94%EA%BE%BC-%EC%A0%9C%ED%92%88%EB%93%A4.html)\n에서 언급한 적이 있는 물건인데, 최종적인 위치를 여기로 확정했습니다. pc 앞에 두고 모니터암과 함께 각도를 자유롭게\n돌리면서 직/간접적으로 백색광부터 따뜻한 빛까지 다양한 색상을 이용할 수 있습니다. 해당 위치가 태블릿 등을 거치하는\n곳이다보니 충전하기에도 용이하고 밤에 필요하면 뽑아서 밖으로 이동하기에도 편리합니다.\n\n---\n\n## 웹캠\n\n면접 등을 보는 용도로 구매한 웹캠입니다.\n\n---\n\n## 기타 무선 제품\n\n책상 좌측 하단에 있는 박스들에 주로 있는데, 게이밍 마우스(요즘엔 거의 사용하지 않는), 게이밍 무선 헤드셋,\n음감용 무선 헤드셋, 배터리 충전기, 링피트 컨트롤러(솔직히 다들 있으시죠?), 무선 엑스박스 컨트롤러, 스위치 팩,\n에어건 등이 있습니다.\n\n---\n\n## 의자\n\n얼마 전에 사망하셔서 집에 있던 식탁 의자 사용중입니다. 근데 원래 의자보다 더 편한 거 같네요?\n\n---\n\n## 마치며\n\n아무래도 불편한게 있으면 참지않고 바로바로 고치는 성격이다보니 무선과 인체공학 제품들로 둘러싸인 책상이\n완성됐네요. 다른 분들은 내 데스크는 이런 부분이 불편해서 사용중인 솔루션에 뭐가 있으신가요? 제 데스크에서\n개선할 만한 부분이 있다 싶으신 부분이 있으면 제 금전이 허락하는 한 참고해보도록 하겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":2}},{"postName":"2024-05-12-Desk setting","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting.md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 서론\n\n아무래도 저는 직업적으로나 취미 적인 측면에서 하루에 컴퓨터를 8시간 이상 사용하는 것은 부지기수이기 때문에,\n가능하면 아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅은 굉장히 공을 들여 만든 부분입니다. 문득 이것 역시도\n컴퓨터를 사용하는 게이머이자 개발자로서 공유하고 이야기를 나누면 재미있을 것 같다는 생각이 들어 글을 쓰게 됐습니다.\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n---\n\n## 현재 내 책상 세팅\n\n현재 제 책상의 전면 상태는 다음과 같습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n오타쿠스러운 취미가 그대로 반영돼 가장 먼저 눈길을 사로잡는 것은 장패드와 각종 실리콘 스탠드 등이겠지만, 그 뒤에\n감춰둔(?) 제 나름의 가능한 아프지 않게 컴퓨터를 사용하기 위한 노력이 있습니다. 이에 대해 한번 천천히 좌측에서\n우측으로 설명해보겠습니다.\n\n---\n\n## 듀얼 모니터\n\n집중력이 떨어지게 하는 역할을 하기도 합니다만, 개발 결과물을 확인하면서 진행하는 용도로 사용한다든가, 구글링\n레퍼런스를 찾아보는 용도로 사용한다는 것이 가장 큰 핑계인 듀얼 모니터입니다. 가장 유용할 때는 롤 경기를 보면서\n카카오톡을 확인하거나, 게임을 플레이하면서 디스코드를 띄워두는 등의 용도입니다.\n\n평소에 높은 집중력을 필요로 할 때는 화면을 하나 꺼두는 어플리케이션을 적극적으로 사용합니다만, 어쩔 수 없이\n두 화면의 활용도가 필요할 때는 듀얼 모니터가 굉장히 유용하게 사용됩니다. 다만 가끔 좌측 화면만 쳐다보고 우측\n화면은 카톡으로만 쓰는 경우를 보면 이럴거면 왜 듀얼 모니터를 쓰는지 의문이 들기도 합니다.\n\n---\n\n## 닌텐도 스위치\n\n작업을 하다가 모든 걸 때려치고 싶은 충동이 들 때 제 안의 흑염룡을 잠재워주는 닌텐도 스위치입니다. 정작 오디오\n인터페이스가 되어 있지 않아 게임을 할 때는 싸구려 모니터 스피커로만 게임을 한다는 것은 안 비밀입니다. 그래도\n젤다 시리즈, 파이어 엠블렘 시리즈, 마리오 시리즈, 컵헤드, 오버쿡드, 하데스, 유니콘 오버로드, 야추 등의 게임을\n플레이한 나름 효자 게임기입니다.\n\n최근에는 스트레스 풀고 싶을 때 태고의 달인을 켜고 신나게 팔을 흔들어서 제 진을 빼놓는 용도로 사용하고 있습니다.\n\n---\n\n## creative pebble v2\n\n가성비로 유명한 스피커입니다. 사실 책상에 놓을만한 사이즈의 물건이 이것 밖에 없었고, 생각보다 음향이 다른 저가형\n스피커와 다른 것을 못 느껴서 사기 당한건가 하는 생각도 처음엔 들었지만 그냥 썼었는데 마지막에 레퍼런스로 달아둔\n링크들을 통해 음향 설정을 하고 나니 많이 달라진 것을 확인할 수 있었습니다.\n\n가격, 크기, 음향과 같은 부분을 고려했을 때 굉장히 훌륭한 제품이라고 생각합니다.\n\n---\n\n## 데스크 팔 받침\n\n책상을 놓을 공간이 협소하다보니 작은 책상을 샀는데, 문제는 팔을 거치할 공간이 없어 팔꿈치가 공중에 떠 있고\n몸이 지나치게 모니터에 붙어있는 자세가 된다는 것이었습니다. 이 때문에 겨드랑이, 어깨 등의 통증이 심해서\n해결하기 위해 구매한 데스크 팔 받침이고 굉장히 많은 도움을 받고 있습니다. 책상이 작아서 조금만 더 늘렸으면\n좋겠다는 생각이 드시면 추천드립니다.\n\n---\n\n## 모니터 받침\n\n모니터 높이를 높게 쓰는 것이 경추 및 척추 위생에 도움이 된다해서 구매한 모니터 받침입니다. 높이 조절은 되지\n않아 아쉽지만 클래식한 목재 디자인에 이것저것 수납할 공간이 있는 것이 마음에 듭니다. 높이가 조금 모자란 것은\n제가 구매한 태블릿 pc의 박스로 조절해서 추가로 높여서 맞췄습니다.\n\n---\n\n## 추가자료\n\n1. \u003chttps://gall.dcinside.com/mgallery/board/view/?id=speakers\u0026no=181872\u003e\n2. \u003chttps://gall.dcinside.com/mgallery/board/view/?id=speakers\u0026no=189902\u003e\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":1}},{"postName":"2024-05-17-socket hijack","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-17-socket hijack.md","category":"개발이야기","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","content":"\n## 개요 - hijack을 맞이하다\n\n나름대로 테스트코드도 다 돌려 본 채팅이 동작하는 것을 확인한 서버 프로그램을 가지고 있으니 클라이언트에서 부하\n테스트를 작성하는 것은 그렇게 어렵지 않을 것이라 생각했었습니다. 그리고 착각은 무엇인가 할 때마다 산산히 부서져\n나가고 있는 것을 체감하는 요즘입니다. 이번에 맞이한 녀석은 바로 `hijack`입니다.\n\nk6를 잘 모르는 상태에서 소켓 연결을 위해 메시지를 보내고, get request도 보내고 하다가 마침내는 ws의 connect를\n이용해서 요청을 보내는 데 성공했는데 이게 웬걸, 서버사이드에서 황당한 에러 메시지가 나왔습니다.\n\n![hijack log](/images/hijack/error%20-%20hijack.png)\n\n?? http response code는 200인데 error는 발생했고, 내 연결은 hijack(탈취)되었다고? 보자마자 제 머리 속에서\n떠오른 이미지는 이것이었습니다.\n\n![이게 무슨 소리요 의사양반](https://i.namu.wiki/i/uf88vRFdi3xVPlSMkSblePa7NN6QL1pmvUzCWe5rqlxLXvMtjHxqXTTapVkKUh4gSAvYdrI2DkfpWkFo8vpX_A.mp4)\n\n이게 대체 무슨 소리요 의사양반, 제가 여태까지 짜 둔 로직은 탈 생각은 하지도 않고 왜 클라이언트가 내 소켓을\n훔쳐가는 것이오. 이 도동놈을 내 대체 어찌해야 한다는 말이오. 우리 솔로몬급 판결사 copilot님께서는 이 도둑은\n의적으로 필수불가결하니 보내줘야하고, 오히려 제 서버가 이에 맞춰줘야 한다는 의견을 제시하였고 저는 이에 저항할\n도리 없이 일단 이 도둑에 맞춰 서버를 수정해야 하는 상황에 놓였습니다.\n\n그런데 누군지도 모르는 녀석에게 내 소켓을 탈취당한 것도 모자라 훔쳐가기 편하라고 집을 뜯어고치는 것은 너무\n억울해 이번에 한번 조사를 해보기로 했습니다.\n\n---\n\n## 웹소켓이 연결되는 과정\n\n하이잭에 대해 알기 위해서는 제가 대충 알고 있었던 웹소켓의 연결 과정부터 다시 짚어볼 필요가 있다 생각했습니다.\n웹소켓의 연결 과정은 소위 말하는 handshake를 통해 이루어집니다. 이 과정은 다음과 같습니다.\n\n1. 클라이언트가 서버에게 웹소켓 연결을 요청합니다.\n2. 서버는 클라이언트에게 응답을 보냅니다.\n3. 클라이언트는 서버에게 응답을 보냅니다.\n4. 연결이 성공하면 서버와 클라이언트는 데이터를 주고받을 수 있습니다.\n\n이런 교양 넘치는 사람들 간의 합의를 통해 연결이 이루어지는 것이 일반적인 연결 과정입니다. 여기까지가 제가 알고\n있는 내용이고, 서버사이드에서 유닛테스트 및 통합테스트를 통해 이 과정을 정상적으로 마칠 경우에 메시지 역시\n정상적으로 주고받을 수 있었습니다.\n\n---\n\n## 도동놈, 아니 도둑님 잡아라\n\n그런데 이번에는 클라이언트가 서버에게 연결을 요청하고, 서버가 응답을 보내고, 클라이언트가 응답을 보내는\n과정은 제가 서버 내에서 임의의 클라이언트를 상정하던 것과는 달랐습니다. 아무래도 그것은 제가 사용하는 k6의\nws.connect가 연결을 요청하는 과정에서 hijack이라는 go의 websocket 패키지의 메서드와 다른 방식으로 연결을\n하는 것일 가능성이 높아보였습니다.\n\n![나는 능이버섯이다](/images/hijack/능이버섯.png)\n\n뭐 여기까지 왔는데 어쩌겠습니까. 제 반려 프로그램을 포기할 수는 없으니 이 도둑님께 굴복하는 수밖에요. 조금 더\n찾아보니 websocket hijack 관련해서는 보안 관련 이슈들이 주를 이루고 있었으나, 다른 것은 go의 http 패지키의\nhijack interface였습니다. 즉 제가 쓰는 k6도 go를 기반으로 만들어졌고, 제 서버 역시도 go로 만들어졌기 때문에\n단순히 웹소켓 연결을 요청하는 것이 아니라 hijack을 통해 연결을 요청하는 것이었습니다.\n\n---\n\n## 내가 해야하는 조치\n\n현재 제 서버는 연결을 할 때 연결이 hijack에 의해서가 아니라 기존의 gin Context의 connection을 이용한 것입니다.\n이 때문에 hijack을 통해 연결을 요청하는 경우에는 연결이 되지 않는 문제가 발생하게 되었습니다. 이 문제를 해결하기 위해서\n제가 해야할 조치는 기존에 작성한 채팅쪽 서비스 코드와 소켓 연결 모듈을 새로운 인터페이스에 맞게 수정하는 것이네요.\n별 것 아니네요!\n\n는 그럴리가 없으니, 이슈를 새로 따서 현재 작성된 hijack이 이루어지지 않을 때의 연결을 위한 코드에서 최소한의\n수정을 통해 더 높은 단의 추상 interface를 제공하고 이를 통해 양쪽의 연결을 이루어지게끔 수정하는 것이 가능한\n지에 대한 검토 및 재설계의 과정을 거쳐야 할 것 같습니다. 개발은 너무 재밌어요.(농담 아님)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","date":"2024-05-17T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-30-Blog 기능 개발","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/2024-03-30-Blog 기능 개발.md","category":"개발일지","title":"블로그 기능 개발 일지","subtitle":"세로 화면, 목차 및 카테고리 aside, subtitle 등","content":"\n## 기능 추가 이유\n\n기존에 블로그를 사용하면서 있었으면 좋겠다고 생각했던 **기능**들이 있었습니다. 읽기에 **불편한 인터페이스**나, **예쁘지 않은 디자인**과 같은 부분들이었습니다. 이번에 기능들을 추가해서 그런 아쉬움들을  어느 정도 **개선**했습니다.\n\n### 문제\n\n* **글과 카테고리의 수**가 늘어나서 읽고자 하는 글을 **탐색**하기 어려웠다.\n* 글 하나를 읽은 후 **다음 글**로 넘어가기가 어려웠다.\n* **subtitle**을 title에 형식적으로 포함돼어 있어 **다양한 layout**에서 사용하는 **확장성**이 떨어졌다.\n* 글 내용이 길어졌을 때 **원하는 지점으로 이동**하기가 어려웠다.\n\n이 밖에도 많았지만, 그 중 **핵심적인 불편사항**들은 위와 같았습니다. 이 문제들을 아래에서 **도입한 기능**들을 통해 해결했습니다.\n\n### 해결 방법\n\n* **카테고리 페이지** 추가\n* 카테고리 페이지에 접근하기 위한 **aside 추가**(세로 화면일 시 보이지 않음)\n\n* **이전 글, 다음 글 버튼**이 직관적으로 동작하게 **알고리즘 변경**\n* **홈**으로 돌아가는 버튼 추가(세로, 가로 화면 모두)\n\n* title과 subtitle을 **구분**하기 위해 **subtitle 추가**\n* subtitle을 이용하도록 기존의 **layout들을 수정**\n\n* **목차**를 이용하는 **aside** 추가(세로 화면일 시 보이지 않음)\n\n---\n\n## 느낀 점\n\n### 남들만큼 무난한 것을 만드는 것은 어려운 일이다\n\n일단 뭐라도 써야한다는 생각에 시작부터 한 블로그였던 만큼, **디자인이나 기능적으로 모자란 부분**들이 굉장히 많았습니다. 이를 나중에 보완하고, 수정된 템플릿에 맞춰 기존 글을 수정하는 일은 쉽지 않았습니다. 제가 **자바스크립트, html과 같은 웹에서 사용하는 기술**에 대한 지식이 모자라기도 했지만, 특히 제가 **미적 감각이나 경험**이 부족해서 **디자인을 수정**하는 일은 더 어려웠습니다. 다행히도 **지인분의 도움**을 얻어 일순간 테러 수준이었던 디자인을 무난한 수준으로 만들 수 있었습니다. 감사합니다 선생님.\n\n최근에 **마케팅** 관련해서 공부하는 과정에서, 어떻게 하면 사람에게 **잘 전달되고 끌리는 것**을 만들 수 있을지에 대해 많은 고민을 하는 경험을 하게 됐습니다. **기존의 블로그**는 이 부분을 신경쓰지 않았어서 양쪽에서 많이 아쉬웠기 때문에, 가급적 그 부분에 **집중해서 개선**하려고 노력했습니다. 이 과정에서 나온 것들이 이제 aside에 추가된 **목차와 카테고리 페이지, subtitle** 등입니다.\n\n이 정도 글을 확보하고 형태를 갖추는 데 **3개월**이나 걸렸다니, 좀 괜찮은 블로그라고 말할 수 있는 수준이 되려면 얼마나 걸릴지 조금 막막하긴 합니다. 아직도 많이 모자라지만, 그래도 이젠 최소한의 읽을거리가 있는 **컨텐츠**가 확보됐고 이들을 읽는 데 있어서 **많이 불편하지 않게** 만드는 데 성공했다 말할 수 있지 않을까 싶어 조금은 뿌듯하네요. 다음에는 **무난한 것**을 넘어서는 **흥미로운 것**이 되도록 발전하고 싶습니다.\n\n### 환경이 변화를 가져온다\n\n이번에 추가한 기능 중 가장 획기적이라 할만한 것은 **aside**로 움직이면서 **헤더들에 대한 하이퍼링크**를 제공하는 **목차**입니다. 이 기능을 추가한 이유는 제가 블로그를 이용하면서 글을 읽을 때 종종 **원하는 부분으로 바로 이동**하고 싶다는 생각이 들었기 때문이었습니다.\n\n단순히 **편의성 기능**이라 생각했던 부분이었는데, 이를 추가하고 나서 기존의 글들을 보니 이전에 **보이지 않았던 아쉬운 부분**들이 보이기 시작했습니다. 헤더로 처리한 내용들이 너무 장황하거나, 전달하고자하는 내용을 제대로 담고 있지 못한 경우가 꽤나 많았기 때문입니다.\n\n다시 말해, 쓸 때는 잘 쓴 줄 알았는데 퇴고도 거쳐놓고도 **미숙한 글**이란 사실을 깨닫고 **부끄러움**에 몸서리치게 됐단 뜻입니다. 초창기에 비해서는 그래도 많이 나은 글을 쓰고 있다고 생각하고 있습니다만, 이전 글들을 볼때마다 더 잘 할 수 있는 부분들이 많았다 싶어서 아쉽네요. 기회가 되면 시간을 내서라도 이전 글들에서 헤더들 만큼은 **개선**해보고 싶습니다.\n\n그래도 목차 기능 덕분에 앞으로는 제가 쓰고 있는 헤더 및 소제목들이 글의 내용을 얼마나 잘 반영하고 있는지가 더 선명하게 드러나게 돼서 이전보다는 좀 덜 부끄러운 글을 쓸 수 있게 되지 않을까 합니다.\n\n---\n\n## 앞으로의 계획\n\n이번에 기능들을 추가하게 된 것은 제게 있어서 **시험 기간에 방 청소**를 한 것과 같은 경험이었습니다. 사실 이 기능들을 추가하기 전에는 js, html에 대한 지식이 모자라다보니 너무 오랜 시간이 걸릴 것 같아 막막해서 미루고 있었습니다. 그런데 우연히 **여유 시간**이 생겼는데 기존에 하던 일들은 하기가 싫어서 잠깐 **딴짓**을 한 것이 이번 **블로그 개발**이었습니다.\n\n그런데 막상 시작하고 보니 생각보다 굉장히 **즐거운 경험**이었고, 결과물에도 나름 **만족**스럽네요. 아쉽게도 지난 3개월간 떠오른 모든 아이디어 구현이 완료가 된 상태이기에 당장은 더 추가할 기능 계획은 없습니다. 뭐 좀 지나면 '내가 이렇게 끔찍한 블로그를 사용하고 있었다고?'라는 생각을 하게 되면서 주섬주섬 계획을 하나씩 늘려나가지 않을까 싶습니다.\n\n그럼 한동안 또 새로 청소한 방을 실컷 어지르러 가보겠습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"블로그 기능 개발 일지","subtitle":"세로 화면, 목차 및 카테고리 aside, subtitle 등","date":"2024-03-30T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-17-처음으로 오픈소스 참여하기","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/2024-04-17-처음으로 오픈소스 참여하기.md","category":"개발일지","title":"처음으로 오픈소스 참여하기","subtitle":"다양한 형태의 프로젝트와의 협업을 통한 배움의 시작","content":"\n### 목차\n\n- [도움을 구하는 입장에서 벗어나 주는 입장으로](#도움을-구하는-입장에서-벗어나-주는-입장으로)\n- [회사에서 스폰서하고 모든 것이 잘 갖춰져 있는 vizro](#회사에서-스폰서하고-모든-것이-잘-갖춰져-있는-vizro)\n- [초창기 가상환경 구축이 인상적인 tagsy-discord](#초창기-가상환경-구축이-인상적인-tagsy-discord)\n- [아직 협업을 위한 노력이 더 필요해보이는 BTC-ETF-Tracker](#아직-협업을-위한-노력이-더-필요해보이는-btc-etf-tracker)\n- [마치며](#마치며)\n\n---\n\n## 도움을 구하는 입장에서 벗어나 주는 입장으로\n\n다른 사람과 협업하는 것으로 혼자 하는 것보다 많은 것을 배울 수 있다는 것을 이번에 채팅 프로그램을 작성하면서 알 수 있었기 때문에 제 기존의 프로젝트에 팀을 구성해보려는 생각을 했지만, 다른 대단한 프로젝트들에 비해 매력적으로 보이지도 않고 홍보하는 것이 용이하지 않아 쉽지 않았습니다. 그래서 반대로 다른 사람의 프로젝트에 참여해보면 어떨까 싶어 고민하던 와중 [다음 글](https://well-balanced.medium.com/%EA%BC%BC%EC%88%98%EB%A1%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0-b34ee4cc2bc2)을 읽게 됐습니다.\n\n해당 팁을 받아들여 이후 약 3일간 github에서 good first issue를 탐색하고 연락을 취하는 과정을 통해 총 3개의 다른 프로젝트에서 issue에 참가해서 오픈소스에 기여하는 경험하고 있는 중입니다. 해당 프로젝트는 각각 [vizro](https://github.com/mckinsey/vizro), [tagsy-discord](https://github.com/tarto-dev/tagsy-discord), [BTC-ETF-Tracker](https://github.com/BuildWithData/BTC-ETF-Tracker)입니다. good first issue라는 라벨을 통해 다른 사람들의 참여에 대해 생각할 정도로 관리를 신경쓰는 프로젝트들이었기 때문에 잠깐의 경험으로도 재밌는 것을 배울 수 있었습니다.\n\n---\n\n## 회사에서 스폰서하고 모든 것이 잘 갖춰져 있는 vizro\n\nvizro는 mckinsey에서 개발한 데이터 시각화 어플리케이션을 만들 때 사용하는 툴킷으로 주로 python을 사용해서 작성돼 있습니다. 프로젝트에 참여하게 된 issue는 [이것](https://github.com/mckinsey/vizro/issues/424#issuecomment-2061052264)이었습니다. 이슈의 내용은 현재 작성하고 있는 문서에 대한 링크들이 자신들이 규칙으로 정해놓은 것들을 제대로 따르면서 이용하는 사람이 편하게 읽을 수 있도록 정리하는 것이었습니다.\n\n해당 프로젝트는 hatch라는 CI 솔루션을 채용한 잘 만들어진 시스템을 갖추고 있었기 때문에, 공식 문서를 잠깐 읽는 것만으로 한번에 가상환경을 개발할 수 있는 형태로 세팅할 수 있는 것이 굉장히 놀라웠습니다. 덕분에 저는 단 한 번의 코멘트로 된 조언을 받고도 해당 프로젝트에 기여를 시작할 수 있었습니다. 또한 곳곳에 사용하기 편하게 배치된 문서를 읽으면서 오픈 소스에 참여하는 사람이 편하게 느끼도록 돕기 위해 어떤 부분들을 고려해야하는 지에 대해 배울 수 있었습니다.\n\n---\n\n## 초창기 가상환경 구축이 인상적인 tagsy-discord\n\ntagsy-discord는 discord에서 사용할 수 있는 태그를 통한 key-value 저장소를 만들어주는 봇입니다. 해당 프로젝트에 참여하게 된 issue는 [이것](https://github.com/tarto-dev/tagsy-discord/issues/26#issuecomment-2067624087)이었습니다. 이슈의 내용은 author에게서 모든 tag를 가져오는 기능을 추가하는 것이었습니다.\n\n이 프로젝트는 주로 venv, pip requirements를 통해 가상환경을 구축해서 개발 환경을 관리했고 commit message를 관리하기 위한 방법으로 contribution guide를 새로 만들어두고, pre-commit hooks란 것을 만들어서 코딩 스타일을 맞추는 것을 강제한 것이 인상 깊었습니다. 차후에 다른 사람들과 협업을 하기 위해 오픈소스 프로젝트를 만들 때 이런 것들을 참고해야겠다는 생각이 들었습니다.\n\n---\n\n## 아직 협업을 위한 노력이 더 필요해보이는 BTC-ETF-Tracker\n\nBTC-ETF-Tracker는 비트코인으로 구성한 ETF를 추적하는 프로젝트입니다. 해당 프로젝트에 참여하게 된 issue는 [이것](https://github.com/BuildWithData/BTC-ETF-Tracker/issues/34#issuecomment-2065411254)이었습니다. 이슈의 내용은 sqlite에서 데이터를 저장할 때 데이터가 rounded 되지 않고 소수점이 일정하지 않게 저장되는 것이었습니다.\n\n세 프로젝트 중에는 가장 모자란 점이 많았고 초창기의 것이었기 때문에 아쉬운 부분도 많았지만, 그렇기 때문에 제가 느낄때 가장 우선이었던 250여줄의 DRY 원칙을 위배하는 raw sql로 작성된 테이블 생성 python 스크립트를 수정하는 것이었습니다. 당분간은 리팩토링 위주로 정리를 하고 프로젝트에 기여를 시작하게 되지 않을까 생각 중입니다.\n\n---\n\n## 마치며\n\n오픈 소스에 기여하는 것이 막연하게 어렵게만 느껴졌는데 이번 일을 계기로 도움을 원하는 곳은 많고, 동시에 도움을 받기 위해서도 굉장히 많은 노력을 해야한다는 것을 알 수 있었습니다. 그리고 열정적으로 활동하는 사람들과 교류를 하면서 새로운 것을 배울 수 기회를 얻고 싶다는, 제가 기존에 원했던 목표를 달성할 수 있어서 기쁘게 생각합니다. 모든 프로젝트를 꼭 끝까지 완수할 때까지 도전하지는 않겠지만, 꾸준히 여러 프로젝트에 참여하면서 다양한 경험을 쌓아보고 싶습니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"처음으로 오픈소스 참여하기","subtitle":"다양한 형태의 프로젝트와의 협업을 통한 배움의 시작","date":"2024-04-17T00:00:00.000Z","categories":"개발일지","published":true}},{"postName":"2024-02-07-천원돌파 의존성 역전","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-07-천원돌파 의존성 역전.md","category":"디자인패턴","title":"천원돌파 의존성 역전","subtitle":"","content":"\n## 목차\n\n0. 요약\n1. 문제 상황\n2. 의존성 역전을 통한 개선\n3. 다양한 방식의 의존성 역전\n4. 마치며\n\n---\n\n## 요약\n\n* 의존성 역전 패턴은 객체지향 프로그래밍의 핵심 원리 중 하나로, 객체 간의 결합도를 낮추고 유연성을 높이는 방법입니다.\n* 의존성 역전은 상위 모듈이 하위 모듈을 추상화한 인터페이스나 추상 클래스에 의존하도록 하는 것을 말합니다.\n* 제어 역전을 통해 필요한 의존 객체의 생성부터 사용, 생명주기 관리까지 모든 것을 외부에서 관리하도록 하는 것도 가능합니다.\n\n---\n\n## 문제 상황\n\n실제로 이런 끔찍한 사례를 마주하지 않으면 더 좋겠지만, 만약 우리에게 다음과 같은 억지스러운 프로그램을 작성해야하는 상황이 닥쳤을 때를 한 번 생각해보겠습니다. 우리에게는 특정 바이너리 파일을 읽고 이 파일에 1이 얼마나 들어가 있는지 세는 프로그램을 만들라는 요구사항이 주어졌습니다. 그렇다면 다음과 같은 코드를 작성할 수도 있을 겁니다.\n\n```python\nclass BinaryFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass DataAnalyzer:\n    def __init__(self):\n        self.file_manager = BinaryFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n그런데 만약에 나중에 요구사항이 변화해서, 바이너리 파일에서 1의 갯수를 세는 것 만이 아니라 텍스트 파일에서 1의 갯수를 세는 것도 요구사항으로 추가된다면 어떻게 될까요? 어쩌면 우리는 다음과 같은 끔찍한 코드를 작성해야할 수도 있을겁니다.\n\n```python\nclass BinaryFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass TextFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'r')\n\n    def read_file(self):\n        return self.file.read()\n\nclass DataAnalyzer:\n    def __init__(self, file_type):\n        if file_type == 'Binary':\n            self.file_manager = BinaryFileManager()\n        elif file_type == 'Text':\n            self.file_manager = TextFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n우리는 단순히 DataAnalyzer 객체에서 사용할 새로운 클래스를 추가했을 뿐인데, DataAnalyzer 내부의 메서드 역시도 구현을 변환해야했습니다. 만약 이후에 새로운 파일 타입이 추가된다면, 또 다시 DataAnalyzer 내부의 메서드를 수정해야할 것입니다. 이런 상황에서 우리는 어떻게 해야할까요?\n\n---\n\n## 의존성 역전을 통한 개선\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass IFileManager(ABC):\n    @abstractmethod\n    def open_file(self, file_name):\n        pass\n\n    @abstractmethod\n    def read_file(self):\n        pass\n\nclass BinaryFileManager(IFileManager):\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass TextFileManager(IFileManager):\n    def open_file(self, file_name):\n        self.file = open(file_name, 'r')\n\n    def read_file(self):\n        return self.file.read()\n\nclass DataAnalyzer:\n    def __init__(self, file_manager: IFileManager):\n        self.file_manager = file_manager\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n개선한 코드는 Binary와 text 형태를 동시에 처리할 수 있게 사양이 변화됐는데도, 상위 모듈인 DataAnalyzer의 내부 구현은 영향을 받지 않았습니다. 이처럼 소프트웨어 간의 모듈이 상대에게 의존하게 될 때, 상대의 세부 구현이 변하더라도 상대적으로 적은 영향을 받도록 추구하는 패턴의 프로그래밍 작성 방식 중 하나를 우리는 의존성 역전이라 부릅니다.\n\n의존성 역전은 구체적으로 상위 모듈이 하위 모듈에 의존하는 상황에서 그것의 구체적인 구현에 의존하지 않고, 하위 모듈을 추상화한 상위 모듈에 의존하도록 하는 것을 말합니다. 여기에서 말한 하위 모듈을 추상화한 상위 모듈이란 위의 예시에서 본 IFileManager와 같은 인터페이스, 혹은 추상 클래스들을 말합니다. 다른 예시를 들어 살펴보자면 컴퓨터와 주변 기기들을 다음과 같이 작성할 수 있을 것입니다.\n\n```java\n\nimport java.util.ArrayList;\n\ninterface PeripheralDevice {\n    void connect();\n}\n\nclass Mouse implements PeripheralDevice {\n    @Override\n    public void connect() {\n        System.out.println(\"Mouse is connected.\");\n    }\n}\n\n\nclass Keyboard implements PeripheralDevice {\n    @Override\n    public void connect() {\n        System.out.println(\"Keyboard is connected.\");\n    }\n}\n\nclass Computer {\n    private ArrayList\u003cPeripheralDevice\u003e peripheralDevices;\n\n    public Computer() {\n        this.peripheralDevices = new ArrayList\u003c\u003e();\n    }\n\n    public void start() {\n        System.out.println(\"Computer is starting...\");\n    }\n\n    public void addPeripheral(PeripheralDevice peripheralDevice) {\n        peripheralDevices.add(peripheralDevice);\n    }\n\n    public void connectPeripherals() {\n        for (PeripheralDevice peripheralDevice : peripheralDevices) {\n            peripheralDevice.connect();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // PeripheralDevice를 구현한 Mouse와 Keyboard 객체 생성\n        PeripheralDevice mouse = new Mouse();\n        PeripheralDevice keyboard = new Keyboard();\n\n        // Computer 객체 생성 및 PeripheralDevice로 Mouse와 Keyboard 연결\n        Computer desktop = new Computer();\n        desktop.addPeripheral(mouse);\n        desktop.addPeripheral(keyboard);\n\n        // Computer 시작 및 PeripheralDevice 연결\n        desktop.start();\n        desktop.connectPeripherals();\n    }\n}\n\n```\n\n위에서 구현한 자바 코드는 컴퓨터를 OOP의 형태로 표현한 것입니다. 컴퓨터에는 다양한 주변기기를 연결할 수 있습니다. 그리고 그 주변기기의 동작에는 여러가지 형태가 존재하고, 앞으로도 새로운 주변기기가 생성될 것이니 interface라는 추상화된 상위 모듈에 구현을 의존한다면 더 유연하게 추가 구현이 발생할 때 대응할 수 있습니다.\n\n의존성 역전 패턴을 활용하면 새로운 저수준의 모듈을 구현에 추가하려 할 때 뿐 아니라, 저수준 모듈의 구현이 변했을 때 이에 대응할 수 있다는 장점도 가지고 있습니다.\n\n이제 예시를 통해 의존성 역전의 장점을 설명해보겠습니다.\n\n기존에는 UserRepository 객체가 MySQL 데이터베이스에 저장하는 로직을 구현했다고 가정해봅시다. 그런데 MySQL이 유료화가 된다거나 심각한 보안 문제가 있는 것이 발견돼서 PostgreSQL 데이터베이스를 사용하도록 변경해야하는 상황을 맞이했습니다. 만약 기존 UserRepository가 다음과 같이 데이터베이스에 종속적이라면, 기존의 UserRepository 객체를 수정해야 할 것입니다.\n\n```java\npublic class UserRepository {\n    public void save(User user) {\n        // MySQL 데이터베이스에 저장하는 로직\n        try {\n            MysqlDataSource dataSource = new MysqlDataSource();\n            dataSource.setUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\n            dataSource.setUser(\"username\");\n            dataSource.setPassword(\"password\");\n\n            Connection connection = dataSource.getConnection();\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO users (username, email) VALUES (?, ?)\");\n            statement.setString(1, user.getUsername());\n            statement.setString(2, user.getEmail());\n            statement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class UserRepository {\n    public void save(User user) {\n        // PostgreSQL 데이터베이스에 저장하는 로직\n        try {\n            PGSimpleDataSource dataSource = new PGSimpleDataSource();\n            dataSource.setUrl(\"jdbc:postgresql://localhost:5432/mydatabase\");\n            dataSource.setUser(\"username\");\n            dataSource.setPassword(\"password\");\n\n            Connection connection = dataSource.getConnection();\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO users (username, email) VALUES (?, ?)\");\n            statement.setString(1, user.getUsername());\n            statement.setString(2, user.getEmail());\n            statement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n[위는 기존에 MySQL을 사용하다가 PostgreSQL을 사용하도록 변경한 코드입니다. 이렇게 변경하면 UserRepository 객체의 구현이 변경되어야 하므로 의존성 역전 패턴을 활용하지 않은 것입니다.]\n\n하지만 의존성 역전 패턴을 활용하면 UserRepository 객체가 Database 인터페이스에 의존하도록 하고, MySQLDatabase와 PostgreSQLDatabase 클래스가 Database 인터페이스를 구현하도록 하면 UserRepository 객체는 Database 인터페이스에만 의존하게 되어 MySQL 데이터베이스를 사용하는 것이 아닌 PostgreSQL 데이터베이스를 사용하는 것으로 쉽게 변경할 수 있습니다.\n\n```java\npublic interface Database {\n    void save(User user);\n}\n\npublic class MySQLDatabase implements Database {\n    @Override\n    public void save(User user) {\n        // MySQL 데이터베이스에 저장하는 로직\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"username\", \"password\")) {\n            String query = \"INSERT INTO users (username, email) VALUES (?, ?)\";\n            try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n                preparedStatement.setString(1, user.getUsername());\n                preparedStatement.setString(2, user.getEmail());\n                preparedStatement.executeUpdate();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class PostgreSQLDatabase implements Database {\n    @Override\n    public void save(User user) {\n        // PostgreSQL 데이터베이스에 저장하는 로직\n        try (Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost:5432/mydatabase\", \"username\", \"password\")) {\n            String query = \"INSERT INTO users (username, email) VALUES (?, ?)\";\n            try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n                preparedStatement.setString(1, user.getUsername());\n                preparedStatement.setString(2, user.getEmail());\n                preparedStatement.executeUpdate();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class UserRepository {\n    private Database database;\n\n    public UserRepository(Database database) {\n        this.database = database; // 의존성 주입을 통해 Database 객체를 외부에서 받음\n    }\n\n    public void save(User user) {\n        database.save(user);\n    }\n}\n```\n\n[위는 의존성 역전 패턴을 활용하여 MySQL을 사용하다가 PostgreSQL을 사용하도록 변경한 코드입니다. UserRepository 객체는 Database 인터페이스에만 의존하고 있으며, Database 인터페이스를 구현한 MySQLDatabase와 PostgreSQLDatabase 클래스가 Database 인터페이스를 구현하고 있습니다.]\n\n---\n\n## 다양한 방식의 의존성 역전\n\n여태까지는 의존성 역전을 구현하는 방법으로 상위 모듈이 하위 모듈을 추상화한 인터페이스나 추상 클래스에 의존하도록 하는 방법을 살펴봤습니다. 그러나 제가 이야기하는 것은 추상화한 인터페이스나 클래스 도입에 따른 결합도 감소 및 유연성 높이는 방법이 아닌, 의존성 역전 패턴입니다. 그 이유는 이제 다음에 이야기할 추가적인 두가지 형태로 의존성 역전을 구현하는 것이 가능하기 때문입니다.\n\n* 의존성 주입\n* 제어 역전\n\n### 의존성 주입\n\n의존성 주입은 객체가 직접 자신이 사용할 객체를 생성하는 것이 아니라, 외부에서 객체를 주입받아 사용하는 방식을 말합니다. 이는 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있습니다. 의존성 주입은 다음과 같은 코드를 개선해야 하는 상황에서 사용할 수 있습니다.\n\n```python\nclass DataAnalyzer:\n    def __init__(self):\n        self.file_manager = BinaryFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n위의 코드에서 DataAnalyzer는 BinaryFileManager를 직접 생성하고 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하고 있음을 의미합니다. 이를 의존성 주입을 통해 개선하면 다음과 같이 작성할 수 있습니다.\n\n```python\nclass DataAnalyzer:\n    def __init__(self, file_manager):\n        self.file_manager = file_manager\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n의존성 주입을 통해 DataAnalyzer는 BinaryFileManager를 직접 생성하지 않고, 외부에서 주입받아 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하지 않고, 외부에서 주입받은 객체에 의존하고 있음을 의미합니다.\n\n그러나 의존성 주입은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있지만, 객체를 생성하고 주입하는 코드가 복잡해질 수 있습니다.\n\n이를 해결하기 위해 등장한 개념이 바로, 제어 역전입니다. 제어 역전은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점을 가지면서도, 객체를 생성하고 주입하는 코드가 복잡해지는 문제를 해결하기 위해 등장한 개념입니다.\n\n### 제어 역전\n\n제어 역전은 객체의 생성과 사용을 분리하기 위해 객체를 생성하고 사용하는 책임을 외부에 위임하는 것을 말합니다. 아까 전까지 이야기 한 의존성 주입과 얼핏 보면 동일한 이야기를 하는 것으로 이야기하기 쉽습니다. 하지만 의존성 주입은 객체를 생성하고 사용하는 책임을 외부에 위임하는 반면, 제어 역전은 객체를 생성하고 사용하는 책임을 객체 자신이 가지고 있는 것을 말합니다.\n\n말이 좀 어렵죠? 집을 청소하는 상황을 비유를 들어서 한 번 이야기해보려 합니다. 집을 청소하는 상황에서, 집주인이 직접 청소를 하지 않고, 청소부에게 청소를 맡기는 것을 의존성 주입이라고 할 수 있습니다. 이 때 우리가 기존에 이야기 해 온 의존성 주입의 방식들은 집주인이 청소부에게 청소를 위임할 때, 필요한 도구들을 직접 전달하는 것과 같습니다.\n\n그런데 이러기 위해서는 청소 도구들을 주인이 직접 관리해야할 뿐더러, 청소부가 어떤 도구를 사용해야 하는지에 대한 지시를 직접 해야하는 등의 문제가 있을 수 있습니다. 우리는 청소를 하기 싫어서 서비스를 이용하려는 것인데 오히려 더 많은 일을 해야하는 상황이 되는 것이죠.\n\n그렇다면 아예 집안 청소 서비스를 이용한다면 어떻게 될까요? 우리는 단순히 서비스 업체를 이용하기만 하면 업체는 우리 집의 상황을 판단하고, 우리에게 필요한 모든 도구를 가져온 뒤에 청소를 해주는 것입니다. 이렇게 서비스를 이용하면 우리는 청소에 집중할 수 있고, 다른 것에 신경 쓰지 않아도 되는 것이죠.\n\n그리고 이것이 바로 **제어 역전**입니다. 제어 역전은 우리가 맞이한 문제를 해결하기 위해 외부에 일을 맡기고, 그 일을 외부에서 해결하는 것을 말합니다. 마치 집안 청소 서비스를 이용하는 것처럼 말이죠.\n\n비유를 통해 이야기해봤으니, 그러면 이제 코드를 통해 한 번 살펴보겠습니다. 예시로는 이제 우리에게 친숙해진 DataAnalyzer와 FileManager를 사용하겠습니다.\n\n```python\ndata_analyzer = DataAnalyzer(BinaryFileManager())\ndata_analyzer.process_data(sample_file_name)\n```\n\n만약 우리가 data_analyzer를 통해 BinaryFileManager를 사용하려 한다면, 위와 같은 코드를 사용하게 됩니다. 하지만 만약 기획이 바뀌어 우리에게 TextFileManager를 사용하라는 요구사항이 생긴다면, 우리는 다음과 같이 코드를 변경해야 할 것입니다.\n\n```python\ndata_analyzer = DataAnalyzer(TextFileManager())\n```\n\n이처럼 의존성 주입을 사용하고 있더라도, 기존의 방식으로는 여전히 객체를 생성하고 사용할 때 마다 문제 상황에 맞는 객체를 생성해야 하는 문제가 있습니다. 이런 현상을 이제 제어 역전을 사용하여 해결해보겠습니다.\n\n```python\nclass FileManagerController:\n    def __init__(self):\n        self.file_manager = None\n\n    def get_file_manager(self):\n        return self.file_manager\n\n    def set_file_manager(self, file_type):\n        if file_type == 'binary':\n            self.file_manager = BinaryFileManager()\n        elif file_type == 'text':\n            self.file_manager = TextFileManager()\n\nfile_manager_controller = FileManagerController()\nfile_manager_controller.set_file_manager(filename.split('.')[-1])\n\ndata_analyzer = DataAnalyzer(file_manager_controller.get_file_manager())\ndata_analyzer.process_data(sample_file_name)\n```\n\n이를 통해 DataAnalyzer는 들어온 파일을 처리할 때 더 이상 파일의 정보를 알 필요가 없어졌습니다. 이는 파일 매니저 컨트롤러가 파일의 정보를 알고 있기 때문입니다. 이처럼 제어 역전을 사용하면 객체를 생성하고 사용할 때 마다 문제 상황에 맞는 객체를 생성해야 하는 문제를 해결할 수 있습니다.\n\n다만 분명 FileManagerController가 들어와서 제어가 역전됐는데, 얼핏 보기에는 코드가 복잡해지고 있는 것처럼 보일 수 있습니다. 그러면 더 나아가서, 만약 우리가 이 데이터 분석 모듈을 웹서버에 탑재해야하는 경우를 상정해보면 어떨까요?\n\n```python\nclass WebServer:\n    def __init__(self, data_analyzer):\n        self.data_analyzer = data_analyzer\n\n    def handle_request(self, file_name, file_type):\n        self.file_manager_controller.set_file_manager(file_type)\n        self.data_analyzer = DataAnalyzer(self.file_manager_controller.get_file_manager())\n        self.data_analyzer.process_data(file_name)\n```\n\n이제 우리는 보내오는 파일이 어떤 형태이든지간에, FileManagerController만이 이것을 처리할 뿐 이를 이용하는 WebServer는 어떤 파일이 들어오든지간에, FileManagerController에게 파일의 형태를 알려주기만 하면 됩니다. 다음처럼 말입니다. 사실 조금만 더 손 보면 파일 형태도 FileManagerController에게 알려주지 않아도 될 것입니다.\n\n```python\nfile_manager_controller = FileManagerController()\nweb_server = WebServer(file_manager_controller)\n\nweb_server.handle_request(\"data.bin\", 'binary')\nweb_server.handle_request(\"data.txt\", 'text')\n```\n\n---\n\n## 마치며\n\n긴 여정을 통해 의존성 역전에 대해 알아보았습니다. 의존성 역전은 객체지향 프로그래밍의 핵심 원리 중 하나로 객체 간의 결합도를 낮추고 유연성을 높이는 방법으로, 잘 사용하면 코드의 재사용성을 높이고 유지보수성을 높일 수 있습니다. 하지만 집안에 쓰레기가 얼마 없을 때는 빗자루를 집어드는 것이 청소 업체에 연락을 하는 것보다 우선하듯이, 의존성 역전 역시 코드의 유연성을 높일 필요한 상황에서 사용하는 것이 중요합니다.\n\n여러분이 앞으로 프로그램을 개발하는 데 있어, 그리고 제가 개발하는 과정에 있어서, 마주하게 될 많은 문제 상황들 중에 한번 쯤 의존성 역전이 이를 천원돌파하는 최강의 드릴이 되길 기원합니다. 그리고 이 글이 여러분의 그 드릴을 조금이나마 빛나게 해줄 수 있었다면 저에게는 더할나위 없는 즐거움이 될 것입니다. 긴 글 읽어주셔서 감사합니다. 다음 주제는... 뭐 당장 생각해 둔 것은 없습니다만 다른 디자인 패턴 중 하나를 써보면 어떨까 싶네요.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"천원돌파 의존성 역전","date":"2024-02-07T00:00:00.000Z","categories":"디자인패턴","subtitle":""}},{"postName":"2024-02-13-Strategy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-13-Strategy Pattern.md","category":"디자인패턴","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. interface를 통한 해결의 문제점\n5. 전략 패턴을 통한 해결\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**전략 패턴**은 **알고리즘**을 독립적인 객체로 **캡슐화**해서, 클라이언트와 **분리**하는 디자인 패턴입니다. 이를 통해 클라이언트는 알고리즘을 변경하지 않고도 다양한 알고리즘을 사용할 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 오리의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 오리의 **꽥꽥** 소리를 낸다는 행동은 오리의 종류에 따라 다르게 구현될 수 있습니다. 또한 여기에 **날다**와 같은 기능을 추가하는 것이 요구될 수도 있습니다. 이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 **전략 패턴**입니다.\n\n---\n\n## 요약\n\n* 전략 패턴은 알고리즘을 독립적인 객체로 캡슐화해서, 클라이언트와 분리하는 디자인 패턴입니다.\n* 클라이언트 - 오리, 알고리즘 - 날다, 꽥꽥\n* 상속이나 구현보다는 **구성**을 활용한다.\n\n---\n\n## 문제상황\n\n기존에 수영하고, 소리만 낼 수 있는 오리가 구현돼고 있던 다음과 같은 프로그램이 있었습니다. 모든 오리들은 밖에 표현되는 방식만 다르게 구현돼 있습니다.\n\n```java\npublic abstract class Duck {\n    public void swim() {\n        System.out.println(\"수영\");\n    }\n\n    public void quack() {\n        System.out.println(\"꽥꽥\");\n    }\n\n    public abstract void display();\n}\n\npublic class MallardDuck extends Duck {\n    public void display() {\n        System.out.println(\"MallardDuck\");\n    }\n}\n\npublic class RedheadDuck extends Duck {\n    public void display() {\n        System.out.println(\"RedheadDuck\");\n    }\n}\n\n...\n\n```\n\n그런데 어느날, 오리에 날다 행동을 추가하라는 기획이 내려왔습니다. 그래서 당신은 다음과 같이 날다의 행동을 추가했습니다.\n\n```java\npublic abstract class Duck {\n    ...\n\n    public void fly() {\n        System.out.println(\"날다\");\n    }\n}\n```\n\n그리고 대재앙을 맞이하게 됩니다. 이 오리 클래스를 상속하던 클래스 중에는 날아서는 안되는 rubberduck이 존재했던 것입니다. 이 노란빛 귀염둥이는 화면을 가득 수놓으며 우리를 괴롭히는 상황을 만들어냅니다.\n\n이런 식으로, 상속을 통해 구현된 클래스들에 새로운 행동을 추가하거나, 기존 행동을 변경하는 것은 많은 예상불가능한 결과를 낳을 수 있기 때문에 어렵습니다.\n\n---\n\n## Interface를 통한 해결의 문제점\n\n이 문제를 해결하기 위해 duck을 interface로 만들어서, 각각의 오리들이 이를 구현하도록 할 수 있습니다. 그런데, rubberduck과 같이 가끔 발생하는 예외가 있을 뿐 대부분의 경우에는 동일한 행동을 반복해서 사용하면 될 상황에서 interface를 사용하는 것은 매우 비효율적입니다.\n\n```java\npublic interface Duck {\n    public void swim();\n    public void quack();\n    public void display();\n    public void fly();\n}\n```\n\n위와 같은 Duck을 구현하는 수많은 클래스들에 대해 우리는 모두 4가지 메소드를 구현해야합니다. 그 뿐 아니라 이번에 fly를 추가해야했던 것과 같은 상황이 발생하면, Duck을 **구현**한 모든 클래스들에 해당 메소드들을 다 작성해주어야하는 번거로움이 생깁니다.\n\n---\n\n## 전략 패턴을 통한 해결\n\n이를 해결하기 위해 나온 것이 전략 패턴입니다. 전략 패턴은 **알고리즘**(날다, 꽥꽥 소리내다 등)을 독립적인 객체로 **캡슐화**한 뒤, 클라이언트와 **분리**하는 디자인 패턴입니다. 전략패턴을 사용할 경우 클래스를 만들 때 **변화가 필요한** 메소드는 상속하거나 구현하지 않습니다. 대신 각각의 행동을 독립적인 객체로 만든 뒤 이를 필요한 클래스에 **구성으로 추가**합니다.\n\n```java\npublic interface FlyBehavior {\n    public void fly();\n}\n\npublic interface QuackBehavior {\n    public void quack();\n}\n\n...\n\npublic class Duck {\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void setFlyBehavior(FlyBehavior fb) {\n        flyBehavior = fb;\n    }\n\n    public void setQuackBehavior(QuackBehavior qb) {\n        quackBehavior = qb;\n    }\n}\n```\n\n위와 같은 방식을 통해 우리는 각각의 행동을 독립적인 객체로 만들어서 필요한 클래스에 구성해 추가할 수 있습니다. 이를 통해 우리는 새로운 행동을 추가하거나, 기존 행동을 변경하는 것이 매우 쉬워집니다. 또한, 각각의 행동을 동적으로 변경하거나 확장할 수 있습니다.\n\n다시 말해, 우리는 전략 패턴을 통해 다음과 같은 장점을 얻을 수 있습니다.\n\n1. 한번 구현한 행동을 다른 클래스에도 쉽게 **재사용**할 수 있습니다.\n2. 행동을 **변경**하거나 **확장**하기가 매우 쉬워집니다.\n3. 행동을 **동적**으로 변경하는 것도 가능합니다.\n\n---\n\n## 결론\n\n프로그램의 구체적인 **동작**을 **캡슐화**하고 이를 클래스에서 **구성**하는 형태를 우리는 전략 패턴이라고 부릅니다. 이를 통해 우리는 한 번 작성한 코드를 **재사용**하는 장점을 유지하면서도, 새로운 행동을 **추가**하거나 기존 행동을 **동적으로 변경**하는 것이 용이한 프로그램을 작성할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","date":"2024-02-13T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-14-Decorator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-14-Decorator Pattern.md","category":"디자인패턴","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 데코레이터 패턴을 통한 해결\n5. OCP(Open-Closed Principle)\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n데코레이터 패턴은 **객체의 행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다. 이를 통해 상속을 통한 확장의 문제점을 해결할 수 있습니다.\n\nhead first design은 이에 대한 예시로 커피의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 커피숍에서 판매하는 커피의 **종류**와 **첨가물**을 추가하는 것이 요구될 수 있습니다. 이런 다양한 요구사항을 상속을 통해 구현하는 것은 모든 서브 클래스를 만들어야 하는 등의 이유 때문에 불편하고, 비효율적입니다. 이런 불편을 해소하기 위한 방법 중 하나가 **데코레이터 패턴**입니다.\n\n---\n\n## 요약\n\n* 데코레이터 패턴은 객체의 **행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다.\n* 음료에 들어가는 **첨가물**들을 **데코레이터**로 구현합니다.\n* **서브 클래스**를 만드는 대신, **데코레이터**를 사용하면 런타임에 행동을 확장할 수 있습니다.\n\n---\n\n## 문제상황\n\n커피 샵 시스템을 만들고 있다고 가정해겠습니다. 기존에 커피 숍의 주문 시스템에서 사용하던 음료 클래스는 다음과 같습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic class Espresso extends Beverage {\n    public Espresso() {\n        description = \"에스프레소\";\n    }\n\n    public double cost() {\n        return 1.99;\n    }\n}\n\npublic class HouseBlend extends Beverage {\n    public HouseBlend() {\n        description = \"하우스 블렌드 커피\";\n    }\n\n    public double cost() {\n        return .89;\n    }\n}\n\n...\n```\n\n이런 구현 방식은 새로운 **첨가물**을 **추가**하는 것이 어렵다는 문제가 있습니다. 첨가물이란 모카나 우유와 같이 음료에 추가해서 맛을 바꾸는 것들을 말합니다. 예를 들어 모카라는 첨가물을 제공하려면 어떻게 해야할까요? 우리는 다음과 같은 class를 추가해야할 것입니다.\n\n```java\npublic class EspressoWithMocha extends Beverage {\n    ...\n}\n```\n\n만약 음료의 종류가 10가지였다면 모카를 첨가하게 될 음료에 대해 최대 10가지의 서브 클래스를 만들어야 합니다. 이는 매우 비효율적입니다.\n\n그런데 여기에 더해 모카가 아닌 새로운 첨가물이 추가된다면 어떻게 해야할까요? 심지어 모카와 함께 들어갈 수 있는 우유와 같은 첨가물이라면요? 이런 경우에는 **조합의 수**가 무수히 많아질 수 있습니다.\n\n```java\n\npublic class EspressoWithMilk extends Beverage {\n    ...\n}\n\npublic class EspressoWithMochaAndMilk extends Beverage {\n    ...\n}\n\npublic class HouseBlendWithMochaAndMilk extends Beverage {\n    ...\n}\n\n...\n\n```\n\n이런 식으로 **서브 클래스**를 만드는 것은 매우 비효율적입니다. 이를 해결하기 위해 등장한 것이 바로 **데코레이터 패턴**입니다.\n\n---\n\n## 데코레이터 패턴을 통한 해결\n\n데코레이터 패턴은 커피에 다양한 첨가물을 추가할 수 있는 상황처럼, 객체에 **다양한 추가 요소**를 **동적으로 추가**할 필요가 있을 때 사용할 수 있는 패턴입니다.\n\n데코레이터 패턴은 일종의 **투명한 래퍼**를 만드는 것과 같습니다. 이 래퍼는 자신이 감싸고 있는 객체와 같은 인터페이스를 구현합니다.\n\n데코레이터 패턴을 통해 위의 커피 숍 문제를 다음과 같이 해결할 수 있습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic abstract class CondimentDecorator extends Beverage {\n    Beverage beverage;\n    public abstract String getDescription();\n}\n```\n\n위의 데코레이터 패턴이 존재하는 상태에서 다음과 같은 서브 클래스들이 구현돼있다 가정해보겠습니다.\n\n1. **Beverage**\n    * Espresso\n    * HouseBlend\n    * DarkRoast\n\n2. **CondimentDecorator**\n    * Mocha\n    * Soy\n    * Whip\n    * Milk\n\n이제 우리는 Espresso에 Mocha와 Milk를 추가하는 것을 다음과 같이 구현할 수 있습니다.\n\n```java\nBeverage beverage = new Espresso();\nbeverage = new Mocha(beverage);\nbeverage = new Milk(beverage);\n\nSystem.out.println(beverage.getDescription() + \" $\" + beverage.cost());\n```\n\n위의 방식은 기존에 서브 클래스를 만드는 방식과는 다르게 수많은 조합을 일일이 구현할 필요가 없습니다. 또한, 런타임에 행동을 확장할 수 있게 되었습니다.\n\n---\n\n## OCP(Open-Closed Principle)\n\n이처럼 우리는 데코레이터 패턴을 통해 음료에 다양한 첨가물을 추가하더라도 새로운 행동을 추가하는 서브 클래스를 만들 필요가 없어졌습니다. 또한, 다양한 객체들을 조합할 수 있게 되었습니다.\n\n이런 식으로 객체의 행동을 **확장할 수 있으면서, 변화에는 닫혀있는 특징**을 우리는 **OCP(Open-Closed Principle)**라고 합니다.\n\n---\n\n## 결론\n\n데코레이터 패턴은 **객체의 행동을 동적으로 확장**할 수 있게 해주는 디자인 패턴입니다. 기존처럼 상속을 통해 확장을 하려할 경우에는 변화하는 부분에 대한 **캡슐화**가 어렵고, 불필요한 서브 클래스의 생성이 발생할 수 있습니다.\n\n데코레이터 패턴은 기존의 **객체를 장식(decorate)**하는 방식으로 객체의 행동을 확장합니다. 이를 통해 객체의 행동을 동적으로 확장할 수 있으면서, **OCP**를 준수할 수 있게 됩니다.\n\n대신 데코레이터 패턴을 사용하기 위해 다양한 객체를 조합하는 것은 관리하기 어려울 수 있습니다. 이를 해결하기 위해 **팩토리 패턴**과 같은 디자인 패턴을 함께 사용할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","date":"2024-02-14T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-14-Observer Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-14-Observer Pattern.md","category":"디자인패턴","title":"옵저버 패턴","subtitle":"어느새 빗물이 내 발목에 고이기 전에 알려줬어야지!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 옵저버 패턴을 통한 해결.\n5. Pull 방식의 옵저버 패턴\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**옵저버 패턴**은 객체의 **상태 변화**를 **관찰**하는 객체를 만들어, 상태 변화가 있을 때마다 이를 **통보**하는 패턴입니다. 이 패턴에서는, **주제**와 **옵저버**가 있습니다. 주제는 상태를 가지고 있으며, 옵저버는 주제의 상태를 관찰하고 있다가 상태가 변화하면 이를 통보받아 처리합니다.\n\nhead first design patterns는 이에 대한 예시로 날씨 정보를 제공하는 서비스를 제시해서 설명합니다. 날씨 정보를 제공하는 서비스는 날씨 정보를 제공하는 주제가 되고, 날씨 정보를 받아서 처리하는 서비스는 옵저버가 됩니다.\n\n---\n\n## 요약\n\n1. 옵저버 패턴은 **신문사**와 **구독자**로 비유할 수 있습니다. 신문사는 구독자에게 새로운 뉴스가 나올 때마다 이를 통보합니다. 이때 신문사는 주제가 되고, 구독자는 옵저버가 됩니다.\n2. 날씨 정보 서비스 - **주제**, 디스플레이 - **옵저버**\n3. 옵저버 패턴은 주제가 통보하는 **push** 방식과 주제에게 상태를 요청하는 **pull** 방식이 있습니다.\n4. 상호작용하는 객체들 사이에서 **느슨한** 결합을 사용해서, 객체들을 서로 **독립적**으로 **재사용**할 수 있게 합니다.\n\n---\n\n## 문제 상황\n\n현재 온도, 습도, 기압을 제공하는 날씨 정보 서비스를 만들고 있습니다. 이 서비스는 다음과 같은 요구사항을 가지고 있습니다.\n\n1. 어딘가에서 보내주는 날씨 정보를 받아서, 이를 표시하는 **다양한 디스플레이**를 만들어야 합니다.\n2. **날씨 정보**를 제공하는 서비스는 날씨 정보가 **변경**될 때마다 **디스플레이**에게 이를 **통보**해야 합니다.\n3. 디스플레이는 날씨 정보가 변경될 때마다, 자신의 디스플레이를 **갱신**해야 합니다.\n\n이를 다음과 같이 구현을 했다고 가정해보겠습니다.\n\n```java\npublic class WeatherData {\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public void measurementsChanged() {\n        float temp = getTemperature();\n        float humidity = getHumidity();\n        float pressure = getPressure();\n\n        currentConditionsDisplay.update(temp, humidity, pressure);\n        statisticsDisplay.update(temp, humidity, pressure);\n        forecastDisplay.update(temp, humidity, pressure);\n    }\n\n    ...\n}\n```\n\n위 코드의 문제점은, 새로운 디스플레이 항목이 추가될 때마다 WeatherData 클래스를 수정해야 한다는 것입니다. 또, 실행 중에 디스플레이를 추가하거나 제거하는 것이 불가능합니다. 즉, 바뀌는 부분을 **캡슐화**하지 못했기 때문에 **확장성**이 떨어집니다.\n\n이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 **옵저버 패턴**입니다.\n\n---\n\n## 옵저버 패턴을 통한 해결 (push 방식)\n\n다음과 같이 위의 코드를 옵저버 패턴을 통해 수정해보겠습니다.\n\n```java\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic class WeatherData implements Subject {\n    private ArrayList\u003cObserver\u003e observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList\u003cObserver\u003e();\n    }\n\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void removeObserver(Observer o) {\n        int i = observers.indexOf(o);\n        if (i \u003e= 0) {\n            observers.remove(i);\n        }\n    }\n\n    public void notifyObservers() {\n        for (int i = 0; i \u003c observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n\npublic class CurrentConditionsDisplay implements Observer {\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\n...\n// 기타 다른 Display 클래스들\n```\n\n이제 WeatherData 클래스는 Subject 인터페이스를 구현하고, Observer 인터페이스를 구현하는 디스플레이 클래스들은 이를 구독하고 있습니다. 따라서, WeatherData 클래스는 디스플레이 클래스들을 알 필요가 없어졌습니다. 이것이 바로 **느슨한 결합**입니다.\n\n디스플레이 객체들은 WeatherData 객체에 등록되어 있으며, WeatherData 객체는 디스플레이 객체들에게 상태가 변경될 때마다 이를 통보합니다.\n\n위와 같은 형태로 구현한 Observer를 **Push** 방식이라고 합니다. Push 방식은 주제가 옵저버에게 필요한 데이터를 **직접 전달**합니다.\n\n하지만, 이 방식은 주제가 옵저버에게 필요한 데이터를 모두 전달해야 한다는 단점이 있습니다. 옵저버가 데이터를 받을 필요가 없는 경우에도 데이터를 받게 되기 때문에, **불필요한 데이터**를 받게 됩니다.  이 때문에 만약 주제에 **새로운 데이터**가 추가된다면, 옵저버에게 영향을 주게 됩니다.\n\n예를 들어 현재 WeatherData에 새로운 데이터인 windSpeed가 추가된다면, 모든 옵저버에게 windSpeed를 전달해야 하고 옵저버에는 새로운 변수 windSpeed를 추가해야 합니다. 이는 주제와 옵저버 사이의 **느슨한 결합**을 유지하기 어렵게 만듭니다.\n\n---\n\n## Pull 방식의 옵저버 패턴\n\n이를 해결하기 위한 방법 중 하나가 **Pull** 방식의 옵저버 패턴입니다. 이 방식은 옵저버가 주제에게 필요한 데이터를 **요청**하기 때문에, 주제는 옵저버에게 **필요한 데이터**만 전달하게 됩니다.\n\n다음은 Pull 방식의 옵저버 패턴을 구현한 코드입니다.\n\n```java\n\n...\n\npublic interface Observer {\n    public void update(Subject s);\n}\n\npublic class WeatherData implements Subject {\n\n    ...\n\n    public void notifyObservers() {\n        for (int i = 0; i \u003c observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(this);\n        }\n    }\n\n    ...\n}\n\npublic class CurrentConditionsDisplay implements Observer {\n\n    ...\n\n    public void update(Subject s) {\n        WeatherData weatherData = (WeatherData)s;\n        this.temperature = weatherData.getTemperature();\n        this.humidity = weatherData.getHumidity();\n        display();\n    }\n\n    ...\n}\n```\n\n현재 pull 방식의 옵저버 패턴은 주제가 옵저버에게 필요한 데이터를 전달하지 않고, 옵저버가 주제에게 필요한 데이터를 요청합니다. 이를 통해, 주제는 옵저버에게 필요한 데이터만 전달하게 되며, 불필요한 데이터를 전달하지 않게 됩니다.\n\npull 방식의 옵저버 패턴은 기존과 다르게, 만약 주제에 새로운 데이터가 추가되어도 옵저버에게 영향을 주지 않습니다. 이는 주제와 옵저버 사이의 느슨한 결합을 유지할 수 있게 합니다.\n\n대신, pull 방식의 옵저버 패턴은 옵저버가 주제에게 필요한 데이터를 요청하기 때문에, 옵저버가 주제에게 **종속적**이게 됩니다. 이는 옵저버가 주제가 구현한 인터페이스를 알아야 하기 때문입니다.\n\n이 때문에 일반적으로, pull 방식의 옵저버 패턴을 사용하는 것이 더 좋습니다.\n\n---\n\n## 결론\n\n옵저버 패턴은 특정 객체의 **상태**가 **변경**될 때, 이를 **관찰**하는 다수의 객체에게 이를 **통보**하는 패턴입니다. 이 패턴을 통해 주제와 옵저버 사이의 **느슨한 결합**을 유지할 수 있게 되며, 객체들을 서로 **독립적**으로 **재사용**할 수 있게 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"옵저버 패턴","subtitle":"어느새 빗물이 내 발목에 고이기 전에 알려줬어야지!","date":"2024-02-14T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-15-Factory Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-15-Factory Pattern.md","category":"디자인패턴","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 간단한 팩토리 패턴을 통한 해결\n5. 팩토리 메소드 패턴을 통한 해결\n6. 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n7. 추상 팩토리 패턴을 통한 해결\n8. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**팩토리 패턴**은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 기존에 객체를 생성하는 코드를 직접 사용하던 것과 달리, 이를 팩토리 클래스에 위임해서 객체를 생성하기 때문에 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n\nhead first design은 이에 대한 예시로 **피자 주문 시스템**을 만드는 과정을 제시해서 설명합니다. 피자 주문 시스템에서는 다양한 종류의 피자를 주문할 수 있습니다. 이런 다양한 종류의 피자를 만들 때 각각의 피자를 생성하는 코드를 직접 사용하는 것은 비효율적이고, 유연성이 떨어집니다. 이런 불편을 해소하기 위한 방법 중 하나가 **팩토리 패턴**입니다.\n\n---\n\n## 요약\n\n* 팩토리 패턴은 **객체의 생성을 캡슐화**하는 디자인 패턴입니다.\n* 객체를 생성하는 코드를 직접 사용하는 것이 아니라, 팩토리 클래스에 **위임**해서 객체를 생성합니다.\n* 이를 통해 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n* 팩토리 패턴은 객체 생성을 위임하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다.\n* 팩토리 - 피자/재료 공장, 제품 - 피자/재료\n\n---\n\n## 문제상황\n\n피자 주문 시스템을 만들고 있다고 가정해겠습니다. 기존에 피자 주문 시스템에서 사용하던 **피자 클래스**는 다음과 같습니다.\n\n```java\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    List\u003cString\u003e toppings = new ArrayList\u003c\u003e();\n\n    public String getName() {\n        return name;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        }\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    public void prepare() {\n        System.out.println(\"Preparing \" + name);\n    }\n\n    public void bake() {\n        System.out.println(\"Baking \" + name);\n    }\n\n    public void cut() {\n        System.out.println(\"Cutting \" + name);\n    }\n\n    public void box() {\n        System.out.println(\"Boxing \" + name);\n    }\n}\n...\n```\n\n위의 코드는 피자 주문 시스템에서 사용하는 피자 클래스입니다. 이 피자 클래스는 다양한 종류의 피자를 생성할 수 있습니다. 하지만 이런 식으로 **orderPizza 메소드**를 통해 **피자(인스턴스)**를 만드는 것은 **구상 클래스에 의존**하기 때문에 유연성이 떨어져서 문제가 있습니다.\n\n만약에 새로운 종류의 피자를 추가하고 싶다면 어떻게 해야 할까요? 또는 피자의 재료를 추가하거나, 기존의 피자를 수정하거나, 동일한 이름의 다양한 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n그럴 때마다 다음과 같은 방식으로 **orderPizza** 메소드를 수정해야 할 것입니다.\n\n```java\npublic Pizza orderPizza(String type) {\n    Pizza pizza = null;\n\n    if (type.equals(\"cheese\")) {\n        pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n        pizza = new GreekPizza();\n    } else if (type.equals(\"pepperoni\")) {\n        pizza = new PepperoniPizza();\n    // 새로운 3 종류의 피자 추가\n    } else if (type.equals(\"veggie\")) {\n        pizza = new VeggiePizza();\n    } else if (type.equals(\"clam\")) {\n        pizza = new ClamPizza();\n    } else if (type.equals(\"calm\")) {\n        pizza = new CalmPizza();\n    }\n\n    ...\n}\n```\n\n이 때 바뀌는 부분이 새로운 피자를 추가하는 부분이기 때문에, 이를 **캡슐화**하는 것이 좋습니다. 이런 **객체 생성** 부분을 캡슐화하는 것이 바로 **팩토리 패턴**입니다.\n\n---\n\n## 간단한 팩토리를 통한 해결\n\n**간단한 팩토리**는 **객체 생성을 전담**하는 클래스를 만들어서 객체 생성을 **위임**하는 방식입니다. 이를 통해 객체 생성을 캡슐화하고, 클라이언트 코드와 구상 클래스를 **분리**할 수 있습니다.\n\nhead first design pattern에서는 이를 디자인 패턴이 아니라 프로그래밍에서 자주 사용하는 관용구라고 설명합니다. 이는 디자인 패턴의 정의가 인터페이스 구현을 통한 객체의 행동을 캡슐화하는 것이기 때문입니다.\n\n그렇다 하더라도 간단한 팩토리를 사용해서 객체 생성을 캡슐화하는 것은 팩토리 패턴의 기본이 되는 개념이기 때문에 이를 통해 팩토리 패턴을 이해할 수 있습니다.\n\n위의 피자 주문 시스템을 간단한 팩토리를 통해 해결해보겠습니다.\n\n```java\npublic class SimplePizzaFactory {\n    public Pizza createPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        } else if (type.equals(\"veggie\")) {\n            pizza = new VeggiePizza();\n        } else if (type.equals(\"clam\")) {\n            pizza = new ClamPizza();\n        } else if (type.equals(\"calm\")) {\n            pizza = new CalmPizza();\n        }\n\n        return pizza;\n    }\n}\n\npublic class PizzaStore {\n    SimplePizzaFactory factory;\n\n    public PizzaStore(SimplePizzaFactory factory) {\n        this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = factory.createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n}\n```\n\n간단한 팩토리를 통해 객체 생성을 캡슐화했습니다. 이를 통해 피자 주문 시스템의 클라이언트 코드와 구상 클래스를 분리할 수 있습니다.\n\n단순히 객체 생성을 위임했을 뿐으로 보이지만 이를 사용하는 클라이언트가 매우 많을 수도 있고, 서브 클래스로 PizzaShopMenu, NYPizzaFactory, ChicagoPizzaFactory 등을 만들 수 있습니다.\n\n또 간단한 팩토리 클래스로 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n이런 식으로 객체 생성을 캡슐화해서 유연성을 높이는 것이 바로 **팩토리 패턴**의 기본 개념입니다.\n\n---\n\n## 팩토리 메소드 패턴을 통한 해결\n\n그런데 만약에 피자 주문 시스템을 **확장**해서 각 지역마다 다른 종류의 피자를 만들고 싶다면 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자를, 시카고 지역에서는 시카고 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n이런 경우에 **팩토리 메소드 패턴**을 사용할 수 있습니다. 기본 팩토리 패턴에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했다면, 팩토리 메소드 패턴에서는 객체 생성하는 메소드를 **추상화**해서 객체 생성을 추가적으로 캡슐화합니다.\n\n예를 들어 다음과 같이 **createPizza** 메소드를 추상화해서 팩토리 메소드 패턴을 사용할 수 있습니다.\n\n```java\npublic abstract class PizzaStore {\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    abstract Pizza createPizza(String type);\n}\n\npublic class NYPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new NYStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new NYStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new NYStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n\npublic class ChicagoPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new ChicagoStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new ChicagoStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new ChicagoStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n```\n\n이처럼 팩토리 메소드 패턴은 createPizza 메소드를 추상화해서 객체 생성을 캡슐화합니다. 이를 통해 팩토리 메소드 패턴은 객체 생성을 위임하는 과정을 추상화해서 기본 팩토리 패턴보다 더 유연하게 객체 생성을 관리할 수 있습니다.\n\n이 때문에 팩토리 메소드 패턴을 정의할 때, 객체를 생성할 때 필요한 **인터페이스**를 만든 뒤 어떤 클래스 **인스턴스**를 만들지는 **서브 클래스**에서 결정하도록 맡기게 됩니다. 이것은 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n이 때 PizzaStore를 **Creator(생산자)** 클래스, createPizza를 **팩토리 메소드**, Pizza를 **Product(제품)** 클래스라고 합니다.\n\n---\n\n## 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n\n위의 팩토리 메소드 패턴을 통해 알 수 있는 것 중 하나가 바로 **의존성 역전 원칙**입니다. 이 원칙은 모듈을 작성할 때 **추상화에 의존**하도록 만들고, **구체화에 의존**하지 않도록 하는 원칙을 말합니다. 다른 말로는, **상위 수준 모듈**은 **하위 수준 모듈**에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다고도 합니다.\n\n기존에 피자 주문 시스템에서는 PizzaStore 클래스가 구상 클래스에 의존하고 있었습니다. 이런 식으로 객체 생성을 위임하는 클래스가 구상 클래스에 의존하게 되면 유연성이 떨어지게 됩니다.\n\n그런데 팩토리 메소드 패턴을 통해 PizzaStore를 구현할 때는 이를 우선 추상화해서 객체 생성을 위임하는 클래스가 추상 클래스에 의존하도록 만들었습니다. 이를 통해 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않도록 만들었습니다.\n\n### 의존성 역전 원칙을 지키는 방법\n\n1. 변수를 사용할 때는 **구상 클래스**가 아닌 **추상 클래스**나 **인터페이스**를 사용합니다.\n2. 구상 클래스에서 **유도된 클래스**를 만들지 않습니다.\n3. 베이스 클래스에서 이미 구현된 **메소드 오버라이드**를 하지 않습니다.\n\n---\n\n## 추상 팩토리 패턴을 통한 해결\n\n여태까지 상황에서 더 나아가, 피자 주문 시스템에서 사용하는 원재료 군에 따른 **제품군**을 만들려면 기존의 방식으로는 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자와 뉴욕 원재료를, 시카고 지역에서는 시카고 피자와 시카고 원재료를 만들고 싶다면요?\n\n이런 경우에 **추상 팩토리 패턴**을 사용할 수 있습니다. **기본 팩토리 패턴**에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했고, **팩토리 메소드 패턴**에서는 객체 생성을 위임하는 메소드를 추상화해서 객체 생성을 캡슐화했습니다.\n\n추상 팩토리 패턴에서는 객체 생성을 위임하는 **클래스를 인터페이스로 추상화**해서 객체 생성을 캡슐화합니다. 이를 통해 추상 팩토리 패턴은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다. 구상 클래스는 서브 클래스에서 만듭니다.\n\n예를 들어 다음과 같이 **PizzaIngredientFactory** 인터페이스를 추상화해서 추상 팩토리 패턴을 사용할 수 있습니다.\n\n```java\npublic interface PizzaIngredientFactory {\n    public Dough createDough();\n    public Sauce createSauce();\n    public Cheese createCheese();\n    public Veggies[] createVeggies();\n    public Pepperoni createPepperoni();\n    public Clams createClam();\n}\n\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n\npublic class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n```\n\n위와 같이 추상 팩토리 패턴을 사용해서 **객체 생성을 위임**하는 클래스를 **인터페이스**로 **추상화**했습니다. 이를 통해 추상 팩토리 패턴은 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다.\n\n---\n\n## 결론\n\n팩토리 패턴은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 이는 공장에서 물건을 만드는 것처럼 클라이언트가 **팩토리 클래스에 위임**해서 객체를 생성하기 때문에, 구상 클래스와 클라이언트 코드를 분리하고 느슨한 결합을 유지해서 유연성을 높일 수 있습니다. 사용자는 물건을 만드는 공장에 요청을 할 뿐, 어떻게 만드는지는 알 필요가 없습니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화해서 사용하는 모듈은 **구상 클래스**에 의존하지 않고, **추상화된 인터페이스**에 의존하게 됩니다. 이는 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n팩토리 패턴을 구현하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다. 이를 통해 객체 생성을 위임하는 방식에 따라 객체 생성을 캡슐화하는 방법을 이해할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","date":"2024-02-15T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-16-Command Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-16-Command Pattern.md","category":"디자인패턴","title":"커맨드 패턴","subtitle":"나는 IoT를 지배할 수 있다!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 커맨드 패턴을 통한 해결\n5. 매크로 커맨드 패턴 사용하기\n6. NoCommand 패턴 사용하기\n7. 복잡한 기능 추가하기\n8. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**커맨드 패턴**은 **메소드 호출**을 객체로 **캡슐화**하는 패턴입니다. 코드를 호출한 객체는 호출되는 객체가 일을 어떻게 처리하는지 알 필요가 없습니다.\n\n이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다. 이제 작업을 요청하는 쪽과 작업을 수행하는 쪽을 **분리**할 수 있습니다.\n\nhead first design은 이에 대한 예시로 **IoT 리모컨**을 예시로 사용합니다. IoT 리모컨은 다양한 기기를 제어할 수 있는 리모컨입니다. TV, 에어컨, 전구, 창문 등 다양한 기기를 제어할 수 있어야 합니다.\n\n다양한 기기를 제어할 때 각각의 기기를 제어하는 코드를 직접 사용하는 것은 비효율적이고, 유연성이 떨어집니다. 리모콘은 기기들에 명령만 내릴 뿐 어떻게 처리하는지 모르는 것이 좋습니다.\n\n이런 불편을 해소하기 위한 방법 중 하나가 **커맨드 패턴**입니다. 커맨드 패턴을 사용하면 리모컨은 기기들에 명령만 내리고, 기기들은 명령을 받아서 처리하는 방법을 알고 있습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n---\n\n## 요약\n\n1. 커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 패턴입니다.\n2. 코드를 호출한 객체는 호출되는 객체가 일을 어떻게 처리하는지 알 필요가 없습니다.\n3. 이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n4. 커맨드 패턴은 **커맨드 객체**, **리시버 객체**, **인보커 객체**, **클라이언트 객체**로 구성됩니다.\n5. 커맨드 객체는 **실행 메소드**를 가지고 있습니다. 이 메소드는 리시버 객체의 **작업을 수행**합니다.\n6. 리시버 객체는 **실제 작업을 수행**하는 객체입니다.\n7. 인보커 객체는 **커맨드 객체를 저장**하고 **실행 메소드를 호출**합니다.\n8. 클라이언트 객체는 **커맨드 객체를 생성**하고, **인보커 객체에 전달**합니다.\n9. **매크로 커맨드 패턴**을 통해 **여러 개의 커맨드**를 묶어서 실행할 수 있습니다.\n10. 커맨드 객체 - 키기/끄기, 리시버 객체 - TV/에어컨/전구/창문, 인보커 객체 - 리모컨, 클라이언트 객체 - 사용자\n11. **큐, 로그, 스택** 등과 결합해 **취소, 다시 실행**과 같은 복잡한 기능을 추가할 수 있습니다.\n\n---\n\n## 문제상황\n\nIoT 리모컨을 만들어 달라는 요청과 함께 리모컨에서 다룰 수 있어야 하는 다양한 기기들이 주어졌습니다. 이 기기들은 다음과 같습니다.\n\n```java\npublic class TV {\n    public void on() {\n        System.out.println(\"TV를 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"TV를 끕니다.\");\n    }\n\n    public void setInputChannel(int channel) {\n        System.out.println(\"채널을 \" + channel + \"로 변경합니다.\");\n    }\n\n    public void setVolume(int volume) {\n        System.out.println(\"볼륨을 \" + volume + \"로 변경합니다.\");\n    }\n}\n\npublic class AirConditioner {\n    public void on() {\n        System.out.println(\"에어컨을 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"에어컨을 끕니다.\");\n    }\n\n    public void setTemperature(int temperature) {\n        System.out.println(\"온도를 \" + temperature + \"로 변경합니다.\");\n    }\n}\n\npublic class Light {\n    public void on() {\n        System.out.println(\"전구를 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"전구를 끕니다.\");\n    }\n}\n\npublic class Window {\n    public void open() {\n        System.out.println(\"창문을 엽니다.\");\n    }\n\n    public void close() {\n        System.out.println(\"창문을 닫습니다.\");\n    }\n}\n...\n```\n\n이런 다양한 클래스들이, 공통적인 인터페이스조차 존재하지 않습니다. 그런데 더 큰 문제는 앞으로도 계속해서 새로운 기기들이 추가될 것이라는 점입니다. 이런 상황에서 어떻게 리모컨을 만들 수 있을까요?\n\n---\n\n## 커맨드 패턴을 통한 해결\n\n이를 해결하기 위해 나온 것이 **커맨드 패턴**입니다. 커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 패턴입니다. 이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n\n**식당에서 주문**을 받는 것을 예시로 들어보겠습니다. 주문을 받는 직원은 주문을 받고, 주문을 요리하는 요리사에게 주문을 전달합니다. 이때 직원은 요리사가 어떻게 요리를 하는지 알 필요가 없습니다. 요리사는 주문을 받아서 요리를 하는 방법을 알고 있습니다.\n\n이 때 **손님**은 **주문**을 하는 **직원**에게 주문을 전달하고, 직원은 **요리사**에게 주문을 전달합니다. 이때 손님은 요리사가 어떻게 요리를 하는지 알 필요가 없습니다. 요리사는 주문을 받아서 요리를 하는 방법을 알고 있습니다.\n\n그리고 이것이 바로 커맨드 패턴이 동작하는 방식입니다. **메소드 호출(음식)**을 사용할 **클라이언트(손님)**는 이를 **객체(주문)**로 **캡슐화**했기 때문에 호출되는 **객체(요리사)**가 일을 어떻게 처리하는지 알 필요가 없습니다.\n\n이를 다른 표현으로는 **클라이언트 객체, 리시버 객체, 커맨드 객체, 인보커 객체**라고도 합니다.\n\n클라이언트 객체는 커맨드 객체를 생성하고, 인보커 객체에 전달합니다. 인보커 객체는 커맨드 객체를 저장하고, 리시버 객체의 작업을 수행하는 실행 메소드를 호출합니다. 커맨드 객체는 실행 메소드를 가지고 있습니다. 이 메소드는 리시버 객체의 작업을 수행합니다. 리시버 객체는 실제 작업을 수행하는 객체입니다.\n\n이런 커맨드 객체를 리모컨에 적용하면 다음과 같이 됩니다.\n\n```java\npublic interface Command {\n    public void execute();\n}\n\npublic class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.on();\n    }\n}\n\npublic class TVOffCommand implements Command {\n    TV tv;\n\n    public TVOffCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.off();\n    }\n}\n\n// 에어컨, 전구, 창문에 대한 커맨드 객체들도 같은 방식으로 만들어줍니다.\n...\n\npublic class SimpleRemoteControl {\n    Command slot;\n\n    public SimpleRemoteControl() {}\n\n    public void setCommand(Command command) {\n        slot = command;\n    }\n\n    public void buttonWasPressed() {\n        slot.execute();\n    }\n}\n```\n\n위와 같이 커맨드 패턴을 사용하면 리모컨은 기기들에 명령만 내리고, 기기들은 명령을 받아서 처리하는 방법을 알고 있습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n리모콘이 커맨드를 실행하는 방법은 다음과 같습니다.\n\n```java\n\nSimpleRemoteControl remote = new SimpleRemoteControl();\n\nTV tv = new TV();\n\nTVOnCommand tvOn = new TVOnCommand(tv);\nTVOffCommand tvOff = new TVOffCommand(tv);\n\nremote.setCommand(tvOn);\nremote.buttonWasPressed(); // TV를 켭니다.\n\nremote.setCommand(tvOff);\nremote.buttonWasPressed(); // TV를 끕니다.\n```\n\n---\n\n## 매크로 커맨드 패턴 사용하기\n\n커맨드 패턴을 통해 여러 개의 커맨드를 **묶어서 실행**할 수 있습니다. 이를 **매크로 커맨드 패턴**이라고 합니다.\n\n예를 들어 더운 여름날 사용하기 위해 TV를 켜는 커맨드와 에어컨을 켜는 커맨드를 묶어서 하나의 커맨드로 만들 수 있습니다. 이렇게 하나의 커맨드로 묶어서 실행하면 TV를 켜는 커맨드와 에어컨을 켜는 커맨드를 따로 실행하는 것보다 편리합니다.\n\n구현은 다음과 같습니다.\n\n```java\npublic class MacroCommand implements Command {\n    Command[] commands;\n\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n\n    public void execute() {\n        for (int i = 0; i \u003c commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n}\n```\n\n이렇게 하면 여러 개의 커맨드를 하나의 커맨드로 묶어서 실행할 수 있습니다.\n\n---\n\n## NoCommand 패턴 사용하기\n\n커맨드 패턴은 처음에 객체를 생성할 때 커맨드 객체를 저장하고, 실행 메소드를 호출합니다. 이때 객체를 생성하지 않았을 때의 처리를 위해 **NoCommand 패턴**을 사용할 수 있습니다. NoCommand 패턴을 사용하면 객체를 생성하지 않았을 때의 처리를 쉽게 할 수 있습니다. \n\n예를 들어 리모컨에 아무런 커맨드를 설정하지 않았을 때의 처리를 위해 다음과 같이 NoCommand 패턴을 사용할 수 있습니다.\n\n```java\npublic class NoCommand implements Command {\n    public void execute() {}\n}\n\npublic class RemoteControl {\n    Command[] onCommands;\n    Command[] offCommands;\n\n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i \u003c 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n}\n```\n\nNoCommand 패턴을 사용하지 않았을 경우에는 if문을 사용해서 처리해야 했을 것입니다. if (onCommand != null) { ... } else { ... }와 같이 말입니다.\n\n이런 NoCommand 객체는 일종의 **널 객체**입니다. 이 객체는 아무런 동작을 하지 않습니다. 이런 객체를 사용하면 클라이언트 객체는 커맨드 객체가 없을 때의 처리를 신경 쓰지 않아도 됩니다.\n\n---\n\n## 복잡한 기능 추가하기\n\n커맨드 패턴을 **스택, 큐, 로그** 등과 결합해서 **취소, 다시 실행**과 같은 **복잡한 기능**을 추가할 수 있습니다. 대표적으로 여러 작업을 큐에 저장해서 순서대로 실행하거나, 실행한 작업을 스택에 저장해서 취소하거나, 특정 체크 포인트 이후의 모든 행동을 로그에 기록해서 복구 시스템을 구축할 수 있습니다.\n\n---\n\n## 결론\n\n커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 디자인 패턴입니다. 이는 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n\n**리모컨**을 예시로 들면 사람은 리모컨을 사용해서 TV를 켜고 끄고, 에어컨을 켜고 끄고, 전구를 켜고 끄고, 창문을 열고 닫습니다. 이때 사람은 TV, 에어컨, 전구, 창문이 어떻게 동작하는지 알 필요가 없습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n커맨드 패턴은 **커맨드 객체**, **리시버 객체**, **인보커 객체**, **클라이언트 객체**로 구성됩니다.\n\n커맨드 객체는 **실행 메소드**를 가지고 있습니다. 리시버 객체는 실제 **작업 수행**을 하는 객체입니다. 인보커 객체는 **커맨드 객체 저장**을 하고, **실행 메소드 호출**을 합니다. 클라이언트 객체는 **커맨드 객체 생성**을 하고, **인보커 객체에 전달**합니다.\n\n커맨드 패턴을 통해 여러 개의 커맨드를 **묶어서 실행**할 수 있습니다. 이를 **매크로 커맨드 패턴**이라고 합니다. 매크로 커맨드 패턴을 통해 적은 노력으로 여러 개의 커맨드를 실행할 수 있습니다.\n\n인보커에서 커맨드 객체를 저장할 때 객체를 생성하지 않았을 때의 처리를 위해 **NoCommand 패턴**을 사용할 수 있습니다. 이런 NoCommand 객체는 일종의 **널 객체**입니다. 이 객체는 아무런 동작을 하지 않습니다. 이런 객체를 사용하면 클라이언트 객체는 커맨드 객체가 없을 때의 처리를 신경 쓰지 않아도 됩니다.\n\n커맨드 패턴을 **스택, 큐, 로그** 등과 결합해서 **취소, 작업 대기 큐, 복구 시스템** 등의 **복잡한 기능**을 추가할 수 있습니다.\n\n이처럼 커맨드 패턴을 통해 **메소드 호출**을 객체로 **캡슐화**하면 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"커맨드 패턴","subtitle":"나는 IoT를 지배할 수 있다!","date":"2024-02-16T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-17-Singleton Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-17-Singleton Pattern.md","category":"디자인패턴","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 고전적인 싱글톤 패턴을 통한 해결\n5. 멀티 쓰레드 환경에서의 문제점\n6. 다양한 방법을 통한 해결 - 이중검사 락, 정적인 초기화, Enum\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스**가 **하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**해서 전역 변수처럼 사용할 수 있습니다.\n\nhead first design은 이에 대한 예시로 **초콜릿 보일러**를 예시로 사용합니다. 초콜릿 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 맛있는 초콜릿을 많이 만들기 위해 무려 **500 갤런(약 1892리터)**의 초콜릿을 만들 수 있는 것을 들였습니다.\n\n이 때문에 이 보일러를 두 개나 유지하는 것은 굉장히 비효율적입니다. 이 거대한 초콜릿 보일러 하나를 동작시키는 것도 힘들 뿐더러, 두 개 이상에서 나온 것을 받아 초코바를 만드는 것도 힘들기 때문입니다.\n\n하지만 한 개의 보일러를 **두 명이 동시에 사용**하려하면 어떤 문제가 생길 수 있을까요? 초콜릿 보일러가 가득 차 있는 상태에서 새로운 재료를 붓는다거나, 끓어넘치고 있는데 온도를 더 올려버리는 등의 문제가 생길 수 있습니다. 이런 문제를 해결하기 위해서는 초콜릿 보일러를 하나만 유지하고, 이를 **공유**해서 사용하는 것이 좋습니다.\n\n이런 식으로 싱글톤 패턴은 **리소스를 절약**하고, 객체 간의 **상태를 공유**하기 위해 사용됩니다. 대신 객체 인스턴스가 하나만 만들어지기 때문에, 이 객체 인스턴스를 공유하는 모든 객체들은 멀티 쓰레드 환경에서는 주의할 필요가 있습니다.\n\n---\n\n## 요약\n\n1. 싱글톤 패턴은 특정 클래스에 대해 **객체 인스턴스**가 **하나만** 만들어지도록 해 주는 패턴입니다.\n2. 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n3. 하나뿐인 인스턴스를 공유하기 때문에 **멀티 쓰레드 환경**에서는 주의해야 합니다.\n4. 고전적인 싱글톤 패턴은 **지연 초기화**와 **스레드 안전성**을 보장하지 않습니다.\n5. 이를 해결하기 위해 **이중검사 락**을 사용하는 방법이 있습니다.\n6. **정적인 초기화**를 사용하는 방법도 있습니다.\n7. java에서는 **Enum**을 사용하는 방법이 권장됩니다.\n\n---\n\n## 문제상황\n\n초콜릿 공장에서 초콜릿을 만드는 보일러를 만들고 있습니다. 이 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 이 보일러는 다음과 같이 구현되어 있습니다.\n\n```java\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n\n    public ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n    public void drain() {\n        if (!isEmpty() \u0026\u0026 isBoiled()) {\n            // 끓인 우유/초콜릿을 다음 단계로 넘긴다.\n            empty = true;\n        }\n    }\n\n    public void boil() {\n        if (!isEmpty() \u0026\u0026 !isBoiled()) {\n            // 우유/초콜릿을 끓인다.\n            boiled = true;\n        }\n    }\n\n    public boolean isEmpty() {\n        return empty;\n    }\n\n    public boolean isBoiled() {\n        return boiled;\n    }\n}\n```\n\n우유나 초콜릿을 채워넣었는지 여부와 우유나 초콜릿을 끓였는지 여부를 세심하게 관리하고는 있지만, 이 **보일러가 여러 개**가 생성되어서 **동시에 사용**될 경우에는 어떻게 될까요? 차있지 않은 보일러를 끓이려고 하거나, 이미 끓인 보일러에 우유나 초콜릿을 채워넣으려고 하는 등의 문제가 생길 수도 있을 것입니다.\n\n이런 문제를 해결하기 위해서는 이 보일러를 **하나만 유지**하고, 이를 **공유**해서 사용하는 것이 좋습니다. 이것이 싱글톤 패턴의 개념입니다. 500 갤런이나 되는 거대한 보일러를 하나만 유지하되, 여기에다가 많은 직원들이 접근해서 우유나 초콜릿을 채워넣고, 끓이고, 다음 단계로 넘기는 것이죠.\n\n---\n\n## 고전적인 싱글톤 패턴을 통한 해결\n\n고전적인 싱글톤 패턴은 다음과 같이 구현됩니다.\n\n```java\npublic class ChocolateBoiler {\n    private static ChocolateBoiler uniqueInstance;\n\n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public static ChocolateBoiler getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new ChocolateBoiler();\n        }\n        return uniqueInstance;\n    }\n    ...\n}\n```\n\n고전적인 싱글톤 패턴은 위와 같이 생성자를 **private**으로 선언하고, 유일한 객체 인스턴스를 반환하는 **getInstance** 메소드를 만들어서 객체 인스턴스를 하나만 만들도록 합니다. getInstance 메소드는 객체 인스턴스가 없을 때만 객체 인스턴스를 만들고, 객체 인스턴스가 이미 있을 때는 객체 인스턴스를 반환하도록 합니다.\n\n이렇게 하면 **객체 인스턴스가 하나**만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 인스턴스가 하나만 만들어지기 때문에 객체 간의 **상태를 공유**할 수 있습니다.\n\n---\n\n## 멀티 쓰레드 환경에서의 문제점\n\n다만 이 방법은 **멀티 쓰레드** 환경에서는 문제가 될 수 있습니다.\n\n만약 아직 객체 인스턴스가 **생성되지 않은 상태**에서 **두 개 이상의 쓰레드**가 getInstance 메소드를 호출하게 되면 무슨 일이 일어날까요? 두 개 이상의 쓰레드가 동시에 getInstance 메소드를 호출하게 되면, 두 개 이상의 객체 인스턴스가 생성될 수 있습니다.\n\n초콜릿 공장에 필요한 보일러를 주문하라는 지령서를 실수로 두 명의 직원이 받아서, 거대한 보일러가 두 개나 도착해버린 상황을 상상해 보세요. 우리 공장에는 이런 보일러를 놓을 공간도 없는데 말입니다.\n\n이런 상황을 방지하기 위해서는 멀티 쓰레드 환경에서도 **스레드 안전성**을 보장해야 합니다.\n\n이를 단순하게 해결하는 방법으로는 생성자에 **synchronized** 키워드를 사용하는 방법이 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static synchronized ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        uniqueInstance = new ChocolateBoiler();\n    }\n    return uniqueInstance;\n}\n```\n\n그런데 synchronized 키워드를 사용하면, **getInstance** 메소드를 호출할 때마다 synchronized 키워드를 사용한 **동기화**를 해야하기 때문에 **성능**이 떨어질 수 있습니다.\n\n대략적으로 **100배** 정도 성능이 떨어진다고 합니다. 이 과정이 **병목(bottleneck)** 지점이 될 경우 프로그램 성능에 크게 영향을 미칠 수 있습니다.\n\n이런 문제를 해결하기 위해서는 여러 가지 방법이 있습니다. 이 중에서는 **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다.\n\n---\n\n## 이중검사 락을 사용한 싱글톤 패턴을 통한 해결\n\n**이중검사 락(Double-Checked Locking)**을 사용하는 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        synchronized (ChocolateBoiler.class) {\n            if (uniqueInstance == null) {\n                uniqueInstance = new ChocolateBoiler();\n            }\n        }\n    }\n    return uniqueInstance;\n}\n```\n\n이렇게 하면 getInstance 메소드를 호출할 때마다 **동기화**를 하지 않고도 **스레드 안전성**을 보장할 수 있습니다. 대부분의 경우에 uiqueInstance는 이미 null이 아닐테니까요.\n\n---\n\n## 정적인 초기화를 사용한 싱글톤 패턴을 통한 해결\n\n**정적인 초기화**를 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\nprivate static ChocolateBoiler uniqueInstance = new ChocolateBoiler();\n\npublic static ChocolateBoiler getInstance() {\n    return uniqueInstance;\n}\n```\n\n대신 이렇게 하면, 프로그램이 시작될 때 바로 객체 인스턴스가 생성되기 때문에 **지연 초기화**가 되지 않습니다. 이런 방법은 **지연 초기화**가 필요하지 않은 경우에 사용하는 것이 좋습니다.\n\n---\n\n## Enum을 사용한 싱글톤 패턴을 통한 해결\n\njava에서는 **Enum**을 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic enum ChocolateBoiler {\n    INSTANCE;\n\n    private boolean empty;\n    private boolean boiled;\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n...\n```\n\n위와 같은 방법은 멀티 쓰레드 환경에서 스레드 안정성을 보장하고, 고급 문법인 **직렬화**와 **리플렉션** 등의 문제도 해결할 수 있습니다. 이 때문에 java에서는 이 방법을 사용하는 것을 권장합니다.\n\n---\n\n## 결론\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스가 하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n\n**멀티 쓰레드 환경**에서는 주의해야 하지만, 이를 해결하기 위한 다양한 방법이 있습니다. 이 중에서는 생성자를 **synchronized**하거나, **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다. java에서는 Enum을 사용하는 방법을 권장합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","date":"2024-02-17T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-18-Adapter Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-18-Adapter Pattern.md","category":"디자인패턴","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 어댑터 패턴을 통한 해결\n5. 객체 어댑터와 클래스 어댑터\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**어댑터 패턴**은 다른 인터페이스로 **기존 클래스의 인터페이스를 변환**하는 패턴입니다. 이는 **호환성 문제**를 해결할 수 있습니다. 호환성 문제는 클래스의 인터페이스가 클라이언트의 **요구사항**과 맞지 않을 때 발생합니다.\n\n이때 어댑터 패턴을 사용하면 클라이언트의 요구사항에 맞게 클래스의 인터페이스를 변환할 수 있습니다. 마치 한국 콘센트를 유럽 콘센트에 맞게 변환하는 것과 같습니다.\n\nhead first design patterns는 이에 대한 예시로 전에 사용했던 **오리**를 가져옵니다. 어쩌다보니 오리가 모자라서 **칠면조**를 사용해야 상황이 왔는데, 칠면조는 오리와는 다른 울음 소리를 내고 있습니다. 이때 칠면조의 목소리를 오리와 동일하게 변환하는 어댑터를 사용하면 칠면조를 오리로 사용할 수 있습니다.\n\n어댑터를 사용해서 기존에 사용하던 오리 코드를 수정하지 않고 칠면조를 오리로 사용하면 코드의 수정이 최소화됩니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다.\n\n어댑터 패턴 구현 방식은 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다. 클래스 어댑터는 **상속**을 통해 어댑터를 구현하고, 객체 어댑터는 **구성**을 통해 어댑터를 구현합니다.\n\n---\n\n## 요약\n\n1. 어댑터 패턴은 **클래스의 인터페이스를 다른 인터페이스로 변환**하는 패턴입니다.\n2. **호환성 문제**를 해결할 수 있습니다.\n3. 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다.\n4. 어댑티 - 칠면조, 어댑티 - 오리, 클라이언트 - 사용자\n5. 구현 방식에 따라 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다.\n\n---\n\n## 문제상황\n\n동물원에서 기존에 오리만으로 이루어진 공연이 있었습니다. 그런데 어느 날 몇 마리의 오리가 아프게 되어서 공연을 할 수 없게 되었습니다. 그래서 동물원은 칠면조를 대신해서 공연을 하기로 했습니다. 그런데 오리가 \"**꽥꽥**\" 소리를 내는데 반해 칠면조는 \"**고블고블**\" 소리를 내기 때문에 공연을 할 수 없었습니다.\n\n위와 같은 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Duck {\n    public void quack();\n    public void fly();\n}\n\npublic interface Turkey {\n    public void gobble();\n    public void fly();\n}\n```\n\n이런 상황에서 칠면조를 오리로 사용하는 방법이 필요합니다. 칠면조의 \"고블고블\" 소리가 오리의 \"꽥꽥\" 소리와 동일하게 동작하도록 만드는 것이죠.\n\n---\n\n## 어댑터 패턴을 통한 해결\n\n이런 상황에서 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 어댑터 패턴을 사용하면 칠면조의 \"고블고블\" 소리를 오리의 \"꽥꽥\" 소리로 **변환**할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n\n    public void quack() {\n        turkey.gobble();\n    }\n\n    public void fly() {\n        turkey.fly();\n    }\n}\n```\n\n이렇게 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 칠면조의 \"고블고블\" 소리는 어댑터를 통해 \"꽥꽥\" 소리로 **변환**되어 공연 연출가에게 전달됩니다.\n\n이런 방식으로 어댑터 패턴을 사용하면 기존의 코드를 수정하지 않고 칠면조를 오리로 사용할 수 있습니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다. 동물원의 입장에서는 새로운 오리를 추가로 구매할 필요가 없어지고, 칠면조의 입장에서는 꽥꽥 소리를 내는 훈련을 할 필요가 없어지는 겁니다. 애초에 불가능하겠지만요.\n\n---\n\n## 객체 어댑터와 클래스 어댑터\n\n위와 같이 **인터페이스를 통해 어댑터를 구현**하는 것을 **객체 어댑터**라고 합니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 객체를 **소유**하는 것을 통해 요구되는 인터페이스를 제공합니다.\n\n또 다른 방법으로는 **다중 상속**을 통해 어댑터를 구현할 수도 있습니다. 이를 **클래스 어댑터**라고 합니다. 클래스 어댑터는 변환 대상과 변환 결과를 동시에 상속받아서 변환을 수행합니다. 오리와 칠면조를 **교배**시켜 만든 새로운 종류의 새라고 생각하시면 됩니다.\n\n클래스 어댑터를 코드로 나타내면 다음과 같습니다.\n\n```c++\nclass TurkeyAdapter : public Duck, public Turkey {\n    public:\n        void quack() {\n            gobble();\n        }\n\n        void fly() {\n            Turkey::fly();\n        }\n\n        void gobble() {\n            cout \u003c\u003c \"Gobble gobble Quack quack\" \u003c\u003c endl;\n        }\n}\n```\n\n---\n\n## 결론\n\n**어댑터 패턴**은 클래스의 인터페이스를 **다른 인터페이스로 변환**하는 패턴입니다. 이를 통해 **호환성 문제**를 해결하면 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다. 이는 오리만으로 이루어지던 공연에 칠면조를 추가할 수 있게 되는 것과 동일한 맥락입니다.\n\n어댑터 패턴을 구현하는 방법은 **객체 어댑터**와 **클래스 어댑터**로 나눌 수 있습니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 **객체를 소유**하는 것을 통해 요구되는 인터페이스를 제공합니다. 클래스 어댑터는 변환 대상과 변환 결과를 **동시에 상속**받아서 변환을 수행합니다. 이는 칠면조의 입에 **소리 변환기**를 달아주는 것과 칠면조와 오리를 **교배**시켜 새로운 종류의 새를 만드는 것과 비슷하게 생각하시면 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","date":"2024-02-18T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-19-Facade Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-19-Facade Pattern.md","category":"디자인패턴","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 파사드 패턴을 통한 해결\n5. 최소 지식 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**파사드 패턴**은 **복잡한 서브시스템을 간단하게 제공**하는 패턴입니다. 이는 간단한 인터페이스를 통해 까다로운 구현을 숨기고 사용자가 쉽게 사용할 수 있게 합니다. 이는 **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **홈시어터**를 가져옵니다. 홈시어터는 DVD 플레이어, 음향 시스템, 프로젝터 등으로 이루어져 있습니다.\n\n만약 홈시어터에서 영화 한 편을 보기 위해 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 한다면 사용자는 매번 영화를 보기 위해 많은 시간을 소비해야 합니다. 그러다보면 그냥 영화를 안 보고 말게 될 수도 있습니다.\n\n이때 파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 소위 버튼 하나만 **딸깍** 누르면 영화가 시작되는 것과 같습니다.\n\n**최소 지식 원칙**은 **객체 사이의 상호작용**을 **최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n---\n\n## 요약\n\n1. **파사드 패턴**은 복잡한 서브시스템을 **단순한 인터페이스**로 제공합니다.\n2. **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n3. 딸깍 - 파사드, DVD 플레이어/음향 시스템/프로젝터 - 서브시스템\n4. 파사드는 클라이언트와 구성 요소로 이루어진 **서브시스템을 분리**합니다.\n5. 파사드는 여러 클래스를 **하나로 감싸서 사용**할 수 있습니다.\n6. **최소 지식 원칙**은 객체 사이의 **상호작용을 최소화**한다는 원칙입니다.\n\n---\n\n## 문제상황\n\n한 영화광이 자신의 꿈이었던 자기만의 **홈 시어터**를 마침내 구축했습니다. 그런데 막상 꿈이 현실이 되고 보니, 그렇게 행복할 줄만 알았던 영화 생활은 녹록치 않았습니다.\n\n영화를 볼 때마다 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 하고, 심지어 동작하지 않은 것이 있으면 그것을 해결해야 했습니다. 이러다보니 영화를 보는 것이 귀찮아지고, 결국 홈 시어터를 사용하지 않게 되었습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class DvdPlayer {\n    // DvdPlayer의 동작을 위한 메소드들\n}\n\npublic class Amplifier {\n    // Amplifier의 동작을 위한 메소드들\n}\n\npublic class Projector {\n    // Projector의 동작을 위한 메소드들\n}\n\n...\n\npublic static void main(String[] args) {\n\n    Client client = new Client();\n\n    DvdPlayer dvdPlayer = new DvdPlayer();\n    Amplifier amplifier = new Amplifier();\n    Projector projector = new Projector();\n    // ...\n    dvdPlayer.on();\n    amplifier.on();\n    projector.on();\n    // ...\n}\n```\n\n평생의 숙원이었던 홈 시어터를 포기할 수는 없기 때문에 해결하기 위한 방법을 강구하던 중 이에 대한 해결방법에 대한 제안을 듣게 되었습니다.\n\n---\n\n## 파사드 패턴을 통한 해결\n\n**파사드 패턴**을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 버튼 하나만 **딸깍** 누르면 영화를 투영할 스크린은 내려오고, 창문을 가리는 커튼이 닫히고, DVD 플레이어가 켜지고, 음향 시스템이 켜지고, 프로젝터가 켜지는 것과 같습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class HomeTheaterFacade {\n    DvdPlayer dvdPlayer;\n    Amplifier amplifier;\n    Projector projector;\n    // ...\n\n    public HomeTheaterFacade(DvdPlayer dvdPlayer, Amplifier amplifier, Projector projector, ...) {\n        this.dvdPlayer = dvdPlayer;\n        this.amplifier = amplifier;\n        this.projector = projector;\n        // ...\n    }\n\n    public void watchMovie() {\n        dvdPlayer.on();\n        amplifier.on();\n        projector.on();\n        // ...\n    }\n}\n```\n\n파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 이를 통해 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하고, **여러 클래스를 하나로** 감싸서 사용할 수 있습니다.\n\n---\n\n## 최소 지식 원칙\n\n**최소 지식 원칙**은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 상호작용하는 **클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n최소 지식 원칙을 따르는 4개의 가이드라인은 다음과 같습니다.\n\n1. 객체 자체\n2. 메소드에 매개변수로 전달된 객매\n3. 메소드를 생성하거나 인스턴스를 만든 객체\n4. 객체에 속하는 구성 요소\n\n만이 객체와 상호작용을 하도록 한다.\n\n---\n\n## 결론\n\n**파사드 패턴**은 복잡한 서브시스템을 **간단한 인터페이스**로 제공합니다. 이를 통해 **복잡성**을 감소시키고 **유지보수성**을 높일 수 있습니다.\n\n**홈 시어터**의 예시를 통해 설명하면 이는 사용자가 버튼 하나를 **딸깍**하는 것만으로 영화를 볼 수 있게 되는 것과 같습니다. 파사드 패턴이 없었다면 사용자는 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법과 같은 수많은 복잡한 과정을 알아야 했을 것입니다.\n\n이런 것을 통해 파사드 패턴이 가지고 있는 **두 가지 역할**을 알 수 있습니다. 하나는 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하는 것이고, 나머지 하나는 **여러 클래스를 하나의 인터페이스로 감싸서 사용**할 수 있게 하는 것입니다.\n\n**최소 지식 원칙**을 따르는 것은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용하는 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","date":"2024-02-19T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-21-Template Method Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-21-Template Method Pattern.md","category":"디자인패턴","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 템플릿 메소드 패턴을 사용한 해결책\n5. 후크 메소드\n6. 할리우드 원칙\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 일부 단계를 서브클래스로 미루는 패턴입니다. 이는 **알고리즘의 구조**를 변경하지 않고 알고리즘의 **특정 단계**를 서브클래스에서 **재정의**할 수 있게 합니다.\n\n이 과정을 통해 템플릿 메소드 패턴은 알고리즘의 **템플릿(틀)**을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **카페인 음료 만들기**를 가져옵니다. 카페인 음료에는 커피와 홍차가 있을 수 있고, 둘은 많은 부분에서 같은 과정을 거치지만 '찻잎'과 '커피 콩'을 넣는 부분이나, '설탕과 우유'와 '레몬'을 추가하는 과정이 다릅니다.\n\n템플릿 메소드 패턴을 통해서 메소드에서 **공유**하는 부분은 상위 클래스에서 구현해 두고, **차이**가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 **후크 메소드**란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n**할리우드 원칙**은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, **의존성이 부패**하(복잡하기 꼬이)지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n\n---\n\n## 요약\n\n1. **템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 **일부 단계**를 서브클래스로 미루는 패턴입니다.\n2. **템플릿**을 통해 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다.\n3. **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n4. 물 끓이기 - 고정 알고리즘, 찻잎/커피 콩 넣기 - 서브클래스에서 재정의할 수 있는 부분\n5. **후크 메소드**는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n6. **할리우드 원칙**은 **의존성이 부패**하지 않도록 하는 원칙입니다.\n\n---\n\n## 문제상황\n\n기존에 커피만 판매하던 카페에서 최신 유행에 맞추어 홍차를 판매하기로 결정했습니다. 처음에는 둘의 제조법이 다르기 때문에 별개의 방식으로 관리하고 있었지만, 일을 진행하는 과정에서 과정에서 중복되는 부분이 많은데 이를 따로 관리하는 것이 비효율적이라는 생각을 하게 됐습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    abstract void prepareRecipe(); \n    abstract void boilWater(); \n    abstract void pourInCup();\n}\n\npublic class Coffee extends CaffeineBeverage {\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void brewCoffeeGrinds() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addSugarAndMilk() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage{\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        steepTeaBag();\n        pourInCup();\n        addLemon();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void steepTeaBag() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addLemon() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n---\n\n## 템플릿 메소드 패턴을 사용한 해결책\n\n현재 카페에서 커피와 홍차를 준비하는 과정에서 물 끓이기와 컵에 따르기가 중복되는 것을 볼 수 있습니다. 또 찻잎을 우리는 것과, 레몬을 추가하는 것은 커피를 우리는 것과 우유를 첨가하는 것과 비슷한 행위입니다.\n\n이런 중복성을 해소하기 위해 템플릿 메소드 패턴을 사용할 수 있습니다. 바로 prepareRecipe() 메소드를 추상화하는 것을 통해 말입니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n\n    abstract void brew();\n    abstract void addCondiments();\n\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n기존의 prepareRecipe는 abstract로 선언돼 모든 서브클래스에서 별개로 구현해야했지만, 현재 prepareRecipe는 final로 선언돼 있어 서브클래스에서 오버라이드할 수 없습니다. 이를 통해 prepareRecipe는 고정된 알고리즘을 가지고 있습니다. 하지만 여기에 brew()와 addCondiments()는 추상 메소드로 선언돼 있어 서브클래스에서 구현해서 각자의 알고리즘을 만들 수 있습니다.\n\n이렇게 **템플릿**이라는 **골격** 내에서 **동일한 부분**을 **상위 클래스**에서 구현하고, 일부 **차이**가 나는 부분을 **서브 클래스**에서 구현하는 것을 우리는 **템플릿 메소드**라고 합니다.\n\n---\n\n## 후크 메소드\n\n위에서처럼 모든 서브 클래스마다 다르게 동작을 해야하는 경우도 있지만, 때로는 **아무 동작도 하지 않아야** 되는 경우도 있습니다. 이럴 때 사용하는 것이 바로 **후크 메소드**입니다.\n\n후크 메소드는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n예를 들어, 커피나 홍차를 끓이는 것과 달리 우유, 설탕, 레몬을 추가하는 것은 선택사항입니다. 이럴 때 후크 메소드를 사용할 수 있습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        ...\n        if (customerWantsCondiments()) {\n            addCondiments();\n        }\n    }\n\n    ...\n    // 후크 메소드\n    boolean customerWantsCondiments() {\n        return true;\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    ...\n    // 후크 메소드 오버라이드\n    @Override\n    boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith(\"y\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n기존에 상위 클래스에서 hooker 메소드인 customerWantsCondiments는 아무것도 하지 않습니다. 그리고 서브 클래스인 커피에서는 유저의 입력에 따라서 첨가물인 설탕과 우유를 추가할지 말지를 결정합니다.\n\n---\n\n## 할리우드 원칙\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정하는 것을 말합니다.\n\n템플릿 메소드 패턴은 이 원칙을 따르는 대표적인 패턴입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않습니다.\n\n예를 들어, 스타버즈에서 음료수를 제조하기 시작하면 커피나 홍차를 만들기 위해 물을 끓이고, 컵에 따르는 것은 상위 클래스에서 결정하고, 그 외의 것인 커피를 우려내거나 찻잎을 우려낼 때에만 서브 클래스를 불러냅니다.\n\n이런 것이 할리우드 원칙입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않는 것입니다. 이는 일종의 의존성 역전이라고도 할 수 있습니다.\n\n---\n\n## 결론\n\n템플릿 메소드 패턴은 알고리즘의 템플릿(틀)을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\n템플릿 메소드 패턴을 통해 메소드에서 공유하는 부분은 상위 클래스에서 구현해 두고, 차이가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 후크 메소드란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","date":"2024-02-21T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-23-Iterator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-23-Iterator Pattern.md","category":"디자인패턴","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 반복자 패턴을 사용한 해결책\n5. 단일 역할 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**반복자 패턴**은 **컬렉션**의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소**에 **접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 접근을 하는 기능을 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\nhead first design patterns는 여러 가지 **음식점 통합**을 해야하는 상황을 이야기합니다. 음식점의 종류에는 팬케이크 하우스, 디너 하우스, 카페가 있고 이들은 각각의 메뉴를 ArrayList, Array, HashMap과 같이 **다른 형태로 관리**하고 있습니다. 이런 상황에서 한 명의 웨이트리스에게 메뉴들을 읽는 다른 방법들을 다 숙지시키고 일을 맡기는 것은 비효율적이고 위험합니다.\n\n이때 반복자 객체를 통한 접근을 사용해서 문제를 해결할 수 있습니다. 웨이트리스는 개별의 객체들을 순회하는 방법들에 대해 인지할 필요 없이 이를 **캡슐화**한 **반복자 객체**를 사용해서 각각의 객체들을 순회할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다**.\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n\n---\n\n## 요약\n\n1. **반복자 패턴**은 컬렉션의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소에 접근**할 수 있게 하는 패턴입니다.\n2. 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다.\n3. 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n4. **단일 역할 원칙**은 \"클래스는 하나의 변경 이유만을 가져야 한다.\"라는 원칙입니다.\n\n---\n\n## 문제상황\n\n마을의 디너 하우스에서 사업 확장의 일환으로 팬케이크 하우스와 **합병**을 하기로 결정했습니다. 이 합병은, 식사는 훌륭하지만 디저트가 아쉬웠던 약점 보완을 통해 시너지 작용을 해서 더 많은 손님을 유치할 수 있으리라 기대했습니다.\n\n그런데 여기에서 일 할 웨이트리스들 간에서 불만의 목소리가 나왔습니다. \"나는 **반대쪽 식당의 메뉴판**을 읽을 수가 없는데요?\"\n\n확인해보니, 팬케이크 하우스는 **ArrayList**, 디너 하우스는 **Array**로 메뉴를 관리하고 있었습니다. 이런 상황에서 두 식당을 통합하려면 손님은 자기가 주문하려는 메뉴를 알고 있는 웨이트리스가 누구인지를 알아내든지, 웨이트리스가 두 식당의 메뉴판을 다 숙지하고 있어야 하는 문제가 발생할 것으로 예상됩니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class MenuItem {\n    String name;\n    String description;\n    boolean isVegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean isVegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.isVegetarian = isVegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    ...\n}\n\npublic class PancakeHouseMenu {\n    ArrayList\u003cMenuItem\u003e menuItems;\n\n    public PancakeHouseMenu() {\n        menuItems = new ArrayList\u003cMenuItem\u003e();\n\n        addItem(\"K\u0026B 팬케이크 세트\", \"스크램블드 에그와 토스트가 곁들여진 팬케이크\", true, 2.99);\n        addItem(\"레귤러 팬케이크 세트\", \"달걀 후라이와 소시지가 곁들여진 팬케이크\", false, 2.99);\n        addItem(\"블루베리 팬케이크\", \"신선한 블루베리와 시럽으로 만든 팬케이크\", true, 3.49);\n        addItem(\"와플\", \"와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.\", true, 3.59);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        menuItems.add(menuItem);\n    }\n\n    public ArrayList\u003cMenuItem\u003e getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n\n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n\n        addItem(\"채식주의자용 BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", true, 2.99);\n        addItem(\"BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", false, 2.99);\n        addItem(\"오늘의 스프\", \"감자 샐러드를 곁들인 오늘의 스프\", false, 3.29);\n        addItem(\"핫도그\", \"사워크라우트, 갖은 양념, 양파, 치즈가 곁들여진 핫도그\", false, 3.05);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        if (numberOfItems \u003e= MAX_ITEMS) {\n            System.err.println(\"죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n\n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n\n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n\n    public void printMenu() {\n        ArrayList\u003cMenuItem\u003e breakfastItems = pancakeHouseMenu.getMenuItems();\n        MenuItem[] lunchItems = dinerMenu.getMenuItems();\n\n        System.out.println(\"아침 메뉴\");\n        for (int i = 0; i \u003c breakfastItems.size(); i++) {\n            MenuItem menuItem = breakfastItems.get(i);\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n\n        System.out.println(\"점심 메뉴\");\n        for (int i = 0; i \u003c lunchItems.length; i++) {\n            MenuItem menuItem = lunchItems[i];\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n위와 같은 상황을 개선하지 않으면 앞으로 더 많은 음식점을 통합하려는 목표를 가진 주인 입장에서는 심각한 걸림돌이 될 수 있습니다. 새로운 종업원을 교육하는 것도 힘들고, 주문의 절차도 복잡해지기 때문입니다.\n\n여태까지 디자인 패턴을 적용하면서 이런 문제를 해결해왔듯이, **반복**이 되면서 **변하는 부분**을 찾아내고, 이를 **캡슐화**해서 **재사용**할 수 있게 만들어야 합니다.\n\n\n---\n\n## 반복자 패턴을 사용한 해결책\n\n**반복자 패턴**을 사용하면 위와 같은 문제를 해결할 수 있습니다. 반복자 패턴은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션**의 **모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n비유를 통해 설명하자면 웨이트리스에게 메뉴들을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 **쪽지**를 주는 것과 같습니다. 이 쪽지는 각각의 식당에 대한 메뉴판을 순회하는 방법을 캡슐화한 반복자 객체입니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\npublic interface Menu {\n    Iterator createIterator();\n}\n\npublic class PancakeMenuIterator implements Iterator {\n    ArrayList\u003cMenuItem\u003e items;\n    int position = 0;\n\n    public PancakeMenuIterator(ArrayList\u003cMenuItem\u003e items) {\n        this.items = items;\n    }\n\n    public Object next() {\n        MenuItem menuItem = items.get(position);\n        position = position + 1;\n        return menuItem;\n    }\n\n    public boolean hasNext() {\n        return position \u003c items.size();\n    }\n}\n\npublic class PancakeHouseMenu implements Menu {\n    ...\n\n    public Iterator createIterator() {\n        return new PancakeHouseMenuIterator(menuItems);\n    }\n}\n\npublic class Waitress {\n    ...\n\n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n\n        System.out.println(\"아침 메뉴\");\n        printMenu(pancakeIterator);\n        System.out.println(\"점심 메뉴\");\n        printMenu(dinerIterator);\n    }\n\n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = (MenuItem) iterator.next();\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n이제 더 많은 식당들을 추가하더라도 각각의 웨이트리스들에게 새로운 메뉴판을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 쪽지를 읽는 방법을 숙지시키는 것만으로도 교육과정을 줄일 수 있습니다.\n\n---\n\n## 단일 역할 원칙\n\n**단일 역할 원칙**(Single Responsibility Principle)은 **\"클래스는 하나의 변경 이유만을 가져야 한다.\"**라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 **바뀌는 부분**의 **역할**이 **하나**이도록 하자는 원칙입니다.\n\n반복자 패턴을 사용하면 이 원칙을 지킬 수 있습니다. 웨이트리스는 메뉴판을 읽는 방법을 숙지시키는 역할만을 가지고 있고, 반복자 객체는 메뉴판을 순회하는 역할만을 가지고 있습니다. 이렇게 각각의 객체들은 하나의 역할만을 가지고 있기 때문에 단일 역할 원칙을 지킬 수 있습니다.\n\n---\n\n## 결론\n\n**반복자 패턴**은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션의 모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 반복 작업을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n이는 마치 여러 가지 **다른 형태의 메뉴판**을 가지고 있는 **음식점의 메뉴**를 통합할 때, 근무할 웨이트리스에게 각각의 메뉴를 숙지하게 하는 것이 아니라 이를 **통합한 쪽지**를 주는 것과 같습니다. 이를 통해 웨이트리스는 각각의 메뉴를 숙지할 필요 없이 쪽지를 통해 메뉴를 **순회**할 수 있게 됩니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 **컬렉션에서 분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다.**\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","date":"2024-02-23T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-Composite Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-Composite Pattern.md","category":"디자인패턴","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 컴포지트 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**컴포지트 패턴**은 객체들이 복합적으로 구성된 **집합 객체**와 **단일 객체**가 있을 때, 이를 **동일하게 접근**할 수 있는 인터페이스로 구현한 뒤 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\nhead first design patterns에서는 기존의 팬케이크 식당과 디너 식당을 합병하는 상황에서 더 나아간 문제를 제시합니다. 여기에 디저트 식당을 추가로 합병한 뒤에, 이들의 메뉴를 각각 다른 시간대에 독립된 형태로 제공하는 것이 아니라 **복합적인 형태**로 제공하려면 어떻게 해야 할까요?\n\n예를 들어, 프랜차이즈의 오너가 시너지를 위해 디저트 식당을 합병한 경우를 가정해보겠습니다. 회사에서 목표로하는 것은 이 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, **기존 메뉴와 함께** 제공하는 것입니다. 디너 식당의 메뉴에 디저트 메뉴 코너를 추가하듯이 말입니다.\n\n**컴포지트 패턴**은 이런 문제에 대한 해결을 제시합니다. 기존에 반복자 패턴은 여러 다른 형태의 객체들을 단일의 반복자라는 인터페이스를 통해 순회할 수 있게 만들어 줬던 것과는 다르게, 컴포지트 패턴을 사용하려면 복합 객체와 단일 객체가 **동일한 인터페이스**를 가지고 있어야 합니다.\n\n새로운 인터페이스를 통해 컴포지트 패턴을 사용하면, 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있으면서 동시에 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 요약\n\n1. **컴포지트 패턴**은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다.\n2. 클라이언트가 **개별 객체**와 **복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있게 합니다.\n3. 컴포지트 패턴을 사용하면 **복합 객체**와 **단일 객체**가 동일한 인터페이스를 가지고 있어야 합니다.\n4. 컴포지트 패턴을 통해 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 문제상황\n\n성공적으로 팬케이스 하우스, 디너 하우스를 합병한 프랜차이즈의 오너는 이제 **수평적 확장**에 그치지 않고 **수직적인 확장**에 관심을 가지게 되었습니다. 그리고 그 수단은 바로 디저트 식당을 합병하는 것입니다.\n\n팬케이크 하우스와 디너 하우스의 합병은 서로가 운영하지 않는 시간대를 이용해 시너지를 내는 것이 목적이었습니다. 그러나 케이크 식당은 이와는 다르게, 기존의 메뉴와 함께 제공되어야 합니다. 이를 통해 동일 시간대에 더 많은 수익을 창출하는 것이 이번 합병의 목표입니다.\n\n위 상황을 코드로 나타내면 다음과 같습니다. 여기에 생략된 기존의 팬케이크, 디너 식당의 메뉴를 관리하는 클래스들을 반복자를 통해 작성한 코드는 [반복자 패턴 - 저녁밥도 팬케이크도 다 단비꺼야](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/02/23/Iterator-Pattern.html)를 참고해 주세요.\n\n```java\npublic class DessertMenu {\n    ArrayList\u003cMenuItem\u003e menuItems;\n\n    public DessertMenu() {\n        menuItems = new ArrayList\u003c\u003e();\n\n        addItem(\"케이크\", \"초콜릿 케이크\", true, 3.00);\n        addItem(\"케이크\", \"바닐라 케이크\", true, 3.00);\n        addItem(\"케이크\", \"딸기 케이크\", true, 3.00);\n    }\n\n    // 기타 디저트 메뉴를 구성하는 메서드들\n    ...\n}\n```\n\n문제는 위와 같은 메뉴를 관리하는 클래스를 기존의 팬케이크, 디너 식당의 메뉴에 추가하는 것이 복잡하단 것입니다.\n\n해결책 중 하나로는 디저트 메뉴의 항목을 각각 추가할 수도 있습니다. 하지만 만약에 디저트 식당에 새로운 메뉴가 추가하거나 삭제되면 이를 통합한 모든 메뉴들에 해당 작업을 실행해야 합니다. 또 만약 디저트 식당을 매각하게 돼서 메뉴를 삭제해야 한다면 이 또한 골치아픈 일이 될 것입니다.\n\n결국, 이처럼 각각이 다른 형태로 관리되는 메뉴들을 유연하게 통합하는데에는 한계가 있습니다.\n\n---\n\n## 컴포지트 패턴을 사용한 해결책\n\n우선 현재와 같이 각각의 메뉴를 관리하는 클래스들을 동일하게 **메뉴 항목**으로 취급할 수 있는 **인터페이스**를 만들어야 합니다. 이 인터페이스는 메뉴 항목이 가지는 **공통적인 특성**을 정의해야 합니다.\n\n이를 위해 MenuComponent라는 추상 클래스를 만들고, 이 클래스를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n코드로 표현하면 다음과 같습니다.\n\n```java\npublic abstract class MenuComponent {\n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n\n    // 기타 메서드들\n}\n```\n\nMenuComponent는 단일 메뉴와, 메뉴판이 가지는 공통적인 특성과 그렇지 않은 것이 동시에 정의돼있습니다. 이 때문에 클라이언트는 개별 메뉴와 복합 메뉴를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\n대신 개별 메뉴인 MenuItem의 경우에는 add, remove, getChild 메서드를 사용할 수 없게 만들어야 합니다. 이를 위해 UnsupportedOperationException을 던지는 것입니다.\n\n이제 이를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n```java\npublic class MenuItem extends MenuComponent {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean vegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n\n    public void print() {\n        System.out.print(\"  \" + getName());\n        if (isVegetarian()) {\n            System.out.print(\"(v)\");\n        }\n        System.out.println(\", \" + getPrice());\n        System.out.println(\"     -- \" + getDescription());\n    }\n}\n```\n\n```java\npublic class Menu extends MenuComponent {\n    ArrayList\u003cMenuComponent\u003e menuComponents = new ArrayList\u003c\u003e();\n    String name;\n    String description;\n\n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n\n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n\n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void print() {\n        System.out.print(\"\\n\" + getName());\n        System.out.println(\", \" + getDescription());\n        System.out.println(\"---------------------\");\n\n        Iterator\u003cMenuComponent\u003e iterator = menuComponents.iterator();\n        while (iterator.hasNext()) {\n            MenuComponent menuComponent = iterator.next();\n            menuComponent.print();\n        }\n    }\n}\n```\n\n이제 위의 **컴포지트 패턴**을 적용한 메뉴와 메뉴판을 웨이트리스에게 제공하면, 이를 복합적으로 **통합**해서 제공하는 시스템을 구축할 수 있게 됩니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TestMenu {\n    public static void main(String[] args) {\n        MenuComponent pancakeHouseMenu = new Menu(\"팬케이크 하우스 메뉴\", \"아침 메뉴\");\n        MenuComponent dinerMenu = new Menu(\"디너 메뉴\", \"점심 메뉴\");\n        MenuComponent dessertMenu = new Menu(\"디저트 메뉴\", \"디저트 메뉴\");\n\n        MenuComponent waitress = new Menu(\"전체 메뉴\", \"전체 메뉴\");\n\n        waitress.add(pancakeHouseMenu);\n        waitress.add(dinerMenu);\n\n        dinerMenu.add(desertMenu);\n        pancakeHouseMenu.add(desertMenu);\n\n        waitress.print();\n    }\n}\n```\n\n---\n\n## 결론\n\n**복합 객체**와 **단일 객체**를 동일하게 다루어서 **유연**하게 객체들을 **조합**하는 문제를 해결해야하는 경우가 있습니다. 이런 경우에는 양 객체에 **동일한 인터페이스**를 적용하는 **컴포지트 패턴**을 사용할 수 있습니다.\n\n컴포지트 패턴은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트가 **개별 객체**와 복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있습니다.\n\n이는 마치 프랜차이즈 오너가 사업을 **수평적 확장**에서 **수직적 확장**으로 바꾸는 것과 같습니다. 이를 통해 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, 기존 메뉴와 함께 제공하는 것입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-State Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-State Pattern.md","category":"디자인패턴","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 상태 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다. 이는 객체의 상태를 클래스로 표현해서 **추상화**하고, 상태 객체의 동작을 통해 조작하고자 하는 객체가 **자동으로 행동**을 **변경**할 수 있도록 합니다.\n\n상태 패턴을 사용하면 객체의 관점에서는 동일한 동작을 하지만, 내부적으로는 상태에 따라 다른 동작을 하도록 할 수 있습니다. 이는 마치 객체의 **클래스가 바뀌는 것**과 같은 효과를 가져옵니다.\n\nhead first design patterns는 **동전 투입기**를 예시로 들어 상태 패턴을 설명합니다. 동전 투입기는 **동전 없음**, **동전 있음**, **동전 투입됨**과 같은 여러 가지 **조건**에 따라 동작을 달리합니다. 이것들을 **내부 변수**의 값을 통해 **조건문**으로 처리하려 할 경우 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이런 상황에서 **상태 패턴**을 사용하면 각각의 **상태**를 클래스로 **캡슐화**해서 나중에 변경해야 하는 내용을 국지화할 수 있습니다. 이를 통해 상태에 따라 객체가 알아서 행동을 바꿀 수 있도록 할 수 있습니다. 이는 마치 매 순간 동전 투입기가 **새로운 물건**으로 변신하는 것과 같은 효과를 가져옵니다.\n\n상태 전환은 State 클래스로 제어할 수도 있고, Context 클래스로 제어할 수도 있습니다.\n\n---\n\n## 요약\n\n1. **상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다.\n2. 객체의 상태를 **클래스로 표현**하고, **내부 상태**에 따라 객체의 행동을 **알아서** 바꿀 수 있게 합니다.\n3. 상태 전환은 **State 클래스**로 제어할 수도 있고, **Context 클래스**로 제어할 수도 있습니다.\n4. Gumball Machine - Context, State - 동전 없음, 동전 있음, 동전 투입됨\n\n---\n\n## 문제상황\n\n동전을 투입하고 손잡이를 돌리면 알맹이가 나오는 껌볼 기계를 만들어 달라는 요청이 들어왔습니다. 이를 구현하기 위해서는 매 입력이 들어온 순간마다 해당 기계가 동전이 있는지, 손잡이를 돌렸는지, 알맹이가 있는지 정보를 가지고 있어야 합니다.\n\n이 정보들을 기존의 변수로 처리하려고 하면 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n\n    int state = SOLD_OUT;\n\n    public GumballMachine(int count) {\n        this.count = count;\n        if (count \u003e 0) {\n            state = NO_QUARTER;\n        }\n    }\n\n    public void insertQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"동전은 한 개만 넣어주세요.\");\n        } else if (state == NO_QUARTER) {\n            state = HAS_QUARTER;\n            System.out.println(\"동전을 넣으셨습니다.\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"매진되었습니다.\");\n        } else if (state == SOLD) {\n            System.out.println(\"잠깐만 기다려 주세요. 알맹이가 나가고 있습니다.\");\n        }\n    }\n\n    // ejectQuarter, turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이처럼 해당 객체가 동작할 때마다 사용할 메소드들은 모든 변수들에 대해 **분기문**을 처리해야하기 때문에 가독성이 떨어지고, **새로운 명령이나 변수**가 추가될 때마다 코드를 수정해야 하기 때문에 유지보수가 어렵습니다.\n\n만약 예를 들어 동전을 돌리는 순간에 10분의 1 확률로 두 개의 알맹이가 나오는 기능을 추가하고 싶다면 어떻게 해야할까요? 이를 위해서는 수많은 경우의 수를 고려해서 코드를 수정해야 합니다.\n\n---\n\n## 상태 패턴을 사용한 해결책\n\n문제를 반대로 생각해서 메소드가 실행될 때마다 모든 상태를 분기문을 통해 확인하는 것이 아니라, **객체의 상태**를 **변경**하고 해당 상태에 따라 객체의 **행동이 정해진다**면 어떨까요? 그것이 바로 **상태 패턴**입니다.\n\n상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현하도록 한 뒤, 이들을 **통합하는 인터페이스**를 제공하는 것을 통해 상태 패턴을 구현할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface State {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    GumballMachine gumballMachine;\n\n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    public void insertQuarter() {\n        System.out.println(\"동전을 넣으셨습니다.\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n\n    public void ejectQuarter() {\n        System.out.println(\"동전을 넣어주세요.\");\n    }\n\n    // turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n\n// HasQuarterState, SoldState, SoldOutState 클래스도 비슷한 방식으로 구현됩니다.\n```\n\n이렇게 구현한 상태 패턴을 통해 GumballMachine 클래스를 새로 구현하면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n\n    State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int count) {\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n\n        this.count = count;\n        if (count \u003e 0) {\n            state = noQuarterState;\n        }\n    }\n\n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void releaseBall() {\n        System.out.println(\"알맹이가 나가고 있습니다.\");\n        if (count != 0) {\n            count = count - 1;\n        }\n    }\n\n    // getCount, refill 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이제 각각의 상태에 대해 별도의 **클래스**로 **캡슐화**했기 때문에, Gumball은 현재 상태에 따로 인지할 필요 없이 인터페이스를 이용만 하면 됩니다. 이에 따른 **동작**은 각각의 **상태 클래스에서 정의**되어 있기 때문입니다.\n\n이는 추가적으로 상태를 추가하거나, 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 유지보수가 용이합니다.\n\n---\n\n## 결론\n\n**상태 패턴**은 객체의 **상태에 따라 객체의 행동을 변경**할 수 있게 하는 패턴입니다. 이는 객체의 **상태를 클래스로 표현**하고, 상태에 따라 **객체의 행동이 자동으로 결정**되도록 합니다. 이는 마치 객체의 클래스가 바뀌는 것과 같은 효과를 가져옵니다.\n\n상태 패턴을 통해 객체의 상태를 context가 아닌 **상태 클래스에서 관리**함으로써, context는 상태에 대해 알 필요 없이 **인터페이스를 통해 행동을 결정**할 수 있게 됩니다. 이는 유지보수가 용이하고, 새로운 상태를 추가하거나 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 **유연한 코드**를 작성할 수 있게 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-28-Proxy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-28-Proxy Pattern.md","category":"디자인패턴","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 프록시 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**프록시 패턴**은 특정 객체로의 **접근을 제어하는 대리인**을 제공하는 패턴입니다. 이는 객체의 접근을 제어함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, 객체 생성 비용을 줄이기 위해 **객체를 생성하는 시점을 미루는** 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 **원격에서 제어**하는 **Gumball Machine**을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 **GumballMonitor**라는 **프록시**를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n자바에서는 프록시 패턴을 지원하기 위한 유용한 라이브러리를 다양하게 제공합니다.\n\n---\n\n## 요약\n\n1. **프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다.\n2. 프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다.\n3. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 **착각**합니다.\n4. 프록시 패턴은 **보안**이 중요한 객체에 대한 접근을 제어하는데 사용할 수 있습니다.\n5. **원격 객체**에 대한 접근을 제어하는데 사용할 수 있습니다.\n6. 객체 **생성 비용**을 줄이기 위해 객체를 **생성하는 시점을 미루는 목적**으로 사용할 수 있습니다.\n7. Gumball Machine - 실제 객체, GumballMonitor - 프록시\n\n---\n\n## 문제상황\n\n기존 Gumball Machine을 요청한 회사에서 **원격**으로 기계별 **상태를 파악**하고 싶다는 요청을 보냈습니다. 이를 구현하기 위해서 기존의 Gumball Machine에 대한 접근을 제어하는 GumballMonitor 클래스를 만들 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    int count;\n    String location;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n}\n\npublic class GumballMonitor {\n    GumballMachine machine;\n\n    public GumballMonitor(GumballMachine machine) {\n        this.machine = machine;\n    }\n\n    public void report() {\n        System.out.println(\"Gumball Machine: \" + machine.getLocation());\n        System.out.println(\"Gumball Inventory: \" + machine.getCount());\n    }\n}\n```\n\n그런데 이처럼 코드를 만들기 전에 요구 사항을 확실히 파악하는 것은 불가능에 가깝습니다. 이런 상황에서 모니터링을 기존의 코드를 수정하지 않고 추가하려면 어떻게 해야 할까요?\n\n---\n\n## 프록시 패턴을 사용한 해결책\n\n프록시 패턴을 사용하면 기존의 코드를 수정하지 않고도 모니터링을 추가할 수 있습니다. 프록시 패턴은 GumballMonitor 클래스는 그대로 두고, 원격에서 제어하는 Gumball Machine에 대한 **접근을 제어하는 프록시**를 만들어서 Gumball Machine을 제어할 수 있게 합니다.\n\n프록시는 진짜 객체를 **대신**하는 역할을 합니다. 이는 클라이언트가 진짜 객체에 직접 접근하는 것이 아니라, 프록시를 통해 접근하도록 합니다. 클라이언트는 프록시를 통해 진짜 객체에 접근하지만, 클라이언트는 이를 모르고 프록시를 진짜 객체로 착각합니다.\n\n클라이언트 객체는 원격 객체의 메소드 호출을 하는 것으로 착각하지만, 실제로는 프록시 객체의 메소드 호출을 하는 것입니다. 네트워크 통신과 같은 복잡한 작업은 프록시 객체가 처리해 줍니다.\n\n이런 프록시 보조 객체는 클라이언트 뿐 아니라 서버 쪽에서도 사용할 수 있습니다. 두 객체는 각자의 위치에서 받은 요청을 처리하고, 서로 통신을 하면서 진짜 서비스에서 클라이언트의 요청을 처리해줍니다.\n\n이를 java.rmi 패키지를 사용해서 구현하면 다음과 같습니다.\n\n```java\nimport java.rmi.*;\n\npublic interface GumballMachineRemote extends Remote {\n    public int getCount() throws RemoteException;\n    public String getLocation() throws RemoteException;\n    public State getState() throws RemoteException;\n}\n```\n\n```java\nimport java.io.*;\n\npublic interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    public static final long serialVersionUID = 2L;\n    transient GumballMachine gumballMachine;\n    // 기타 메소드\n}\n```\n\n```java\nimport java.rmi.*;\n\npublic class GumballMachine implements GumballMachineRemote {\n    int count;\n    String location;\n    State state;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n\n    public State getState() {\n        return state;\n    }\n}\n```\n이외에 rmi 레지스트리에 등록하는 등의 작업은 생략하겠습니다.\n\n---\n\n## 결론\n\n**프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다. 이는 객체의 **접근을 제어**함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, **객체 생성 비용**을 줄이기 위해 객체를 생성하는 시점을 미루는 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 원격에서 제어하는 Gumball Machine을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 GumballMonitor라는 프록시를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n다만 프록시 패턴은 원격에서 제어하는 것 외에도 다양한 객체의 **접근 방식을 제한**하는데 사용할 수 있습니다. 이 부분을 각자의 요구와 개발 환경에 맞게 사용하는 것이 중요하다 할 수 있을 것입니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","date":"2024-02-28T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-04-03-4월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-03-4월 1주차 알고리즘 문제.md","category":"Algorithm","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","content":"\n### 목차\n\n- [\\[이번 주의 문제\\] Can Make Palindrome from Substring](#이번-주의-문제-can-make-palindrome-from-substring)\n- [가능한 적게 저장하라](#가능한-적게-저장하라)\n- [integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법](#integer-보다-string이-더-빠른-경우-input에-적절한-보정을-사용하는-방법)\n- [pattern 찾기 =\\\u003e 변환하기](#pattern-찾기--변환하기)\n- [가능한 적게 저장하라 - 2](#가능한-적게-저장하라---2)\n\n---\n\n## [이번 주의 문제] Can Make Palindrome from Substring\n\n[문제 링크](https://leetcode.com/problems/can-make-palindrome-from-substring/description/)\n\n문제 요약: inputs[left:right+1]를 rearrange하고 k번 이하의 문자를 변경해서 palindrome을 만들 수 있는지 확인하는 문제이다.\n\ndp, prefix sum을 통한 (i, j) 구간의 저장 공간 줄이기, xor 연산의 사용, binary로 변환하는 방법 등을 통해 풀이를 개선할 수 있다. [참고자료](https://leetcode.com/problems/can-make-palindrome-from-substring/solutions/371999/python-100-runtime-and-memory/)\n\n내 풀이 개선 과정\n\n1. [prototype without rearrange](https://github.com/kaestro/algorithms_v3/commit/4e0178afb27014628516dc2a47c0c557b9969d19)\n2. [saving everything is too much](https://github.com/kaestro/algorithms_v3/commit/3e5f988d9bf8e79222c52e4d2f4bb22d6034436c)\n3. [using prefix sum to reduce space](https://github.com/kaestro/algorithms_v3/commit/78b0945d61b74012b3f331c2829354404e73424e)\n4. [Use List instead of Dictionary When index range is small and limited. If only odd/even matters don't add and %= 2, use xor](https://github.com/kaestro/algorithms_v3/commit/f8bd0f94ea3eee84ddf7df8df5130967efc02ea5)\n5. [If only odd/even number matters, you may change integer into binary](https://github.com/kaestro/algorithms_v3/commit/d3a4fbeb4c0c86ada9266748c5b848a7b8b0782f)\n\n---\n\n## 가능한 적게 저장하라\n\n- [문제 링크](https://leetcode.com/problems/toeplitz-matrix/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/6208041d46052adfabceeb6c1b34685d68896482)\n\n문제 요약: 대각선의 값들이 모두 동일한 value를 가지는 지 확인하는 문제이다.\n\n최초의 풀이는 대각선의 값들을 dictionary 안에 저장하고, 이들을 같은지 확인하는 방식으로 구현했다. key로는 (row, col)을 쓰고, mat[(row, col)] == mat[(row-1, col-1)]인지 확인했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0]))}\n```\n\n그런데 이는 최초의 첫 row/col만 확인하면 되는 문제이기 때문에, dictionary에 해당 값들만 저장하고 이를 비교하도록 구현을 변경했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if i == 0 or j == 0}\n```\n\n이 밖에 key로 row - col을 사용하는 것도 한가지 방법이며, 이 방법을 사용할 경우 dictionary가 아니라 조금의 튜닝을 통해 일반적인 list로도 구현이 가능하다.\n\n---\n\n## integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법\n\n- [문제 링크](https://leetcode.com/problems/split-with-minimum-sum/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/825c371389d1f69d10666d23fc8f38bbf650c2b3)\n\n문제 요약: 각 수의 자릿수를 가지고 split number를 만든 뒤에 이 중 합이 가장 작은 split sum을 구하는 문제이다.\n\n내 기존 풀이는 integer를 나누고, 나머지를 digits list에 저장하는 방식이었다. 그런데 이러는 것보다 string으로 변환한 뒤 처리하는 것이 더 유리할 수 있다. 이는 각각을 나누는 연산을 진행하는 것보다 string으로 변환하는 것이 빠르기 때문으로 추측된다.\n\n```python\ndef save_digits_as_int(num: int):\n    digits = []\n    while num \u003e 0:\n        digits.append(num % 10)\n        num //= 10\n    return digits\n```\n\n```python\ndef save_digits_as_char(num: int):\n    return list(str(num))\n```\n\n해당 문제는 맨 앞에 0이 나오는 경우를 허용하는 문제이기 때문에 input integer의 자리수가 홀수일 경우 0을 추가해주는 보정을 하면 해결이 쉬워진다.\n\n---\n\n## pattern 찾기 =\u003e 변환하기\n\n- [문제 링크](https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/c0515d3bf3ab61a79de9f97679ffe965902ea9bb)\n\n문제 요약: 주어진 integer에 대해 pattern이 [1, 0, -1] 세 가지로 주어지고, 이것들이 부분 순열에서의 증가, 동일, 감소 패턴을 나타내는 문제이다. 그리고 이 pattern이 몇 번 나오는지 확인하는 문제이다.\n\n기존의 내 문제 풀이는 모든 index에 대해 pattern이 존재하는지 확인하는 방식으로 구현했다.\n\n```python\nfor i in range(len(nums) - len(patterns)):\n    for j in range(len(patterns)):\n        if patterns[j] == 1 and nums[i + j + 1] \u003c= nums[i + j]:\n            break\n        elif patterns[j] == 0 and nums[i + j + 1] != nums[i + j]:\n            break\n        elif patterns[j] == -1 and nums[i + j + 1] \u003e= nums[i + j]:\n            break\n    else:\n        result += 1\n```\n\n이 문제는 pattern을 만드는 문제로 바꾸어 생각해서 해결할 수 있다.\n\n```python\ndef apply_pattern(nums: List[int], pattern: List[int]) -\u003e List[int]:\n    ans = []\n    for i in range(1, len(nums)):\n        if (nums[i] == nums[i - 1]):\n            ans.append(0)\n        elif (nums[i] \u003e nums[i - 1]):\n            ans.append(1)\n        else:\n            ans.append(-1)\n    return ans\n```\n\n둘의 시간복잡도는 동일하지만 두 번째 방법이 더 직관적이고 이해하기도 쉬우면서, 더 적은 비교 연산을 수행하기 때문에 성능이 좋게 나타나는 것을 확인할 수 있었다.\n\n---\n\n## 가능한 적게 저장하라 - 2\n\n- [문제 링크](https://leetcode.com/problems/design-an-ordered-stream/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/f38f736837c54887b8a31bbb59a0806a8b7f2c7b)\n\n문제 요약: stream이 들어올 때, id 지점 기준으로 내보낼 수 있는 연속된 chunk가 형성되면 이를 내보내는 문제이다.\n\n기존의 내 풀이는 stream에서 return할 값들을 새로운 list에 저장하고, 이를 return하는 방식으로 구현했다.\n\n```python\nresult = []\nfor i in range(self.idx, len(self.stream)):\n    if self.stream[i] is None:\n        break\n    result.append(self.stream[i])\n    self.idx += 1\nreturn result\n```\n\n그러나 이는 정직한 부분 리스트를 반환하는 함수이기 때문에 새로운 list를 생성할 필요가 없다.\n\n```python\nbegin = self.idx\nwhile self.stream[self.idx]:\n    self.idx += 1\n\nreturn self.stream[begin:self.idx]\n```\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","date":"2024-04-03T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-09-4월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-09-4월 2주차 알고리즘 문제.md","category":"Algorithm","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","content":"\n### 목차\n\n- [\\[금주의 문제\\] sliding window를 통해 더 적게 비교하기](#금주의-문제-sliding-window를-통해-더-적게-비교하기)\n- [trailing zeros 제거하는 다양한 방법](#trailing-zeros-제거하는-다양한-방법)\n- [저장을 통해 연산 횟수 줄이기](#저장을-통해-연산-횟수-줄이기)\n\n---\n\n## [금주의 문제] sliding window를 통해 더 적게 비교하기\n\n- [문제 링크](https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2200%20-%20LeetCode.py)\n\n- 문제 요약\n  - list integer에서 key값과 좌우로 k만큼 떨어진 index로 구성된 list를 구하는 문제이다.(findKthDistanceIndices)\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(k*n)$\n    - set을 이용해서 key가 발견되면 좌우 index range를 update하고, 최후에 sorted된 list를 반환하는 방식으로 구현했다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - sliding window를 통해 update해야할 필요가 있는 index를 범위를 줄인다\n    - 한 번만의 loop만으로 문제를 해결할 수 있다.\n\n---\n\n## trailing zeros 제거하는 다양한 방법\n\n- [문제 링크](https://leetcode.com/problems/remove-trailing-zeros-from-a-string/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/1057a28ce89c643e18d6b9f72a6aa5f3de68044b)\n\n- 문제 요약\n  - 문자열로 저장한 수에서 맨 뒤의 0들을 모두 제거하는 문제이다.\n- 풀이 요약\n  - 내 풀이\n    - 내 풀이는 input string을 list로 변환한 뒤 pop을 사용해 0을 제거하는 방식으로 구현했다.\n    - 이는 python에서 list pop은 stack과 같이 동작하기 때문에 효율적이기 때문이다.\n  - 다른 풀이\n    - rstrip을 사용한다\n    - 수를 integer로 변환하고 뒤집었다가 다시 뒤집는다\n\n---\n\n## 저장을 통해 연산 횟수 줄이기\n\n- [문제 링크](https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2970%20-%20LeetCode.py)\n\n- 문제 요약\n  - integer array에서 subarrary를 삭제한 뒤에 전 구간에서 increasing하는 array가 되는 경우, 삭제한 subarray를 incremovable subarray라 한다. 이때 incremovable subarray의 개수를 구하는 문제이다.\n- 풀이 요약\n  - Brute Force 풀이\n    - Time Complexity: $O(n^3)$\n    - 모든 subarray에 대해 잘라지지 않은 subarray가 increasing한지 확인하는 방법\n  - 개선 풀이\n    - Time Complexity: $O(n^2)$\n    - 모든 subarray들의 increasing 여부를 저장한다. 그런 다음 자르고 나서 좌 우가 increasing하고, 연결부가 increasing한 경우를 찾는다.\n\n```python\nfor i in range(len(nums)):\n    for j in range(i, len(nums)):\n        if isIncreasingSubarray.get((0, i - 1), True) and isIncreasingSubarray.get((j + 1, len(nums) - 1), True):\n            if nums[j+1] \u003e nums[i-1] if i \u003e 0 and j \u003c len(nums) - 1 else True:\n                result += 1\n```\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","date":"2024-04-09T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-15-4월 3주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-15-4월 3주차 알고리즘 문제.md","category":"Algorithm","title":"4월 3주차 알고리즘 문제","subtitle":"더 적은 연산으로 문제 해결하기, 사용중인 저장 공간을 재활용","content":"\n### 목차\n\n- [주어진 조건을 더 적은 연산으로 해결하기](#주어진-조건을-더-적은-연산으로-해결하기)\n- [이미 사용중인 메모리의 저장 공간을 활용한 문제 해결](#이미-사용중인-메모리의-저장-공간을-활용한-문제-해결)\n\n---\n\n## 주어진 조건을 더 적은 연산으로 해결하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-strong-pair-xor-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/fedf633e9215df5a417ccc3aaeaddf51b1497ce2)\n\n- 문제 요약\n  - Strong Pair는 $\\|(x - y)\\| \\leq min(x, y)$를 만족하는 pair이다.\n- 풀이 요약\n  - 기존 풀이\n    - if (abs(x - y) \u003c= min(x, y))\n  - 개선 풀이\n    - if y \u003c= 2 * x\n\n---\n\n## 이미 사용중인 메모리의 저장 공간을 활용한 문제 해결\n\n- [문제 링크](https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/2f8a28a20ab10b13af7c892818c92ee7b52ea371)\n\n- 문제 요약\n  - list에서 가장 작은 수의 index를 찾는다. 이 때 같은 수가 여러개라면 가장 작은 index를 찾는다.\n  - 해당 값을 결과 값에 더하고, 좌우의 값을 visited로 만든다.\n- 풀이 요약\n  - 기존 풀이\n    - heap을 이용해서 가장 작은 수를 찾는다.\n    - 좌우의 값을 확인한 뒤 이를 heap에서 제거한다.\n    - 실제로 추가/제거하는 연산이 많아진다.\n  - 개선 풀이\n    - 연산 완료 및 visited 처리된 index의 값을 -1로 변경한다.\n    - heap이 아니라 sort한 이후에 visit을 이용해 처리한다.\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 3주차 알고리즘 문제","subtitle":"더 적은 연산으로 문제 해결하기, 사용중인 저장 공간을 재활용","date":"2024-04-15T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-21-4월 4주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-21-4월 4주차 알고리즘 문제.md","category":"Algorithm","title":"4월 4주차 알고리즘 문제","subtitle":"gap 채우기, sum of all odd length subarrays","content":"\n### 목차\n\n- [정렬된 수 사이에 gap을 채우기](#정렬된-수-사이에-gap을-채우기)\n- [sum of all odd length subarrays](#sum-of-all-odd-length-subarrays)\n\n---\n\n## 정렬된 수 사이에 gap을 채우기\n\n- [문제 링크](https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/4d05a526eabd8241f08d206d321e807fa5017fb8)\n\n- 문제 요약\n  - 주어진 integer array에서 각 요소를 재배열하거나 작아지게 하는 연산을 통해 각 element 간의 차이가 1 이하가 되도록 만들 때, 마지막 요소의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - 각 수를 set으로 만들어 정렬한다\n    - 수 사이의 gap을 찾는다.\n    - gap이 1 이상인 경우, gap을 채운다.\n  - 개선 풀이\n    - 수를 정렬한다.\n    - 이전 수와 현재 수의 차이가 1 이상인 경우, 현재 수를 이전 수 + 1로 만든다.\n\n```python\ndef maximumElementAfterDecrementingAndRearranging(arr: List[int]) -\u003e int:\n  arr sort()\n  prev = 0\n  for i in range(1, len(arr)):\n      if arr[i] - arr[prev] \u003e 1:\n          arr[i] = arr[prev] + 1\n      prev = i\n\n  return arr[-1]\n```\n\n---\n\n## sum of all odd length subarrays\n\n- [문제 링크](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/cd8f5cd113d3a4f802efe154e84989e8746f9ab9)\n\n- 문제 요약\n  - 주어진 integer array에서 odd length subarray의 합을 구하라.\n- 기존 풀이\n  - prefix sum을 구한다.\n  - 이를 이용해 odd length subarray의 합을 구한다.\n  - Time complexity: $$O(n^2)$$\n- [개선 풀이](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/solutions/854184/java-c-python-o-n-time-o-1-space/?source=submission-ac)\n  - arr[k]가 포함된 subarray의 개수는 $$(k+1) * (n-k)$$이다.\n  - 따라서, arr[k]가 포함된 subarray의 합은 $$arr[k] * (k+1) * (n-k)$$이다.\n  - 이 중 홀수 길이의 subarray의 갯수는 전체 길이가 홀수인 경우 짝수보다 1개 더 많다.\n  - Time complexity: $$O(n)$$\n\n```python\ndef sumOddLengthSubarrays(arr: List[int]) -\u003e int:\n  n = len(arr)\n  ans = 0\n  for i in range(n):\n      ans += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n  return ans\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 4주차 알고리즘 문제","subtitle":"gap 채우기, sum of all odd length subarrays","date":"2024-04-21T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-28-4월 5주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-28-4월 5주차 알고리즘 문제.md","category":"Algorithm","title":"4월 5주차 알고리즘 문제","subtitle":"2 pointer, 초기화, projection","content":"\n### 목차\n\n- [두 수의 합이 주어진 수가 되는 경우 찾기](#두-수의-합이-주어진-수가-되는-경우-찾기)\n- [반대 경우의 수가 나왔을 때 초기화를 통한 처리 방법](#반대-경우의-수가-나왔을-때-초기화를-통한-처리-방법)\n- [3d 입체를 2d로 투영할때의 면적 구하기](#3d-입체를-2d로-투영할때의-면적-구하기)\n\n---\n\n## 두 수의 합이 주어진 수가 되는 경우 찾기\n\n- [문제 링크](https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/ea58957b4a598a7f38fbbfa2a04d8230c3d57115)\n\n- 문제 요약\n  - 주어진 integer array에서 두 수를 선택하여 더한 값이 같은 경우를 찾은 뒤, 그 곱이 가장 큰 경우를 찾아라\n- 풀이 요약\n  - sorted array에서 2 pointer를 사용하여 두 수를 선택한다.\n\n```python\ndef maxOperations(self, nums: List[int], k: int) -\u003e int:\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    result = 0\n    while left \u003c right:\n        if nums[left] + nums[right] == k:\n            result += 1\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] \u003c k:\n            left += 1\n        else:\n            right -= 1\n    return result\n```\n\n---\n\n## 반대 경우의 수가 나왔을 때 초기화를 통한 처리 방법\n\n- [문제 링크](https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/0ad2579f8b8c4c2218b5fe4c8b675fa50330290d)\n\n- 문제 요약\n  - 주어진 binary string에서 연속된 1의 개수가 연속된 0의 개수보다 많은 경우 True를 반환하라\n- 풀이 요약\n  - longestOne/Zero, currentOne/Zero를 사용하여 연속된 1과 0의 개수를 센다.\n  - 반대 것이 나오면 currentOne/Zero를 0으로 초기화하면서 반대 것의 개수를 센다.\n\n```python\ndef checkZeroOnes(self, s: str) -\u003e bool:\n    longestOne, longestZero = 0, 0\n    currentOne, currentZero = 0, 0\n    for ch in s:\n        if ch == '1':\n            currentOne += 1\n            currentZero = 0\n        else:\n            currentZero += 1\n            currentOne = 0\n        longestOne = max(longestOne, currentOne)\n        longestZero = max(longestZero, currentZero)\n    return longestOne \u003e longestZero\n```\n\n---\n\n## 3d 입체를 2d로 투영할때의 면적 구하기\n\n- [문제 링크](https://leetcode.com/problems/projection-area-of-3d-shapes/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/27901b40b7156cc68d9593cb5f28f000712bc489#diff-0226d5b537395ebe798252e8565dadecfa5545dbc7de1dc158294433b7627e03)\n\n- 문제 요약\n  - 3d 블록 입체를 2d array 형태로 주었을 때, xy, yz, zx 평면으로 투영한 면적의 합을 구하라\n- 풀이 요약\n  - xy: 2d array에서 0이 아닌 값의 개수\n  - yz: 2d array에서 각 row의 최대값의 합\n  - zx: 2d array에서 각 column의 최대값의 합\n\n```python\ndef projectionArea(self, grid: List[List[int]]) -\u003e int:\n    xy = sum(1 for row in grid for val in row if val)\n    yz = sum(max(row) for row in grid)\n    zx = sum(max(col) for col in zip(*grid))\n    return xy + yz + zx\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 5주차 알고리즘 문제","subtitle":"2 pointer, 초기화, projection","date":"2024-04-28T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-05-5월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-05-5월 1주차 알고리즘 문제.md","category":"Algorithm","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","content":"\n### 목차\n\n- [두 수가 교차하는 경우의 수를 다루는 방법](#두-수가-교차하는-경우의-수를-다루는-방법)\n\n---\n\n## 두 수가 교차하는 경우의 수를 다루는 방법\n\n- [문제 링크](https://leetcode.com/problems/semi-ordered-permutation/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/eb87856177f2836c0da339976e9473f63910c9dc)\n\n- 문제 요약\n  - Semi-Ordered Permutation이란, 처음이 가장 작은 수이고 가장 마지막이 가장 큰 수이며, 중간에는 어떤 수든 나타날 수 있는 순열이다.\n  - 순열이 주어졌을때 인접한 두 수를 swap하여 Semi-Ordered Permutation을 만드는 최소 교환 횟수를 구하라.\n- 풀이 요약\n  - 가장 작은 수가 1에 도착하는 횟수 + 가장 큰 수가 n에 도착하는 횟수를 구하면 된다.\n  - **이 때 두 수가 교차하는 경우 1을 빼주면 된다.**\n\n```python\ndef semiOrderedPermutation(self, A: List[int]) -\u003e int:\n    n = len(A)\n    i, j = A.index(1), A.index(n)\n    return i + n - 1 - j - (i \u003e j)\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","date":"2024-05-05T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-12-5월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-12-5월 2주차 알고리즘 문제.md","category":"Algorithm","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","content":"\n### 목차\n\n- [$O(n)$으로 배열 내 요소 간 최대 차이 구하기](#on으로-배열-내-요소-간-최대-차이-구하기)\n- [필요 없는 중간과정 생략하기](#필요-없는-중간과정-생략하기)\n- [3개의 distinct한 subarray를 구하는 방법](#3개의-distinct한-subarray를-구하는-방법)\n\n---\n\n## $O(n)$으로 배열 내 요소 간 최대 차이 구하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea)\n\n- 문제 요약\n  - int array가 주어졌을 때, i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(n^2)$\n    - i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.\n    - 따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - A[j] \u003e A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.\n    - 그렇지 않을 경우에는 i를 j로 갱신한다.\n\n```python\ndef maxDifference(self, nums: List[int]) -\u003e int:\n    max_diff = -1\n    min_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] \u003e min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n    return max_diff\n```\n\n---\n\n## 필요 없는 중간과정 생략하기\n\n- [문제 링크](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2)\n\n- 문제 요약\n  - n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.\n  - 개선 풀이\n    - 어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.\n    - 따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.\n    - 이 때문에 처음과 끝만 보면 된다.\n\n```python\ndef mostVisited(self, n: int, rounds: List[int]) -\u003e List[int]:\n    start, end = rounds[0], rounds[-1]\n    if start \u003c= end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(1, end + 1)) + list(range(start, n + 1))\n```\n\n---\n\n## 3개의 distinct한 subarray를 구하는 방법\n\n- [문제 링크](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6)\n\n- 문제 요약\n  - int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.\n  - subarray는 연속된 요소들의 집합이다.\n- 풀이 요약\n  - Time Complexity: $O(n^2)$\n  - 3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n\n```go\nfunc minCost(nums []int) int {\n    n := len(nums)\n\n    minCost := math.MaxInt32\n    for i := 1; i \u003c n - 1; i++ {\n        for j := i + 1; j \u003c n; j++ {\n            cost := nums[0] + nums[i] + nums[j]\n            minCost = min(minCost, cost)\n        }\n    }\n    return minCost\n}\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","date":"2024-05-12T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-24-Dynamic Programming","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-24-Dynamic Programming.md","category":"Algorithm","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","content":"\n## Dynamic Programming은 Optimization Problem 해결 방법이다\n\n여러 가지 문제 중에 Dynamic Programming을 사용해서 푸는 문제들은 Optimization Problem을 푸는 경우로 한정됩니다. 그렇다면 Optimization Problem은 무엇을 의미하는 것일까요?\n\n이는 여러개의 [선택 가능한 후보 중에서 최적의 해 또는 최적의 해에 근접한 값을 찾는 문제](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)를 말합니다. 이는 종종 [특정 기능의 최대값 또는 최소값을 찾는 것](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)이 포함됩니다. 예를 들면 이동에 소요되는 최소 시간, 작업 수행에 필요한 최소 비용, 장치에서 생성할 수 있는 최대 전력 등이 있습니다.\n\n---\n\n## Dynamic Programming을 사용하는 문제의 특징\n\n최적값을 문제를 푸는 문제들 중에서도 Dynamic Programming을 통해 해결할 수 있는 문제들은 다음의 두 가지 특징을 가지고 있습니다.\n\n1. **Optimal Substructure** : 문제의 최적해가 부분 문제의 최적해로 구성되어 있습니다.\n2. **Overlapping Subproblems** : 부분 문제들이 중복되어 계산되는 경우가 있습니다.\n\n### Optimal Substructure\n\n문제의 최적해가 부분 문제의 최적해로 구성돼 있다는 다음과 같은 의미를 나타냅니다. 우선, 주어진 문제의 최적해를 선택할 수 있다고 가정해 보겠습니다. 이 최적해를 구하는 구조의 특징을 통해 최적해의 값을 정의내릴 때, 부분 문제의 최적해를 사용할 수 있습니다.\n\n예를 들어, Rod-Cutting 문제 즉 막대기를 가장 비싼 가격의 단위 막대기들로 자르는 최적의 해를 구하는 문제를 생각해보겠습니다. 이 문제에서 막대기는 단위 길이별로 가격이 정해져 있습니다.\n\n$$Price_1 = 1, Price_2 = 5, Price_3 = 8$$과 같이 말입니다.\n\n이 때 길이가 4인 막대기를 자르는 최적의 해를 구한다고 가정했을 때, 길이가 5인 막대기를 자르는 최적의 해를 구하는 방법은 다음과 같습니다.\n\n$$Price_5 = \\max_{k=1}^{3}(Price_k + Price_{5-k})$$\n\n이처럼 특정 순간의 최적해를 구할 때, 그 최적해를 구성하는 부분 문제의 최적해를 사용해서 표현할 수 있습니다.\n\n### Overlapping Subproblems\n\n이 때 부분 문제들을 구하는 과정 역시 중복되어 계산되는 경우가 있습니다. 방금의 Rod-Cutting 문제를 예시로 들면 Price(5)의 최적해를 구하기 위해서는 Price(4), Price(3), Price(2)의 값을 계산해야합니다. 그리고 이는 다시 {Price(3), Price(2), Price(1)}, {Price(2), Price(1), Price(0)}의 값을 계산해야합니다. 이 때 Price(3)은 Price(2)를 계산할 때도 필요하고 Price(1)을 계산할 때도 필요합니다.\n\n---\n\n## Dynamic Programming의 구현 방법\n\nDynamic Programming을 구현하는 방법은 요약하자면 다음과 같습니다.\n\n```markdown\n1. 최적해를 구하는 경우를 나타내는 함수를 부분 문제의 최적해를 이용해 표현합니다.\n2. 부분 문제가 더 나눌 수 없는 경우를 찾아내고, 이를 기저 조건으로 설정합니다.\n3. 부분 문제를 구하는 과정에서 중복되는 계산을 피하기 위해, 부분 문제의 최적해를 저장하는 배열을 사용합니다.\n```\n\n### Top-Down Approach\n\nTop-Down Approach는 재귀적인(recursive) 방법을 사용하여 문제를 푸는 방법입니다. 예를 들어 rod-cutting 문제를 해결하려 할 때 Price(5)의 값을 구하기 위해 Price(4), Price(3), Price(2)의 값을 구하는 방법입니다. 이는 보통 재귀적인 방법을 사용하여 구현되며 이를 memoization이라고 합니다.\n\n### Bottom-Up Approach\n\nBottom-Up Approach는 반복적인(iterative) 방법을 사용하여 문제를 푸는 방법입니다. 이는 보통 반복문을 사용하여 작은 값부터 큰 값까지 순차적으로 계산하는 방법입니다. 이를 tabulation이라고 합니다.\n\n문제의 성향에 따라 Top-down approach가 더 적은 연산을 필요로 할 수도 있지만, Bottom-up approach가 더 직관적이고 iterative한 계산 방식을 사용하기 때문에 디버깅에 용이한 등의 장점을 가지고 있습니다.\n\n---\n\n## 참고 자료\n\n- Introduction To algorithms pg.380 ~ 434\n- [Convex Optimization for All](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)\n- [Optimization Problems](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)\n- [tabulation vs memoization](https://www.geeksforgeeks.org/tabulation-vs-memoization/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","date":"2024-04-24T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-25-BFS and DFS","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-25-BFS and DFS.md","category":"Algorithm","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","content":"\n## BFS와 DFS는 그래프를 탐색하는 방법 중 두 가지입니다\n\nBFS(Breadth First Search)와 DFS(Depth First Search)는 그래프를 탐색하는 방법 중 하나입니다. 여기서 그래프를 탐색한다는 것은 그래프의 정점(vertex)에 접근해서 해당 정점이 가지고 있는 정보를 이용해 자신이 원하는 연산을 수행하는 것을 의미합니다. 미로 찾기 문제를 풀 때, 미로를 그래프로 표현하고 출발점에서 도착점까지의 경로를 찾는 문제를 풀 때 각각의 정점을 방문하면서 탈출구에 도달할 때까지 탐색하는 것이 그래프 탐색의 한 예입니다.\n\n### BFS(Breadth First Search)\n\nBFS는 그래프를 탐색할 때 너비를 우선으로 탐색하는 방법입니다. 즉, 시작 정점에서 가까운 정점부터 탐색을 진행하며 큐(Queue)를 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산의 경우에는 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 시간 복잡도는 $O(V+E)$입니다. 이를 통해 풀 수 있는 문제의 예시로는 모든 정점 간의 거리가 같을 때 최단 경로를 찾는 문제가 있습니다.\n\n#### shortest path\n\n### DFS(Depth First Search)\n\nDFS는 그래프를 탐색할 때 깊이를 우선으로 탐색하는 방법입니다. 시작 정점에서 깊이를 우선으로 탐색을 진행하며 스택(Stack)을 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산은 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 BFS와 마찬가지로 시간 복잡도는 $O(V+E)$입니다.\n\nDFS는 각각의 간선을 다음의 네 가지로 구분하는 데 사용할 수 있습니다.\n\n```plaintext\n1. 트리 간선(tree edge): DFS 트리에서 나온 간선(edge)\n2. 순방향 간선(forward edge): DFS 트리에서 나온 간선이 아니지만, 자식 노드로 가는 간선(edge)\n3. 역방향 간선(back edge): DFS 트리에서 나온 간선이 아니지만, 조상 노드로 가는 간선(edge)\n4. 교차 간선(cross edge): DFS 트리에서 나온 간선이 아니지만, 서로 다른 서브트리 간의 간선(edge)\n```\n\n여기서 dfs트리란 DFS를 수행하면서 만들어지는 각 정점을 방문하는 순서대로 정렬된 트리를 의미합니다. DFS 트리에서 나온 간선(edge)이라는 것은 DFS를 수행하면서 만들어지는 트리에서 나온 것을 의미하며 나머지 간선(edge)들은 DFS 트리에서 나오지 않는 것들입니다.\n\n#### topological sort\n\n구성 요소 간에 우선순위가 존재하는 경우 이를 정렬하는 것을 위상정렬(topological sort)이라고 합니다. 위상정렬은 DFS를 이용하여 구현할 수 있으며 다음과 같은 순서를 따릅니다.\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다. 탐색하는 과정에서 각각의 정점을 방문하는데 걸린 시간을 기록한다.\n2. 모든 정점을 방문한 후, 각 정점을 방문한 시간을 기준으로 내림차순으로 정렬한 linked list를 반환한다.\n```\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다.\n2. 탐색하고 빠져나오는 순간에 해당 정점을 linked list의 맨 앞에 추가한다.\n3. 이를 모든 정점을 방문할 때까지 반복한다.\n4. linked list를 반환한다.\n```\n\n```python\ndef topological_sort(graph):\n    visited = [False] * len(graph)\n    topological_order = []\n    stack = []\n\n    for v in range(len(graph)):\n        if not visited[v]:\n            stack.append(v)\n            while stack:\n                node = stack[-1]\n                if not visited[node]:\n                    visited[node] = True\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            stack.append(neighbor)\n                else:\n                    stack.pop()\n                    topological_order.append(node)\n\n    return topological_order[::-1]\n```\n\n#### acyclic graph\n\nacyclic graph는 사이클이 없는 그래프를 의미합니다. 이 때 acyclic graph는 위상정렬을 통해 정렬할 수 있습니다.\n\n#### strongly connected components\n\nstrongly connected component는 모든 구성 vertex(정점)들이 서로 도달 가능한 그래프의 부분 그래프를 의미합니다. 이를 수학적으로 표현하면 다음과 같습니다.\n\nvertices C is strongly connected component when\n\n$$G = (V, E)$$\n$$C \\subseteq V$$\n$$\\forall u, \\forall v \\in C, u \\rightarrow v \\text{ and } v \\rightarrow u$$\n\n이를 DFS를 이용해 구하는 방법은 다음과 같습니다.\n\n1. 그래프 $G$에 대해 DFS를 수행해서 모든 정점에 대해 끝나는 시간을 기록한다.\n2. 그래프 $G$의 간선을 뒤집어서 그래프 $G^T$를 만든다.\n3. $G^T$에 대해 DFS를 수행해서 끝나는 시간이 큰 정점부터 탐색한다.\n4. 탐색하는 과정에서 방문하는 정점들이 하나의 strongly connected component를 형성한다.\n\n```python\ndef strongly_connected_components(graph):\n    visited = [False] * len(graph)\n    stack = []\n    for v in range(len(graph)):\n        if not visited[v]:\n            dfs(graph, v, visited, stack)\n\n    graph_reverse = [[] for _ in range(len(graph))]\n    for v in range(len(graph)):\n        for neighbor in graph[v]:\n            graph_reverse[neighbor].append(v)\n\n    visited = [False] * len(graph)\n    components = []\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs_reverse(graph_reverse, node, visited, component)\n            components.append(component)\n\n    return components\n```\n\n---\n\n## 출처\n\n- Introduction to Algorithms, 3rd Edition. Thomas H. Cormen, Charles E. pg.610 ~ 644\n- [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-directed-acyclic-graph/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","date":"2024-04-25T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-07-Shortest Path(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-07-Shortest Path(1).md","category":"Algorithm","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","content":"\n### 목차\n\n- [Introduction](#introduction)\n- [Optimal substructure](#optimal-substructure)\n- [negative-weight edges](#negative-weight-edges)\n- [Cycles](#cycles)\n- [relaxation](#relaxation)\n- [References](#references)\n\n---\n\n## Introduction\n\nShortest path problem은 그래프에서 두 정점 사이의 최단 경로를 찾는 문제이다. 이 문제는 다양한 분야에서 응용되며, 다양한 알고리즘이\n 제안되어 있다. Shortest path problem은 다음과 같은 세 가지 유형으로 나뉜다.\n\n1. Single-source shortest path problem\n    - 주어진 그래프에서 특정 정점에서 다른 모든 정점까지의 최단 경로를 찾는 문제이다.\n2. Single-destination shortest path problem\n    - 주어진 그래프에서 모든 정점에서 특정 정점까지의 최단 경로를 찾는 문제이다.\n3. All-pairs shortest path problem\n    - 주어진 그래프에서 모든 정점 사이의 최단 경로를 찾는 문제이다.\n\n이 글에서는 single-source shortest path problem에 대해 다룬다. single-source shortest path problem은 다음과 같은 두 가지 유형으로 나뉜다.\n\n1. Unweighted graph: 그래프의 간선에 가중치가 없는 경우\n2. Weighted graph: 그래프의 간선에 가중치가 있는 경우\n\n이 글에서는 weighted graph에 대해 다룬다. weighted graph에서 single-source shortest path problem을 해결하는 대표적인 알고리즘은\n 다음과 같다.\n\n1. Dijkstra's algorithm\n2. Bellman-Ford algorithm\n\n---\n\n## Optimal substructure\n\nShortest path problem은 optimal substructure를 가진다. Optimal substructure란 문제의 최적해가 부분 문제의 최적해로부터 구해질 수\n 있는 성질을 말한다.\n Shortest path problem에서 optimal substructure는 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. If $p$ contains an intermediate vertex $x$, then $p$ can be divided into two subpaths $s \\rightarrow x$ and $x \\rightarrow v$. The subpath $s \\rightarrow x$ is a shortest path from $s$ to $x$, and the subpath $x \\rightarrow v$ is a shortest path from $x$ to $v$.\n\n즉, 최단 경로 $p$가 중간 정점 $x$를 포함하고 있다면, $p$는 두 개의 부분 경로 $s \\rightarrow x$와 $x \\rightarrow v$로 나눌 수 있다.\n 부분 경로 $s \\rightarrow x$는 $s$에서 $x$로 가는 최단 경로이며, 부분 경로 $x \\rightarrow v$는 $x$에서 $v$로 가는 최단 경로이다.\n\n---\n\n## negative-weight edges\n\n그래프의 간선이 음수 가중치를 가지는 경우, cycle이 존재할 수 있다. 이 경우, shortest path problem을 해결하는 알고리즘은 cycle을\n 탐지하여 음의 무한대로 수렴할 수 있다.\n\nDijkstra's algorithm의 경우 모든 간선의 가중치가 양수인 경우에만 사용할 수 있다. Bellman-Ford algorithm은 음수 가중치를 가지는\n 간선이 존재하고 cycle이 없는 경우에 사용할 수 있다.\n\n---\n\n## Cycles\n\nShortest path problem에서 cycle이 존재하는 경우, 해당 cycle이 음수 가중치를 가지는 경우와 양수 가중치를 가지는 경우로 나뉜다.\n 음수 가중치를 가지는 cycle이 존재하는 경우, shortest path problem을 해결하는 알고리즘은 cycle을 탐지하여 음의 무한대로 수렴할 수\n 있어 해를 구할 수 없다. 반면 양수 가중치를 가지는 cycle이 존재하는 경우, 해당 cycle을 포함하는 경로는 무한히 큰 가중치를 가지므로\n 최단 경로가 될 수 없다. 즉 우리는 shortest path problem에서 cycle을 포함하는 경로를 고려하지 않는다.\n\n---\n\n## relaxation\n\nShortest path problem을 해결하는 알고리즘은 relaxation이라는 연산을 사용한다. relaxation은 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. The relaxation operation updates the shortest path estimate $v.d$ and the predecessor $v.\\pi$ of vertex $v$ if a shorter path from $s$ to $v$ is found.\n\n즉, 매 정점 $v$에 대해 $s$에서 $v$로 가는 최단 경로 $v.d$와 이전 정점 $v.\\pi$를 업데이트하는 연산이다.\n\n---\n\n## References\n\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n  by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, p.643 ~ p.650\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":1}},{"postName":"2024-05-10-Graph","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Graph.md","category":"Algorithm","title":"Graph","subtitle":"탐색을 위한 자료구조","content":"\n### 목차\n\n- [1. 그래프란?](#1-그래프란)\n- [2. 그래프의 활용](#2-그래프의-활용)\n- [3. 그래프 표현 방법](#3-그래프-표현-방법)\n  - [3.1 인접 행렬(Adjacency Matrix)](#31-인접-행렬adjacency-matrix)\n  - [3.2 인접 리스트(Adjacency List)](#32-인접-리스트adjacency-list)\n- [Reference](#reference)\n\n---\n\n## 1. 그래프란?\n\n그래프는 정점과 간선으로 이루어진 자료구조이다. 그래프는 다음과 같은 특징을 가진다.\n\n- 정점(Vertex): 데이터를 저장하는 공간\n- 간선(Edge): 정점과 정점을 연결하는 선\n- 방향성: 간선에 방향이 있는 경우 방향 그래프, 없는 경우 무방향 그래프\n- 가중치: 간선에 가중치가 있는 경우 가중치 그래프, 없는 경우 비가중치 그래프\n\n## 2. 그래프의 활용\n\n그래프는 주로 탐색을 위해 사용된다. 여기에서 탐색이란 그래프의 정점(vertex)을 방문하기 위해\n간선(edge)을 따라 이동하는 것을 의미한다. 탐색을 통해 그래프의 구조를 파악하거나 특정 정점을\n 찾는 등의 작업을 수행할 수 있다. 대표적인 예시로는 미로 찾기, 최단 경로 찾기, 네트워크 경로\n 찾기 등이 있다.\n\n그래프 탐색 알고리즘에는 다음과 같은 것들이 있다.\n\n- 깊이 우선 탐색(DFS, Depth First Search)\n- 너비 우선 탐색(BFS, Breadth First Search)\n- 다익스트라 알고리즘(Dijkstra Algorithm)\n- 벨만-포드 알고리즘(Bellman-Ford Algorithm)\n- ...\n\n## 3. 그래프 표현 방법\n\n대표적으로 그래프는 대표적으로 다음의 두 가지 방법으로 표현할 수 있다\n\n- 인접 행렬(Adjacency Matrix)\n- 인접 리스트(Adjacency List)\n\n### 3.1 인접 행렬(Adjacency Matrix)\n\n인접 행렬은 2차원 배열로 그래프를 표현하는 방법이다. 인접 행렬은 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V x V` 크기의 2차원 배열이 필요하다.\n- 정점 `u`와 정점 `v`가 연결되어 있으면 `matrix[u][v] = 1`, 연결되어 있지 않으면 `matrix[u][v] = 0`이다.\n- 가중치 그래프의 경우 `matrix[u][v] = w`로 표현한다.\n\n```python\nmatrix = [[1, 0, 0, 1, 0],\n          [0, 1, 1, 0, 0],\n          [0, 1, 1, 1, 1],\n          [1, 0, 1, 1, 0],\n          [0, 0, 1, 0, 1]]\n```\n\n인접 행렬은 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(1)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 유용하다.\n  - 가중치 그래프의 경우 간선의 가중치를 쉽게 확인할 수 있다.\n  - 무방향 그래프의 경우 대각선을 기준으로 대칭성을 가진다.\n  - 행렬의 곱셈을 이용해 그래프의 연결 여부를 확인할 수 있다.\n  - ...\n- 단점\n  - 정점의 개수가 많을 경우 메모리 낭비가 심하다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 낭비가 심하다.\n  - ...\n\n인접 행렬은 정점의 개수가 적고 간선의 개수가 많은 밀집 그래프(Dense Graph)의 경우에 적합하다.\n\n### 3.2 인접 리스트(Adjacency List)\n\n인접 리스트는 리스트를 이용해 그래프를 표현하는 방법이다. 인접 리스트는 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V`개의 리스트가 필요하다.\n- 각 리스트는 해당 정점과 연결된 정점들을 저장한다.\n- 가중치 그래프의 경우 각 리스트의 원소는 정점과 가중치를 저장한다.\n\n```python\nadj_list = [[(3, 1)],\n            [(1, 1), (2, 1)],\n            [(1, 1), (2, 1), (3, 1), (4, 1)],\n            [(0, 1), (2, 1), (3, 1)],\n            [(2, 1), (4, 1)]]\n```\n\n인접 리스트는 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 메모리 사용량이 적다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(E)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 사용량이 적다.\n  - ...\n- 단점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 비효율적이다.\n  - 가중치 그래프의 경우 간선의 가중치를 확인하기 어렵다.\n  - ...\n\n인접 리스트는 정점의 개수가 많고 간선의 개수가 적은 희소 그래프(Sparse Graph)의 경우에 적합하다.\n\n---\n\n## Reference\n\n- [Introduction to Algorithms, 3rd Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Graph","subtitle":"탐색을 위한 자료구조","date":"2024-05-10T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-10-Shortest Path(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(2).md","category":"Algorithm","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`벨만-포드 알고리즘`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n 포함된 그래프에서도 사용할 수 있다. 음수 가중치를 가진 간선이 포함된 그래프에서도 사용할\n 수 있다는 장점이 있으며, 음수 사이클이 존재하는 경우 false/error를 반환하는 방식으로\n 음수 사이클을 탐지할 수 있다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n벨만-포드 알고리즘은 다음과 같은 방식으로 동작한다.\n\n```plaintext\nBELLMAN-FORD(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  for i = 1 to |V[G]| - 1  // 그래프의 정점 수 - 1만큼 반복합니다.\n3      for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n4          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n5  for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n6      if d[v] \u003e d[u] + w(u, v)  // u를 통해 v로 가는 경로가 v의 현재 거리 값보다 작다면\n7          return false  // 음의 사이클이 존재하므로 false를 반환합니다.\n8  return true  // 모든 간선에 대해 음의 사이클이 없다면 true를 반환합니다.\n```\n\n`BELLMAN-FORD(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `d`: 정점 `s`로부터 정점 `v`까지의 최단 거리를 저장하는 배열\n- V[G]: 그래프 `G`의 정점 집합\n- E[G]: 그래프 `G`의 간선 집합\n\n---\n\n## Algorithm by python\n\n```python\ndef bellman_ford(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 간선들에 대해 반복적으로 거리를 갱신(relax)합니다\n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbour in graph[node]:\n                if distance[neighbour] \u003e distance[node] + graph[node][neighbour]:\n                    distance[neighbour], predecessor[neighbour] = distance[node] + graph[node][neighbour], node\n\n    # 음수 사이클을 확인합니다\n    for node in graph:\n        for neighbour in graph[node]:\n            assert distance[neighbour] \u003c= distance[node] + graph[node][neighbour]\n\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n벨만-포드 알고리즘의 시간 복잡도는 $O(VE)$이다. 이는 모든 간선에 대해 최단 거리를 갱신하는\n 과정을 $|V| - 1$번 반복하기 때문이다.\n\n---\n\n## Reference\n\n- [Bellman-Ford algorithm - Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":2}},{"postName":"2024-05-10-Shortest Path(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(3).md","category":"Algorithm","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`Dijkstra algorithm`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n포함된 그래프에서는 사용할 수 없다. 대신 음수 가중치를 가진 간선이 없는 그래프에서는 `Bellman-ford algorithm`보다\n더 빠르게 동작한다.\n\n이를 위해 `Dijkstra algorithm`은 `priority queue`를 사용하여 최단 거리를 계산하며, 이미 계산이 완료된 정점\n들은 다시 계산하지 않는다. 이 때문에 `Dijkstra algorithm`은 `그리디 알고리즘`으로 분류된다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n`Dijkstra algorithm`은 다음과 같은 방식으로 동작한다.\n\n```plaintest\nDIJKSTRA(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  S = {}  // 최단 경로가 발견된 정점들의 집합 S를 초기화합니다.\n3  Q = V[G]  // 모든 정점들을 포함하는 우선순위 큐 Q를 생성합니다.\n4  while Q != {}  // Q가 빌 때까지 반복합니다.\n5      u = EXTRACT-MIN(Q)  // Q에서 거리 값이 가장 작은 정점 u를 추출합니다.\n6      S = S append {u}  // u를 S에 추가합니다.\n7      for each vertex v in Adj[u]  // u의 모든 인접 정점 v에 대해\n8          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n```\n\n`DIJKSTRA(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `S`: 이미 최단 거리를 계산한 정점의 집합\n- `Q`: 아직 최단 거리를 계산하지 않은 정점의 집합\n- `V[G]`: 그래프 `G`의 정점 집합\n- `Adj[u]`: 정점 `u`에 인접한 정점들의 집합\n\n---\n\n## Algorithm by python\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 우선순위 큐를 초기화합니다\n    queue = [(0, start)]\n\n    while queue:\n        # 우선순위 큐에서 가장 가까운 노드를 추출합니다\n        current_distance, current_node = heapq.heappop(queue)\n        # 이미 처리된 노드인 경우 건너뜁니다\n        if current_distance \u003e distance[current_node]:\n            continue\n        # 인접 노드에 대해 최단 거리를 갱신합니다\n        for neighbor, weight in graph[current_node].items():\n            new_distance = current_distance + weight\n            if new_distance \u003c distance[neighbor]:\n                distance[neighbor] = new_distance\n                predecessor[neighbor] = current_node\n                heapq.heappush(queue, (new_distance, neighbor))\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n`Dijkstra algorithm`의 시간 복잡도는 `O((V + E) log V)`이다. 이는 `priority queue`를 사용하여\n최단 거리를 계산하기 때문에 정점을 추출하는 과정이 `O(log V)`이기 때문이다. Bellman-ford algorithm과\n달리 모든 간선이 아니라 `최소 거리를 가진 정점만`을 추출하여 계산하기 때문에 더 빠르게 동작한다.\n\n---\n\n## Reference\n\n- [Dijkstra algorithm - wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n- [Dijkstra algorithm - geeksforgeeks](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\n- [Introduction to algorithms, 3rd edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":3}},{"postName":"2024-02-25-Chat Application 0.개요","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-25-Chat Application 0.개요.md","category":"개발일지","title":"ChatApplication 개요","subtitle":"","content":"\n## 목차\n\n1. 프로젝트 소개\n2. 프로젝트 구조\n3. 기술 스택 및 개발 환경\n\n\n---\n\n\n## 프로젝트 소개\n\nGo 및 백엔드에서 사용하는 전반적인 기술을 익히는 것을 목표로 하는 프로젝트로, 최종 결과물로는 다수의 사용자들이 실시간으로 채팅을 주고받을 수 있는 **[웹 어플리케이션](https://github.com/kaestro/ChatApplication)**을 개발하는 것을 목표로 합니다.\n\n채팅은 다수의 유저가 동시에 접속해서 실시간으로 메시지를 주고 받는 기능을 필요로 합니다. 이 때문에 현대 서버 기술에서 중요하게 여겨지는 동시성, 캐시, 데이터베이스 등의 기술의 필요성을 느낄 수 있는 프로젝트라고 생각했습니다. 동시에 이런 기능을 테스트하는 방법을 만들어보는 것도 목표로 하고 있습니다.\n\n여기서 다수란 약 15000명의 사용자가 동시에 접속할 수 있는 서비스로, 이는 스팀 서비스에서 인기 게임 100위 안에 들어가는 게임의 동시 접속자 수와 비슷한 수치입니다. 이와 관련해서 세부적인 테스트 환경은 추후에 다시 정의할 예정입니다.\n\n\n---\n\n\n## 프로젝트 구조\n\n\n메인 서버: 회원 가입, 로그인 등의 유저 관리 기능 처리. 채팅 서버로 유저와의 연결 담당. 캐시 및 데이터베이스 서버와의 연결 담당.\n\n캐시 서버: 로그인 정보, 채팅 메시지 등을 저장하고 조회하는 서버.\n\n데이터베이스 서버: 유저 정보, 채팅 메시지 등을 저장하고 조회하는 서버.\n\n\n---\n\n\n## 기술 스택 및 개발 환경\n\n```\n1. 서버 개발 언어: Go\n2. 사용 프레임워크: Gin\n3. 배포 환경: Microsoft Azure\n4. 데이터베이스: PostgreSQL\n5. 채팅 메시지 전달 및 로그인 캐시 서버: Redis\n6. 채팅 메시지 저장 및 조회: MongoDB\n7. 테스트 방법: Postman, websocket king\n```\n\n\n### 서버 개발 언어: Go\n\n\n* Go가 서버단에서 개발 편리성이 높고, 빠른 속도로 동작하는 것으로 알려져 있는데 이를 체험해보기 위해\n* Go 루틴과 같은 기능을 통해 동시성 처리를 쉽게 할 수 있기 때문에, 채팅 서버에서 동시성 처리가 많이 필요한 부분이 있을 것으로 예상되기 때문에\n* Go의 수요가 높아질 것으로 예상되는데, 이에 대한 경험을 쌓기 위해\n\n\n### 사용 프레임워크: Gin\n\n\n* Go를 활용한 웹 프레임워크 중에서 가장 인기 있는 프레임워크 중 하나로 학습자료가 많고, 현업에서 사용하는 곳도 많아서\n\n\n### 배포 환경: Microsoft Azure\n\n\n* 배포를 위해 사용되는 클라우드 서비스는 크게 AWS, Azure, GCP가 있습니다.\n* 그런데 Azure를 제외하고는 이전에 사용해 본다고 무료 크레딧을 이미 다 활용했기 때문에 이 참에 Azure를 사용해보기로 했습니다.\n\n\n### 데이터베이스: PostgreSQL\n\n\n* MySQL과 비교했을 때, 한글 처리가 더 용이해서 문제가 덜 발생했기 때문.\n* 최초에는 MySQL을 통한 개발 환경을 구축했으나, 한글 처리에 문제가 발생해서 변경함.\n\n\n### 채팅 메시지 전달 및 로그인 캐시 서버: Redis\n\n\n* 캐시 서버로 현재 가장 많이 쓰이는 솔루션 중 하나이기 때문에\n* Azure에서도 Redis를 제공하기 때문에\n\n\n### 채팅 메시지 저장 및 조회: MongoDB\n\n\n* 개발 목적 중 하나는 NoSQL 데이터베이스를 경험해보는 것이었기 때문에\n* 채팅 어플리케이션으로 기획을 한 것도 이러한 이유\n* MongoDB는 Azure에서도 제공한다.\n* MongoDB는 채팅 메시지와 같은 비정형 데이터를 저장하기에 적합하고 알려져 있다.\n\n\n### 테스트 방법: Postman, websocket king\n\n\n* Postman은 기존에 사용해본 경험이 있고, websocket king은 웹소켓을 테스트하기 위한 툴로 알려져 있기 때문에\n* 이외의 것을 하려면 클라이언트를 개발해야 하는데, 클라이언트 개발 경험 자체가 없어 이를 개발하려하면 시작 자체가 어려울 것으로 예상되기 때문에.\n* 때문에 해당 부분은 개발에서 목표로 하고 있는 수치인 15000명의 동시 접속자 수를 테스트하기에 현재 부적합하며, 추후에 다시 정의할 예정입니다.\n* 15000명의 동시 접속 역시도 해당 접속자들이 어느 정도의 메시지를 주고받는지, 어느 정도의 메시지를 저장하는지에 따라서 달라질 수 있기 때문에, 이에 대한 테스트 방법 또한 추후에 다시 정의할 예정입니다.\n* 대략적으로 생각중인 것은 얼마 전 아프리카 tv에서 7만명의 동접자가 1분에 1번의 채팅을 소화하지 못해서 방송이 다운되는 사태가 있었기 때문에, 이와 비슷한 수치를 목표로 테스트를 진행할 예정입니다.\n\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":0,"classes":"wide","title":"ChatApplication 개요","date":"2024-02-25T00:00:00.000Z","categories":"개발일지","subtitle":""}},{"postName":"2024-02-26-Chat Application review(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-26-Chat Application review(1).md","category":"개발일지","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n개발할 때 최초에 생각한 것과 별개로 기능 추가 및 변경이 빈번하게 발생하게 된다. 이 때마다 기존의 코드를 변경하기 용이하게 하기 위한 추상화, business logic 분리, unit test 등의 작업이 필요하다.\n\n원래는 login api를 다루는 서버에서 채팅 역시도 다루게 될 것이라고 생각했다. 그런데 현재 서버 구조는 api를 다루는 형태로 되어 있으니 이를 api 전용 서버로 두고, 채팅을 다루는 서버는 따로 두는 것이 낫지 않을까? 라는 생각이 들었다.\n\n\n---\n\n\n## 진행 내용\n\n* 프로젝트 개요, 구조, 기술 스택, 개발 환경 등 정리. =\u003e [프로젝트 개요](http://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/02/26/Chat-Application-%EA%B0%9C%EC%9A%94.html)\n* 메인 서버 구조 설계\n* User CRUD API 구현\n* DBManager, SessionManager, PasswordManager internal package 구현\n\n---\n\n### 메인 서버 구조 설계\n\n```\nmyapp\n├── api\n│   ├── handler\n│   │   └── user\n│   ├── models\n│   └── service\n│       └── user\n├── internal\n│   ├── db\n│   ├── session\n│   └── password\n├── pkg\n├── scripts\n├── tests\n└── main.go\n```\n\n* api: API 요청을 처리하는 패키지.\n  * handler: API 요청을 처리하는 핸들러.\n  * models: API 요청과 응답에 사용되는 모델.\n  * service: API 요청을 처리하는 비즈니스 로직.\n  * user: User API 요청을 처리하는 패키지.\n* internal: 내부 패키지.\n  * db: 데이터베이스 관련 패키지.\n  * session: 세션 관리 패키지.\n  * password: 비밀번호 관리 패키지.\n* pkg: 외부에 공개되는 패키지.(미정)\n* scripts: 스크립트 파일.\n  * 현재 sql 파일을 실행하는 스크립트만 존재.\n* tests: 테스트 파일.\n  * go 서버의 unit test 파일만 존재.\n  * 추후 요구하는 규모에 따라 테스트 환경을 구축할 예정.\n* main.go: 프로그램의 진입점.\n\n---\n\n### User CRUD API 구현\n: Login, Logout, Signup, deleteAccount API 구현.\n\n**구현 내용**\n* Login API\n  * 로그인 요청을 처리하는 핸들러 구현.\n  * 로그인 성공 시 세션을 생성하고, 세션 ID를 응답.\n  * 로그인 실패 시 에러 메시지를 응답.\n* Logout API\n  * 로그아웃 요청을 처리하는 핸들러 구현.\n  * 세션을 삭제.\n* Signup API\n  * 회원가입 요청을 처리하는 핸들러 구현.\n  * 회원가입 실패 시 에러 메시지를 응답.\n* deleteAccount API\n  * 회원탈퇴 요청을 처리하는 핸들러 구현.\n  * 로그인 세션을 통해 회원탈퇴.\n  * 회원탈퇴 실패 시 에러 메시지를 응답.\n\n[**구현 상세**](https://github.com/kaestro/ChatApplication/tree/main/myapp/api)\n\nDBManager와 SessionManager를 통해 유저의 정보를 조회하고, 관리를 위한 로직을 수행.\nPasswordManager를 통해 비밀번호를 암호화하여 저장하고, 비밀번호 검증을 수행.\n\nuser data model을 구현, 이를 orm 패키지를 사용하여 데이터베이스와 연동한다.\n\nhandler에 응답을 처리하는 로직을 구현한 뒤 login 같은 경우는 비즈니스 로직이 변경될 수 있으므로 service 패키지를 통해 자주 변경되는 부분을 분리하였다.\n\n---\n\n### DBManager, SessionManager, PasswordManager internal package 구현\n: User CRUD API 구현 과정에서 필요한 패키지 구현\n\n**구현 내용**\n\n* DBManager\n  * 데이터베이스와 연동하여 유저 정보를 조회, 추가, 삭제하는 로직을 수행.\n  * orm 패키지를 사용하여 데이터베이스와 연동.\n  * DB 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* SessionManager\n  * 캐시 서버를 통해 세션을 관리.\n  * 세션 생성, 조회, 삭제 로직을 수행.\n  * 세션 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* PasswordManager\n  * 비밀번호를 암호화하여 저장하고, 비밀번호 검증하는 로직을 수행\n  \n**구현 상세**\n\n**DBManager**는 DB 연결을 gorm을 통해 생성하고, create, read by single field, read all table, update row, delete row 기능을 제공한다.\n\n**SessionManager**는 redis를 통해 세션 키 생성, 세션 생성, 조회, 삭제, 정합성 확인 기능을 제공. =\u003e *TODO* 현재 \u003cu\u003eLoginSessionGenerator.go를 LoginSessionKeyGenerator.go로 파일명 변경한다\u003c/u\u003e\n\n**Store**라는 추상적인 인터페이스를 통해 session을 관리하고, 현재 이를 RedisStore를 통해 구현한다. 이는 추후에 다른 저장소를 사용할 때 변경이 용이하도록 하기 위해서이다.\n\n**PasswordManager**는 bcrypt를 통해 비밀번호를 암호화하고, 비밀번호 검증하는 기능을 제공한다.\n\n---\n\n## 문제 및 해결 방법\n\n### 문제상황\n\n```\n1. dbManager가 연결 객체 자체를 반환하고 있었음.\n2. 암호화 로직이 api마다 중복되어 있었음.\n3. login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n4. user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n```\n\n\n### 해결 방법\n\n**dbManager가 연결 객체 자체를 반환하고 있었음.**\n\n**문제점**: GetDB() 함수를 통해 db 객체를 반환하고 있었다. 이는 db 객체를 직접 사용하게 되어, dbManager의 로직이 변경될 때마다 모든 곳에서 변경이 필요하게 된다.\n\n```go\nvar (\n\tonce sync.Once\n\n\tdb *gorm.DB\n)\n\nfunc GetDB() *gorm.DB {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err = gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn db\n}\n```\n\n**해결 방법**: dbManager에서 허용하는 로직만을 public하게 제공하도록 변경.\n\n```go\ntype DBManager struct {\n\tdb *gorm.DB\n}\n\nvar (\n\tonce sync.Once\n\n\tmanager *DBManager\n)\n\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmanager = \u0026DBManager{\n\t\t\tdb: db,\n\t\t}\n\t})\n\n\treturn manager\n}\n\nfunc (m *DBManager) Create(value interface{}) error {\n    return m.db.Create(value).Error\n}\n...\n```\n\n\n---\n\n\n**암호화 로직이 api마다 중복되어 있었음.**\n\n**문제점**: 비밀번호 암호화, 비밀번호 검증 로직이 user CRUD api마다 중복되어 있었음.\n\n```go\nfunc Signup(c *gin.Context) {\n    ...\n\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\n    ...\n}\n```\n\n**해결 방법**: Password package를 생성하여 비밀번호 암호화, 비밀번호 검증 로직을 분리.\n\n```go\npackage password\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(hashedPassword), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n```\n\n### login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n\n**문제점**: login api의 비즈니스 로직이 변경될 때마다 handler에서 변경이 필요하게 됨.\n\n```go\n\tdb.GetDB().Create(\u0026user)\n\n\t// 로그인 정보를 담은 요청 본문을 생성합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\tbody, _ := json.Marshal(loginInfo)\n\n\t// 테스트를 위한 HTTP 요청을 생성합니다.\n\treq, _ := http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw := httptest.NewRecorder()\n\n\t// Gin 엔진을 생성하고 LogIn 핸들러를 등록합니다.\n\tr := gin.Default()\n\tr.POST(\"/login\", userAPI.LogIn)\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\t// 잘못된 비밀번호로 로그인을 시도합니다.\n\tloginInfo.Password = \"wrongpassword\"\n\tbody, _ = json.Marshal(loginInfo)\n\treq, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw = httptest.NewRecorder()\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 401인지 확인합니다.\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\n\tt.Log(\"Login test passed!\")\n}\n```\n\n구현 과정에서 DBManager, SessionManager, Password 등의 패키지를 추가하게 됐다. 이 과정에서 추상화, 접근 제어 등의 기능이 도입되었고 이 때마다 handler에서 변경이 필요하게 됨.\n\n이와 관련한 해결 방법으로 service 패키지를 통해 비즈니스 로직을 분리하고자 함.\n\n```go\nvar (\n\tErrAlreadyLoggedIn            = errors.New(\"user is already logged in\")\n\tErrUserNotFound               = errors.New(\"failed to find user\")\n\tErrInvalidPassword            = errors.New(\"invalid password\")\n\tErrFailedToGenerateSessionKey = errors.New(\"failed to generate session key\")\n\tErrFailedToSaveSessionKey     = errors.New(\"failed to save session key\")\n)\n\ntype LoginService struct {\n\tdbManager      *db.DBManager\n\tsessionManager *session.SessionManager\n}\n\nfunc NewLoginService(dbManager *db.DBManager, sessionManager *session.SessionManager) *LoginService {\n\treturn \u0026LoginService{\n\t\tdbManager:      dbManager,\n\t\tsessionManager: sessionManager,\n\t}\n}\n\nfunc (s *LoginService) LogIn(userEmailAddress, userPassword, userSessionKey string) (string, error) {\n\t// 세션 키가 sessionManager에 저장되어 있는지 확인합니다.\n\tif s.sessionManager.IsSessionValid(userSessionKey, userEmailAddress) {\n\t\treturn \"\", ErrAlreadyLoggedIn\n\t}\n\n\t// 사용자 정보를 담을 User 구조체를 선언합니다.\n\tvar user models.User\n\n\t// 사용자가 제공한 이메일 주소로 데이터베이스에서 사용자를 찾습니다.\n\terr := s.dbManager.Read(\u0026user, \"email_address\", userEmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\t// 사용자가 제공한 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교합니다.\n\tif !password.CheckPasswordHash(userPassword, user.Password) {\n\t\treturn \"\", ErrInvalidPassword\n\t}\n\n\t// 세션 키를 생성합니다.\n\tsessionKey, err := session.GenerateRandomSessionKey()\n\tif err != nil {\n\t\treturn \"\", ErrFailedToGenerateSessionKey\n\t}\n\n\t// 세션 키를 캐시에 저장합니다.\n\terr = s.sessionManager.SetSession(sessionKey, user.EmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrFailedToSaveSessionKey\n\t}\n\n\treturn sessionKey, nil\n}\n```\n\n---\n\n### user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n\n**문제점**: user CRUD api를 구현 때마다 postman을 통해 수동으로 테스트를 진행하고 있었음.\n\n**해결 방법**: user CRUD api를 매 빌드시마다 검증할 unit test를 작성.\n\n```go\nfunc TestUserHandler(t *testing.T) {\n\t// 테스트를 위한 사용자 정보를 생성합니다.\n\tsampleUser := models.User{\n\t\tUserName:     \"testuser\",\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\n\t// Gin 엔진을 생성하고 핸들러들을 등록합니다.\n\tginEngine := gin.Default()\n\tginEngine.POST(\"/login\", userAPI.LogIn)\n\tginEngine.POST(\"/logout\", userAPI.LogOut)\n\tginEngine.POST(\"/signup\", userAPI.SignUp)\n\tginEngine.POST(\"/deleteAccount\", userAPI.DeleteAccount)\n\n\t// signup HTTP 요청을 처리합니다.\n\tbody, _ := json.Marshal(sampleUser)\n\thttpRequest, _ := http.NewRequest(\"POST\", \"/signup\", bytes.NewBuffer(body))\n\tresponseRecorder := httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\tt.Log(responseRecorder.Body.String())\n\n\t// 응답 상태 코드가 201인지 확인합니다.\n\tif assert.Equal(t, http.StatusCreated, responseRecorder.Code) {\n\t\tt.Log(\"SignUp 테스트 통과\")\n\t}\n\n\t// login HTTP 요청을 처리합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: sampleUser.EmailAddress,\n\t\tPassword:     sampleUser.Password,\n\t}\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogIn 테스트 통과\")\n\t}\n\n\t// logout HTTP 요청을 처리합니다.\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/logout\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", responseRecorder.Body.String())\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogOut 테스트 통과\")\n\t}\n\n\t// deleteAccount HTTP 요청을 처리합니다.\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 전 LogIn 테스트 통과\")\n\t}\n\n\tt.Log(\"Session-Key:\" + responseRecorder.Body.String())\n\tvar responseBody map[string]string\n\tjson.Unmarshal(responseRecorder.Body.Bytes(), \u0026responseBody)\n\tsessionKey := responseBody[\"sessionKey\"]\n\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/deleteAccount\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", sessionKey)\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 테스트 통과\")\n\t}\n}\n```\n\n---","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":1,"classes":"wide","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","date":"2024-02-26T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-02-27-Chat Application review(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-27-Chat Application review(2).md","category":"개발일지","title":"ChatApplication Review(2)","subtitle":"컨테이너화, ChatDBManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n\n단순히 프로그램이 동작하는 것을 넘어서, 오랜 기간동안 개발 및 유지될 것을 고려하면 많은 부분이 달라진다는 것을 경험할 수 있었다. unittest들이 작성돼있었던 덕분에 sessionManager 같은 것들을 refactor했는데도 동작이 여전히 가능하단 것을 쉽게 확인할 수 있었지만, 동시에 이를 자동화하기 위한 방법도 고려해 둬야한다는 것도 알 수 있었다.\n\n또한 이후 개발에 있어서 현재 예측할 수 없는 스펙 부분에 대응하기 위해 가능한 많은 부분을 유연하게 만들어두는 것이 중요하다는 것도 알 수 있었다. 내가 현재 생각해 둔 디렉토리의 형태부터 시작해서 변수/파일명, 인터페이스 접근 방식 등 생각보다 훨씬 많은 것들에 대해 유연하게 대응할 수 있도록 만들어둘 수 있는 부분이 많았다.\n\n그리고 containerization이 끝났다 해서 이를 remote cloud server에 올리는 것이 단순하지만은 않다는 것도 느낀다.\n\n---\n\n\n## 진행 내용\n\n* 배포를 위한 containerization 작업 완료\n* 채팅 기능을 위한 모듈들의 기본적인 구조 설계 및 이에 따른 구조 refactoring\n* 채팅에서 사용할 mongodb 인터페이스 설계\n\n---\n\n## 문제 및 해결 방법\n\n### 문제: 빌드한 어플리케이션이 로컬에서와 다르게 동작함\n  1. postgresql과의 연결이 안됨\n     * 기존에 hostname이 localhost로 돼있었는데, containerization을 할 경우 이를 postgresql로 DBManager를 바꿔야하기 때문.\n     * 로컬에서 테스트할 경우에 문제가 되는 부분이기 때문에 이를 양쪽 환경에서 다르게 쓸 방법을 찾아야함.\n  2. Failed to process session key 에러가 발생하고 있음.\n\t * 이는 로컬에서는 발생하지 않았던 에러로, 이를 해결하기 위해선 어떤 부분이 문제인지 파악해야함.\n\t * 이를 위해선 로컬에서와 동일한 환경을 만들어야함.\n\t * postgresql과 마찬가지로 hostname을 localhost를 쓰던 것이 문제였고, 이를 redis로 바꿔야함.\n   \n### 해결 방법:\n  * ENV를 사용하여 환경변수를 설정하고, 없을 경우에는 default인 localhost를 사용하게 해서 local에서 동작하도록 변경함.\n  * 해당 ENV는 docker-compose.yml와 dockerfile에서 사용하도록 변경함.\n   * [https://github.com/kaestro/ChatApplication/commit/e6258879d661345d7aeeac0a05ed953e8bd05a0e](https://github.com/kaestro/ChatApplication/commit/e6258879d661345d7aeeac0a05ed953e8bd05a0e)\n  * ex)\n\n    * before)\n```go\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n```\n\n\t* after)\n```go\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdbURL := os.Getenv(\"DB_URL\")\n\t\tif dbURL == \"\" {\n\t\t\tdbURL = \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\" // default value\n\t\t}\n\t\tdb, err := gorm.Open(\"postgres\", dbURL)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n```\n\n---\n\n### 문제: 몽고 db의 인터페이스 설정\n\n1. 허용하고자 하는 동작은 어느 것들이 있는가\n2. 기존의 디렉토리와 함께했을 때 구성은 어떻게 해야하는가\n  * models같은 경우에는 api/models 디렉토리 상에 위치하고 있는데, 이를 몽고 db의 internal에서도 사용해야하는 시점에서 디렉토리 구성을 개선할 필요가 발생함.\n\n### 해결 방법:\n\n1. 일단 나머지 모듈들을 만들어서 테스트하는 데에 필요한 AddMessage, GetMessages, CreateChatRoom, GetChatRooms 정도의 함수를 만든다.\n2. internal/db/mongodb 디렉토리를 만들고 여기에 ChatDBManager.go를 만들어 몽고 db들 중 chat에 한정한 인터페이스로 이번에 작성한 모듈이 국한되도록 한다.","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":2,"classes":"wide","title":"ChatApplication Review(2)","subtitle":"컨테이너화, ChatDBManager","date":"2024-02-27T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-06-Chat Application review(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-06-Chat Application review(3).md","category":"개발일지","title":"ChatApplication Review(3)","subtitle":"팀원 모집, 확장성 높은 디자인, CI/CD","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n---\n\n## 느낀 점\n\n---\n\n## 진행 내용\n\n* 추가 진행에서 협업할 인원 모집\n* 채팅 기능을 위한 모듈들의 작성\n* 설계 조건 맞추기 위한 이론적인 구상\n* 협업을 위한 환경 설정\n\n---\n\n## 문제 및 해결 방법\n\n### 문제 요구 스펙 관련해서 Redis와 같은 세션을 여러개 사용해야할 가능성이 높다는 것을 확인\n\n* RedisStore가 고정적으로 하나의 Redis와의 연결만을 생성할 수 있었음.\n\n### 해결 방법\n\n* StoreFactory를 만들고, RedisStoreFactory를 분리.\n* RedisStoreFactory가 추후에 여러가지 Redis연결을 생성하는 것이 용이하도록 구성함.\n\n```go\ntype RedisStoreFactory struct{}\n\nfunc (factory *RedisStoreFactory) Create(sessionTypeNum SessionType) SessionStore {\n\tvar store SessionStore\n\tif sessionTypeNum == LoginSession {\n\t\tredisAddr := os.Getenv(\"REDIS_ADDR\")\n\t\tif redisAddr == \"\" {\n\t\t\tredisAddr = \"localhost:6379\" // default value\n\t\t}\n\n\t\tstore = \u0026RedisStore{\n\t\t\tclient: redis.NewClient(\u0026redis.Options{\n\t\t\t\tAddr:     redisAddr,\n\t\t\t\tPassword: \"redisPassword\", // no password set\n\t\t\t\tDB:       0,               // use default DB\n\t\t\t}),\n\t\t}\n\t} else if sessionTypeNum == OtherSession {\n\t\tpanic(\"Unauthorized session type number given to RedisStoreFactory.\")\n\t}\n\treturn store\n}\n```\n\n---\n\n### 문제: 여러가지 측면에서 다른 사람의 도움이 있으면 속도가 빨라질 것 같다는 생각이 듬\n\n1. 설계적인 측면에서 second opinion이 필요함.\n2. 코드 리뷰를 통해 유지보수성을 높일 필요가 있음.\n3. 작성해야하는 코드의 양이 많아짐.\n\n### 해결 방법\n\n- 커뮤니티에 모집글을 게시\n- 연락이 온 사람과 화상 미팅 진행\n  - 2명 모집.\n  - 일주일간 진행해보고 계속할 지 여부에 대해 결정하기로 함.\n\n\n---\n\n### 문제: 협업을 위한 환경 설정\n\n1. 브랜치를 관리하기 위한 규칙이 필요\n2. ci를 위한 설정이 필요\n\n\n### 해결 방법\n\n1. 브랜치 관리 규칙을 정함\n\t* main: 배포용 브랜치\n    \t* push 불가능\n\t* pull request 규칙 설정\n\t\t* 승인을 받아야만 merge 가능\n\t\t* 코드 소유자의 리뷰가 필요\n2. github action을 통해 ci를 설정함\n\t* go 프로젝트 빌드/테스트가 성공해야만 merge 가능\n\t\t* [TODO] 기존의 테스트 코드들이 mock을 사용하지 않아서 테스트가 불가능한 상황 해소 필요\n\t* docker 빌드가 성공해야만 merge 가능\n\n```yaml\nname: CI\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: 1.22\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Dockerfile main_server 빌드\n      run: docker build -t main_server:latest .\n      working-directory: myapp\n\n    - name: Build with docker-compose\n      run: docker-compose up -d\n      working-directory: myapp\n\n    - name: Test\n      run: go test ./...\n      working-directory: myapp\n\n    - name: Build\n      run: go build ./...\n      working-directory: myapp\n```\n\n---\n\n### 문제: azure에 컨테이너를 통한 배포\n\n* 컨테이너에 앞서 이에 포함된 main_server를 acr(azure container registry)에 올리는 과정에서 문제가 발생함.\n  * [Docker를 통한 어플리케이션 생성 wiki](https://github.com/kaestro/ChatApplication/wiki/Docker%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%83%9D%EC%84%B1)\n  * [Azure Container Registry](https://github.com/kaestro/ChatApplication/wiki/Azure-Container-Registry)\n\n### 해결 방법\n\n* 기존에 acr의 이름이 너무 길어서 camelCase를 사용했던 것이 문제였음. docker는 push할 때 대/소문자가 있을 경우 인증 오류를 발생시킬 수 있음.\n* [공식문서](https://learn.microsoft.com/ko-kr/azure/container-registry/container-registry-faq#az-acr-login-succeeds-but-docker-fails-with-error--unauthorized--authentication-required)\n* 기존의 purmirContainerRegistry를 purmir로 변경함.\n\n---\n\n### Kubernetes를 통한 배포\n\n### 문제: kubernetes로 로컬에 클러스터를 생성한 상태에서 요청이 이루어지지 않고 있음.\n\n### 해결 방법\n\n* log를 일단 읽어야 문제 해결이 가능할 것 같음.\n* kubernetes에 대한 이해 필요\n* 혹은 kubernetes 이외의 방법을 통한 배포를 고려해야할 수도 있음.","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":3,"classes":"wide","title":"ChatApplication Review(3)","subtitle":"팀원 모집, 확장성 높은 디자인, CI/CD","date":"2024-03-06T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-17-Chat Application review(4)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-17-Chat Application review(4).md","category":"개발일지","title":"ChatApplication Review(4)","subtitle":"code study, 설계도, azure cost analysis","content":"\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n---\n\n## 느낀 점\n\n* 팀원 간에 목표를 공유하고 지식을 전파해 두는 것의 어려움과 필요성.\n* 공유해야하는 지식들의 다양함과 효율적인 공유 방법.\n* 프로젝트를 진행할 때 cost analysis의 중요성.\n\n---\n\n## 진행 내용\n\n* 팀원에게 프로젝트 목표 공유\n* 프로젝트 상세 내용 설명 및 진입점 제안\n* 설계도 작성\n* Azure Cost Analysis\n\n---\n\n## 문제 및 해결 방법\n\n### [1] 모집한 팀원이 프로젝트 작업을 시작하기 위한 목표 공유가 필요했음\n\n### [1] 해결 방법\n\n* 코드를 함께 읽어나가는 study session을 진행함.\n* README.md 업데이트를 통해 프로젝트 목표를 제시함.\n* mockTestImplementation이라는 브랜치 생성 및 팀원들에게 이를 진입점으로 제안함.\n* draw.io를 통한 설계도 작성 및 공유\n  * [설계도 링크](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n### [2] Azure Cost Analysis\n\n* Azure의 무료 이용 기간이 끝나고 한달 예상 비용이 40만원으로 예측됨.\n\n### [2] 해결 방법\n\n* 현재 Azure 구독을 정지시켜둔 상태.\n* 주로 발생하는 비용은 ACR(Azure Container Registry)와 AKS(Azure Kubernetes Service)의 비용으로 예상됨.\n* ACR을 Docker Hub로 변경하고, serverless로 전환하여 비용을 절감 가능할 것으로 예상.\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":4,"classes":"wide","title":"ChatApplication Review(4)","subtitle":"code study, 설계도, azure cost analysis","date":"2024-03-17T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-19-Chat Application review(5)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-19-Chat Application review(5).md","category":"개발일지","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **문제 및 해결 방법**\n\n---\n\n## 느낀 점\n\n* **기술 스택**을 선택할 때, **명확한 기준**을 통한 비교를 할 필요성을 체감\n* 당장 수요에 맞는 **가벼운 기술**을 선택하되, 규모가 커질 것을 대비하여 **확장성**을 고려해야 함.\n* **MVP**(Minimum Viable Product)를 정의 내리고 이를 기준으로 기존 **기술 스택 선택**이 **타당성**을 검토해야 함.\n* **결론**:\n  * **MVP**: postgresql, redis, rabbitMQ, golang - gin\n  * **확장**: mysql, memcached, kafka, mongodb\n\n---\n\n## 진행 내용\n\n* **설계도**에서 서비스별 사용하기로 한 **기술스택**에 대한 대안 검토\n  * [**설계도 링크**](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n## 문제 및 해결 방법\n\n### [1] **기술 스택** 선택에 대한 명백한 **근거** 부족\n\n* 기술 스택 선택에 대한 **명백한 근거**가 부족.\n* 현재 기술 스택의 **장단점**을 명확히 파악하지 못하고 있음.\n* 단순히 **유명하고 핫하기 때문**에 선택한 경우가 많음.\n* 기술 스택의 **장점**을 **활용**하지 못하고 있음.\n* 이에 따라 **이미 사용 가능한 기술**을 충분히 활용하지 못하고 있음.\n* **프로젝트가 진행**되기보다 새로운 기술을 학습하는 데 더 많은 시간을 할애하고 있음.\n\n### [1] 해결 방법\n\n* 모듈 혹은 서비스 별로 사용되는 **기술스택**의 **대안**을 조사하고, 이에 대한 **비교**를 통해 명확한 기준을 세움.\n\n* **웹서버**\n  * 현재 사용중인 기술 스택: **golang - gin**\n  * **대안**: node.js - express, java - spring boot, python - fast api\n  * **기존 기술** 선택 이유: golang이 가진 **웹서버 성능** 및 **동시성 처리**에 대한 장점.\n  * 의문점\n    * 다른 기술 스택에 비해 **golang**은 어떤 점에서 **동시성 처리**에 더 유리하다고 말할 수 있는가?\n      * **[Golang은 진정 동시성을 처리하는 데 유리한가?](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/03/19/Golang%EC%9D%80-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%97%90%EC%84%9C-%EC%9C%A0%EB%A6%AC%ED%95%9C%EA%B0%80.html)**\n* **데이터베이스**\n  * 현재 사용중인 기술 스택: **postgresql**\n  * 대안: **mysql**\n  * **기존 기술** 선택 이유: 사용 **경험**이 있음\n  * 조사 결과 PostgreSQL은 mySQL에 비해 **복잡한 동작**을 필요로 할 때 사용하는 기술 스택으로 알려져 있다.\n    * **\u003chttps://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/\u003e**\n  * 팀원들도 mysql에 경험이 더 많은 편이므로, **mysql로 이전**하도록 생각하고 있다.\n* **NoSQL**\n  * 현재 사용중인 기술 스택: **mongodb**\n  * 대안: 유저 정보 저장에 사용하는 **SQL 데이터베이스**에서의 통합\n  * 기존 기술 **선택 이유**: **문서형 데이터베이스**로서 가지는 장점이 있다는 점.\n  * **문제점**\n    * 그 장점이 뭔지 모름\n    * 문서형 데이터베이스가 무엇인지도 잘 모름\n  * **mongoDB**의 장점\n    * **데이터 형태**에 구애를 덜 받으므로 **이모티콘**과 같은 string 외 **다양한 데이터**를 처리하는 데에 용이하다\n    * **채팅 방 단위**로 데이터를 구현시에 **기존 데이터**를 **신규 입장자**에게 제공하기 유리하다\n  * **RDBMS**의 장점\n    * string만 사용할 경우 table과 로직을 통해서 **기초적인 채팅**을 **빠르게 구현**할 수 있다.\n  * **선택**: **RDBMS**(mysql/postgresql) 중에 하나로 **채팅의 interface**를 구현하고, **string에 한정**한 뒤 방 입장시에 **접속 이전 데이터**를 제공하지 않는 방향으로 **mvp**를 구성한 뒤에 기능을 **확장**하는 과정에서 **mongoDB** 도입을 고려한다.\n  * **추가**적인 mongoDB 및 문서형 데이터베이스에 대한 **연구** 필요\n* **세션**\n  * 현재 사용중인 기술 스택: **redis**\n  * 대안: **memcached**, 세션이 아닌 **토큰**(JWT 등)을 사용\n  * 기존 기술 **선택 이유**\n    * 사용해 본 적이 있는 기술 스택\n    * 유명해서 자료를 구하는 것이 용이\n  * 참고 자료\n    * [**Redis vs Memcached**](https://velog.io/@sileeee/Redis-vs-Memcached)\n    * [**Session storage로 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)**](https://1-7171771.tistory.com/127)\n    * [**Memcached vs Redis: Choose Your In-Memory Cache**](https://kinsta.com/blog/memcached-vs-redis/)\n  * **Memcached**\n    * 장점\n      * 적은 **메모리 사용량** - 적은 메타 데이터\n      * 안정적인 **응답 시간**\n      * **데이터 변경이 적은 경우** 메모리 파편화가 적음\n      * **수평적 확장**이 쉬움 - **multi-threading** 지원\n    * 단점\n      * 적은 **데이터 타입**과 **API**\n      * **데이터 변경이 잦은 경우**에 파편화가 많이 발생\n  * **Redis**\n    * 장점\n      * 다양한 **데이터 타입**과 **기능**\n      * 많은 사용자\n      * **디스크**에 저장 가능\n      * **Key**에 저장할 수 있는 **데이터의 크기**가 큼\n      * **pub/sub**을 지원해서 **메시지 큐**로도 사용 가능\n    * 단점\n      * **메모리 사용량**이 많음(실제 필요량보다 **2배** 가까이 사용하는 구조)\n      * 트래픽이 많은 경우 **응답 시간**이 불안정 - **발생 가능성 낮음**\n  * **선택**\n    * **MVP**의 관점에서 더 빠르게 시작할 수 있는 것은 Redis이다. 이는 **기능 및 데이터 타입**을 여럿 이미 구현돼 있기 때문이다.\n    * 트래픽이 많은 경우에 응답 시간이 얼마나 불안정해지는지 **측정**할 방법을 마련해두고, 그에 따라 **Memcached**로 전환할지 여부를 결정한다.\n    * Redis를 사용하면 다른 기술 스택 없이 **메시지 큐**를 처리할 수 있을 지도 모름\n* **메시지 큐**\n  * 현재 **사용 예정**이었던 기술 스택: **kafka**\n  * 대안: **RabbitMQ**, **ActiveMQ**\n  * 기존 기술 **선택 이유**\n    * 메시지 큐 기술들 중 가장 **유명**해서.\n  * 추가적으로 따로 글을 파서 고민해봐야 할 듯\n  * **참고 자료**\n    * **\u003chttps://gwonbookcase.tistory.com/49\u003e**\n    * **\u003chttps://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html\u003e**\n  * **kafka**의 장점\n    * **분산 처리 기능**을 가장 잘 활용할 수 있음.\n    * 메모리가 아니라 **파일 시스템**을 이용한다.\n    * **TPS**가 높고 **대용량 실시간 로그 처리**에 유리하다\n    * broker가 **push**하는 것이 아니라 **pull**하는 방식\n  * **activeMQ** vs **rabbitMQ**\n    * rabbitMQ가 **더 다양한 프로토콜**을 지원하고, activeMQ는 **java**에 더 특화된 모양이라 이 부분은 연구 필요\n  * **선택**\n    * **RabbitMQ**로 MVP를 구현하고, **확장성**이 필요할 경우 **Kafka**로 전환하는 방향으로 진행한다.\n    * RabbitMQ가 kafka에 비해 보다 기능이 **간단**하고 **빠르게 구현**할 수 있을 것으로 예상되기 때문\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":5,"classes":"wide","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","date":"2024-03-19T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-29-Chat Application review(6)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-29-Chat Application review(6).md","category":"개발일지","title":"ChatApplication Review(6)","subtitle":"MVP, Develop Branch, Chat 모듈","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **진행 과정**\n\n---\n\n## 느낀 점\n\n---\n\n## 진행 내용\n\n* MVP(Minimum Viable Product) 설정\n* Develop Branch 생성\n* Chat 모듈 구현\n\n---\n\n## 진행 과정\n\n### MVP(Minimum Viable Product) 설정\n\n#### 문제: 너무 많은 기능을 구현하려고 하다 보니 진행이 되지 않음\n\n* 사용할 줄 모르고, **먼 훗날**에 사용할 것 같은 기능을 구현하려고 하다 보니 진행이 되지 않았다.\n  * kubernetes, message queue, etc...\n* 해당 기술들의 **필요성**이나 **장점**에 대한 인식도 모자랐다.\n\n#### 해결 방법\n\n* **MVP**를 설정하여 **필요한 기능만** 구현하도록 목표를 재설정했다.\n  * MVP: 사용자가 최소한으로 사용할 수 있는 제품\n* 재설정한 **목표**\n  * **User** 관련: 로그인, 회원가입\n  * **Chat** 관련: 채팅방 생성, 채팅방 입장, 채팅방 메시지 전송\n  * **Log** 관련: 채팅방 로그 저장, 채팅방 로그 조회\n\n---\n\n### Develop Branch 생성\n\n#### 문제: Main Branch 이전에 병합을 통한 확인이 필요\n\n* **Main Branch**는 실제로 배포를 해야하기 때문에 가능한 **안정적인 코드**가 들어가야 한다.\n* Main Branch 이전에 작성한 모듈들 간에 **호환성 확인 및 통합**을 위한 중간 Branch가 필요를 체감.\n\n#### 해결 방법\n\n* **Develop Branch**를 생성하여 Main Branch 이전에 코드를 병합하여 확인하도록 하였다.\n* Main Branch와 달리 Develop Branch는 **Admin**은 직접 코드 수정이 가능하도록 해 개발 진행 속도를 올릴 수 있도록 함.\n\n---\n\n### Chat 모듈 구현\n\n#### 진행 과정\n\n**최초**에는 참고자료 없이 **직접 구현** 시도. 이 과정에서 다음과 같은 것들을 구현 및 수정하였다.\n\n* **Room**과 **Client** 객체를 구현\n  * **Room**: 채팅방을 나타내는 객체\n    * 사용자를 추가, 제거\n    * 메시지 전송\n  * **Client**: 채팅방에 참여하는 사용자를 나타내는 객체\n    * 웹소켓을 소유\n    * loginSessionID를 통해 구분(userID로 구분이 나은가?)\n    * 메시지 전송\n* **connect**, **disconnect** 이벤트를 구현\n  * **connect**: 클라이언트가 채팅방에 입장\n  * **disconnect**: 클라이언트가 채팅방에서 퇴장\n\n#### 의문점\n\n* 방 관련\n  * 방들은 어느 **자료구조**로 저장해야하는가?\n  * **저장하는 장소**는 file인가 메모리인가?\n  * 메모리에 저장한다면 **서버가 감당할 수 있는 크기**는 어느 정도인가?\n  * 이것을 **별개의 서버**로 감당하게 하는 것이 좋은가?\n* 클라이언트 관련\n  * 웹소켓은 얼마나 오랫동안 **유지**해야하는가?\n  * 연결이 끊어질 경우 Client 객체를 **삭제**해야하는가?\n  * Client 객체를 만들고 삭제하는 것의 **부하**는 어느 정도인가?\n  * Client 객체는 방과 마찬가지로 어떻게 **관리**해야하는가?\n\n#### 진행 예정 사항\n\n다른 다중 채팅 프로그램이 구현된 오픈소스를 공부해보는 시간을 가질 예정\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":6,"classes":"wide","title":"ChatApplication Review(6)","subtitle":"MVP, Develop Branch, Chat 모듈","date":"2024-03-29T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-29-Chat Application review(7)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-29-Chat Application review(7).md","category":"개발일지","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","content":"\n## 목차\n\n- [목차](#목차)\n- [느낀 점](#느낀-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [Chat 모듈 구현](#chat-모듈-구현)\n    - [모듈 사양이 불명확할 때의 구현](#모듈-사양이-불명확할-때의-구현)\n      - [clientManager.go](#clientmanagergo)\n    - [추상화를 통해 모듈의 작업 단위를 세부적으로 분리](#추상화를-통해-모듈의-작업-단위를-세부적으로-분리)\n      - [room.go](#roomgo)\n      - [roomManager.go](#roommanagergo)\n    - [이후 진행 방향](#이후-진행-방향)\n\n---\n\n## 느낀 점\n\n1. 협업에서 모듈의 사양 합의가 돼있지 않을 때, 이에 대응하기 용이한 유연한 코드를 작성하는 방법\n2. MVP 내에서도 더 세부 단계에서 어디서부터 구현을 시작해야 하는지에 대한 고민\n3. 추상화를 통해 모듈 내부의 역할을 세부적으로 분리하는 방법\n4. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 검토의 필요성\n\n---\n\n## 진행 내용\n\n- Chat 모듈 구현\n\n---\n\n## 진행 과정\n\n### Chat 모듈 구현\n\n#### 모듈 사양이 불명확할 때의 구현\n\n- **문제**\n  - 다른 팀원과 모듈의 사양에 대해 합의가 돼있지 않다\n  - 내가 작성한 chat 모듈을 다른 팀원이 사용할 때 어떤 형태로 부를 것인지 불명확하다\n  - 내가 chat 모듈에서 이용해야하는 다른 모듈의 형태가 불명확하다\n\n- **해결**\n  - 코드를 가능한 작은 단위로 나누어 유연한 변경이 가능하도록 한다\n  - 함수에서 파라미터로 받는 값을 특정한 형태로 제한하고, 이를 활용하는 상위 모듈을 작성한다\n  - 상위 모듈에서는 추후에 다른 모듈에서 이를 호출할 때 필요한 값을 제한한다.\n\n##### clientManager.go\n\n```go\nfunc (cm *ClientManager) CheckClient(sessionID string) bool {\n  _, ok := cm.clients[sessionID]\n  return ok\n}\n\nfunc (cm *ClientManager) GetClient(sessionID string) *Client {\n  if !cm.CheckClient(sessionID) {\n    fmt.Println(\"Client with sessionID\", sessionID, \"does not exist\")\n    return nil\n  }\n\n  return cm.clients[sessionID]\n}\n```\n\n#### 추상화를 통해 모듈의 작업 단위를 세부적으로 분리\n\n- **문제**\n  - 단일 클래스들이 하는 역할이 너무 많아 코드가 복잡해졌다.\n    - 기존에는 client, room, socket이라는 세 개의 클래스를 통해 구현을 작업하려 했음.\n  - 각각의 클래스가 하는 일들이 무엇인지 구분하기 어려웠다.\n    - room, client는 방에 client를 추가하고 이들을 관리하는 작업들을 동시에 했다.\n  - 클래스 간에 하는 영역이 겹치는 부분이 많아 코드 중복이 발생했다.\n\n- **해결**\n  - 클래스가 할 일을 더 작은 단위로 나누어 추상화한다.\n    - [room](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/room.go)\n      - 방을 crud하는 메소드를 제공한다.\n      - 방에 들어온 client의 crud를 관리한다.\n      - 방에 들어온 client들 간의 메시지를 주고 받는 작업을 한다.\n  - 이 과정에서 사라진 이들을 관리하는 작업을 Manager 클래스로 분리한다.\n    - ClientManager, RoomManager, ChatManager 등으로 분리한다.\n    - [ChatManager](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/chatManager.go)는 최상위 클래스로, RoomManager, ClientManager를 통해 채팅 전반을 관리한다.\n\n##### room.go\n\n```go\nfunc NewRoom() *Room {\n  room := \u0026Room{\n    client_chan: make(map[*Client]*websocket.Conn),\n    broadcast:   make(chan []byte),\n    register:    make(chan *ClientConn),\n    unregister:  make(chan *ClientConn),\n  }\n\n  go room.run()\n\n  return room\n}\n```\n\n##### roomManager.go\n\n```go\ntype RoomManager struct {\n  rooms map[string]*Room\n}\n\nfunc GetRoomManager() *RoomManager {\n  roomOnce.Do(func() {\n    roomManager = \u0026RoomManager{\n      rooms: make(map[string]*Room),\n    }\n  })\n\n  return roomManager\n}\n\nfunc (rm *RoomManager) CheckRoom(roomID string) bool {\n  _, ok := rm.rooms[roomID]\n  return ok\n}\n\nfunc (rm *RoomManager) GetRoom(roomID string) *Room {\n  if !rm.CheckRoom(roomID) {\n    fmt.Println(\"Room with roomID\", roomID, \"does not exist\")\n    return nil\n  }\n\n  return rm.rooms[roomID]\n}\n```\n\n#### 이후 진행 방향\n\n1. 현재 작성중인 포멧의 추가 구현\n2. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 필요성 검토\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":7,"classes":"wide","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","date":"2024-04-09T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-10-Chat Application review(8)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-10-Chat Application review(8).md","category":"개발일지","title":"ChatApplication Review(8)","subtitle":"팀 해체, 모듈 재설계 및 구현, CI 환경 구축","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [팀 해체](#팀-해체)\n  - [Chat 모듈 구현](#chat-모듈-구현)\n    - [Client/Room 로직 재설계 및 구현](#clientroom-로직-재설계-및-구현)\n    - [디버깅 및 테스트](#디버깅-및-테스트)\n  - [API 모듈 구현](#api-모듈-구현)\n    - [API 로직 분리 및 테스트 구현](#api-로직-분리-및-테스트-구현)\n  - [CI 환경 구축](#ci-환경-구축)\n    - [docker-compose](#docker-compose)\n    - [github actions](#github-actions)\n\n---\n\n## 배운 점\n\n1. 혼자서 개발하는 것과 팀으로 개발하는 것의 차이\n2. 잘못된 설계를 재설계하는 방법 및 설계의 중요성\n3. 시스템 구축의 어려움\n4. docker 서비스간 의존성 해소 방법\n5. 문제 발생의 주 원인은 휴먼에러다.\n\n---\n\n## 진행 내용\n\n- 팀 해체\n- Chat 모듈 구현\n- api 모듈 구현\n- CI 환경 구축\n\n---\n\n## 진행 과정\n\n### 팀 해체\n\n- **문제**\n  - 팀원 간의 기술 스택 이해도, 투여 시간 등의 차이로 협업의 장점이 발휘되지 않음\n  - 상대방에게 의존성을 강제한 협업 방식이 참여율이 저조해지면서\n    - code review가 없으면 pull request가 승인 되지 않음\n    - 독립적인 모듈들의 개발의 통합까지 도달하지 못함\n- **해결**\n  - 팀 해체\n- **결과**\n  - 실력과 현재 상황에 맞는 목표 재설정\n  - 개발 속도 향상\n\n결국 해체하기는 했지만, 다른 사람과 협업할 때 그 사람들과 소통하는 방법이나 이를 위해 통합 환경을 구축하는 방법에 대해서 배울 수 있었다. 또한 혼자서 개발을 진행했다면 구체적이고 실현 가능한 목표 설정에는 도달하는데는 지금보다 더 오랜 시간이 걸렸을 것이라 생각한다.\n\n---\n\n### Chat 모듈 구현\n\n#### Client/Room 로직 재설계 및 구현\n\n![image](https://imgur.com/eKEJVT0.jpg)\n\n- **문제**\n  - Client, Room 객체가 너무 많은 역할을 수행하고 있었음\n  - 한 개의 방이 여러 클라이언트를 가지는 구조에 대한 고려가 된 설계가 아니었음\n  - 하나의 client가 연결된 방마다 websocket connection을 가지고 있어야 해서 load가 높음\n\n- **[해결](https://github.com/kaestro/ChatApplication/tree/main/myapp/internal/chat)**\n  - Client, Room의 역할을 분리하는 객체를 추가\n    - clientManager, roomManager: client, room의 관리를 담당. 생성, 삭제, 조회 등의 기능을 제공한다.\n    - clientSession: client에서 room으로의 연결을 담당. client의 메시지를 room에 전달한다.\n    - roomClientHandler: room에서 client로의 연결을 담당. room의 메시지를 client에 전달한다.\n  - 구조 변경\n    - roomManager에서 관리하는 key를 roomName이라는 변수로 고정. 이에 따라 roomId를 삭제\n    - client는 여러 연결을 clientSession으로 관리\n    - room은 여러 연결을 roomClientHandler로 관리\n    - chatManager를 제외한 객체의 메소드는 private으로 변경\n  - client 재설계\n    - client는 websocket을 하나만 가지고, room 별로 chan을 clientSession을 통해 가진다.\n    - 이에 따라 메시지는 단순 byte가 아니라 ChatMessage 구조체로 전달한다.\n    - 이를 위한 ChatMessage 구조체를 정의하고, json으로 marshal/unmarshal하는 함수를 추가한다.\n\n여러 연결을 서로 가져야 하는 m to n 관계에서 중간 객체를 추가하여 관리하는 방법을 배웠다. 이를 통해 client와 room의 역할을 명확히 구분하고, 각 객체의 역할을 명확히 할 수 있었다. 결과적으로 client와 room의 수명을 분리하여 관리할 수 있게 되는 등 코드의 전반적인 유연성과 가독성이 향상되었다.\n\n#### 디버깅 및 테스트\n\n- **문제**\n  - 함수의 파라미터, 반환값의 타입이 겹치는 것이 많아 순서를 틀리는 휴먼 에러가 주 원인이 되었음\n  - 소켓 프로그래밍 프로세스 및 프로토콜에 대한 이해 부족\n  - 설계 이상으로 필요한 하위 모듈이 많아짐\n- **해결 방안**\n  - types, jsonProperties 패키지를 추가하여 타입을 명확히 구분\n  - 이들을 이용한 재구조화 진행 예정.\n  - 모듈의 추가적인 분리 및 통합을 진행하고 테스트 코드를 작성할 예정\n  - 소켓의 handshake와 같은 프로토콜에 대한 이해를 높이기 위한 학습 예정\n\n시스템적으로 사람이 실수할 수 있는 부분을 최소화하기 위한 노력이 많이 필요하고, 이것이 가장 많은 시간을 소요하는 부분이었다. 컴퓨터가 이해하는 코드를 짜는 것은 쉽지만, 사람이 이해하는 코드를 짜는 것은 어렵다.\n\n---\n\n### API 모듈 구현\n\n#### API 로직 분리 및 테스트 구현\n\n![image](https://imgur.com/BJgnieR.jpg)\n\n- **문제**\n  - 기존의 모듈이 handler와 logic이 혼재되어 확장성(테스트, 로직 변경 및 추가)이 떨어짐\n  - 테스트 코드에 대한 규약을 변경하면서 기존의 테스트 코드에 대한 전면적인 수정이 필요함\n\n- **해결**\n  - logic과 handler를 분리\n  - 해당 과정에서 로직을 더 작은 단위로 나누어 작성\n  - handler와 loginc에 대한 테스트 코드 작성\n\nhandler와 service를 분리하는 이유에 대해 이해할 수 있었다. 이를 구분함으로써 handler는 요청을 받아서 응답을 보내는 역할만 하게 되었고, logic은 handler에게 요청을 받아서 데이터를 처리하는 역할만 하게 되었다. 이를 통해 각각의 테스트 코드를 작성하고 신뢰성을 확보하기 용이하고, 유연한 코드 작성을 통해 코드의 확장성을 높일 수 있었다.\n\n### CI 환경 구축\n\n#### docker-compose\n\n```yml\n# docker-compose.yml\nversion: '3'\nservices:\n  postgresql:\n    image: postgres:latest\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_PASSWORD=rootpassword\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgresql_data:/var/lib/postgresql/data\n\n  db_init:\n    build: ./db_init\n    environment:\n      - POSTGRES_PASSWORD=rootpassword\n    depends_on:\n      - postgresql\n\n  redis:\n    image: redis:latest\n    command: redis-server --requirepass redisPassword\n    ports:\n      - \"6379:6379\"\n  \n  chatroom_list:\n    image: redis:latest\n    command: redis-server --requirepass redisPassword\n    ports:\n      - \"6380:6380\"\n\n  mongodb:\n    image: mongo:latest\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongodb_data:/data/db\n  \n  main_server:\n    build: ./myapp\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - postgresql\n      - redis\n      - mongodb\n    environment:\n      - REDIS_ADDR=redis:6379\n      - REDIS_PASSWORD=redisPassword\n      - DB_URL=postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\n      - MONGO_URL=mongodb://mongodb:27017  \n\n  test:\n    build: \n      context: ./myapp\n      dockerfile: Dockerfile.test\n    depends_on:\n      - main_server\n      - postgresql\n      - redis\n      - mongodb\n      - db_init\n    environment:\n      - REDIS_ADDR=redis:6379\n      - REDIS_PASSWORD=redisPassword\n      - DB_URL=postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\n      - MONGO_URL=mongodb://mongodb:27017\n\n\nvolumes:\n  postgresql_data:\n  mongodb_data:\n```\n\n- **문제**\n  - 기존의 테스트 방식은 자동화 돼있지 않았음.\n    - 테스트의 오류가 발생시 로직 상의 문제인지, 환경의 문제인지 판단하기 어려웠음\n    - 테스트를 까먹는 경우가 발생함\n    - 새로운 환경에서 테스트를 진행할 때 환경 구축에 시간이 소요됨\n\n- **해결**\n  - docker-compose를 통한 테스트 환경 구축\n    - 테스트 환경을 [docker-compose](https://github.com/kaestro/ChatApplication/blob/main/docker-compose.yml)로 구축한다\n      - db_init, wait-for-it, wait-for-postgres 등의 서비스를 추가\n    - 테스트 환경을 구축하는 과정을 자동화하여 테스트 환경을 쉽게 구축할 수 있게 함\n\n빌드를 할 경우에, 단순 빌드 뿐 아니라 내부 테스트를 진행하고 오류의 여부에 대해 시스템적으로 확인할 수 있게 됐다. 이를 통해 테스트를 까먹는 경우를 방지하고, 테스트 환경을 구축할 필요가 없어진다. 이를 통해 테스트를 자주 진행할 수 있게 되었고, 테스트를 통해 코드의 신뢰성을 확보할 수 있게 되었다.\n\n#### github actions\n\n```yml\n# .github/workflows/ci.yml\nname: CI\n\non:\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: 1.22\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Build and Test with docker-compose\n      run: |\n        docker-compose run --rm test\n        docker-compose logs test \u003e test.log\n        echo \"exit_code=$?\" \u003e\u003e $GITHUB_ENV\n        docker-compose down\n\n    - name: Upload test log\n      uses: actions/upload-artifact@v2\n      with:\n        name: test-log\n        path: test.log\n\n    - name: Exit with code\n      run: exit ${{ env.exit_code }}\n```\n\n- **문제**\n  - 테스트 결과를 확인하기 위해 로컬에서 테스트를 진행해야 함\n  - 여러 독립적인 모듈을 리모트한 환경에서 테스트하는 것이 불가능해 이를 수동으로 진행해야 함\n  - 테스트가 다른 모듈이 준비가 완료되기 전에 진행되거나, table이 없는 상태에서 테스트가 진행되는 등의 문제가 발생함\n  - github actions 테스트 결과를 확인할 방법이 없었음\n\n- **해결**\n  - github actions를 통한 테스트 자동화\n  - db_init, wait-for-it, wait-for-postgres 등을 통한 테스트 환경이 remote에서도 구축됨\n  - upload-artifact를 통해 테스트 결과를 확인할 수 있음\n\n여러 모듈을 독립적으로 개발한 뒤 통합하는 과정에서 테스트를 자동화 하는 시스템을 구축했다. 또한 docker 내에서 여러 서비스 간의 의존성을 해결하는 방법을 배웠다.\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":8,"classes":"wide","title":"ChatApplication Review(8)","subtitle":"팀 해체, 모듈 재설계 및 구현, CI 환경 구축","date":"2024-04-10T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-12-Chat Application Readme","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-12-Chat Application Readme.md","category":"개발일지","title":"API Server For ChatApplication","subtitle":"","content":"\n## 개요\n\n백엔드 개발에서 요구되는 능력들 중 **실시간 통신, 데이터베이스 및 API 서버 구축, 인증 및 보안** 등의 능력 향상을 목적으로 한 **[채팅 어플리케이션 API 서버](https://github.com/kaestro/chatapplication)**입니다.\n\n기초적인 채팅 메시지 전송 및 수신, 사용자 인증, 사용자 정보 관리에서 시작해, 최종적으로는 대규모 인원의 동시 접속 및 트래픽을 처리할 수 있는 서버를 구축하는 것을 목표로 하고 있습니다.\n\n최신의 테스트가 끝난 형태의 코드는 **main branch**에서, 테스트 진행중인 코드는 **develop branch**, 개발중인 기능은 **feature branch**에서 확인하실 수 있습니다.\n\n---\n\n## 목차\n\n- [개요](#개요)\n- [목차](#목차)\n- [MVP(Mininum Viable Product)](#mvpmininum-viable-product)\n- [기술 스택](#기술-스택)\n- [구조](#구조)\n  - [chat](#chat)\n  - [api](#api)\n  - [db/session](#dbsession)\n- [프로젝트 규칙](#프로젝트-규칙)\n  - [코드 컨벤션](#코드-컨벤션)\n  - [git branch 전략](#git-branch-전략)\n  - [test](#test)\n  - [github actions](#github-actions)\n- [확장 계획](#확장-계획)\n  - [1차 목표](#1차-목표)\n  - [2차 목표](#2차-목표)\n- [인프라 현상황 및 차후 구상](#인프라-현상황-및-차후-구상)\n\n---\n\n## MVP(Mininum Viable Product)\n\n현재 목표로 하는 채팅 프로그램의 가장 **기본적인 기능**은 다음과 같습니다.\n\n```md\n1. 로그인 및 회원가입\n2. 채팅방 생성 및 입장\n3. 채팅 메시지 전송 및 수신\n```\n\n---\n\n## 기술 스택\n\n현재 진행 중인 프로젝트의 기술 스택은 다음과 같습니다.\n\n- 웹서버\n  - goLang\n  - gin framework\n- 데이터베이스\n  - postgresql\n- 세션 관리\n  - redis\n- CI\n  - github actions\n  - docker\n- 형상관리\n  - git\n\n다중 접속자 간의 실시간 통신은 동시에 여러 사용자가 상호작용하는 웹서버를 구축해야하기 때문에, 이를 위해 동시성 처리에 유리한 goLang을 선택했습니다. gin framework는 goLang의 웹 프레임워크 중 사용이 간편하고 속도가 빠르다는 평가가 있어 선택했으며, 그 밖의 기술들은 기존에 제가 사용해 본 적이 있는 것들이거나 배우는 데에 많은 부하가 걸리지 않는 것들 위주로 선택했습니다.\n\n이들을 선택한 자세한 이유는 **[다음 포스트](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/03/19/Chat-Application-5%EC%A3%BC%EC%B0%A8-review.html)**에서 확인하실 수 있습니다.\n\n---\n\n## 구조\n\n진행 중인 프로젝트의 구조는 크게 api, db/session, chat 3가지로 나누어져 있습니다.\n\n```md\nmyapp\n├── api\n│   ├── handler\n│   ├── model\n│   └── service\n├── internal\n│   ├── db\n│   ├── chat\n│   └── session\n├── main.go\n└── go.mod\n```\n\n### chat\n\nchat 모듈은 사용자의 실시간 통신을 위한 내부 로직을 처리하는 중추적인 역할을 합니다. 사용자의 메시지 전송 및 수신, 채팅방의 생성 및 입장 등의 기능을 처리합니다. 구조는 다음과 같습니다.\n\n```md\nchat\n├── chatManager.go\n├── roomManager.go\n├── clientManager.go\n├── room.go\n├── roomClientHandler.go\n├── client.go\n└── clientSession.go\n```\n\n[chatManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/chatManager.go)는 chat 모듈 외부에서 chat 모듈을 사용하기 위한 인터페이스를 제공합니다.\n\n[roomManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/roomManager.go)/[clientManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/clientManager.go)는 room/client의 생성 및 삭제와 같은 기능을 처리합니다.\n\n[room](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/room.go)은 채팅방을 나타내는 구조체로, 채팅방의 정보와 채팅방에 속한 클라이언트들을 관리합니다. 이 때 roomClientHandler를 통해 클라이언트에게 메시지를 전송하는 등의 상호작용을 처리합니다.\n\n[client](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/client.go)는 사용자를 나타내는 구조체로, 사용자의 정보와 사용자의 세션을 관리합니다. 이 때 clientSession을 통해 room에 메시지를 전송하는 등의 상호작용을 처리합니다.\n\n### api\n\n```plaintext\napi\n│\n├───handlers\n│   ├───userHandler\n│   └───chatHandler\n│\n├───service\n│   ├───userService\n│   └───chatService\n│\n└───models\n```\n\napi는 사용자의 http request를 받아 처리하는 역할을 합니다. 사용자의 요청을 받아 처리하는 handler, 데이터베이스와 통신하는 model, 비즈니스 로직을 처리하는 service로 나누어져 있습니다.\n\n작성한 될 api의 종류에는 user의 인증, 채팅방의 생성 및 입장, 채팅 메시지의 전송 및 수신 등이 있습니다.\n\n주로 사용하는 기술 스택은 goLang과 gin framework입니다.\n\n### db/session\n\n![db](/images/chatapplication%20소개/db.png)\n![session](/images/chatapplication%20소개/session.png)\n\ndb와 session은 데이터베이스와 세션을 관리하는 역할을 합니다. 데이터베이스는 사용자의 정보, 채팅방의 정보, 채팅 메시지 등을 저장하고, 세션은 사용자의 로그인 상태를 관리합니다.\n\n데이터베이스는 postgresql을 사용하고, 세션은 redis를 사용합니다. interface로 추상화돼 있어 추후 다른 데이터베이스나 세션 관리 시스템을 사용할 수 있도록 설계했고, factory 패턴을 사용해 데이터베이스와 세션을 생성합니다. 각각의 객체는 싱글톤 패턴을 사용해 객체를 생성하고 관리합니다.\n\n---\n\n## 프로젝트 규칙\n\n프로젝트를 진행하면서 지키고자 하는 규칙은 다음과 같습니다.\n\n### 코드 컨벤션\n\n- goLang의 gofmt 규칙을 따른다\n- single responsibility principle을 따른다\n- 변수명이 하는 역할을 명확하게 반영하도록 한다\n\n### git branch 전략\n\n- main branch는 통합 테스트가 완료된 안정적인 상태를 유지한다\n- develop branch는 feature를 병합해서 테스트 중인 최신 상태를 유지한다.\n- feature branch는 기능별로 나누어 작성한다\n\n### test\n\n- 모든 코드는 unit test를 작성한다\n- 소스 코드의 test코드는 _test.go로 작성한다\n  - ex) chat.go -\u003e chat_test.go\n- 모든 코드는 테스트 통과 후 pull request를 진행한다\n- 테스트는 가능한 자동화한다\n\n### github actions\n\n- develop/main branch에 대해 pull request가 올라오면 자동으로 [다음의 테스트](https://github.com/kaestro/ChatApplication/blob/main/.github/workflows/ci.yml)를 진행한다\n  - docker 빌드\n  - 웹서버 테스트\n\n---\n\n## 확장 계획\n\n### 1차 목표\n\n최소한의 채팅 기능이 구현된 이후에는 채팅 기능은 아니지만, 부가적인 기능들과 최소 기능을 구현하는 과정에서 생긴 의문점과 TODO로 작성하고 넘어간 부분들을 해소하는 것을 목표로 하고 있습니다.\n\n- 부가적인 기능의 예시\n  - 내부 로직 처리의 로그 기능 추가\n  - 로그 기능의 debugging, running mode 추가\n  - 미들웨어를 통한 반복적인 검증 로직 추가\n  - **[github issues](https://github.com/kaestro/ChatApplication/issues)**\n\n- **[의문점 예시](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/Questions.md)**\n  - clientManager/roomManager는 얼마나 오랫동안, 얼마나 많은 client/room를 관리할 수 있는가?\n  - garbage collection을 통해 client/room을 어떻게 관리할 것인가?\n  - key의 충돌 등이 일어나는 예외 사항에 대한 처리는 어떻게 할 것인가?\n\n- **[TODO](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/TODO.md)**\n\n### 2차 목표\n\n1차 목표를 달성한 이후에는 **대규모 인원과 트래픽을 처리**할 수 있는 서버를 구축하는 것을 목표로 하고 있습니다.\n\n**목표**로하고 있는 대규모 인원과 트래픽은 다음과 같이 **정의**했습니다.\n\n```md\n1. 15000명 이상의 동시 접속자 - steam 기준 인기 순위 100위의 동접자\n2. 분당 7000건 이상의 메시지 전송 - 아프리카 TV 기준 채팅방이 감당할 수 없었던 트래픽\n```\n\n이는 **분당 1억건** 이상의 메시지 전송을 처리할 수 있는 서버를 구축해야 한다는 것을 의미합니다. 이를 위해 추가적으로 **도입할 계획이 있는 기술**들은 다음과 같습니다.\n\n```md\n1. message queue\n2. load balancer\n3. nosql\n4. 부하 테스트\n```\n\n이 외에 유틸적인 측면 등에서 추가할 예정인 기능들은 다음 [문서](https://github.com/kaestro/ChatApplication/wiki/%EC%B6%94%ED%9B%84-%EC%B6%94%EA%B0%80-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%B6%80%EB%B6%84%EB%93%A4)를 참고해 주세요.\n\n---\n\n## 인프라 현상황 및 차후 구상\n\n현재 진행 중인 프로젝트의 인프라 구성 및 [설계도](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)는 다음과 같습니다.\n\n![image](https://camo.githubusercontent.com/b0ca2b60dbacab06d3aa600efaec77524fd96b74f9b7059b74288cac6c9ab486/68747470733a2f2f64726976652e676f6f676c652e636f6d2f75633f6578706f72743d646f776e6c6f61642669643d3176483557387a384d6333764a6262384e566b75384f704f687049686e6259477a)\n\n```md\n1. github actions\n2. docker\n3. go web server\n4. postgresql\n5. redis\n```\n\n차후 구상중인 인프라 구성 및 설계도는 다음과 같습니다.\n\n![image](https://github.com/kaestro/ChatApplication/assets/32026095/5d97f107-028d-476d-803e-e64a1f86e078)\n\n```md\n1. load balancer\n2. message queue\n3. nosql\n4. 부하 테스트\n5. cloud server\n```\n\n---\n","layout":"default","recommended":true,"data":{"layout":"default","classes":"wide","title":"API Server For ChatApplication","date":"2024-04-12T00:00:00.000Z","categories":"개발일지","recommended":true,"subtitle":""}},{"postName":"2024-04-15-Chat Application review(9)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-15-Chat Application review(9).md","category":"개발일지","title":"ChatApplication Review(9)","subtitle":"EnterChat 재설계, logging 기능 구현, routes 패키지 추가","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [EnterChat 재설계 및 구현](#enterchat-재설계-및-구현)\n  - [logging 기능 구현](#logging-기능-구현)\n  - [routes 패키지 추가](#routes-패키지-추가)\n  - [chat 테스트 CI에 추가](#chat-테스트-ci에-추가)\n\n---\n\n## 배운 점\n\n1. 혼자서 개발하는 것과 팀으로 개발하는 것의 차이\n2. 잘못된 설계를 재설계하는 방법 및 설계의 중요성\n3. 시스템 구축의 어려움\n4. docker 서비스간 의존성 해소 방법\n5. 문제 발생의 주 원인은 휴먼에러다.\n\n---\n\n## 진행 내용\n\n- EnterChat 재설계 및 구현\n- logging 기능 구현\n- routes 패키지 추가\n- chat 테스트 CI에 추가\n\n---\n\n## 진행 과정\n\n### EnterChat 재설계 및 구현\n\n- **문제**\n  - websocket이 연결되는 방식에 대한 이해 부족에 따른 잘못된 설계\n    - 접속 정보를 request body로 전송\n    - http request로 접속 정보를 전송 후 소켓 연결을 저장해두지 않음\n- **해결**\n  - websocket을 요청할 때 client.do가 아니라 dialer.Dial로 연결해서 connection을 저장\n  - 접속 정보 중 비밀번호를 제외한 정보를 loginSessionInfo라는 새로운 구조체로 전송\n  - 이 때 request body가 아닌 header에 저장\n- **결과**\n  - 채팅 메시지 송수신 확인\n\n### logging 기능 구현\n\n- **문제**\n  - 로그를 print로만 출력하고 있어서 디버깅이 어려움\n  - debug 로그만 남기고 있어, release 버전용 로그 기능이 필요함\n- **해결**\n  - gin의 Logger middleware를 통한 initialization을 구현\n  - 해당 과정에서 logging 패키지 추가\n\n### routes 패키지 추가\n\n- **문제**\n  - routes를 main.go에 직접 작성하고 있어 가독성과 확장성이 떨어짐\n- **해결**\n  - routes 패키지를 추가하여 routes를 분리\n\n### chat 테스트 CI에 추가\n\n- **문제**\n  - 기존에 db와의 연결 혹은 websocket 연결이 필요한 테스트를 CI에 추가하지 않음\n  - 이에 대한 테스트를 수동으로 진행함\n- **해결**\n  - chat 테스트를 CI에 추가\n  - github actions의 로그를 별도의 파일로 저장해서 확인 기능 추가\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":9,"classes":"wide","title":"ChatApplication Review(9)","subtitle":"EnterChat 재설계, logging 기능 구현, routes 패키지 추가","date":"2024-04-15T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-05-06-Chat Application review(10)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-06-Chat Application review(10).md","category":"개발일지","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [grafana k6를 통한 테스트용 client 작성](#grafana-k6를-통한-테스트용-client-작성)\n  - [pre-commit을 통한 코드 품질 관리 도입](#pre-commit을-통한-코드-품질-관리-도입)\n  - [docker를 통한 시스템 구축 시도 및 실패](#docker를-통한-시스템-구축-시도-및-실패)\n\n---\n\n## 배운 점\n\n1. grafana k6의 사용법\n2. 섣부른 시스템 구축의 위험성\n\n---\n\n## 진행 내용\n\n- grafana k6를 통한 테스트용 client 작성\n- pre-commit을 통한 코드 품질 관리 도입\n- docker를 통한 시스템 구축 시도 및 실패\n\n---\n\n## 진행 과정\n\n### grafana k6를 통한 테스트용 client 작성\n\n![테스트 클라이언트](/images/chatapplication%20review/testclient.png)\n\n- javascript, grafana k6를 통해 테스트용 클라이언트 작성\n- httpRequests, loadTest, utils 패키지로 구성\n- 기본 모듈단 작성 완료했으며, 이후에는 테스트 케이스를 작성할 예정\n\n---\n\n### pre-commit을 통한 코드 품질 관리 도입\n\n- **문제**\n  - 완전히 코드가 저장되지 않은 상태로 커밋을 하거나, 코드의 품질이 낮은 상태로 커밋을 하는 경우가 발생\n- **해결**\n  - pre-commit을 통해 코드 품질을 관리하고, 코드가 저장되지 않은 상태로 커밋하는 것을 방지\n- **결과**\n\n![pre-commit](/images/chatapplication%20review/precommit.png)\n\n---\n\n### docker를 통한 시스템 구축 시도 및 실패\n\n- **문제**\n  - docker를 통해 부하 테스트 시스템을 구축하려 했으나, mounting volume이나 복잡한 명령어 사용 등에 어려움을 겪음\n- **해결**\n  - docker를 통한 부하 테스트 시스템 구축 포기 및 로컬 환경에서 진행하기로 결정\n- **결과**\n  - 부하테스트 작성 시작\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":10,"classes":"wide","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","date":"2024-05-06T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-05-16-Chat Application review(11)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-16-Chat Application review(11).md","category":"개발일지","title":"ChatApplication Review(11)","subtitle":"작성중","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [client의 load test debugging](#client의-load-test-debugging)\n    - [signout이 진행이 안되고 있었음](#signout이-진행이-안되고-있었음)\n    - [enterchat 요청이 받아들여지지 않고 있었음](#enterchat-요청이-받아들여지지-않고-있었음)\n\n---\n\n## 배운 점\n\n- 주고받는 데이터 프로토콜 정확성의 중요성\n- 로그를 어느 정도까지 디테일하게 찍어주느냐의 중요성\n\n---\n\n## 진행 내용\n\n- client의 load test debugging\n\n---\n\n## 진행 과정\n\n### client의 load test debugging\n\n1. signout이 진행이 안되고 있었음\n2. enterchat 요청이 받아들여지지 않고 있었음\n\n#### signout이 진행이 안되고 있었음\n\nloadtest에서 header에 value의 key를 sessionkey로 보내고 있었는데 Session-Key가 올바른 키의 이름이었음.\n\n#### enterchat 요청이 받아들여지지 않고 있었음\n\n(진행중)\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":11,"classes":"wide","title":"ChatApplication Review(11)","subtitle":"작성중","date":"2024-05-16T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-21-re 제로부터 시작하는 블로그(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-21-re 제로부터 시작하는 블로그(1).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","content":"\n### 목차\n\n- [나를 드러내기 위해서 라는 세속적인 계기](#나를-드러내기-위해서-라는-세속적인-계기)\n- [그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을](#그-때는-아직-몰랐습니다-남들이-다-하는-데에는-이유가-있다는-것을)\n- [부족하고 모자랐던 흑역사](#부족하고-모자랐던-흑역사)\n- [그래도 남이 봐주니 즐겁고 고마웠던 시간](#그래도-남이-봐주니-즐겁고-고마웠던-시간)\n\n---\n\n## 나를 드러내기 위해서 라는 세속적인 계기\n\n블로그를 다시 시작하게 된 계기는 굉장히 세속적이었습니다. 구직을 하는 초창기에 한 면접관께서 면접 중간에 제게 피드백으로 '이력서가 다른 사람들보다 많이 모자라기 때문에 이를 채우기 위한 노력을 할 필요가 있다, 일단 기술 블로그를 쓰는 것이 좋을 것 같다.'라는 조언을 해주셨기 때문입니다.\n\n저는 운이 좋은 편이라 이력서가 많이 미비한 상태에서도 꽤나 많은 면접을 볼 수 있기는 했지만, 그것이 이력서가 모자라도 괜찮다는 것과는 또 다른 이야기였습니다. 이력서가 모자라다는 것은 제가 어떤 사람인지, 어떤 경험을 가지고 있는지, 어떤 역량을 가지고 있는지를 제대로 보여주지 못한다는 것이기 때문입니다. 이 부분을 채우고 저를 채용 과정에서 더 잘 보여주면서 스스로에 대해 더 잘 알아볼 필요가 있다는 생각을 하게 되어 블로그를 다시 시작하게 되었습니다. 이전의 것을 경험이라고 할 수 있다면 말이죠.\n\n---\n\n## 그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을\n\n블로그를 시작하기 위해서는 일단 여러 플랫폼 중에서 무엇을 고를 지부터 선택해야 했습니다. 최근에 국내 1세대 블로그인 이글루스가 문을 닫는 것을 보고 가능하면 제가 작성한 글들에 대한 소유권을 유지하고 싶다는 생각이 들었고, 동시에 github pages를 이용한 블로그를 하면 깃허브에 글을 쓰는 것만으로도 contribution의 수를 늘릴 수 있기 때문에 굉장히 이득이라는 생각이 들었습니다. 그리고 남들이 주로 쓰는 플랫폼을 벗어나면 힙 해보이지 않을까 하는 망상도 조금 있었습니다.\n\n그러나 그 때는 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 걸 말이죠. github pages를 통한 블로그를 운영한다는 것은 결국 조그마한 웹 서비스를 스스로 운영하는 것과 같기 때문에 내가 거의 모든 통제를 가지고 있지만, 동시에 내가 하지 않은 그 어떤 것도 주어지지 않는다는 것을 말입니다. 그리고 인터넷 상에는 내가 눈치채지 못한 곳에서 생각보다 엄청나게 많은 것들이 바쁘게 동작하고 있다는 사실도 알 수 있었습니다.\n\n---\n\n## 부족하고 모자랐던 흑역사\n\n지금이야 '네가 작가냐, 글 쓸 시간에 코드 좀 짜라'는 말을 듣고 반성할 정도로 활발하게 글을 쓰는 편입니다만, 첫 글을 쓸 때에는 굉장히 막막했던 기억이 납니다. 우선은 무엇을 써야할지도 모르겠고, 무엇을 써야할지 알겠다고 해도 어떻게 써야할지도 모르겠었습니다. 그래서 그냥 블로그를 만들었다는 것을 기념하기 위해 블로그를 만들었다는 글을 쓰는 것으로 시작했지만, 끝나자마자 바로 그 다음 글은 어떻게 써야할 지에 대한 고민이 시작되었습니다.\n\n이 때 제가 도움을 크게 받은 것은 chatgpt였습니다. 아직도 얼추 어떤 질문을 넣었는지 기억이 납니다. '내가 요 근래 이런저런 것들을 공부했는데 이걸 기반으로 기술 블로그를 쓴다면 무슨 주제들을 다루면 좋을까? 그리고 그 주제별로 목차 제시해줘.' 마침 그 때가 의존성 역전에 대해 공부한 시기였고 기술적으로 매력있는 주제라는 생각이 들었기 때문에 그 주제를 기반으로 한 목차를 채우는 것으로 작문을 시작했습니다. 그리고 해당 글을 게재하고 많은 분들의 피드백을 받고 제가 크게 잘못했다는 것을 알 수 있었습니다.\n\n해당 글은 이제 블로그에서 내려두고 피드백을 기반으로 수정한 것이 이 [천원돌파 의존성 역전](https://kaestro.github.io/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2024/02/07/%EC%B2%9C%EC%9B%90%EB%8F%8C%ED%8C%8C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84.html)입니다. 피드백을 받고 많이 고친 것인데도 저 정도이니 원래는 어느 정도였는지 알 수 있으실 겁니다. 하지만 레포지토리 내에는 남겨둔 상태이니 혹시라도 궁금하신 분이면 쓰레기통에 버려진 기밀 문서를 뒤진다는 마음가짐을 가지고 찾아보시면 제 흑역사를 즐기실 수도 있을 겁니다.\n\n---\n\n## 그래도 남이 봐주니 즐겁고 고마웠던 시간\n\n그래도 블로그를 시작하고 남이 글을 읽고 반응을 보여주는 경험은 너무나도 즐겁고 소중하면서도 고마운 순간들이었습니다. 아직도 많이 모자라지만, 그 끔찍했던 글들을 홍차넷과 pgr21이란 커뮤니티에 퍼날랐을 때 이를 읽고 달아주신 댓글들 하나하나 덕분에 여태까지 이 블로그를 그만두지 않고 이어나갈 수 있었습니다. 읽기 불편하고 모자랐던 글들에 힘내라는 응원과 피드백, 잘 읽었다는 칭찬과 격려 모두다 저에게 큰 힘이 되는 소중한 말씀들이었습니다. 그럼 앞으로도 계속해서 글로 이 공간을 채워나가겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","date":"2024-04-21T00:00:00.000Z","categories":"개발일지","published":true,"recommended":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":1}},{"postName":"2024-04-22-re 제로부터 시작하는 블로그(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-22-re 제로부터 시작하는 블로그(2).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","content":"\n### 목차\n\n- [다른 사람과 다른 길을 걷는 용기에 박수를](#다른-사람과-다른-길을-걷는-용기에-박수를)\n- [github pages, jekyll이란](#github-pages-jekyll이란)\n- [기술 블로거는 작가이자, 개발자이다](#기술-블로거는-작가이자-개발자이다)\n- [기술 블로거는 개발자이자, 마케터이다](#기술-블로거는-개발자이자-마케터이다)\n- [마치며](#마치며)\n\n---\n\n## 다른 사람과 다른 길을 걷는 용기에 박수를\n\n'개발자라면 역시 깃허브지!'라는 생각으로 깃허브로 블로그를 시작하기로 결심하신 용감하신 분들께 우선 박수드립니다. 스스로 블로그를 구축하는 것은 많이들 하지 않는 선택이니만큼 쉬운 길이라고는 할 수 없겠지만, 그만큼 할 수 있는 것도 많고 이를 통해 많은 것을 배울 수 있는 개발자로써 한 번쯤 해보면 좋은 경험이라고 생각합니다. 그럼 이제 웹 개발에 대한 지식이라곤 기초적인 api 서버를 구축하는 것 밖에 없었던 제가, github page와 jekyll을 통해 기술 블로그를 운영하면서 겪은 좌충우돌에 대해 잠깐 이야기해보겠습니다.\n\n---\n\n## github pages, jekyll이란\n\n이 둘을 활용하는 자세한 가이드는 [이 페이지](https://pages.github.com/)에서 확인하실 수 있습니다.\n\ngithub pages는 github에서 직접 호스팅을 제공하는 블로그 서비스로 단순히 깃허브 레포지토리에 블로그 정적 파일을 올리기만 하면 이와 관련한 웹페이지와 도메인을 무료로 제공해주는 서비스입니다. 해당 페이지의 빌드와 배포에 관련한 작업은 무려 github에서 직접 만들어둔 workflow인 pages-build-deployment를 통해 관리되며, 본인이 지정해 둔 브랜치를 기반으로 푸시가 일어날 때마다 해당 브랜치의 파일을 빌드하여 배포합니다. 웹 서비스를 경험해 보신 분이라면 이 정도만 해도 충분히 블로그를 운영하는 데에는 문제가 없을 것이며 '생각보다 되게 편리한데? 뭐가 그렇게 힘들었단거야?'라는 생각을 하실 수도 있겠네요.\n\njekyll은 github pages에서 추천하는 정적 사이트 생성기로, 마크다운 파일을 작성되어 있는 layout에 맞는 형태인 HTML로 변환해주는 역할을 합니다. 또한 그 밖에 웹사이트를 만들 때 신경써야 하는 timezone, sitemap, rss feed 등의 기능을 설정만으로도 쉽게 구현할 수 있도록 도와줍니다. 이를 통해 jekyll은 블로그를 운영하는 데 있어 개발보다는 글을 작성하는 데에 많은 시간을 쓸 수 있도록 도움을 줍니다. 또한, jekyll은 liquid라는 템플릿 언어를 사용하여 비교적 간단하게 javascript를 사용하지 않고도 동적인 웹페이지를 만들 수 있으며, 단순히 페이지에 몇 가지 항목을 등록하는 것만으로도 포스트와 관련한 카테고리나 태그, 추천 등의 추가적인 정보를 쉽게 관리할 수 있습니다.\n\n그리고 여기까지가 github pages와 jekyll이 제공하는 모든 것입니다. 사실 저는 이런 것들이 제공되고 있다는 사실도 알지 못하고 블로그가 동작한다는 사실만 인지할 정도로 웹 개발이 모자란 상태에서 운영을 시작했던 데다가, 이 외에도 블로그에 필요한 기능들이 굉장히 많고 유용하다는 것을 깨닫는 과정을 통해 네이버와 같이 여타의 플랫폼에서 제공하는 서비스들이 그만큼 대단하다는 것을 절감할 수 있었습니다.\n\n---\n\n## 기술 블로거는 작가이자, 개발자이다\n\n기술 블로거는 우선은 글을 쓰는 사람이 맞습니다. 하지만 그것은 필요조건일 뿐, 충분 조건은 아닙니다. 말 그대로 깃허브 페이지와 jekyll이 제공하는 것은 글을 작성하면 배포해주고, 이에 필요한 기본적인 포맷인 레이아웃이 끝입니다. 그러면 가장 먼저 시작해야하는 것은 우리에게 너무나 익숙한 웹 사이트의 index 페이지 작성 및 여기에 글이 나열될 수 있는 포스트 페이지를 만드는 것입니다. 즉, 깃허브 페이지로 블로그를 운영하려는 사람은 프론트엔드 개발자가 되어야 합니다.\n\n유명한 블로그 플랫폼인 네이버 블로그를 예시로 들자면 이제 누군가의 네이버 블로그에 들어갔을 때 가장 먼저 맨 위에 글들을 카테고리 별로 나눠주는 메뉴가 놓여있는 것이 대부분입니다. 잠깐, 그런데 내 블로그에 카테고리 별로 나눠주는 버튼은 어디 있죠? 지금부터 만드시면 됩니다. 작성한 글을 읽고 나서 다음 글로 넘어가거나 이전 글로 넘어가는 방법은요? 지금부터 만드시면 됩니다. 댓글은요? 지금부터 만드시면 됩니다.\n\n이처럼 기존에 서비스하던 블로그에서 이미 이러한 수많은 우리가 있는게 너무나도 자연스럽다 생각했던 기능들은 사실 당연한 것이 아니란 것을 깨닫게 되는 첫 순간에는 굉장히 당황스러웠습니다. 그걸 내가 어떻게 해? 그런데 개발자라는 직업의 사람이 모두들 그렇듯, 하다보면 다 된다는 것도 배울 수 있었습니다. 모든걸 제가 만들어야하는 것이 힘들고 괴로운 대신 그만큼 우리가 블로그에 모든 전권을 가지고 있기 때문에, 이런 못생긴 신호등 버튼을 만들어도 아무도 말릴 사람이 없다는 쾌락을 누릴 수 있었던 것은 소소한 재미입니다. 이제는 디자인을 변경했지만요.\n\n![신호등](/images/re%20제로부터%20시작하는%20블로그/신호등.png)\n\n---\n\n## 기술 블로거는 개발자이자, 마케터이다\n\n그렇게 고생해서 다른 블로그들에 있고 나한테 필요한 기능들을 개발해서 글을 쓰는 데까지 오는 데 성공하고 나니 나름대로 뿌듯함을 느낄 수 있습니다. 그런데 이번에는 다른 문제가 있다는 사실을 깨달을 수 있었습니다. 제가 그것을 깨달은 것은 제 블로그 글이나 블로그 자체가  구글이나 네이버 검색엔진을 통해 검색이 되지 않고 있기 때문에, 사실상 제가 작성하고 있는 것은 잘 연결된 인터넷 상에 자리한 것이 아니라 아는 사람만 드나들 수 있는 외딴 섬에 있는 것과 다름이 없다는 사실을 알 수 있었습니다.\n\n아직 구글 검색엔진을 기준으로 가장 먼저 이 부분을 해결하기 위해 제가 조사한 바에 따르면, 구글 검색엔진에 글이 노출이 되기 위해서는 두 가지 해결책을 취할 수 있습니다. 하나는 트래픽이 굉장히 많이 발생하도록 만들어서 구글이 중요한 사이트라고 인식해 검색 엔진에 스스로 등록하게 하는 것입니다. 당연히 이것은 불가능하기 때문에 저는 두 번째 방법을 사용했습니다. 그것은 구글에 직접 이 블로그의 주인임을 증명하고, 구글이 이 블로그를 검색 엔진에 등록하는데 필요한 모든 정보를 제공하는 것입니다. 이것을 [구글 서치 콘솔](https://search.google.com/search-console/about)이라고 합니다.\n\n저는 미련하게도 서치 콘솔에 등록한 이후에 '트래픽이 발생하기만 하면 알아서 잘 되겠지. 글을 쓰고 홍보하기만 하면 어떻게든 될 거야'하는 잘못된 생각을 가지고 일단 글만 쓰다가, 두 달이 넘도록 구글 검색 엔진에 노출이 되지 않아서 문제가 있다 생각해 다시 해결 방법을 찾아 나섰습니다. 그 결과, 구글 검색 엔진에 순수하게 트래픽을 통해 노출되는 것이 아니라 직접 [indexing을 요구](https://support.google.com/webmasters/answer/7440203?hl=ko)하거나 [sitemap을 제출](https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap?hl=ko\u0026visit_id=638493812450328388-2387940056\u0026rd=1)하는 등의 노력을 해야 작은 트래픽이라도 구글 검색 엔진에 노출이 된다는 것을 알 수 있었습니다.\n\n결과적으로 현재 저는 무려 블로그를 시작한 근 세달만에 블로그에 트래픽이 생기기 시작한 사실을 확인할 수 있었습니다.\n\n![디스커버](/images/re%20제로부터%20시작하는%20블로그/디스커버.png)\n![검색결과](/images/re%20제로부터%20시작하는%20블로그/검색%20결과.png)\n\n---\n\n## 마치며\n\n비록 제가 생각한 것보다 기술 블로그를 github pages를 통해 스스로 운영하는 과정은 많은 작업을 요구하는 일이었습니다. 하지만 그 덕분에 제가 알지 못했던 웹과 관련한 많은 기술들을 학습할 수 있었고, 처음으로 사이트에 트래픽이 생긴 날은 굉장히 감격스럽기도 했습니다. 그만큼 블로그를 운영하는 것은 개발자로써 나름대로 힘든 만큼 재미있고 굉장히 많이 자극이 되는 경험이었습니다.\n\n그럼 다음 편에서는 조금 더 구체적으로 블로그를 운영하면서 겪은 일들에 대해 이야기해보겠습니다. 긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","date":"2024-04-22T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":2}},{"postName":"2024-04-23-re 제로부터 시작하는 블로그(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-23-re 제로부터 시작하는 블로그(3).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","content":"\n### 목차\n\n- [개발자의 블로그는 살아서 변화한다](#개발자의-블로그는-살아서-변화한다)\n- [사람들의 눈을 끌기 위한 노력](#사람들의-눈을-끌기-위한-노력)\n- [ui이 바뀌면 컨텐츠도 변화한다](#ui이-바뀌면-컨텐츠도-변화한다)\n- [심심할 틈이 없었던 3개월](#심심할-틈이-없었던-3개월)\n\n---\n\n## 개발자의 블로그는 살아서 변화한다\n\n개발자의 블로그란 것은 굳이 말하자면 디자이너와 작가가 개발자에게 직통 연결을 상시 가지고 있는 서비스와도 같다고 말할 수 있습니다. 글을 쓰다가 다음 포스트로 넘어가기 기능이 있으면 좋겠다는 생각이 들면 이를 바로 만들어 주고, 글이 몇 개 없을 때는 일렬로 늘어놓다가 글이 많아지면 카테고리로 분류하고 싶어지는 등의 변화의 요구가 즉각적으로 반영되기 때문입니다.\n\n다음은 제 블로그의 변천사 사진 몇 장입니다.\n\n|![image](/images/re%20제로부터%20시작하는%20블로그/before_grid_colorful.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_before_grid.png)|\n|---|---|\n|![image](/images/re%20제로부터%20시작하는%20블로그/front_without_recommend.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_recent.png)|\n\n처음에는 단순하게 흰 화면에 일렬로 글을 늘어놓았다가, 여백이 신경쓰여 그라데이션을 넣어보고, 숱한 항의(?) 끝에 이를 삭제하고, 가운데를 그림자 처리를 통해 종이가 놓인 것 같은 이미지에 카테고리 버튼을 넣은 뒤에, 끝내는 격자 형태로 글을 나열하고, 추천글 항목을 추가한 뒤에 최근 글을 보여주는 것으로 마무리되었습니다. 이처럼 자신에게 전권이 주어진 개발자의 블로그는 끊임없이 변화하고 발전하는 생명체와 같다고 생각합니다.\n\n---\n\n## 사람들의 눈을 끌기 위한 노력\n\n녹조라떼 급의 안구 테러 수준이었던 제 최초의 블로그 디자인이 제가 장난 친 것으로 보일 수도 있지만, 제 나름대로는 어떻게 하면 들어온 사람이 제가 작성한 컨텐츠에 집중할 수 있을까를 고민해서 나온 결과입니다. 해당 디자인을 한 것은 마케팅 관련한 책 중에서 '좋아 보이는 것들의 비밀'이라는 것을 읽고 나서 하게 된 결정이었습니다. 해당 책에서는 색상과 빛의 밝기, 각도와 같은 것을 활용해서 좋아 '보이는' 것을 통해 사람의 시선을 끌 것을 이야기하고 있었고 그 관점에서 봤을 때 저기에 표현돼있지 않은 제 블로그 더 이전의 형태는 너무 단조로웠기 때문입니다.\n\n'사람의 시선을 가운데로 유도하기 위해서는 어떻게 빛을 배치하면 될까?'라는 고민에서 시작해 제 블로그 전체 테마인 초록색 그라데이션에 억지로 맞추려다보니 나왔던 저 끔찍한 디자인은 주변 분의 꾸짖음과 함께 그림자를 이용해서 종이가 가운데에 올라온 것 같은 심플한 디자인으로 변경됐습니다.\n\n그리고 여기에 더해 글의 카테고리가 4개를 넘어가면서부터 한 줄로는 사람들이 읽고 싶은 글을 찾기 어려워지는 문제가 발생했기 때문에, 이를 해결하기 위해 격자 패턴 배열을 자주 사용하는 커뮤니티(pgr21, 홍차넷 등) 것들을 참조해서 추가하고, 여기에 더해 추천 글 항목과 최신글을 보여주는 기능을 더해서 홈 페이지를 지금의 모습으로 만들었습니다.\n\n---\n\n## ui이 바뀌면 컨텐츠도 변화한다\n\n이렇게 새로운 기능을 추가하면 재밌는 것은, 제가 쓰는 글 역시도 이에 맞춰서 변화한다는 것입니다. 예를 들어 제가 가장 크게 글쓰기에 변화가 생긴 시점은 화면에 맞추어 이동하는 목차 기능을 추가한 이후였습니다.\n\n|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/before_toc.PNG?raw=true)|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/after_toc.PNG?raw=true)|\n\n해당 기능은 장문의 글을 작성한 것을 제가 면접 전에 복기하는 과정에서 원하는 구간으로 넘어다닐 수 있는 기능이 있으면 글을 읽기에 편리할 것 같다는 생각에서 추가한 것이었습니다. 헤더로 소제목들을 작성해두면 이를 목차로 자동 생성해주는 해당 기능을 만든 이후와 이전에 쓴 글을 비교하면 이후의 글들은 훨씬 더 명확하게 구조화 되어 되는 것을 확인할 수 있었습니다. 이는 그런 기능에 적합한 글이 되게끔 제가 글을 쓸 때 의식하게 되기 때문이라고 생각하고 덕분에 블로그를 막 시작했을 때보다는 조금은 덜 부끄러운 글들을 쓸 수 있게 되지 않았나 생각합니다.\n\n---\n\n## 심심할 틈이 없었던 3개월\n\n절대 쉬운 일이었다고 말하기는 힘듭니다만, 굳이 말하자면 지난 세 달 동안 기술 블로그를 운영한 경험은 자영업자로 비유할 수 있을 것 같습니다. 무료로 웹 호스팅을 해주는 서비스 하나만 가지고 글을 쓰고, 이를 보기 쉽고 가능한 예쁘게(이게 제 최선 맞습니다) 디자인하고, 이를 남들이 보게 만들기 위해 모든 방법을 동원해야 하는 경험을 할 수 있었기 때문입니다.\n\n이 때문에 지난 3개월 동안 블로그를 운영하면서 단 한 순간도 심심할 일은 없었네요. 글을 쓰다보면 새로운 기능을 만들고 싶어지고, 새로운 기능을 만들면 이를 글로 쓰고 싶어지고, 그 글을 쓰면 이를 남들에게 알리고 싶어지는 등의 선순환이 꾸준히 이루어지다보니 어느 새 제 블로그도 곧 100개의 포스트를 채울 날이 얼마 남지 않았습니다.\n\n본인이 한번쯤 스스로 개발한 서비스를 운영하는 경험을 해보고 싶은데 방법을 잘 모르신다면, 깃허브 페이지와 jekyll을 이용한 기술 블로그 운영을 추천드립니다. 그것은 분명히 개발자로써의 인생에 웃으면서 추억할만한 제 신호등 같은 경험 하나쯤은 남겨줄 것이라 생각합니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","date":"2024-04-23T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":3}},{"postName":"2024-02-09-독후감","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-02-09-독후감.md","category":"서평","title":"최근에 읽은 책들","subtitle":"","content":"\n1. 프로그래밍 면접, 이렇게 준비한다 - 존 몽건, 노아 킨들러, 에릭 기게리.\n2. 비전공이지만 개발자로 먹고 삽니다. - 반병현\n3. 실용주의 프로그래머 - 데이비드 토머스, 앤드류 헌트\n4. 한 권으로 읽는 컴퓨터 구조와 프로그래밍 - 조너선 스타인하트\n\n---\n\n## 프로그래밍 면접, 이렇게 준비한다\n\n책 제목대로 프로그래머로 구직을 목표로 할 때 어떻게 준비해야 하는지를 중점으로 다룬 책입니다. 구매 자체는 19년도에 했었는데, 당시에는 워낙 두꺼워서 읽다가 포기했었다가 이제 와서야 다 읽게 됐네요.\n\n책 구성은 크게 3단계로 나뉩니다.\n\n* 1단계: 구직을 진행하는 프로세스는 어떻게 되는가\n* 2단계: 기초적인 컴퓨터 공학적인 지식\n* 3단계: 비공학적인 면접에서 나올법한 질문들\n\n컴퓨터 공학적인 부분은 너무 지엽적이거나, 가벼운 지식만을 다룰 때가 많아서 조금은 아쉬웠습니다. 하지만, 1단계의 구직을 진행하는 프로세스에 대한 설명은 이번 구직 과정에서 많은 도움을 받았습니다. 기존에 제가 생각하지 못했던 것들이라 참고할 만한 것들이 꽤 많았거든요.\n\n대표적으로 chapter1의 제목은 '구직을 시작하기 전에'이고, 첫 소챕터는 '너 자신을 알라'로 시작합니다. 내가 어떤 성향을 가진 사람이고, 그걸 기반으로 어떤 회사에서 어떤 업무를 할 때 성취를 이룰 수 있을 지에 대해 생각해보란 이야기입니다. 해당 과정을 통해 저는 이번 구직 과정에서 지난 번과는 꽤나 다른 경험을 할 수 있었습니다.\n\n19년도에 제가 회사를 입사하려던 과정은 구직이 아니라 취직에 가까웠다 생각합니다. 일단 대학은 졸업했고, 다들 돈을 벌어야하는데 나온 대학 이름 값이 있고 주변은 어느 정도 사회적인 위치에 있는 곳들을 다니니 그정도는 가야지. 근데 그 곳을 가려면 나는 어떤 능력을 길러야하지? 그 곳에서는 어떤 사람을 원할까? 이것을 위주로 생각했습니다. 일터를 구하는 기준이 '나'가 아니라 '직장'이었던 것이죠.\n\n그러다보니 갈 만한 곳이라고 몇 곳을 정해놓고, 그곳에 어울리는 고등학교 때 입시 생각하듯이 준비를 꽤나 오래 했습니다. 당장 내가 무엇을 하고 싶은지 생각하는 것을 미룬 채, 알고리즘 문제들을 여럿 풀고 면접에 나올 법한 컴퓨터 공학 지식을 달달 외웠습니다. 그리고 컴투스에 입사해서 1년 반을 조금 못 다닌 뒤 퇴사했습니다.\n\n컴투스도 좋은 회사이고 소중한 인연들을 만났지만, 제 성향과 맞는 회사는 아니었다고 생각해 그만두게 되었던 것을 보면 제게 가장 먼저 했어야 할 질문이 바로 옆에 있단 것을 이제서야 깨달았습니다. 나는 어떤 사람이지?\n\n그래서 이번 구직 과정에서는 잘 모르는 회사들에 굉장히 많이 지원했고, 이야기를 나누는 과정에서 자신을 되돌아보는 경험을 쌓을 수 있었습니다. 그러니까 이전처럼 면접을 보는 것이 단순하게 그 회사에 들어가는데 성공/실패하는 것이 아니라 나 자신이 발전하는 과정으로 이해가 돼서 지금은 어느 정도는 즐기는 중 입니다.\n\n직장은 한 번 정하게 되면 일상의 굉장히 많은 부분을 차지하는 만큼, 앞서서 남이 생각하는 좋은 직장에 맞추려고 노력하는 것보다 나에게 맞는 곳을 찾으려고 노력하는 것이 굉장히 중요하단 것을 알게 해 준 책이었습니다.\n\n물론 그것 외에 컴퓨터 공학적으로 가볍게 훑어보기에 나쁘지 않은 책입니다. 기본적인 자료구조, 알고리즘, 병렬 처리 등에 대해 다뤄주거든요.\n\n---\n\n## 비전공이지만, 개발자로 먹고 삽니다\n\n그럼에도 첫 책에서 컴퓨터 공학적인 부분이 아쉬웠다고 많이 느껴져서, 면접을 준비하려면 좀 더 공부해 보는 것이 낫지 않겠냐는 생각에 읽게 된 책입니다. 그렇다고 막상 본격적인 책을 읽기에는 겁나서 제목에서 뭔가 만만해 보이는 책을 집었던 것도 있습니다.\n\n제목에서 드러나듯이, 이 분야에 경험이 있는 사람이 독자아니라 요즘 이게 핫하다던데 뭐하는거야?라는 사람들에게 '야, 너도 할 수 있어'라는 이야기를 하는 책에 가까웠습니다.\n\n이런 이야기를 하는 많은 다른 책들과는 다르게, 이 책은 본인이 가지고 있는 특성에 따라 이런 분야의 개발자를 지망하는 것이 좋다는 이야기를 해 준 부분이 꽤 재밌고 도움이 됐습니다. 마침 또 제가 이것에 관심이 있었던 시점이니까요.\n\n공학적 지식 부분에서는 크게 도움이 되진 않았습니다.\n\n---\n\n## 실용주의 프로그래머\n\n꽤나 유명한, 개발 서적의 소위 고전으로 불리는 책입니다. 마침 20주년 판이 나온지 얼마 안 됐고 읽으신 분께서 추천을 해주셔서 집어들게 됐습니다.\n\n전반적으로는 프로그래밍에 관해 저자가 얻은 지혜를 가벼우면서도 동시에 심도있게 전달하려고 노력을 굉장히 많이했다는 인상을 받았습니다. 또 글의 표현이 굉장히 재미있고 전달력이 좋았습니다. 목차 제목만 봐도 '고양이가 내 소스 코드를 삼켰어요' 같은 표현이 나오기도 하니까요.\n\n내용은 이제 개발에서 신경써야하는 테크닉, 디자인 들에 대해서도 이야기를 많이 합니다만, 저는 그보다 개발자가 흔히 하는 실수나 잘못된 마음 가짐 같은 내용들이 더 인상 깊었습니다. 아마 그 근간에는 제가 저런 지식들을 온전히 흡수할 수 있는 경험적 기반이 덜 쌓여서 그런 것도 있겠지만요.\n\n이 책은 전반적으로 내용을 큰 주제로 나눈 뒤, 이를 다시 여러 소주제로 나누고, 이를 줄글로 설명하는 것을 통해 다룹니다. 하지만, 여기에 **관련 항목**을 달아 여러 주제들을 통합적으로 이해하길 추천하고 **도전해볼 것**을 제시해서 해당 주제를 깊게 탐구해보기를 요구합니다. 이 때문에 가볍게 아이디어만 얻기에도 충분히 좋은 책이었습니다만, 이 책을 제대로 이해하려면 시간이 지나 경험을 쌓고 각각의 주제를 음미해야겠다는 생각이 들더군요.\n\n다 읽기는 했습니다만, 나중에 시간을 내서 다시 읽어보려 합니다.\n\n---\n\n## 한 권으로 읽는 컴퓨터 구조와 프로그래밍 - 조너선 스타인하트\n\n사실 이 책을 굉장히 많은 분들께서 추천을 하시던데, 펼쳐보고 깨달았습니다. '왜 내 눈앞에 전공서적이 있는거지...?'\n\n비트나 논리 연산 같은 것들을 다루는 이야기들을 보는 것은 학부를 졸업한 이후로도 가끔 보긴 했습니다. 그런데 하드웨어 적인 이야기를 진공관, 트랜지스터 단위부터 시작해서 이야기하는 책은 학부 때 컴퓨터 구조론 수업을 들은 이후로는 처음 본 것 같습니다. 물론 학부 전공 서적만큼 자세하게 다루진 않습니다만... 이거 읽으라고 낸 것 맞나?라는 생각이 들더군요\n\n그래도 오랜만에 이전에 공부했던 이야기들을 훑으면서, PC(Programming Counter)나 스택, 메모리 등을 하드웨어적인 부분을 통합해서 이야기 해 주는 책을 읽을 수 있었습니다. 물론 읽다가 머리 아파서 적당히 스킵한 내용이 훨씬 많았단 것은 비밀입니다만, 오랜만에 예전 지식들을 떠올리는 과정은 꽤나 즐거웠습니다.\n\n사실 대학원 진학을 고민하던 시절에는 이쪽 분야가 너무 멋있다 생각을 했었던 만큼, 언젠가는 이 책이 아니라 제대로 된 전공 서적도 한 번 봐볼까도 싶긴 합니다. 이 책에서 어려운 내용을 좀 넘긴 부분은 당장 면접에서 크게 도움이 안 된다는 현실적인 이유도 있었습니다만, 짧은(?) 책에 너무 많은 이야기를 담으려다 보니까 디테일이 아쉬워서 결국은 이해하기 위해서는 이것 만으로는 모자라다는 생각이 들더군요.\n\n---\n\n현재는 **프로그래머의 뇌**라는 책을 읽고 있는데, 요 근래 가장 고민이었던 코드를 읽고 새로운 것을 배우는 방법론에 대해 이야기해줘서 굉장히 흥미롭습니다. 이 책에서 지금 다루는 내용은 코드를 단순히 많이 읽는 것보다는 이를 구조화할 수 있는 개념적인 지식을 많이 가지고 있고, 글을 자신의 방식으로 해석해내는 능력을 가져야 이제 코드를 읽고 쓰는 능력이 향상된다 하고 있습니다. 마침 제가 지금 하고 있는 부분인 것 같아 '잘 하고 있어!'라고 칭찬해주는 것 같아 읽는 것일 수도 있겠네요.\n\n이후에도 쉬지않고 좋은 책을 읽도록 노력해보겠습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"최근에 읽은 책들","date":"2024-02-09T00:00:00.000Z","categories":"서평","subtitle":""}},{"postName":"2024-02-20-프로그래머의 뇌","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-02-20-프로그래머의 뇌.md","category":"서평","title":"프로그래머의 뇌","subtitle":"중요한 것은 인지적 부하","content":"\n## 출판사 및 저자\n\n* 저자: 펠리너 헤르만스\n* 출판사: jpub\n\n---\n\n## 책 소개\n\n이 책은 주로 뇌과학, 인지적인 측면에서 프로그래머가 어떻게 하면 프로그램을 더 잘 작성할 수 있는지에 대해 이야기하는 책입니다. 크게 나눈다면\n\n1. 코드를 더 잘 읽는 방법\n2. 코드를 더 잘 생각해보는 방법\n3. 좋은 코드를 작성하는 방법\n4. 협업을 하는 방법\n\n이렇게 네 가지 구성으로 나뉘어져 있습니다.\n\n이 책이 방법론적인 측면에서 제시하는 다양한 방법론 역시도 매우 흥미롭긴 합니다. 새로운 언어를 공부할 때 플래시 카드를 사용해라, 변수들에 원을 치고 이것들이 어디에서 불려지는지를 이어가면서 확인해라, 변수들이 무슨 뜻을 가지는 지를 정리해서 작성해봐라.\n\n하지만 이 이야기들을 다 모아서 책에서 이야기하는 가장 핵심이 무엇이냐에 대해 제가 정리하자면 다음과 같이 요약할 수 있을 것 같습니다.\n\n## \"프로그래밍이란 글을 읽고 쓰는 과정이고, 이를 효과적으로 하기 위해서는 인지적 부하를 줄여야 한다.\"\n\n이런 것 때문에 연구를 통해 확인한 좋은 프로그래머의 자질은 수학적인 능력과는 전혀 상관이 없었고, 오히려 글을 읽고 쓰는 능력만이 유일하게 상관이 높았다고 합니다.\n\n여기서 말하는 인지적 부하란 여러가지가 있을 수 있습니다.\n\n문법에 대한 이해가 얼마나 있느냐일수도 있고,\n\n변수명 자체가 실제 프로그램의 동작을 이해하는데 얼마나 도움이 되느냐일 수도 있고,\n\n주석이 프로그램 전반에 대한 추상적인 개념 및 작성에 대한 이유를 나타내느냐일 수도 있고,\n\n프로그램이 자주 쓰이는 디자인 패턴을 사용하느냐일수도 있고,\n\n때로는 camelCase를 사용하느냐, snake_case를 사용하느냐에 대한 선택이 인지적 부하에 영향을 미칠 수도 있습니다.\n(별개로 camelCase가 인지적 부하가 더 낮다는 것이 통계적으로 밝혀졌다 합니다.)\n\n이 책을 읽고 나서 코드를 작성하는 데 있어 내가 작성한 코드에서 인지적 부하를 줄일 수 있는 방법이 무엇인지에 대해 요즘 많이 고민하게 되었습니다. 대표적으로는 변수명을 작성할 때, 변수가 해당 객체의 행동을 제대로 나타내지 못한다는 생각이 들면 이를 좀 더 명확하게 나타내도록 노력하고 있습니다. 이는 확실히 이해하지 못했던 코드를 이해하는 데 많은 도움이 되고 있습니다.\n\n1. 약자가 흔하게 사용되는 경우가 아니면 약자를 사용하지 않는다.\n2. camelCase \u003e snake_case\n와 같은 원칙들은 꽤나 유용하게 사용하고 있습니다.\n\n이와는 별개로 또 프로그래밍의 개념적인 지식을 습득하려고 노력하고 있습니다. 대표적으로 현재 하고 있는 디자인 패턴 공부가 그것입니다. 이를 통해 이전에는 코드가 동작하는 것을 확인하고 나서 이해한 뒤에 코드를 작성할 수 있었던 반면, 이건 xx 패턴이니까 무슨 용도로 쓰이겠구나 하는 LTM을 통해 프로그램을 더 잘 이해할 수 있게 됐습니다. 가능하면 앞으로도 많은 글을 읽어가며 개념을 습득하려 합니다.\n\n해당 책에서 사람들이 많이하는 착각으로 제시하는 것이 이제 **직접 코드 작성하기**입니다. 그러는 것보다는 어떻게 코드를 작성하는 지에 대한 **예시를 제공하고 이를 훈련**하는 것이 최초의 인지적인 부하가 적기 때문에 학습의 속도나 질적인 모든 면에서 우수하다고 합니다. 이와 마찬가지인 것이 남이 작성한 **코드를 읽는 것**이지요. 이는 요즘에 copilot을 통해 일단 코드를 따라 작성해보고, 원리에 대한 해설을 듣다보니 학습의 속도가 빨라지는 것과 일맥상통한다 생각합니다.\n\n또 신경쓰는 것은 뭔가를 배울 때 **추상적 =\u003e 구체적 =\u003e 추상적** 설명을 통해 내용을 갈무리하는 것입니다. 실제로 요 근래 제가 작성하고 있는 모든 디자인 패턴 글은 이런 형태를 따르고 있습니다. 개요/요약을 통한 추상화 =\u003e 실제 사례를 통한 구체화 =\u003e 결론 요약을 통한 추상화.\n\n디자인 패턴이나 아키텍처 관점이 아니라, 인지과학 측면에서 프로그래머의 생산성을 높이기 위한 고민에 대한 내용이 꽤나 흥미롭고 배울 점이 많은 책이었습니다. 나중에 한 번 더 읽어보고 싶기도 하네요.\n\n다음에 리뷰하게 될 책은 아마 소프트 스킬이 되지 않을까 싶습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"프로그래머의 뇌","subtitle":"중요한 것은 인지적 부하","date":"2024-02-20T00:00:00.000Z","categories":"서평"}},{"postName":"2024-02-22-소프트 스킬","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-02-22-소프트 스킬.md","category":"서평","title":"소프트 스킬","subtitle":"본인을 판매하는 마케터가 돼라","content":"\n## 출판사 및 저자\n\n* 저자: 존 소메즈\n* 출판사: 길벗\n\n---\n\n## 책 소개\n\n개발자들을 위한 책은 일반적으로 개발 기술에 대해 다루는 데 반해, 이 책은 그 외의 것들을 다룹니다. 목차의 다음 7가지 항목을 보면 그 차이를 명백하게 확인할 수 있습니다.\n\n1. 경력\n2. 셀프 마케팅\n3. 학습\n4. 생산성\n5. 재무관리\n6. 건강\n7. 마인드셋\n\n이 중에서 학습부터 마인드셋까지의 뒷 부분들은 무난한 자기계발서의 성향이 강해, 어디서 봤다는 생각이 들만한 내용들이 많았습니다. 큰 일을 작게 쪼개라, 운동을 해라, 긍정적으로 사고해라. 그리고 본인이 이른 나이에 은퇴해서 프리랜서로 근무하게 된 방법에 대한 소개에 대한 내용들이 주를 이룹니다. 저자가 이야기하는 삶의 형태가 저에게 와닿지는 않았지만, 한 번 이런 삶을 사는 사람은 어떻게 그것에 도달했는지 알아보는 기회가 될 수 있었습니다.\n\n저자의 삶의 형태가 제 이상향과 다름에도, 앞의 경력과 셀프 마케팅 부분은 굉장히 인상 깊었습니다. 단순히 컴퓨터 공학적인 지식을 쌓고, 이를 토대로 프로그래밍을 잘하는 사람이라면 충분히 성공할 수 있다고 생각했던 저에게 이 책은 그렇지 않다고 이야기했기 때문입니다.\n\n이 책은 단순히 실력을 쌓는것에서 벗어나 꾸준히 다른 사람들에게 자신을 마케팅하고, 발전해나가는 방식에 대해서 제시합니다. 여기서 제안하는 마케팅 방법에는 다른 사람의 블로그에 댓글을 쓰고, 직접 블로그를 작성하고, 유튜브를 만드는 등의 방법 등 입니다. 여기에 더해 멘토링을 하고 강연을 하거나 책을 쓰는 것은 더 좋다고 이야기합니다.\n\n최근에 다시 구직을 시작하면서 제 기술적인 역량이 부족한 것도 사실이지만, 그것조차 제대로 다른 사람에게 전달하지 못하고 있음을 많이 느꼈습니다. 단순한 취미 활동에서 그치기 위한 공부가 아니기 때문에 본인을 판매하는 장사꾼으로써 스스로를 더 매력있게 갈고 닦는 것을 신경쓰지 않은 것은 제 잘못입니다. 음식이 맛있다고 해서 식당이 장사가 잘 되는 것은 아니듯이, 제가 잘하는 일을 다른 사람에게 전달하지 못하면 그것은 아무런 가치가 없을테니까요.\n\n그나마 다행인 것은, 개발자는 아무래도 일반적인 사람들보다 웹을 깊게 탐구하게 되는 경우가 많아 스스로를 남에게 홍보하기 쉬운 환경에 있다는 점입니다. 지금부터라도 여태 하고 있는 블로그나 깃허브에 토이 프로젝트를 작성하는 것과 같은 노력을 꾸준히 하면(책에서 이야기한 1년 정도라는 오랜 세월을 감내하면서) 보답을 받을 수 있지 않을까 기원해봅니다. 또 지금은 단순히 책을 읽고 기술을 정리하거나 쉬운 단계의 토이 프로젝트를 작성하고 있지만, 언젠가는 더 나아가 오픈 소스 프로젝트에 기여할 기회같은 것이 오면 재밌고 유익할 것 같네요.\n\n이전에 단순히 개발실력만을 키우려고 하던 것에서 벗어나 어떻게하면 좋은 개발자가 될 수 있는지에 대해 고민해 볼 수 있었던 신선한 시선을 제공해 준 책이었습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"소프트 스킬","subtitle":"본인을 판매하는 마케터가 돼라","date":"2024-02-22T00:00:00.000Z","categories":"서평"}},{"postName":"2024-02-27-함께 자라기","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-02-27-함께 자라기.md","category":"서평","title":"함께 자라기","subtitle":"애자일로 가는 길","content":"\n## 출판사 및 저자\n\n* 저자: 김창준\n* 출판사: 인사이트\n\n---\n\n## 책 소개\n\n본 책은 애자일 컨설팅 대표인 김창준님이 애자일에 대해 두 가지 키워드로 이야기하는 책입니다. 그것은 **함께**와 **자라기**입니다. 요약하자면 목표가 불확실한 복잡한 문제를 해결해야 하는 상황에 있을때, 이를 대처하기 위한 방법으로 협력과 학습을 하는 것이 애자일이라 말하고 있습니다.\n\n소프트웨어 개발자로써 맞이하게 되는 문제들은 대부분 목표가 불확실하고 복잡하며, 이 때문에 해결 방법이 명확하게 제시되지 않는 편입니다. 이런 상황에서 이 책에서 제시하는 방법론은 매우 도움이 될 것이라는 생각을 하게 됐습니다. 저자 스스로가 통계적으로, 그리고 다른 회사들에 컨설팅을 하는 과정에서 방법론을 적용했을 때 얻은 성과들에 대해서 제시하고 있기 때문입니다.\n\n이 책에서 제시하는 학습과 협력의 방법론은 다음과 같습니다.\n\n```md\n* 학습을 할 때 난이도 높이고/낮추기\n* 자신이 한 일에 대한 기록과 피드백\n* 자신의 작업을 회고/반성하는 프로세스를 개선하는 프로세스를 만들기\n* 피드백 주기 줄이기\n* 쉬운 문제부터 해결하기\n* 전문가에게 문제 해결하는 방법이 아닌 구체적 사례 듣기\n* 협업시에 복수 공유(해결 방법으로 여러 결과물을 준비한 뒤 공유)\n* 다른 시각을 가진 두 사람이 협력하기\n* 일을 나눠서 하지 않고 함께 하기\n```\n\n이 책은 단순히 소프트웨어를 팀으로 더 잘 만들기 위한 방법론을 제시하는 것이 아니라, 개인이 어떻게 성장해서 좋은 사람이 될 수 있는지에 대한 좋은 방법을 제시해줍니다. 그리고 가장 좋은 소프트웨어를 만드는 방법은 본인 스스로가 꾸준히 발전해나가는 함께 일하기 좋은 사람이 되는 것이라고 이야기합니다.\n\n최근에 저는 개발의 기술적인 측면에서 공부를 많이 하고 있었습니다. 디자인 패턴, 가독성이 좋은 코드, 확장성 있는 코드 등을 어떻게 하면 잘 활용할 수 있는지에 대한 것들을 말입니다. 그러나 이 책을 읽고 나서는 현재 제게 가장 모자란 것은 다른 사람과 함께 자라는 것이라는 생각을 하게 됐습니다.\n\n이 책을 다 읽고 나서, 아는 친구들에게 현재 제가 혼자 진행 중이었던 toy project를 같이 하자고 도움을 요청했습니다. 이것을 같이 하게 되진 않을 것 같지만 코드 리뷰를 해 줄 생각이 있다는 친구도 있었고, 본인이 진행 중인 것을 같이 해보는 것이 어떠냐는 제안도 받을 수 있었습니다. 의도치는 않았지만 이렇게 대화하는 경험을 통해 혼자서는 해결하기 어려운 문제를 도움 받을 수도 있었습니다.\n\n복잡한 문제를 해결하는 데에 있어서 나는 어떤 마음가짐을 가져야 하는가에 대해서, 무엇보다 스스로가 어떤 사람이느냐가 해결에 가장 중요하단 이야기를 해주는 좋은 책이었습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"함께 자라기","subtitle":"애자일로 가는 길","date":"2024-02-27T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-01-HeadFirstDesignPattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-01-HeadFirstDesignPattern.md","category":"서평","title":"헤드 퍼스트 디자인 패턴","subtitle":"이렇게 코드를 짜면 장점이 뭔가요?","content":"\n## 출판사 및 저자\n\n* 저자: 에릭 프리먼, 엘리자베스 프리먼, 케이시 시에라, 버트 베이츠\n* 옮긴이: 서환수\n* 출판사: 한빛 미디어, O'Reilly\n\n---\n\n## 책 소개\n\nGoF의 디자인 패턴 중에 14가지를 정리해 놓은 책입니다. 많은 사람들이 디자인 패턴에 대해 한 책만 본다면 이 책을 보라는 추천사가 많았는데, 읽고 나니 왜 그런지에 대해 알 수 있을 것 같습니다.\n\n이 책은 실제로 프로그래머로써 접할 수 있을 법한 문제 상황을 먼저 제시하고, 이를 해결해 나가는 과정에서 실제로 겪을 수 있는 trial and error의 과정을 보여준 뒤, 디자인 패턴을 적용하면 간지러웠던 부분이 해소해된다는 것을 보여줍니다. 이를 통해 '이래서 디자인 패턴을 활용하면 좋다'라는 것을 보여줘서 이해하기 쉽고 재미있게 읽을 수 있었습니다.\n\n프로그램을 작성하다보면 비슷한 문제를 맞닥뜨리게 되는 경우가 자주 있습니다. 이 때에 작성하고 있는 코드들을 다른 사람들 같은 경우에는 어떻게 해결하는게 효율적이라 생각하는 모음이 디자인 패턴입니다. 바둑에서 소위 정석과 비슷하다고 할 수 있습니다.\n\n제가 따로 요 근래 각각의 패턴을 따라서 정리해 둔 포스트들에서 디테일을 확인할 수 있지만, 이런 디자인 패턴을 알고서 문제를 풀 때 제가 어떤 기준을 통해서 코드를 이렇게 짰다라는 근거를 생각하기 위한 다양한 방법을 생각해 볼 수 있게 해 준다는 점에서 유의미한 책이었다고 생각합니다.\n\n디자인 패턴을 공부해보고 싶은데 어려워서 망설이는 분들에게 추천합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"헤드 퍼스트 디자인 패턴","subtitle":"이렇게 코드를 짜면 장점이 뭔가요?","date":"2024-03-01T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-02-폴리플랏 프로그래밍","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-02-폴리플랏 프로그래밍.md","category":"서평","title":"폴리 플랏 프로그래밍","subtitle":"새로운 자바 언어를 기다리는 히치하이커를 위한 안내서","content":"\n## 출판사 및 저자\n\n* 저자: 임백준\n* 출판사: 한빛 미디어\n\n---\n\n## 책 소개\n\n이 책은 프로그래머로써 특정 언어를 사용할 때 다른 사람은 어떤 것을 기준으로 선택하는가에 대해서 엿볼 수 있는 내용을 담고 있습니다.\n\n이 책이 작성된 시점이 자바 7이 최신이었던 시점이기 때문에, 어느 정도 그 때와 현재 프로그래밍 언어간 지형이 달라졌다는 것을 감안해야하긴 합니다. 하지만 언어가 발전해 나가면서 기존의 언어가 어떻게 제약이 되고 우리는 그런 상황에서 어떻게 기존의 언어와 새로운 언어를 대하고 선택해야하는 지에 대한 이야기는 유효하다고 생각합니다.\n\n이 책은 컴퓨터 프로그래밍 언어 중 코볼이 잘 나가던 시절부터 이야기합니다. 그리고 코볼이 어떻게 사라졌는지를 이야기하면서 현재의 자바 비슷한 행보를 가고 있는 중이라고 말합니다.\n\n저자는 자바는 c, c++가 지배적이던 시절에 나왔을 당시에는 굉장히 섹시한 언어였다고 이야기합니다. 지금도 현업에서 자바는 아직도 굉장히 강력한 언어로 사용되고 있습니다. spring이라는 강력한 프레임워크를 기반으로 객체 지향 프로그래밍을 가장 잘 할 수 있는 언어로 자리잡고 있는 것이 그 이유가 아닐까 생각해봅니다.\n\n하지만 자바가 지금도 섹시한 언어냐고 묻는다면, 많은 사람들은 이에 동의하지 않을 것이라고 생각합니다. 자바를 제대로 알기 위해서는 숨막힐 정도로 쌓여있는 스펙들에 대해 이해해야하고, 이들을 레거시 코드들과 연결할 때 문제가 생기지 않도록 조심해야합니다. 자바는 더 이상 세련되지 않고 수많은 사람들이 기술적인 편의성을 위해 떠안고 있는 숙제로 보입니다. 언젠가는 떠나야할 숙제 말입니다.\n\n저자는 자바가 람다, 클로저 등을 지원하지 않는다는 것이 단순히 자바에서 기능이 없다는 것을 넘어선 문제라고 이야기합니다. 자바는 태생적으로 이를 고려하지 않은 언어이고, 수많은 레거시들을 끌어안고 가야하는 상황에서 자바는 너무 비대해졌으며, 그렇기 때문에 자바에는 새로운 개념을 더이상 담을 수 있는 공간이 없다고 말합니다. 그래서 그는 이런 확장성을 고려한 언어인 C#과 스칼라를 일종의 대안으로 이야기합니다.\n\n스칼라는 비록 저자분의 예상과 다르게 역사의 뒤안길로 사라지는 것이 아닐까 싶습니다만, C#은 강력한 자바의 대항마로 대두되고 있는 시점이라고 느껴집니다. 특히 요 근래에는 서버 사이드에서 go, c와 c++를 대체하기 위한 rust 역시도 새로 각광을 받고 있죠.\n\n프로그래머로써 새로운 언어를 배운다는 것은 저자가 말한 것처럼 단순히 도구가 달라지는 것이 아니라, 새로운 차원의 추상화를 경험하는 것이라고 생각합니다. 그리고 프로그래밍이 점점 더 높은 추상화의 패러다임을 추구하고 있기 때문에 이를 꾸준히 배워나가는 것은 제가 앞으로 프로그래머로써 살아가면서 계속 해나가야할 일이겠지요.\n\n다음 개념의 추상화를 통해서 새로운 패러다임으로 자리잡을 언어는 어느 것이 될까요? 폴리 플랏 프로그래머로써 굉장히 기대되네요.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"폴리 플랏 프로그래밍","subtitle":"새로운 자바 언어를 기다리는 히치하이커를 위한 안내서","date":"2024-03-02T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-10-데이터 중심 애플리케이션 설계","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-10-데이터 중심 애플리케이션 설계.md","category":"서평","title":"데이터 중심 애플리케이션 설계","subtitle":"현대 소프트웨어 데이터 관리 카탈로그","content":"\n## 출판사 및 저자\n\n* 저자: 마틴 클레프만\n* 출판사: 위키 북스\n\n---\n\n## 책 소개\n\n이 책은 현대에 **데이터**를 다룰 때 **발생하는 많은 문제점**들과 이를 **해결하기 위한 많은 방법**들을 원리에서부터 실제 적용한 제품들까지에 이르는 폭 넓은 내용을 이야기합니다. 여러 가지 내가 해결하고자하는 문제 상황에서 사용하는 데이터의 성질에 따라 발생할 수 있는 문제들에는 무엇이 있고, 이를 해결하기 위해서는 어떤 기술을 사용하는 것이 좋을지에 대한 인사이트를 얻을 수 있었습니다.\n\n최근 백엔드 개발자로써 다룰 수 있는 기술 여러 가지 중에서 데이터를 다루는 기술이 핵심적이라는 생각을 하고 있습니다. 이는 날이 갈수록 데이터가 생성되는 속도는 빨라지고 있고, 또한 다양해지고 있기 때문입니다. 그리고 이런 데이터들 별로 공학적이나 경제적으로 효율적인 해결 방법을 내놓는 것은 백엔드 개발자의 책무라고 생각합니다.\n\n근래에 진행하고 있는 채팅 어플리케이션 프로젝트 같은 경우에도 사용자의 메시지, 사용자의 프로필, 사용자의 친구 목록, 사용자의 채팅방 목록, 채팅방의 메시지 등과 같은 다양한 데이터들을 다루게 됐습니다. 이 책을 읽어보면서 제가 다루고 있는 데이터들에 적용할 수 있는 다양한 기술들에 무엇이 있는지와 그 장단점을 고민해 볼 수 있는 시간을 가질 수 있어 좋았습니다. 이를 통해 현재 프로그램이 단순히 동작하는 프로그램을 넘어서, 오랜 기간 다양한 요구에 부합할 수 있도록 설계하는 고민을 하는 데 도움을 받았습니다.\n\n다만 '프로그래머의 뇌'에서 사용한 표현을 빌리자면, 이 책은 굉장히 많은 부하를 요구하는 책입니다. 데이터베이스의 원리부터 시작해서, nosql, 분산시스템, 스트림 등 정말 다양한 주제를 다루고 있습니다. 굉장히 흥미롭고 현재 제가 읽어야하는 책이긴 했지만 동시에 조금 버겁기도 했던 것 같네요. 당장은 한 번 '아 이런 게 있구나' 정도를 가볍게 알아두고 관련된 기술을 사용하게 될 때 겁없이 다가갈 수 있는 원동력을 얻었다는 정도로 만족해야할 것 같습니다. 못해도 올해 말에서 내년 초 정도에는 한 번 더 읽으면 더 많은 것을 깨달을 수 있지 않을까 싶네요.\n\n현재 혹은 나중에라도 여러 종류의 데이터들을 효율적으로 다뤄야하는 문제를 겪게 되실 것 같다면, 이 책을 읽어보시는 것을 통해 도움을 받으실 수 있을 것이라 생각합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"데이터 중심 애플리케이션 설계","subtitle":"현대 소프트웨어 데이터 관리 카탈로그","date":"2024-03-10T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-13-가상 면접 사례로 배우는 대규모 시스템 설계 기초","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-13-가상 면접 사례로 배우는 대규모 시스템 설계 기초.md","category":"서평","title":"가상 면접 사례로 배우는 대규모 시스템 설계 기초","subtitle":"","content":"\n## 출판사 및 저자\n\n* 저자: 알렉스 쉬\n* 출판사: 인사이트\n\n---\n\n## 책 소개\n\n가상 면접 사례로 배우는 대규모 시스템 설계 기초는 차근차근 **단계**를 밟아나가면서 **시스템을 설계**한다면 어떤 것을 **고려**해야하는 지 경험있는 개발자 분께서 앞에서 천천히 시연해주는 듯한 그런 좋은 책이었습니다.\n\n가능하면 읽으시는 분들께서 제목과 부제목을 통해 글의 내용이 본인에게 유용할지 판단하실 수 있도록 하는 것이 제가 이 블로그의 지향점입니다. 그런데 이 책은 도저히 맞는 부제목을 생각할 수가 없었습니다. 그 정도로 책은 **제목**에서 전달하겠다 말한 이야기를 충실하고 **이해하기 쉽게 설명**합니다. 이 책이 대상 독자로 면접자를 가정하고 있긴 하지만, **주제**로 **대규모 시스템 설계 기초**를 다루고 있는 만큼 구직자가 아닌 분께도 충분히 도움이 될만한 내용을 담고 있다 생각합니다.\n\n이 책은 **가상 면접 사례로 배우는 대규모 시스템 설계 기초**입니다. 이 책을 읽으면 **대규모 시스템을 작성해야하는 상황**을 맞이했을 때 발생 가능한 **문제**에는 어떤 것이 있고, 이를 **해결**하기 위해서 사용할 수 있는 **방법**, 그리고 **과정**들에 대해서 배울 수 있습니다.\n\n이 책은 크게 **세 개의 대단원** 구성으로 나누어져 있습니다.\n\n* 시스템을 설계할 때 고려해야 할 **기본 원칙**과 **지식** 이를 다루는 **과정**\n* 부품으로 사용될 **작은 시스템**들을 설계하는 방법\n* 이들을 조합해서 **대규모 시스템**을 설계하는 방법\n\n우선 **규모 확장성(QPS: Queries Per Second)**을 고려해서 설계하는데 필요한 기술들을 소개합니다. 이와 관련된 기술들에는  **CDN, 수평적 확장, 메시지 큐** 등이 있습니다. 이런 기술들 중 어떤 것을 사용할 지 판단하는 근거를 생각하는 것 역시 중요합니다. 이를 위한 **개략적인 추정**을 하기 위해서 **메모리 접근 시간**과 같은 디테일에 대한 지식을 처음으로 가르쳐줍니다. 그리고 위 지식들을 종합해서 **시스템을 설계하는 과정**을 다음의 **문제 이해** 및 **설계 범위 확정**, **개략적인 설계**, **상세 설계**의 단계를 통해 예시를 들어가면서 설명합니다.\n\n그리고 이 설계하는 과정을 적용해서 **처리율 제한 장치**, **안정 해시**, **유일 ID 생성기**와 같은 대규모 시스템에서 활용하게 될 **작은 시스템**들을 설계하는 것을 보여줍니다. 이 때는 알고리즘 수준까지 내려가서 기반 기술에 대한 자세한 설명을 포함합니다.\n\n그리고 이들을 다 같이 엮어서 **뉴스 피드 시스템**, **채팅 시스템**, **검색어 자동완성 시스템**, **유튜브**와 같은 구체적인 대규모 시스템을 설계할 때 할 법한 설계적인 고민들을 보여줍니다.\n\n물론 실제 제품에서 해야할 고민에 비해서는 훨씬 간략한 내용들이지만, 이를 통해 시니어 개발자 분들께서 대규모 시스템을 설계할 때 고려하는 것들에 대한 편린을 엿볼 수 있었던 기회였습니다. 동시에 내가 이용하고 있는 수 많은 서비스들이 이런 고민들을 통해서 수 많은 사람들에게 안정적으로 서비스가 되고 발전한다는 것이 굉장히 어렵고 멋진 일이며 나 역시도 이런 일을 하는 사람이 되고 싶다는 조금의 욕심도 들었습니다.\n\n**여러 프로그램이 상호작용하는 시스템을 설계해야하는 상황**에 놓여서 고민을 하고 있는 개발자분이시라면, 이 책을 통해 자신의 모호한 **질문들을 구체화하고 해결**해나가는 방향을 잡는 데 도움을 주는 든든한 선배분과 함께하는 듯한 경험을 하실 수 있으리라 생각합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"가상 면접 사례로 배우는 대규모 시스템 설계 기초","date":"2024-03-13T00:00:00.000Z","categories":"서평","subtitle":""}},{"postName":"2024-03-14-구글 엔지니어는 이렇게 일한다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-14-구글 엔지니어는 이렇게 일한다.md","category":"서평","title":"구글 엔지니어는 이렇게 일한다","subtitle":"프로그래머에서 소프트웨어 엔지니어로","content":"\n## 출판사 및 저자\n\n* 저자: 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트\n* 역자: 개앞맵시\n* 출판사: O'Reilly, 한빛미디어\n\n---\n\n## 책 소개\n\n최근에 읽은 이 책에 대한 서평 중에서 그런 이야기가 있었습니다. 누군가가 개발자가 읽어야하는 가장 중요한 책 단 세 권을 꼽으라 한다면 기존에는 Code Complete, Refactoring 이후에 마땅한 것이 없었다. 그런데 그 세 번째에 들어갈만한 책이 나왔다. 이 책을 다 읽은 현 시점에서 저 역시도 **이 책은 개발자라면 반드시 읽어야 하는 책의 목록에 들어가야 한다는 생각을 하게 됐습니다.** 동시에 앞의 두 권 역시도 읽어봐야 할거라는 생각이 드네요.\n\n이 책을 요약한 핵심은 책의 첫 장, 첫 문장에서 이미  정리돼있습니다. **프로그래밍과 소프트웨어 엔지니어링의 가장 큰 차이는 시간, (규모) 확장, 실전에서의 트레이드오프 이렇게 세 가지라고 생각합니다.** 그리고 이 책은 장장 700여쪽에 달하는 분량으로 이 이야기들을 다룹니다.\n\n유명한 말 중에 '악마는 디테일에 있다'는 말이 있습니다. 그만큼 전달하려는 메시지는 전달하는 사람과 그 내용의 디테일을 배제하고 이야기할 수 없으리라 생각합니다. 애석하게도 저에게는 이 책이 갖추고 있는 디테일들을 훌륭하게 전달할 수 있는 방법에 대해서 알지 못합니다. 이 책은 충분히 **구글이 겪어온 수십년의 세월동안 얻은 배움의 정수**를 요약해서 후배들이 나아가기를 바라는 소망을 담아 만들어낸 **무공비급**이라 생각합니다.\n\n이에 비하면 매우 보잘것 없는 경험이지만, 최근 두 명의 팀원 분을 모집해 채팅 어플리케이션을 작성하는 경험을 하고 있습니다. 그리고 그 기간은 약 4주째에 들어가고 있는 시점입니다. 이 과정을 통해 내가 작성하고 있는 프로그램이 계속해서 **초기와 같은 발전을 유지하고 소통**이 되면서 이후에도 **계속해서 발전**할 수 있도록 하는 것이 얼마나 어려운 일인지를 느끼고 있습니다.\n\n요즘에는 이런 것을 소프트웨어 업계쪽에서도 관심을 많이 가지고 있는 분위기입니다. 이를 가지고 소위 **CI/CD**라고 부르고 있고 많은 개발 팀에서 git과 같은 버전 관리 시스템이나, jenkins와 같은 툴을 사용하고 있습니다. 저 같은 경우는 git을 사용한지 꽤나 오랜 기간이 됐습니다만, 이것을 왜 사용하고 어떻게 해야하는 지에 대한 이해는 애석하게도 부족하고 고민해 본 적도 없었다는 생각을 하게 됩니다.\n\n아직은 많이 모자랍니다만 이 책을 읽고 프로그래머에서 **소프트웨어 엔지니어**가 되기 위한 고민을 할 수 있는 사람으로 한 발짝 나아갈 수 있었습니다. 좋은 소프트웨어 엔지니어가 되기 위해서 앞으로 **더 많은 사람들이 이용**하고, **수년에서 수십년간 유지보수가 되어야 할 코드**를 작성하려면 무슨 고민을 해야 하는가 그것은 제가 살아나가면서 계속해야 할 숙제일 것입니다.\n\n혹시나 본인이 프로그래머로써 나아가야할 방향을 찾지 못해 방황하고 있거나, 자신의 프로그램이 갈수록 생산성이 떨어진다는 생각을 하고 계시는 분이라면 이 책을 추천드립니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"구글 엔지니어는 이렇게 일한다","subtitle":"프로그래머에서 소프트웨어 엔지니어로","date":"2024-03-14T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-17-스틱!","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-17-스틱!.md","category":"서평","title":"스틱!","subtitle":"1초 만에 착 달라붙는 메시지, 그 안에 숨겨진 6가지 법칙","content":"\n## 출판사 및 저자\n\n* 저자: 칩 히스, 댄 히스\n* 역자: 안진환, 박슬리\n* 출판사: 웅진지식하우스\n\n---\n\n## 책 소개\n\n**'앉아', '기다려'**. 이처럼 간단한 요청을 강아지에게 부탁하고 받아들여지는 일만 해도 굉장히 많은 노력이 듭니다. 하지만 사회에서 맺는 대부분의 관계는 그런 노력을 할 수 있는 여유가 없기 때문에 우리는 한 순간에 내 **메시지**가 상대에게 **전달**되고 **받아들여지기를 소망**합니다.\n\n저자들은 이렇게 남들에게 자신이 전하고자 하는 **메시지**를 **뇌리에 달라붙게 만드는 것**은 천재만이 할 수 있는 것이 아니라, 다음의 **6가지 법칙**을 따르면 기를 수 있는 능력이라고 저자들은 주장합니다. 그리고 이 6가지 법칙들을 지킨 **성공 사례**들을 통해 유효성을 입증하고, 효과적이지 못한 메시지를 **1초 만에 착 달라붙는 메시지로 바꾸는 과정**을 통해서 이 6가지 법칙을 **활용하는 방법**을 설명합니다.\n\n저자들이 주장하는 6가지 법칙, **SUCCES(s)**은 다음과 같습니다.\n\n```md\n1. 단순함(Simplicity)\n2. 의외성(Unexpectedness)\n3. 구체성(Concreteness)\n4. 신뢰성(Credibility)\n5. 감성(Emotions)\n6. 스토리(Stories)\n```\n\n나머지 단어와 달리 **단순함**의 경우는 오해하기 쉬워 설명을 덧붙이면, 저자가 말하는 단순함이란 메시지를 전달하는 방법이 단순해야 한다는 것이 아닙니다. 그보다 메시지를 전달할 때 **핵심**만을 담아야 한다는 것입니다.\n\n최근 면접을 자주 보게 되면서, 내가 이 회사에 매력있는 사람이라는 **메시지**를 전달할 수 있는 방법이 무엇인지에 대해 많은 고민을 하게 되었습니다. 그것 뿐 아니라 제 블로그 글도 다른 사람들에게 **매력적**으로 읽혀서 **기억**에 남고 싶고, 같은 프로젝트를 진행하는 팀원들에게 내 의견을 **효과적**으로 전달하고 싶다고 갈망하게 됐습니다.\n\n저는 이 책을 읽으면서 **효과적인 소통**을 위해 **노력해야하는 방향**을 찾을 수 있었습니다. 당장에 내일 있을 면접 때 제가 어떤 사람으로 보이고 싶은지 돌이켜보고, 이를 위해서 **자기소개**를 준비하는 것을 통해 **적용**해 볼 수도 있었으니까요. 좋은 결과로 이어져서 자랑하는 글을 쓸 수 있으면 그것은 또 하나의 즐거움이겠네요.\n\n꼭 면접을 보는 상황이 아니라도 사람과의 **소통**에 있어서 자신의 의견을 **효과적으로 전달**하는 데 성공한 다양하고 구체적인 사례들을 통해 이 **6가지 법칙(SUCCESs)**을 이야기 하고 있어서, 많은 것을 배울 수 있는 좋은 책이었습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"스틱!","subtitle":"1초 만에 착 달라붙는 메시지, 그 안에 숨겨진 6가지 법칙","date":"2024-03-17T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-29-공부란 무엇인가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-29-공부란 무엇인가.md","category":"서평","title":"떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여","subtitle":"공부란 무엇인가 서평","content":"\n### 목차\n\n- [책 정보](#책-정보)\n- [떡볶이는 좋지만, 더덕 구이는 싫은걸](#떡볶이는-좋지만-더덕-구이는-싫은걸)\n- [공부는 지적인 근육 트레이닝이다](#공부는-지적인-근육-트레이닝이다)\n- [지(知)성장을 위한 시작점](#지知성장을-위한-시작점)\n- [티모 애호가에서 벗어나 장인이 되려면](#티모-애호가에서-벗어나-장인이-되려면)\n- [꿀렁이는 근육에서 벗어나, 추락하는 열차를 지탱하려면](#꿀렁이는-근육에서-벗어나-추락하는-열차를-지탱하려면)\n- [열심히 공부한 당신, 쉬어라](#열심히-공부한-당신-쉬어라)\n\n---\n\n## 책 정보\n\n- 제목: 공부란 무엇인가\n- 저자: 김영민\n- 출판사: 어크로스\n\n---\n\n## 떡볶이는 좋지만, 더덕 구이는 싫은걸\n\n한국은 어려서부터 편식하지 않을 것을 미덕으로 삼는 문화을 갖추고 있습니다. [1인당 전세계 채소 섭취량이 무려 2위](https://m.health.chosun.com/svc/news_view.html?contid=2023071802471)라는 이야기도 있을 정도이니, 부모님들의 노고가 빛을 발하고 있는 모양입니다.\n\n그럼에도 불구하고 채소를 먹기 싫어하는 사람은 여전히 많습니다. 제가 아는 모 여학생은 이제 나이 스물이 다 돼가지만 고기 반찬이 없으면 밥을 먹지 않고, 제육볶음을 먹을 때 채소 비율이 반을 넘어가면 손을 대지 않습니다.\n\n그런데 그 여학생이 고기 한 점 없어도 없어서 못 먹는 음식이 있습니다. 그것이 바로 떡볶이입니다. 그런데 문제는 요즘 수많은 미디어에서 선전하듯 떡볶이는 정제 탄수화물과 단순당에 나트륨 덩어리인 식품이라 몸에 좋지 못하단 것입니다. 그에 반해 더덕 구이 같은 채소는 모두들 입을 모아 먹어야하는 좋은 음식입니다.\n\n물론 사람의 대부분이 채소가 아니라 고기를 더 좋아하는 것이 사실입니다. 그럼에도 채소를 더욱 싫어하게 되는 이유는 어린 시절 강제로 채소를 먹는 경험을 통해 '싫어하는 것', 혹은 '억지로 해야하는 것'이라는 인식이 자리잡았기 때문일지도 모릅니다.\n\n저자는 한국의 공부 문화가 그렇게 자리잡아가고 있는 세태에 대해 걱정하는 마음에 이 책을 썼습니다. 한국의 공부가 입시와 취업으로 환원되지 않을 경우에는 무의미한 것으로 받아들여지고 있기 때문에 공부 자체가 하기 싫은 것으로 인식되고 있고, 공부가 가져다 줄 수 있는 잘 양념된 삶을 이루지 못하고 있는 것이 걱정되기 때문입니다.\n\n국내 최고의 공부 중독자이자 제가 가장 좋아하는 에세이 작가인 김영민 교수님은 이를 위해 공부란 무엇이고, 어떤 것을 공부해야하며, 어떻게, 왜 공부해야하는지와 같은 질문을 제기합니다. 그리고 이에 대해 독자와 대화를 통해 토론하고 본인이 생각하는 답에 대한 제시를 한 뒤 독자 스스로의 답을 제시하기를 바랍니다.\n\n---\n\n## 공부는 지적인 근육 트레이닝이다\n\n세상에 모든 것들은 독특합니다만, 그 중에서도 인간만한 동물은 드물다고 생각합니다. 그리고 헬스장에 가면 그 특이함의 끝이 무엇인가에 대해 엿볼 수 있다고 생각합니다. 온 몸이 상기된 상태로 신음을 내면서 \"한 번만 더...!\"를 외치는 사람들. 그들은 온 몸을 땀으로 적셔가며 숨을 헐떡이고, 자신의 근육을 찢어내는 고통을 스스로 추구하는 구도자들입니다. 그런데 신기한 일은 그들이 그런 고통을 즐긴다는 사실입니다.\n\n그들이 이런 괴로움을 추구하는 것은 아픔 그 자체를 즐거워하기 때문은 아닙니다. 다만 그 괴로움을 경험했을 때, 그리고 그것을 이겨냈을 때 어제의 나보다 나아진 나를 체험할 것을 기대하기 때문에 이를 감내하고 도전하는 것입니다. 지난 달의 내가 3대 200을 들 수 있었는데 이번 달에 230을 해냈다면, 그것은 금전으로 환원되지 않는 무엇보다 소중한 경험이기 때문입니다. 이런 자기 갱신의 체험을 경험한 사람들은 과정에 수반되는 괴로움 역시도 즐기게 되고, 이를 통해 자신의 삶을 더욱 풍요롭게 만들어나갑니다.\n\n공부 역시 마찬가지입니다. 지식을 탐구하고 어제의 무지했던 과거의 나로부터 벗어나는 자기 갱신의 과정을 체험하는 것이 공부입니다. 도서관이라는 지식의 헬스장에 들어가 책이라는 지식의 바벨을 꾸준히 들어가며 머리털이 빠져나가는 고통과 괴로움을 견디는 것이 공부입니다. 그렇다고 진짜 머리털이 너무 많이 빠진다면 그건 좀 곤란합니다. 혹시 본인이 그런 상황에 처해계시다면 도서관보다는 병원을 찾아보시는 것이 좋습니다.\n\n---\n\n## 지(知)성장을 위한 시작점\n\n제가 도서관에서 책을 읽는 것을 헬스장에서 근육을 단련하는 것에 비유하긴 했습니다만, 헬스장에서 운동을 하는 모두가 소위 몸짱이 되는 것은 아닌 것처럼 모든 공부가 지(知)성장을 이끌어 똑똑한 사람이 되도록 만들어주지는 못합니다. 근성장을 위해서는 자신이 단련하려는 하는 근육을 선택하고, 현재 자신이 가진 근력을 측정한 뒤 한계를 뛰어넘기 위해 이에 부딪히는 것이 필요합니다. 공부 역시도 마찬가지입니다.\n\n그렇다면 공부에서 우선 근육에 해당하는 것들에는 무엇이 있을까요? 우선은 특정 개념들을 명료하게 정의하고 사용하는 것부터 시작할 수 있을 것 같습니다. 개념에 대해 정의를 내리는 것은 이해의 첫 걸음이라 할 수 있기 때문입니다. 유명한 [김춘수 시인의 꽃](https://namu.wiki/w/%EA%BD%83(%EA%B9%80%EC%B6%98%EC%88%98))이라는 시에서 '내가 그의 이름을 불러주었을 때, 그는 나에게로 와서 꽃이 되었다.'라고 한 것처럼, 우리는 이름을 불러줄 수 있기 전까지는 사물을 다른 것과 구분지어 인식하지 못합니다.\n\n이 때 해당 개념들을 모호하게 정의하지 않도록 노력해야 할 것입니다. 모호한 정의는 이를 무기 삼으려는 권력자라면 이상적일 수도 있습니다. 나에게로 와서 꽃이 된 객체는 어떤 이름을 부여받았을까요? 제 네이밍 센스는 절망적이기 때문에 예를 들어 '유니' 같은 이름을 지었다 할 때 꽃이 와서 항의할 수도 있습니다. '이름을 불러준다고 했지만, 이런 촌스러운 이름일 거라곤 생각하지 못했어!'라고 말이죠. 그러면 저는 이렇게 말할 수도 있습니다. '내가 이름을 불러준다고 했지 그게 멋진 이름일 거라고 한 적은 없는데?' 그러니 꽃은 명확하게 저에게 요구해야합니다, '고등학생 100명에게 물어봤을 때 70명 이상이 세련됐다라고 말하는 이름을 지어줘'와 같이 말이죠.\n\n하지만 공부에서 개념 정의는 권력 다툼이 아니라 사물에 대한 올바른 인식이 목표이기 때문에 이런 다툼이 발생하지 않도록 노력 해야 합니다. 이를 위해 가급적 명료하고 정확하게 정의해서 자신에게 사물을 올바르게 인식할 수 있는 능력이 함양되도록 노력해야 합니다. 그렇지 않으면 책에서 나온 예시처럼 대머리에 대해 '대머리는 반짝반짝'이라고 말하는 사람이 될 것입니다.\n\n이런 개념들을 세워 지(知)성장이 이루어지고 지식의 척추기립근이 바로 서면서 자기 갱신의 체험을 하게 되면 비로소 눈이 뜨이고 이전보다 좀 더 섬세한 인식을 할 수 있게 될 것입니다.\n\n---\n\n## 티모 애호가에서 벗어나 장인이 되려면\n\n척추 기립근이 바로 서고 눈이 띄었다면 이제 우리는 비로소 눈을 완전히 뜰 능력을 갖춘 생후 2주차의 아기와 동일한 지점에 도착했다고 할 수 있을 것입니다. 하지만 눈을 떴다고 해서 보이는 것에 대한 인식을 할 수 있느냐하면 그건 또 다른 문제입니다. 아기는 수많은 훈련을 해도 한참동안 아빠를 아빠라 부르지 못하고 엄마라고 부릅니다. 이렇게 아기가 아빠와 엄마를 구분짓기 위해 오랜기간 훈련을 해야하는 것처럼 우리가 올바른 인식을 하기 위해서도 수많은 훈련이 필요합니다.\n\n그러나 단순히 훈련을 오래 한다고 해서 능력이 함양되지는 않습니다. 롤에서 우리는 소위 브실골에 있는 한 캐릭터에 수백 수천 게임을 투자한 사람들을 종종 만날 수 있지만, 그들을 우리가 장인이라고 부르지는 않습니다. 그들은 단순히 그 캐릭터를 좋아하고 많이 한 애호가일 뿐입니다. 그렇다면 노력이 어떻게 하면 애호가가 되는데 머무르지 않고 장인이 되도록 할 수 있을까요?\n\n그러기 위해서는 우리는 올바른 방향성을 갖춘 노력을 해야합니다. 그리고 이런 방향성을 잡아주는 역할을 하는 것이 바로 **질문**입니다. 저자분의 표현을 빌리자면, '방광에 아무리 액체가 가득해도 갈증 해소에 도움이 되지 않는 것처럼, 자료가 아무리 가득해도 엉뚱한 위치에 놓여 있다면 지적 호기심 해소에 도움이 되지 않습니다.' 따라서 단순히 게임을 많이 해서 경험을 쌓는 것이 아니라, 그 경험이 발전을 위해 올바른 위치에 쌓이도록 노력해야합니다. 그리고 우리는 질문을 하고 이에 대답을 하는 과정을 통해 이를 이룰 수 있습니다.\n\n질문에도 좋은 질문과 좋지 못한 질문이 있습니다. 좋은 질문에는 여러 기준이 있겠지만 가장 먼저 챙길 가치 중 하나는 완성된 문장으로 질문을 표현하는 것입니다. '아, 정글이 탑 좀...'이라고 눈치 보는 것이 아니라 '정글이 탑에서 대포 웨이브를 쌓는걸 보고 윗동선을 밟아서 다이브를 하면 게임을 유리하게 이끌 수 있지 않았을까요?'와 같이 완성된 문장으로 질문을 표현하는 것입니다. 질문을 할 때 무책임하게 대충 단어를 몇 개 던지고 상대가 알아서 이해해주기를 기대해서는 안됩니다.\n\n그 다음으로는 질문을 할 때 자신의 관점에 지나치게 열중한 나머지 상대방과 소통하지 않고 관점을 무시하지 않도록 노력해야 합니다. 아까 3용 싸움에서 우리가 어떻게 하면 한타를 이길 수 있었을 지에 대해 이야기하고 있는데 갑자기, '아 그러게 내가 아까 탑 오라했을때 왔으면 킬먹고 고속도로 냈을텐데'와 같은 태도를 취해서는 안 될 것입니다. 그런 대화를 통해 이야기가 평행선을 달리지 않도록 하려면 상대의 논의 내부로 들어갈 필요가 있습니다.\n\n그러나 저자의 표현을 빌리면 '상대의 논의 내부로 들어가는 것이 바람직하다 해서, 너무 세세한 문제에 집착하라는 말은 아닙니다.' 너무 깊게 들어가서 대부분 관심을 갖지 않을 질문하는 것은 생산적이지 않고 지적질에 불과한 경우가 대부분이기 때문입니다. '아까 용싸움 할 때 왜 감성센도 쓰셨어요?'와 같은 질문을 해서는 안 될 것입니다.\n\n---\n\n## 꿀렁이는 근육에서 벗어나, 추락하는 열차를 지탱하려면\n\n마침내 지성장을 이루는 데 성공했고, 애호가가 아니라 장인이 되기 위한 방향성을 잡았다면 다음은 이 성장을 다른 사람들과 공유할 필요가 있습니다. 여기서 공유한다는 것은 근육을 꿀렁거리면서 '내 가슴 근육 멋있지?'라며 자랑하는 것을 말하는 것이 아닙니다. 그보다는 [스파이더맨이 열차가 다리에서 떨어지지 않도록 가슴 근육을 최대한 쥐어짠 것처럼](https://www.youtube.com/watch?v=yRhRZB-nqOU), 자신의 지적인 근육이 감당하기 힘들 정도로 어려운 주제에 대한 견해를 제시하고 다른 사람들과 토론하는 것을 말합니다. 이때 이런 어려운 주제에 해당하는 것이 바로 논쟁의 여지가 있는 주제입니다.\n\n논쟁의 여지가 있는 주제를 다룬다는 것은 어렵습니다. 이는 논쟁의 여지가 없는 쉬운 주제를 다루는 것과 달리 기존과 다른 주장을 제시하고 그것을 넘어서야 하기 때문입니다. 본 저자는 예시로 리어왕에서 사생아 에드먼드가 사생아를 멸시하는 상식을 뒤집어놓는 주장을 제시합니다. \"사생아가 비천하다고? 사생아는 자연스럽게 불타는 성욕을 만족시키다가 생겨난 존재이니, 지겹고 따분한 침대에서 의무 삼아 잉태된 정실 자식들보다 낫지!\" 이렇듯 논쟁의 여지가 있는 주제에서 기존과 다른 자신의 견해를 제시하고, 비판을 통한 검증을 받아가며 자신의 견해가 틀렸다는 것을 깨닫는 경험을 통해 이전보다 올바르고 섬세한 인식을 갖추게 될 것입니다. 운이 좋다면 자신의 주장이 올바르다는 것을 깨닫는 경험을 할 수도 있을 것입니다.\n\n이 때 듣고자 관심이 있는 사람에게 전달력 있게 비문이 적은 문장과 똑바른 발음을 통해 해상도가 높은 표현을 사용해서, 상대방이 이해하기 쉽게 주장을 전달해야합니다. 일요일 오전 10시에 선거 유세 차량에서 나오는, 갈라지고 잘 들리지도 않지만 씨끄러워서 짜증을 유발하는 것 만큼은 탁월한 마이크 소리를 통해 아직 잠에서 깨지도 않은 주민들에게 '저에게 투표하시면 아무튼 좋은 일이 생길 겁니다!'와 같은 말을 하는 것으로는 누구의 마음도 움직이지 못할 것입니다. 이런 청중이 듣건 말건 개의치 않고 자기 이야기를 기어이 하고야 마는 것은 서로의 발전을 꾀하는 것보다 자신이 말하는 데서 얻는 쾌감을 추구하는 것일 뿐입니다.\n\n---\n\n## 열심히 공부한 당신, 쉬어라\n\n비일상의 추구의 최종 목표는 일상에서 벗어나 자신을 되돌아보고 자신의 삶의 소중함이나 개선하고 반성할 점을 깨달은 뒤, 다시 일상으로 돌아가서 그것을 실천하는 것입니다. 이는 우리가 여행을 떠날 때 최종 목적지를 집으로 삼는 것과 마찬가지이고, 모든 여행에서 가장 중요한 일은 집으로 무사히 돌아오는 것과 같습니다. 공부 역시도 자신을 갱신하는 여정이기 때문에 일상의 평범함으로 돌아와 휴식을 취하는 것이 가장 중요합니다.\n\n그렇지만 활시위가 이완되기 위해서는 당겨지는 것이 우선해야하듯이, 공부를 열심히 하지 않으면 쉬는 능력 역시도 길러질 수 없습니다. 그러니 진정한 휴식을 취하려면 공부를 통한 자기 갱신의 여정이 앞서야 합니다. 평소에 운동을 하던 사람이 집에 누워 있다면 이를 통해 근육이 회복되고 더 강해질 것이지만, 운동을 하지 않는 저 같은 사람이 집에 누워 있다면 살만 찌우게 될 것입니다.\n\n만약 공부를 해서 휴식을 할 수 있는 체력을 기르는 데 성공했다면 이제는 어떻게 쉬어야 할 지에 대해서 이야기 할 차례입니다. 산책을 취하거나 잠을 자는 것처럼 비어있는 시간을 보내는 것도 좋고, 평소보다 쉬운 글을 읽거나 쓰는 일종의 퇴행도 좋습니다. 저자는 모든 휴식의 궁극으로 빈둥거리며 여행하기를 추천합니다.\n\n떡볶이와 같은 자극적이지만 영양가 없는 공부만 하는 것에서 벗어나 더덕구이와 같이 영양가 있고 하는 것을 보면 뭔가 있어 보이는 사람을 섬세하게 만드는 공부를 하고, 이를 통해 진정한 휴식에 도달하는 사람이 한국 사회에 더 많아지기를 바랍니다.\n\n---\n","layout":"산문","recommended":true,"data":{"layout":"산문","classes":"wide","title":"떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여","subtitle":"공부란 무엇인가 서평","date":"2024-03-29T00:00:00.000Z","categories":"서평","recommended":true}},{"postName":"2024-02-12-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-02-12-Medium review.md","category":"WeeklyPosts","title":"2월 2주차 포스트","subtitle":"","content":"\n1. How I Won Singapore’s GPT-4 Prompt Engineering Competition\n2. Taylor Swift Ticketmaster Meltdown: A System Design Analysis\n3. Advice to my younger self and you after 20 years in programming\n\n---\n\n## 싱가포르의 GPT-4 프롬프트 엔지니어링 대회에서 우승한 방법\n\n: \u003chttps://medium.com/towards-data-science/how-i-won-singapores-gpt-4-prompt-engineering-competition-34c195a93d41\u003e\n\n요즘 부쩍 생성형 ai를 쓸 일이 많아지면서, 많이 하게 되는 고민은 '어떻게 하면 더 좋은 질문을 할 수 있을까?'입니다. 해당 글에서는 이를 총 4가지로 나누어 설명합니다.\n\n* 초급\n  * COSTAR 프레임워크를 사용하라\n  * 구분 기호를 사용하라\n* 고급\n  * LLM 가드레일을 사용하라\n  * 데이터세트 실습 예제를 통한 활용 방법\n\n저는 당장은 데이터 세트 분석에는 관심이 없기에 앞의 세 가지 항목만 참고했고, 굉장히 도움을 많이 받고 있는 중 입니다.\n\n### COSTAR framework\n\nCOSTAR framework는 생성형 ai를 사용할 때 주의할 6가지의 키워드를 말합니다.\n\n1. Context: 맥락\n2. Objective: 목적\n3. Style: 문체\n4. Tone: 응답 태도\n5. Audience: 청중\n6. Response: 응답 형식\n\n대표적으로 요즘 활용하고 있는 방식을 예로 들자면, 제가 자료구조와 알고리즘에 관한 개념적인 복습을 면접을 보기 직전에 하려고 하는 상황을 가정해보겠습니다. 제가 처음에 접근한 방식은 이런 식이었습니다.\n\n#### \"회사에서 주니어 개발자에게 물어볼 만한 자료구조와 알고리즘적 질문들에는 어떤 것이 있을지 제시해줄래?\"\n\n이 때 제안해주는 답변은 다음과 같습니다.\n\n```md\n회사에서 주니어 개발자에게 물어볼 수 있는 몇 가지 자료구조와 알고리즘적 질문에 대해 알려드리겠습니다:\n\n해시맵 구현: 해시맵(해시 테이블)의 작동 원리를 설명하고, 이를 파이썬에서 어떻게 구현할 수 있는지에 대해 물을 수 있습니다.\n\n이진 탐색 트리: 이진 탐색 트리의 특징을 설명하고, 특정 값을 찾거나 삽입하는 작업을 어떻게 수행하는지에 대해 물을 수 있습니다.\n\n...\n```\n\n물론 이 답변도 괜찮긴 합니다만, 제게 있어서 아쉬운 점은 이제 이런 키워드가 제시됐을 때 어떤 순서로 구조화된 공부를 할지에 대해서 잘 모르겠다는 것이었습니다. 이전에는 해당 답변을 받은 다음에, \"리스트와 딕셔너리에 관련해서 물어볼만한 질문에는 어떤 것들이 있을까?\" 와 같은 질문을 통해 공부를 했습니다. 그리고 이것은 꽤나 유용한 학습 방법이었습니다. chatgpt가 없을 때에 비교하면 많이 효율적이고요.\n\n하지만 해당 medium 글을 읽은 후에는 다음과 같은 식으로 질문을 하게 됐습니다. \n\n#### 다음 주에 컴퓨터 공학부 학생들을 대상으로 자료구조와 알고리즘 강의를 하게 됐어. 해당 학생들은 곧 졸업하고 취업을 앞두고 있어. 기본적인 개념의 이해는 돼있지만, 이를 복습하고 시험을 준비하는 과정이 필요하다 할때 커리큘럼을 작성해보려하는데 도와줄래?\n\n그리고 이전과 비해서 '졸업하고 취업을 앞둔 컴퓨터 공학부'라는 명확한 독자를 설정하고, '시험을 준비하는 커리큘럼 준비'라는 맥락을 제시하기 때문에 좀 더 나은 답변을 얻을 수 있게 됐습니다.\n\n```md\n물론이죠! 학생들이 기본 개념을 알고 있지만 실전 경험이 필요한 상황에서는 다음과 같은 커리큘럼을 고려해볼 수 있습니다:\n\n자료구조 복습\n\n배열(Array), 연결 리스트(Linked List), 스택(Stack), 큐(Queue), 트리(Tree), 그래프(Graph) 등의 자료구조를 복습합니다.\n각 자료구조의 특징, 장단점, 구현 방법 등을 다룹니다.\n\n알고리즘 복습\n\n정렬 알고리즘(Sorting Algorithms): 버블 정렬, 선택 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬 등을 복습합니다.\n검색 알고리즘(Search Algorithms): 선형 검색(Linear Search), 이진 검색(Binary Search) 등을 다룹니다.\n그래프 알고리즘(Graph Algorithms): BFS, DFS 등의 기본적인 그래프 탐색 알고리즘을 다룹니다.\n\n문제 해결 능력 향상\n\n실제 문제를 풀어보며 알고리즘을 적용하는 능력을 향상시킵니다.\n온라인 저지(Online Judge) 사이트를 활용하여 다양한 알고리즘 문제를 풀어봅니다.\n\n코딩 테스트 대비\n\n주어진 문제를 효율적으로 해결하기 위한 코딩 테스트 전략과 팁을 공유합니다.\n실전에서 사용되는 자료구조와 알고리즘을 익히고 효율적인 코드를 작성하는 연습을 합니다.\n\n프로젝트 실습\n\n자료구조와 알고리즘을 활용하여 간단한 프로젝트를 진행합니다.\n예를 들어, 그래프 알고리즘을 사용하여 경로 탐색 알고리즘을 구현하는 프로젝트를 할 수 있습니다.\n```\n\n이처럼 단순히 학습을 할 내용을 떠나 조금 더 구체적인 학습의 방식도 제안해주는 것이 꽤나 도움이 많이 됐습니다. \n\n그 다음 항목인 ###를 통해 내용을 나누는 것도 꽤나 많은 도움을 받고 있습니다. 가령, User.py에 정의된 ORM 객체인 User를 이용해서 Login이라는 api를 구현해야한다고 할 경우에\n\n```md\nLogin api를 login.py에 작성하고 싶어. Login은 input으로 email, password를 받고 이를 Oauth2를 통해 토큰을 만들어 반환해주는 인증 api야. 해당 정보를 저장하기 위한 database 모듈과 소통하기 위한 방식은 ORM을 채용하고 있어. Login이 정보를 주고 받게 될 Model은 다음과 같아\n\n###\n\nUser.py의 코드 내용\n```\n\n와 같은 방식으로 질문을 작성하게 됐습니다.\n\n3번째 항목은, chat gpt의 custom instructions에서 요구하는 두 가지 질문을 어떻게 답변할 것인지에 대해 이야기합니다. custom instructions는 우리가 프롬프트에 입력하는 것과는 별개로, 답변을 할 때 고정적으로 chatgpt가 명심해두어야하는 다음과 같은 질문에 대한 답변들을 말합니다.\n\n```md\n1. What would you like ChatGPT to know about you to provide better responses?\n2. How would you like ChatGPT to respond?\n```\n\n글의 저자는 다음과 같은 것을 작성하길 추천하고 있습니다.\n\n```md\n* Task Definition: You will answer questions using this text: [insert text].\n* Output Format: You will respond with a JSON object in this format: {`Question`: `Answer`}\n* If the text does not contain sufficient information to answer the question, do not make up information and give the answers as \"NA\".\n```\n\n저 같은 경우는 다음과 같은 것을 사용하고 있는 중입니다.\n\n```\n* I'm an Junior Programmer who has bachelor's degree on Electricity and computer engineering.\n* Right now I'm trying to earn a job as a software designer\n* I used to be good at algorithms and solving program problems, but not been programming for about 1.5 years\n* I'm trying to learn  how to solve the problems using programs, not wanting to get the sole answers\n* I'm a Korean who is fairly good at English, but much better at using Korean Language\n\n* Don't just give the answers from the scratch code level answers.\n* Try to lead me by giving rough hints that doesn't directly lead to the answer. Instead give vague concepts on how to get direct me to the answer.\n* Try to use vocabularies that are frequently used computer programming environment.\n* 질문에 답하려면 [텍스트 삽입]이라는 텍스트를 사용하세요.\n* 본인이 질문에 답하기에 충분한 정보가 포함되어 있지 않은 경우 정보를 구성하지 말고 \"NA\"로 답하십시오.\n```\n\n---\n\n## Taylor Swift Ticketmaster Meltdown: 시스템 설계 분석\n\n: \u003chttps://learningdaily.dev/taylor-swift-ticketmaster-meltdown-a-system-design-analysis-cd326f7ed57b\u003e\n\n요 근래 테일러 스위프트가 전세계 투어를 다닌 것이 꽤나 화제가 됐었죠. 조단위의 경제적 효과를 불러왔다는 이야기가 나올 정도니 대단하다라고 생각하고 넘어가기만 했던 일이었습니다.\n\n그런데 이런 어마어마한 인파를 처리해야하는 티케팅 서비스가 과연 멀쩡했을까? 여기에는 생각이 닿지 않았었는데 글을 보고 굉장히 재밌단 생각이 들었습니다. 마침 요즘 대용량의 트래픽을 처리하는 경우가 생기면 어떻게 해야하는가에 대한 고민을 좀 해보고 있었던 참이기도 했구요.\n\n이 글에서는 시스템적으로 대용량의 트래픽을 처리하기 위해 했어야하는 접근을 실제 사례를 통해 이야기해서 꽤나 흥미롭게 읽을 수 있었습니다.\n\n1. 캐싱\n2. 우아한 저하\n3. 3자 의존성: 시스템은 가장 약한 링크만큼만 강력하다.\n\n---\n## 20년 동안 프로그래밍을 한 후배인 나와 당신에게 주는 조언\n\n: \u003chttps://medium.com/dev-publicity/advice-to-my-younger-self-and-you-after-20-years-in-programming-a3a2ccc7a942\u003e\n\n미디엄에서 최근에 가장 많이 읽은 글이라고 추천이 돼서 읽은 글입니다. 저자는 Alexey Inkin이라는 IEEE 시니어 멤버인 20년 경력 개발자입니다.\n\n대선배로부터 유용한 조언을 받는듯한 내용으로 가득차 있었고, 재미있는 부분은 개발 실력 측면에서 발전하는 것 외의 부분을 신경써야한다고 많이 강조한 점입니다.\n\n* 초기 단계의 기술에 참여하고, 죽어가는 기술에서 벗어나라\n* 응용보다 과학을 선택하라\n* 돈은 자신에게만 투자하지 말라.(금융 투자에 대한 이야기입니다.)\n\n과 같은 이야기를 하는 것이죠. 초기 단계의 기술에 참여하라는 항목에서 제시한 링크가 꽤나 재밌었습니다.\n\n\u003chttps://survey.stackoverflow.co/2023/#section-salary-salary-and-experience-by-language\u003e\n\n위의 링크는 프로그래밍 언어별 평균 연차와, 중위 연봉을 스택오버플로우에서 통계낸 것입니다. 빨간 것일수록 사용자가 많고, 파란 것일수록 적어서 신뢰도가 떨어진다 할 수 있죠.\n\n요 근래 면접을 보다보면 \"GO\"와 \"RUST\"에 관심이 있는 기업들이 늘고 있다는 생각을 좀 하게 됐습니다. 얼마 전 일론 머스크는 RUST에 대한 강한 관심을 내비치기도 했고, 마이크로 소프트 역시도 RUST를 이용해서 윈도우를 뜯어고치고 있단 이야기가 화제가 되기도 했죠.\n\n새로운 언어를 올해에는 하나쯤 공부해볼까 하는 중이고, 위의 둘 중 하나를 선택하려고 하고 있습니다. 아마 서버 백엔드 쪽으로 직장이 결정되면 GO를, 소프트웨어 쪽으로 가게 된다면 RUST를 공부하는 쪽으로 하지 않을까 싶네요. 일단 당장 목표로 잡아둔 것은 금주부터 해서 GO를 활용한 많은 인원을 수용할 수 있는 실시간 채팅 프로그램을 토이프로젝트로 하나 진행해보려고 하고 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월 2주차 포스트","date":"2024-02-12T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-02-20-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-02-20-Medium review.md","category":"WeeklyPosts","title":"2월 3주차 포스트","subtitle":"","content":"\n1. Embracing Chaos: The Unexpected STrength of the Chaos Monkey Principle\n2. Trying to Innovate? Put down your hammer\n3. I Tried Multiple AI Coding Assistants. These Are The Best\n4. Top 10 Platform Engineering Tools You Should Consider in 2024\n\n\n---\n\n## 혼돈 수용: 혼돈 원숭이 원리의 예상치 못한 힘\n\n: \u003chttps://medium.com/illuminations-mirror/destroying-everything-makes-it-better-the-chaos-monkey-principle-3bc845a76cc4\u003e\n\n넷플릭스에서 사용하는 실패 주입 도구인 카오스 몽키에 대한 글입니다. 이 도구는 소프트웨어 코드 정글에서 혼란을 일으키는 원숭이처럼 네트워크에 오류를 체계적으로 도입하도록 설계돼있습니다.\n\n---\n\n## 혁신을 시도하고 있나요? 망치를 내려놓으세요\n\n: \u003chttps://rachelaudige.medium.com/trying-to-innovate-put-down-your-hammer-a8f9810b1d1a\u003e\n\n망치를 들고 있으면 모든 것이 못으로 보인다는 말에 대한 글입니다. 화재 사태에서 불을 도망칠 때 전문가의 의견을 따라 명령을 받아 가만히 있어야했음에도 도망치다가 전부 죽은 사람의 이야기에서 볼 수 있듯, 우리는 자신의 전문지식으로 인해 무엇이 옳은지 판단하지 못하는 경우가 발생합니다.\n\n이처럼 우리는 도구와 이미 알고 있는 것에 집착하기 때문에, 잘못된 선택을 하게 되고 따라서 **효과적으로 도구를 버리는** 다음과 같은 전략이 필요합니다.\n\n```md\n1. 일반적인 도구를 버리고 다른 혁신 방법에 대해 호기심을 가지십시오.\n2. 다양한 방법으로 배우십시오\n3. 도구 세트에 대한 개념적 프레임워크를 만들어두십시오.\n```\n\n---\n\n## 나는 여러 AI 코딩 어시스턴트를 시도했습니다. 이것들이 최고입니다\n\n: \u003chttps://medium.com/artificial-corner/i-tried-multiple-ai-coding-assistants-these-are-the-best-bb4d6a735fc1\u003e\n\n다섯 가지의 인공지능 코딩 어시스턴트를 시도한 결과를 장단점을 통해 공유하는 글입니다.\n\n```md\n1. Github Copilot: Favorite general-purpose coding assistant\n2. CodiumAI: Good for testing\n3. AWS Code Whisper: Good for writing apps linked to the Amazon ecosystem\n4. Tabnine: An intuitive coding companion\n5. ChatGPT/Bard: Amazing for learning to code\n```\n\n---\n\n## 2024년에 고려해야 할 최고의 플랫폼 엔지니어링 도구 10가지\n\n: \u003chttps://medium.com/@rphilogene/top-10-platform-engineering-tools-you-should-consider-in-2024-892e6e211b85\u003e\n\n플랫폼 엔지니어링은 소프트웨어 릴리스를 빠르게 제공하는 데 도움을 주기 위해 플랫폼을 설계하고 구축하는 것입니다. 이 글에서는 2024년에 고려해야 할 최고의 플랫폼 엔지니어링 도구 10가지를 소개합니다.\n\n```md\n1. Kubernetes: 컨테이너 오케스트레이케\n2. Crossplane: 크로스 쿠버네티스 인프라 관리\n3. Qovery: 내부 개발자 플랫폼(IDP)\n4. Gitlab CI: CI를 위한 통합 도구\n5. port(getport.io): 개발자 포털 구축\n6. AgroCD: Kubernetes 기반 CD 도구\n7. Docker: 컨테이너 기반 애플리케이션 배포\n8. Terraform: 인프라 프로비저닝\n9. Doppler: 환경 변수 관리\n10. DataDog: 모니터링 및 분석 도구\n```\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월 3주차 포스트","date":"2024-02-20T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-02-27-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-02-27-Medium review.md","category":"WeeklyPosts","title":"2월 4주차 포스트","subtitle":"","content":"\n1. \u003chttps://learningdaily.dev/2023-in-review-4-key-takeaways-for-developers-a5bcc8b86133\u003e\n2. \u003chttps://medium.com/@techworldwithmilan/software-architecture-as-code-tools-331a11222da0\u003e\n3. \u003chttps://levelup.gitconnected.com/build-a-personal-ai-tech-news-agent-94e7a2e508fe\u003e\n\n---\n\n## [2023년 회고: 개발자를 위한 4가지 주요 교훈](https://learningdaily.dev/2023-in-review-4-key-takeaways-for-developers-a5bcc8b86133)\n\n본 글은 2023년의 주요 시사점으로 다음의 네 가지를 제시합니다.\n\n1. 클라우드 컴퓨팅에는 점검이 필요하다.\n2. 생성형 AI가 모든 것을 바꾸고 있으며, 개발자가 혁명을 주도할 것이다.\n3. 스마트 시스템 설계가 더 중요해지고 있다.\n4. API 및 제품 디자인에 대한 이해가 필요하다.\n\n해당 관점은 당분간 유지될 것이라 생각하고 이에 맞춰 준비를 일단 하되, 시장의 동향을 지속적으로 관찰하며 변화에 대응해야 한다는 생각을 하게 됐습니다.\n\nAPI 및 제품 디자인에 대한 이야기가 나오면서 프로그램을 작성할 때 제가 작성하고 있는 코드들의 디자인에 대해 더 신경쓰고, 다른 사람이 작성한 코드를 참고해보는 연습을 하고 있습니다.\n\n생성형 AI를 통한 코드 작성은 확실히 요즈음 많은 도움을 받고 있네요. 생산성과 동시에 제 개인적인 성장에도 크게 도움이 되고 있다고 느끼는 중입니다.\n\n스마트 시스템과 클라우드 컴퓨팅은 제가 요 근래 자주 가져오는 주제들 중에 비 정상적으로 엄청난 트래픽이 몰려들었을 때 이에 대해 resilient한 시스템을 어떻게 하면 설계할 수 있을 지에 대한 논의입니다. 이에 대해 go를 이용하면 더 유연한 시스템을 설계하는 데 유리하지 않을까 하는 생각이 들어 요 근래 학습을 시작해서 chatapplication을 작성하고 있습니다.\n\n---\n\n## [소프트웨어 아키텍처 및 기타 다이어그램을 코드로 생성할 수 있는 다양한 도구의 소개](https://medium.com/@techworldwithmilan/software-architecture-as-code-tools-331a11222da0)\n\n컴퓨터가 이해하는 프로그램은 코드이지만, 사람이 이해하기 위해서는 코드 외의 다양한 추상화 수단을 사용하는 것이 유용합니다.\n\n해당 아티클에서는 이미 작성된 코드를 자동으로 다이어그램으로 변환해주는 도구를 포함해서 markdown, javascript 등을 통해 마인드맵, 순서도 등을 생성할 수 있는 다양한 도구를 소개합니다.\n\n* [Structurizr](https://structurizr.com/)\n: C4 모델의 코드를 통해 소프트웨어 아키텍처 다이어그램을 생성할 수 있는 도구입니다.\n\n* [PlantUML](https://plantuml.com/ko/)\n: text를 통해서 UML를 작성할 수 있는 도구입니다.\n\n* [Diagrams](https://github.com/mingrammer/diagrams)\n: 파이썬 코드를 클라우드 시스템 아키텍처 다이어그램으로 변환해주는 도구입니다.\n\n* [Go diagrams](https://github.com/blushft/go-diagrams)\n: Diagrams와 동일하지만 go 언어를 사용하여 작성된 코드를 다이어그램으로 변환해주는 도구입니다.\n\n최근 디자인 패턴을 공부하면서 프로그램들을 이해하기 편하게 구조화하는 것의 필요성을 느끼고 있습니다. 다음에 읽으려고 생각하는 책 중 하나는 [UML 실전에서는 이것만 쓴다](https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000003215770)이기도 합니다.\n\n마침 작성중인 toy project가 go로 작성되어 있는 만큼 go diagrams를 사용해보고 이에 대한 경험도 공유해볼까 합니다.\n\n---\n\n## [개인용 AI 기술 뉴스 에이전트 구축하기](https://levelup.gitconnected.com/build-a-personal-ai-tech-news-agent-94e7a2e508fe)\n\n본 글은 개인용 AI 기술 뉴스 에이전트를 구축하는 방법에 대해 소개합니다.\n\n요 근래 제가 가장 많이 사용하는 뉴스 에이전트는 구글과 medium입니다. 일반적인 뉴스가 정치, 연예, 스포츠 등에 대해서는 훌륭하게 다뤄주는 경우가 많지만 기술 뉴스에 대해서는 그렇지 않은 경우가 많아서, 기술 뉴스를 따로 모아서 보고 싶은 생각이 들었습니다.\n\n마침 이에 대한 글도 있어서 읽어보게 되었는데 굉장히 매력있고 저만의 에이전트를 구축해보면 재미있겠다는 생각이 들었습니다. 현재 진행 중인 toy project가 끝나면 해당 프로젝트를 진행해보면 좋을 것 같습니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월 4주차 포스트","date":"2024-02-27T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-03-03-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-03-03-Medium review.md","category":"WeeklyPosts","title":"2월 5주차 포스트","subtitle":"","content":"\n1. \u003chttps://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42\u003e\n2. \u003chttps://levelup.gitconnected.com/system-design-interview-question-design-spotify-4a8a79697dda\u003e\n\n---\n\n## 자바스크립트는 왜 프로토타입을 선택했을까?\n\n: 자바스크립트에서 추상형태 명칭을 클래스가 아니라 프로토타입을 선택한 철학적인 논의\n\n프로그래밍의 패러다임은 더욱 높은 추상화를 구현하는 방향으로 발전하고 있습니다. 클래스는 우리가 이제는 자연스럽게 받아들이는 개념이지만, 자바스크립트는 클래스가 아닌 프로토타입이라는 개념을 선택했습니다. 지금은 ES6에 들어오면서 자바스크립트 역시도 클래스를 지원하고 있다고 합니다.\n\n클래스는 플라톤의 이데아의 관점에서 일정하게 변하지 않는 공통적인 특성을 추상화한 것이라면, 프로토타입은 비트겐슈타인의 전형적인 예시 관점을 통해서 사물을 그룹화하는 방식을 추상화한 것입니다. 그리고 이런 근간에 있는 아이디어를 통해 언어가 가지는 특질 전반적인 것이 바뀔 수 있다는 것을 알 수 있습니다.\n\n규모가 크고 오래 지속될 프로젝트일수록 내가 결정한 디자인적인 선택이 어떤 영향을 미칠지에 대해 충분히 고민해야 한다는 것을 알 수 있었던 좋은 글이었습니다. 기회가 된다면 이런 결정적인 디자인적인 선택들에 대한 이야기를 더 접할 수 있었으면 좋겠습니다.\n\n---\n\n## System Design Interview Question: Design Spotify\n\n: 수치적으로 더 큰 규모의 시스템을 설계하는 방법에 대한 논의\n\n이 글은 spotify와 같이 많은 유저가 이용해야하는 시스템을 설계할 때 어떤 부분을 고려해야하는 지에 대해 이야기해줍니다.\n\n만약 50만의 유저와 3000만 곡을 다루는 시스템을 설계한다면 이를 효과적으로 처리하기 위해 웹 서버에 대한 로드 밸런싱, db 설계는 어떻게 해야할 것인가?\n\n더 나아가서 5000만의 유저와 2억개의 곡을 다루는 시스템을 설계한다면 caching과 CDN, db scaling을 어떻게 도입해야할 지에 대한 이야기를 다룹니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월 5주차 포스트","date":"2024-03-03T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-03-10-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-03-10-Medium review.md","category":"WeeklyPosts","title":"3월 1주차 포스트","subtitle":"","content":"\n1. \u003chttps://medium.com/musinsa-tech/journey-of-a-frontend-monorepo-8f5480b80661\u003e\n2. \u003chttps://bootcamp.uxdesign.cc/dont-make-this-common-job-interview-mistake-cf0a22aedd02\u003e\n3. \u003chttps://levelup.gitconnected.com/30-python-concepts-i-wish-i-knew-way-earlier-3add72af6433\u003e\n\n---\n\n## 모노레포 이렇게 좋은데 왜 안 써요?\n\n모노레포는 여러 프로젝트를 하나의 저장소에 모아서 관리하는 개발 방식입니다. 이 글에서는 모노레포를 사용하면서 얻은 이점에 대해서 이야기합니다.\n\n최근에 채팅 어플리케이션 프로젝트가 생각보다 규모가 많이 거대해지면서 이를 관리하는 방법에 대한 고민을 하게 됐습니다. 사용하게 될 모듈별로 레포지토리를 따로 둬야 할까? git flow를 적용해야할까? trunk based development를 적용해야할까?\n\n그런 상황에서 이 글과 구글 엔지니어는 이렇게 일한다라는 책을 읽으면서 모노레포와 trunk based development를 사용하기로 결심하게 됐습니다.\n\n이는 충분한 관리를 적용한다면 모노레포와 trunk based development를 통해서 더 빠르게 개발할 수 있고, 안정적인 코드를 유지할 수 있을 것이란 생각이 들었기 때문입니다.\n\n구글이 아니라도 꽤나 많은 회사들이 모노레포를 사용하고 있다고 하는만큼 한번쯤 고민 해 볼만한 주제라고 생각합니다.\n\n---\n\n## Don’t make this common job interview mistake\n\n최근 많은 면접을 보면서 어떤 부분 때문에 면접에서 떨어지는지에 대해 고민을 많이 했습니다. 그리고 이 글에서 한 이야기와 데일 카네기의 '인간관계론'을 통해 제가 가지고 있었던 문제는 '상대가 원하는 것이 무엇인지'에 대한 고민이 부족했다라는 부분이란 생각을 하게 됐습니다.\n\n비단 면접에만 해당하는 부분이 아니라, 다른 사람과의 좋은 관계를 맺기 위해 그 사람의 입장을 이해하기 위해 경청하고 관심을 가지는 것은 중요한 요소입니다.\n\n나는 백엔드 개발자로써 회사에서 생각할 때 어떤 부분에서 기여를 할 수 있는 사람인가, 그렇다면 나를 원할만한 회사는 어떤 곳일까, 내가 기여할 수 있는 부분을 어필하기 위해서는 어떤 이야기를 준비해서 전달해야할까에 대해 고민해보게 됐습니다.\n\n---\n\n## 30 Python Concepts I Wish I Knew Way Earlier\n\n이 글은 파이썬을 사용하면서 사용하기 유용한 30가지 테크닠에 대해 이야기합니다. 기존에 몰랐던 것들만 따로 정리하자면 다음과 같습니다.\n\n1. pprint: 파이썬의 딕셔너리를 예쁘게 출력해주는 모듈\n2. ternary operator: 파이썬의 삼항 연산자\n   * ```python\n     a = 1 if b \u003e 0 else 0 if b \u003c 0 else -1\n     ```\n3. yield 키워드: 제너레이터를 만들 때 사용하는 키워드\n4. while else: while문이 break 없이 종료되었을 때 실행되는 else문\n\n이 밖에도 다양한 테크닉들이 있어서 한번쯤 읽어보면 좋을 것 같습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"3월 1주차 포스트","date":"2024-03-10T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-03-20-Medium review","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-03-20-Medium review.md","category":"WeeklyPosts","title":"3월 2주차 포스트","subtitle":"","content":"\n## 목차\n\n1. [개발자를 위한 10가지 유용한 VS Code 확장 프로그램](https://levelup.gitconnected.com/10-must-have-vs-code-extensions-for-developers-7ddc22d81117)\n2. [PostgreSQL vs MySQL: 나의 사용 사례에 더 적합한 것은 무엇일까?](https://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/)\n3. [블룸 필터 - 1% 오류율로 8배의 공간을 활용할 수 있는 자료구조](https://maloveforme.tistory.com/102)\n\n---\n\n## 10 Must-Have VS Code Extensions for Developers[^1]\n\nBetter Comments, Auto Rename Tag, Bookmarks, Import Cost와 같은 유용한 **VS Code 확장 프로그램**을 소개해주는 글입니다. 여기 있는 것들 중에서 상당 수를 해당 포스트를 읽어본 이후에 채용해봤는데 만족하고 있습니다.\n\n예를 들어 **VSCode - Icons** 같은 경우는 **Explorer 창**에서 파일들의 **아이콘**이 좀 더 **직관적**으로 보여지게 해 줍니다. 이는 파일을 찾는 데 유용할 뿐 아니라, 현재 프로젝트의 **구조를 파악**하는 데도 도움이 됩니다.\n\n**편의성**은 때로는 생각 이상으로 **생산성**을 높여주기도 하는데, 이 글에서 제안하는 확장 프로그램들이 그런 것들이 꽤 많았습니다.\n\n---\n\n## MySQL-쉽고 안정적이다 vs PostgreSQL-복잡한 문제 해결을 할 수 있다[^2]\n\n**PostgreSQL**과 **MySQL**은 둘 다 널리 쓰이는 **오픈 소스 RDBMS**입니다. 이 둘 중에서 어느 것을 선택해야하는 지에 대한 판단을 해야 하는 상황은 이 때문에 꽤나 흔합니다. 이 글은 이 둘의 **차이점**을 설명하고, 어떤 상황에서 어느 것을 **선택**하는 것이 더 **적합**한지에 대해 설명하고 있습니다.\n\n이 글에서 **핵심**은 다음으로 정리할 수 있습니다.\n\n```md\nMySQL: 쉽고, 빠르고 안정적이다.\nPostgreSQL: 복잡한 쿼리와 대규모 데이터베이스를 처리할 수 있는 풍부한 기능을 제공한다.\n```\n\n좀 더 자세하게 자신의 사용 사례에 어느 것이 **적합**할 지에 대해 정보가 필요하다면, 이 글을 읽어보시는 것을 추천합니다.\n\n---\n\n## 블룸 필터 - 1% 오류율로 8배의 공간을 활용할 수 있는 자료구조[^3]\n\n**블룸 필터**는 **확률적 자료 구조**로, **비트 배열**과 **해시 함수**로 구성되어 있습니다. 이 글에서는 블룸 필터의 **원리**와 **활용**에 대해 설명하고 있습니다.\n\n일반적인 자료구조들과 달리 블룸 필터가 **확률적**이 된 이유는 **공간을 절약**하기 위해서 입니다. 비록 *오류가 발생할 확률*이 있지만, 이보다 **공간을 절약**하는 것이 더 중요한 상황에서 블룸 필터를 사용할 수 있습니다.\n\n예를 들어 **100만 개의 URL**을 저장할 때 **일반적인 해시 테이블**을 사용한다면 최소 **25MB**의 공간이 필요하지만, 블룸 필터를 사용한다면 **1%**의 False Positive를 감수하면서 **1.13MB**의 공간으로 저장할 수 있습니다.[^4]\n\n최근 **대용량 데이터**를 **효율적**으로 처리하는 것에 관심이 많았는데, 그 방법 중 하나인 **블룸 필터의 원리**에 대해 알 수 있었던 좋은 글이었습니다.\n\n---\n\n[^1]: \u003chttps://levelup.gitconnected.com/10-must-have-vs-code-extensions-for-developers-7ddc22d81117\u003e\n[^2]: \u003chttps://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/\u003e\n[^3]: \u003chttps://maloveforme.tistory.com/102\u003e\n[^4]: [What is the advantage to using bloom filters - stack overflow](https://stackoverflow.com/questions/4282375/what-is-the-advantage-to-using-bloom-filters)\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"3월 2주차 포스트","date":"2024-03-20T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-03-25-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-1st/2024-03-25-Post reviews.md","category":"WeeklyPosts","title":"3월 3주차 포스트","subtitle":"","content":"\n## 목차\n\n1. [성능 테스트 툴을 통한 **Go** 알아보기 - Go의 개요](https://medium.com/@joaovitorcoelho10/building-a-performance-testing-tool-from-scratch-03dc7acb3687#cf59)\n2. [**API 게이트웨이**가 필요한 이유 - **마이크로 서비스**를 통합하기](https://medium.com/@dmosyan/why-do-you-need-api-gateway-770f10e02beb)\n3. [여기서는 안장을 팔지 않습니다 - 그리고 **slack**은 **채팅프로그램**이 아닙니다](https://medium.com/@stewart/we-dont-sell-saddles-here-4c59524d650d)\n\n---\n\n## **성능 측정기**를 처음부터 작성하기 - **Go의 특징** 개요[^1]\n\n작성자의 **[Jovi](https://github.com/joaovsc10/jovi/tree/main)**라는 어플리케이션을 개발하는 과정을 설명한 글입니다. 이 어플리케이션은 **성능 테스트 툴**로, **Go** 언어로 작성되었습니다.\n\n추후에 현재 프로젝트에서 **성능 측정을 위한 툴**도 만들어야하고 Go를 사용하지만 이에 대한 이해가 모자라단 생각도 많이 하고 있었는데, 이에 대한 정비를 할 수 있는 좋은 글이었습니다.\n\n---\n\n## **API 게이트웨이** - 마이크로 서비스 아키텍처의 **단일 진입점**[^2]\n\n현재 진행 중인 프로젝트는 **모놀리식 아키텍처**로 구성되어 있지만, **마이크로 서비스 아키텍처**에 대해 이해를 해야 현재 사용중인 아키텍처의 문제점을 파악하고 장점을 활용할 수 있을 것이라고 생각합니다. 이 때문에 마이크로 서비스 아키텍처에 관련한 글도 찾아보는 중입니다.\n\n저자가 설명하는 **API 게이트웨이**는 마이크로 서비스 아키텍처에서 시스템 가장자리에서 **단일 진입점**을 제공하는 역할을 합니다. 예를 들어 gRPC, RESTful API 등 **여러가지 프로토콜**을 다른 서비스로 제공하고 있을 때, 이를 **통합해서 접근**할 수 있도록 해줍니다.\n\n이 글에서 API 게이트웨이가 **해결할 수 있는 문제**라고 주장하는 것은 다음과 같습니다.\n\n* 프런트엔드와 백엔드 사이에 어댑터/파사드를 사용하여 **결합을 줄입니다**.\n* 백엔드 서비스를 집계/변환하여 **소비를 단순화**합니다.\n* 위협 감지 및 완화를 통해 **API의 남용을 방지**합니다.\n* API가 소비되는 방식 **이해**(관찰 가능성)\n* API **수명주기 관리**를 통해 API를 제품으로 관리\n* 계정 관리, 청구, 결제를 활용한 **API 수익화**\n\n**API 게이트웨이**부터 시작해서 **마이크로 서비스 아키텍처**에 대한 이해를 높이는 데 도움이 되었던 글이었습니다.\n\n---\n\n## **피상적인 것**이 아니라 사람이 원하는 **본질적인 것**을 어필하라[^3]\n\n**slack이 판매하는 것**은 무엇이라고 생각하시나요? 보통은 **채팅 프로그램**이라고 말할 것입니다. 하지만 저자는 그렇게 접근했으면 slack은 지금과 같은 성공을 거두지 못했을 것이라고 주장합니다.\n\n그렇다면 **slack이 판매하는 것은 무엇일까요?** 이에 대해 저자는 **조직 변화**를 판매했다 말합니다. 커뮤니케이션 비용 절감, 노력이 필요 없는 지식 관리 등을 통해 조직이 **더 나은 팀**이 되어 **성공**하도록 한다는 것입니다.\n\n마케팅이 단순히 제품을 **판매**하는 것이 아니라 **고객의 문제를 해결**하는 것이라는 것을 이해하고, 고객도 알지 못하는 **본질적인 욕망**을 제공하는 것이 중요하다는 것을 알 수 있었던 글이었습니다.\n\n특히 요 근래 스스로를 어필해야하는 상황이 많아지고 **스틱!**과 같은 책을 읽으면서 **마케팅**에 대해 고민하고 있었는데, 많은 도움이 됐습니다.\n\n---\n\n[^1]: \u003chttps://medium.com/@joaovitorcoelho10/building-a-performance-testing-tool-from-scratch-03dc7acb3687#cf59\u003e\n[^2]: \u003chttps://medium.com/@dmosyan/why-do-you-need-api-gateway-770f10e02beb\u003e\n[^3]: \u003chttps://medium.com/@stewart/we-dont-sell-saddles-here-4c59524d650d\u003e\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"3월 3주차 포스트","date":"2024-03-25T00:00:00.000Z","categories":"WeeklyPosts","subtitle":""}},{"postName":"2024-04-04-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-04-Post reviews.md","category":"WeeklyPosts","title":"3월 4주차 포스트","subtitle":"분산 dbms, 빌린 땅 위의 성, 일회용 사람, 색을 잃어가는 세상","content":"\n### 목차\n\n- [Postgres vs 분산 DBMS by TPC-C](#postgres-vs-분산-dbms-by-tpc-c)\n- [빌린 땅 위에 성을 짓지 말라: 하루만에 4천만 달러가 증발한 이유](#빌린-땅-위에-성을-짓지-말라-하루만에-4천만-달러가-증발한-이유)\n- [일회용 물건이 일회용 사람을 만들었다](#일회용-물건이-일회용-사람을-만들었다)\n- [왜 세상은 색을 잃고 있는가](#왜-세상은-색을-잃고-있는가)\n\n---\n\n## Postgres vs 분산 DBMS by TPC-C\n\n[포스트 링크](https://blog.ydb.tech/when-postgres-is-not-enough-performance-evaluation-of-postgresql-vs-distributed-dbmss-23bf39db2d31)\n\nPostgres는 복잡하고 거대한 데이터를 처리할 때 쓰이는 강력한 오픈소스 RDBMS입니다. 그렇지만 Postgres는 수직적 확장은 지원하지만 수평적 확장은 제한적입니다. 그리고 컴퓨팅 기기의 수직적 성능 향상이 더뎌진 시점에서 수평적 확장의 필요가 요즘 대두되는 경우가 많기 때문에 Postgres의 한계는 어느 정도인가, 그리고 이를 분산 DBMS인 YDB와 비교할 경우 어떤 차이가 있는지에 대해 TPC-C라는 OLTP 벤치마크를 통해 비교하고 있습니다.\n\n해당 비교가 이루어진 환경에서 Postgres는 분산 DBMS에 비해 불리한 입장이었습니다. 사용한 데이터베이스가 128개의 CPU코어를 사용하는 세 대의 서버로 구축되어 있었기 때문입니다. 그럼에도 불구하고 측정 기준으로 자주 쓰이는 tpmC(Transactions Per Minute per Core)에서 Postgres는 분산 DBMS에 비해 미세하게 앞서는 성능을 보여줬습니다. 하지만 New Order Latency에서는 YDB가 크게 앞섰습니다.\n\nPostgres는 이미 완성되어 자리잡은 오픈소스인 반면 YDB는 그 정도의 지위까지 획득하지 못했고, 분산형 DBMS가 아직 성장 중이란 것을 생각하면 어찌보면 당연한 일일 수도 있습니다. 그럼에도 현재 Postgres가 왜 많은 곳에서 부하가 높은 일을 처리해야할 때 사용하는지에 대한 이유를 엿볼 수 있었고, 분산 DBMS 역시도 가능성이 있다는 것을 확인할 수 있었습니다.\n\n---\n\n## 빌린 땅 위에 성을 짓지 말라: 하루만에 4천만 달러가 증발한 이유\n\n[포스트 링크](https://medium.com/illumination/wittyfeed-a-40-million-company-that-evaporated-overnight-the-reason-facebook-blocked-them-b7b38c750399)\n\n흔히 유니콘이라 불리는 스타트업은 기업 가치가 10억 달러 이상인 10년 이하 비상장 기업을 말합니다. Witty Feed는 이에 근접했었던 기업으로, 바이럴 미디어 컨텐츠를 페이스북을 통해 공유하는 사업을 했습니다. 그리고 한 달 만에 100만 달러의 수익을 낼 정도로 성장했고 트래픽은 수백만명에 달했습니다. 그리고 그 트래픽은 하루만에 단 몇 천명으로 줄었고 수익은 0으로 떨어졌습니다.\n\n이 몰락은 페이스북에서 캠브릿지 애널리티카라는 회사가 페이스북 사용자의 개인 데이터를 정치 광고를 위해 무분별하게 침해했다는 이유로 페이스북이 연방거래위원회로부터 50억 달러의 벌금을 부과 받은 것에서 시작했습니다. 페이스북은 트래픽 알고리즘을 완전히 변경했고 WittyFeed의 플랫폼을 해제했으며 도메인을 차단했습니다.\n\n이 때문에 WittyFeed는 계좌에 돈이 한 푼도 남지 않았고, 직원들은 급여를 받지 못했습니다. 하지만 창립자들은 이 사태에서 미지급 급여의 두 배에 해당하는 회사 지분을 제공하고 마침내 새로운 OTT 플랫폼인 Stage를 구축하는데 성공합니다. 현재 Stage의 가치는 약 4천만 달러에 달합니다.\n\n이처럼 자신이 소유하지 않은 독점적인 플랫폼에 의존하는 것은 위험하다는 것을 배울 수 있는 글이었습니다. 또한, 이러한 위험을 줄이기 위해 다양한 플랫폼에 투자하고 자체 플랫폼을 구축하는 것이 중요하다는 것을 배울 수 있었습니다.\n\n---\n\n## 일회용 물건이 일회용 사람을 만들었다\n\n[포스트 링크](https://medium.com/@ashely.crouch/how-disposable-objects-have-lead-to-disposable-people-7e52096b1b23)\n\nBic 펜, Temu, Hinge. 이것들의 특징은 무엇일까요? 그것은 이들이 우리에게 한 번 사용하고 버릴 수 있는 편리한 것임을 강조한다는 것입니다. 우리에게 위 제품들은 필요할 때 잠깐 쓰고, 필요 없을 때는 버릴 수 있으면 되니 편하게 사용해보라고 이야기합니다. 그리고 이들을 사용하기 시작하는 순간, 우리는 이들에게서 벗어날 수 없게됩니다. 이것이 우리 삶을 파괴하더라도 말입니다.\n\n이처럼 이들은 본인의 일회성을 강조하지만, 저자는 그 일회성이 종속성을 가지고 있으며 파괴적이라고 주장합니다. 그리고 이것들이 가져다주는 사회적인 폐단으로 여러가지가 있으며, 이 중 Hinge와 같이 사람의 관계에 영향을 주는 일회용품은 타인과의 관계를 파괴하는 지경에 이르렀다고 말합니다. 그리고 끝내는 이를 사용하는 사람을 일회용으로 만들고 있다는 것이 저자의 주장입니다.\n\n사회적으로 인기를 끌고 있는 많은 제품들이 편리함을 내세울 때, 과연 그것은 우리가 편리한 삶을 살 수 있게 해주는 것인지 아니면 이들에 종속되는 일회용 삶을 살게 하는 것인가에 대한 의문을 가지게 하는 글이었습니다. 그리고 내 삶이 지속성을 가지게 하기 위해서는 어떤 노력을 해야하는지 되돌아보게 됐습니다.\n\n---\n\n## 왜 세상은 색을 잃고 있는가\n\n[포스트 링크](https://uxdesign.cc/why-is-the-world-losing-color-56f740f465d4)\n\n이 포스트는 문화 전반에서 화려한 색상이 사라지고 검정색, 회색, 흰색 같은 단조로운 색상이 주를 이루고 있는 현상이 나타나고 있다고 주장합니다.\n\n![1844년 전보](https://miro.medium.com/v2/resize:fit:4800/format:webp/0*jrgZGtQsEeJ8crpD.png)\n출처: \u003chttps://lab.sciencemuseum.org.uk/colour-shape-using-computer-vision-to-explore-the-science-museum-c4b4f1cbd72c\u003e\n\n![2008년 핸드폰](https://miro.medium.com/v2/resize:fit:4800/format:webp/0*dm_T3vkzCNcZ4K_I.png)\n출처: \u003chttps://lab.sciencemuseum.org.uk/colour-shape-using-computer-vision-to-explore-the-science-museum-c4b4f1cbd72c\u003e\n\n그리고 이것은 대량 생산과 표준화를 위해 개성이 희생되는 과정으로 볼 수 있다고 합니다. 어린 시절 집에 있었던 뻐꾸기 시계와 같은 것들은 굉장히 다채로운 색을 가지고 있었던 것으로 기억합니다. 이전보다 개성을 중시하는 시대를 살고 있다고 생각했는데 이와 반대되는 현상도 동시에 나타나고 있단 것을 인지하지 못하고 있었다는 것이 꽤나 충격적이었습니다.\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"3월 4주차 포스트","subtitle":"분산 dbms, 빌린 땅 위의 성, 일회용 사람, 색을 잃어가는 세상","date":"2024-04-04T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-10-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-10-Post reviews.md","category":"WeeklyPosts","title":"4월 1주차 포스트","subtitle":"자유를 판매하는 상인, 버락 오바마의 결정 방법론","content":"\n### 목차\n\n- [나는 자유를 판매하는 상인입니다](#나는-자유를-판매하는-상인입니다)\n- [내가 가장 어려운 결정을 하는 방법](#내가-가장-어려운-결정을-하는-방법)\n\n---\n\n## 나는 자유를 판매하는 상인입니다\n\n[포스트 링크](https://www.youtube.com/watch?v=d6e41W6ZjtY)\n\n기술을 통해 기존에 없었던 물건을 만드는 것은 쉽습니다. 하지만 사용자가 원하는 물건을 만드는 것은 그것을 단순히 만드는 것을 넘어서서 가치를 부여했을 때 이루어지기 때문에 훨씬 어렵습니다. 그 점에서 현대 자동차의 아이오닉 5 로보택시 운전면허 도전 광고는 굉장히 인상 깊었습니다. 본인들의 상품이 어떤 점에서 뛰어난 지에 대해 자랑하는 것이 아니라, 본인의 상품이 도움이 가장 절실한 사회적 약자들에게 자유라는 인류 최고의 가치 중 하나를 제공한다고 이야기하는 방식 때문입니다. 그 사람들은 바로 시각 장애인입니다.\n\n이 광고는 시각 장애인들이 다른 사람들이 누리고 있는 자유를 어떻게 박탈 당하는가부터 이야기를 시작합니다. 우리는 시각 장애인들이 많고 이들이 힘든 삶을 보낸다는 사실을 인식하지 못하지만, 그 이유는 그들이 밖에서 행동하기에 불편하고 이 때문에 이동의 자유가 없기 때문에 그들이 우리 눈에 띄지 않을 뿐이라는 불편한 진실에 대해 이야기합니다. 그리고 그런 시각 장애인 중에 대표로 나온 것이 말이라는 탑승 수단을 애용하던 'Pearl Outlaw'라는 여성이라는 것은 상징적입니다. 마치 시대의 이동수단이 말에서 자동차로 넘어간 것처럼, 그녀에게 새로운 자유를 위해 시대가 넘어갈 것을 암시하는 것처럼 느껴지기 때문입니다.\n\n그녀를 위한 자율 자동차의 면허를 발급할 시험관은 25년 동안 31,500명의 시험 평가를 치르고 16%만의 합격률을 판정내린 베테랑 면접관 'Kandice Jones'입니다. 그런 시험관의 평가를 통해 자율주행에 대한 신뢰를 확보하고자 하는 것 또한 인상 깊습니다. 그리고 그런 그녀는 아이오닉5에 만점 판정을 합니다.\n\n자율 주행은 그 유용성이 높을 것이라 생각되지만, 반발 역시도 크고 그 유용성 역시도 아직 경험하지 못했기에 사람들에게 와닿지 않고 있었다 생각합니다. 이번 광고를 통해 현대 자동차는 그들이 판매하는 상품이 자율주행을 하는 자동차가 아니라, 새로운 자유라는 가치라고 이야기하고 있습니다. 이런 마케팅적인 발상 전환이 굉장히 멋있었습니다.\n\n---\n\n## 내가 가장 어려운 결정을 하는 방법\n\n[포스트 링크](https://barackobama.medium.com/how-i-approach-the-toughest-decisions-dc1b165cdf2d)\n\n답이 없는 어려운 결정을 내리는 것은 인생에서 피할 수 없지만 가장 어려운 일들입니다. 그 중에서도 미국의 대통령이 해결해야하는 문제들은 다른 사람이 겪을 수 없을 만큼 어렵고 수 많은 사람에게 영향을 미치는 만큼 막중한 책임이 따르게 됩니다. 그런 만큼 미국 대통령은 이런 문제를 해결하는 데 있어서 가장 어려운 경험을 많이 한 사람이라 할 수 있습니다.\n\n그런 미국 대통령 중 버락 오바마는 존경할 부분이 많다고 생각합니다. 그가 하는 연설에서부터 생각이 얼마나 깊은지 엿볼 수 있고, 내리는 결정들이 사회적으로 널리 이롭게 작용할 수 있도록 노력한다는 것을 알 수 있기 때문입니다. 그런 그의 결정 방식은 다음과 같은 지침을 따른다고 밝혔습니다.\n\n- 직감을 따르지 말고 건전한 의사 결정 프로세스를 따르라\n  - 전문가의 의견을 진심으로 듣고 사실을 따르라\n  - 회의에 참여하는 모든 사람의 의견에 귀기울여라\n- 자신의 의견에 반대하는 사람과 일해라\n- 인간 관계를 통해 자신을 확인하고 휴식하는 시간을 가져라\n\n이를 요약하면 자신의 판단에 대해 비판적이고 객관적으로 평가받을 수 있는 환경에 있으려고 노력하라고 이해할 수 있습니다. 결국 답이 없는 문제에 대해 해결한다는 것은 그만큼 다양한 관점을 반영해야 하고, 이를 단순히 노력이 아니라 시스템과 환경을 조성하려는 노력이 필요하겠다는 생각을 하게 됐습니다. 동시에 그런 힘든 환경에서 일한다면 자신을 확인하고 휴식하는 시간을 가져야 한다는 것도 알 수 있었습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 1주차 포스트","subtitle":"자유를 판매하는 상인, 버락 오바마의 결정 방법론","date":"2024-04-10T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-15-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-15-Post reviews.md","category":"WeeklyPosts","title":"4월 2주차 포스트","subtitle":"첫번째 팬케이크는 버려라, 기술 직군 경력 우선순위, 2023년 top programming languages","content":"\n### 목차\n\n- [첫번째 팬케이크는 버려라](#첫번째-팬케이크는-버려라)\n- [기술 직군에서 경력을 쌓을 때 우선순위 가이드](#기술-직군에서-경력을-쌓을-때-우선순위-가이드)\n- [2023년 top programming languages](#2023년-top-programming-languages)\n\n---\n\n## 첫번째 팬케이크는 버려라\n\n[포스트 링크](https://medium.com/weirdo-poetry/the-first-pancake-principle-a67e374bceea)\n\n창의적이거나 매력적인 아이디어에 흥미를 느꼈다가 막상 시작하면 본인이 생각하지 못했던 난관들 때문에 압도되는 일이 자주 생깁니다. 저 같은 경우는 이번에 진행한 [채팅 프로젝트](https://github.com/kaestro/chatapplication) 같은 경우가 그랬습니다. 동시 수용 인원 15000명과 1분당 7천개의 메시지 수신을 중계하는 서버를 구축한다는 아이디어는 얼핏 봤을때 너무 매력적이었습니다. 그리고 여기에 사용하면 될 것이라 생각한 기술 스택도 마찬가지였습니다. 그리고 저는 그 아이디어를 구현하기 위해 무작정 시작했고, 압도되는 난관들을 마주했습니다.\n\n저자는 본인이 보이 스카우트 때 팬 케이크를 구우면서 배운 원칙을 통해 이 일은 자연스러운 일이며 오히려 \"신에 대한 희생\"이라고 표현합니다. 이는 무엇을 실제로 시작하기 전에는 무슨 일이 일어날 지 알 수 없기 때문에 조정하는 과정에서는 실패가 발생하는 게 당연하다는 이야기입니다. 마치 팬케이크를 굽기 위한 팬이 처음에 적절하게 달궈졌는지 확인하기 위해 첫번째 팬케이크를 버리는 것처럼 말이죠. 그리고 이 때문에 저자는 첫번째 팬케이크는 버리는 마음가짐을 통해 기대의 부담을 벗어나야 상상력을 제대로 발휘할 수 있다고 말합니다.\n\n저자는 이를 이용해서 본인이 하이쿠로만 말하는 로봇에 관한 연재 만화를 그린 일화를 추가로 제시합니다. 처음에는 모자랐지만 그 아이디어가 완벽해질 때까지 기다렸다면 아무것도 만들어지지 못했을 것이라는 말과 함께요. 이처럼 무언가를 시작할 때 완벽을 추구한다는 잘못된 목표를 가지지 않도록 해야겠습니다.\n\n---\n\n## 기술 직군에서 경력을 쌓을 때 우선순위 가이드\n\n[포스트 링크](https://dnastacio.medium.com/hierarchy-of-career-priorities-c18768d32598)\n\n저자는 Maslow의 욕구 계층 구조를 참고하여 기술 직군에서 경력을 쌓을 때 우선순위를 제안하고, 이를 기반으로 한 자신이 배운 것들을 공유합니다. 이를 참고하면 기술 직군에서 경력을 쌓을 때 어떤 것에 집중해야 하는지에 대한 가이드가 될 수 있을 것이라는 생각을 하게 됐습니다.\n\n![우선순위 계층](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*8tp3caPQO7klijrsv2JDlw.png)\n\n```plaintext\n1. 고용 가능성\n2. 보상과 안정성\n3. 성장과 발전\n4. 일과 삶의 균형 및 웰빙\n5. 목적과 의미\n```\n\n위의 예시들을 통해 4가지 교훈을 제시합니다.\n\n```plaintext\n1. 기술 스택이 고용 가능성을 정의한다.\n2. 노후화 기간인 3년: COBOL\n3. 최첨단을 주의하라.\n4. 고도로 전문화된 도메인 프로젝트를 주의하라.\n```\n\n우선 제품 기술 스택이 직원에게 고용 가능성 관점에서 가장 중요한 요소라는 이야기로 시작합니다. 이는 현재 작업을 이어나갈 사람을 구하는 것과 동시에 이후에 이를 이어받을 사람을 시장에서 구하는 것이 용이해진다는 의미이기 때문입니다. 이 때문에 노후화되고 인기가 없는 기술 스택을 사용하는 상사는 사람을 그만두게 할 수 있다고 이야기합니다.\n\n그리고 이런 기술의 트렌드는 전반적으로 3년을 주기로 변화하고 있으며, 그 예시로 COBOL을 듭니다. 그리고 다음의 github 사용자 활동 분석을 제시해서 이를 뒷받침합니다. 이 트렌드를 보며 javascript, typescript와 같은 기존에 크게 주목하지 않았던 언어에 대해 생각해보고 다른 글들도 찾아보게 됐습니다.\n\n![언어 선호도 변화 추이](https://camo.githubusercontent.com/8718666e98e034746add66bab1ba74bcb6d8670266b2fcc1b9dfef3cff621db7/68747470733a2f2f6d69726f2e6d656469756d2e636f6d2f76322f726573697a653a6669743a313130302f666f726d61743a776562702f312a4b59634534697a49396d5042484c4e71735f787552412e706e67)\n\n그렇지만 그렇다고 하여 최첨단의 것을 추구하는 것이 가지는 위험성에 대해서도 경고하며, 특정 기술 스택에 지나치게 의존되어 있지 않도록 주의하라고 이야기합니다. 이는 특정 기술 스택에 의존하게 되면 그 기술 스택이 노후화되거나 인기가 없어질 때 큰 타격을 받을 수 있기 때문입니다.\n\n---\n\n## 2023년 top programming languages\n\n[포스트 링크](https://linuxiac.com/github-top-programming-languages-of-2023/)\n\n| Ranking | Programming Language | Percentage |\n|---------|----------------------|------------|\n| 1       | Python               | 17.715%   |\n| 2       | Java                 | 11.086%   |\n| 3       | Go                   | 10.817%   |\n| 4       | JavaScript           | 10.065%   |\n| 5       | C++                  | 9.712%    |\n| 6       | TypeScript           | 7.610%    |\n| 7       | PHP                  | 4.835%    |\n| 8       | Ruby                 | 4.690%    |\n| 9       | C                    | 4.309%    |\n| 10      | C#                   | 3.531%    |\n\n생각하는 것과 언어 사용의 지표가 많이 다르고, 여러 방면으로 찾아 볼 필요가 있겠다는 생각을 하게 됐습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 2주차 포스트","subtitle":"첫번째 팬케이크는 버려라, 기술 직군 경력 우선순위, 2023년 top programming languages","date":"2024-04-15T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-21-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-21-Post reviews.md","category":"WeeklyPosts","title":"4월 3주차 포스트","subtitle":"","content":"\n### 목차\n\n- [good first issue 라벨을 이용하여 오픈소스 기여하기](#good-first-issue-라벨을-이용하여-오픈소스-기여하기)\n- [빨리빨리? 불안증? 뇌과학자가 소개하는 한국인이 분노하는 이유?](#빨리빨리-불안증-뇌과학자가-소개하는-한국인이-분노하는-이유)\n- [외톨이? 고독사? 한국이 세상에서 가장 외로운 나라가 된 이유?](#외톨이-고독사-한국이-세상에서-가장-외로운-나라가-된-이유)\n- [구글 검색에 블로그 노출시키기](#구글-검색에-블로그-노출시키기)\n- [고루틴의 동작 원리에 관하여](#고루틴의-동작-원리에-관하여)\n\n---\n\n## good first issue 라벨을 이용하여 오픈소스 기여하기\n\n[포스트 링크](https://well-balanced.medium.com/%EA%BC%BC%EC%88%98%EB%A1%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0-b34ee4cc2bc2)\n\ngood first issue 라벨을 이용하면 오픈 소스에 기여하는 것이 쉬워진다는 이야기이다. good first issue는 기존의 개발자들이 해결하기 쉬우면서도 진입점으로 사용하기 좋은 이슈들을 해결하지 않고 새로 오픈 소스에 기여하려는 사람들을 위해 남겨두는 라벨이다. 이러한 이슈들을 만든다는 것 자체가 일을 체계적으로 하고 깃허브 생태계에 대한 이해도가 높다는 의미여서 해당 라벨을 기준으로 검색을 하니 확실히 관리가 잘 되고 있는 레포지토리이면서 새로운 사람을 필요로하는 것들을 찾을 수 있었다.\n\n이를 통해 현재 tagsy-discord, vizro와 같은 오픈 소스 프로젝트에 참여를 하는 중이다.\n\n---\n\n## 빨리빨리? 불안증? 뇌과학자가 소개하는 한국인이 분노하는 이유?\n\n[포스트 링크](https://www.youtube.com/watch?v=AJSscwZP1Xs)\n\n최근 한국을 세계에서 가장 우울한 나라라는 이야기가 화제가 되고 있다. 이를 한국은 시스템이 잘 되어 있기 때문에 예측이 가능한 영역이 많아 문제가 되고 있다는 관점이었다. 왜냐하면 예측이 어긋날 때 사람은 고통을 느끼기 때문이다. 이런 예시로 한국은 지하철을 탈 때 환승을 위한 열차 칸과 출구 조차도 신경쓴다는 이야기를 한다. 이와 반대 되게 예측하는 능력이 없으면 불안은 오지 않는다고 하며 그 예시로 아기가 어머니가 집을 나가는 것을 경험하고 예측하게 되는 순간부터 불안을 느끼게 되는 것을 이야기한다.\n\n한국은 이런 예측 가능성 때문에 통제에 대한 욕구가 굉장히 강한 경향을 가지고 있다. 대표적인 것이 사주팔자나 MBTI 같은 것을 통해 사람을 예측하려고 하는 유행이 있다. 여기에 더해 한국은 사회적으로 시기별로 삶에 대해 약속이 어느 정도 되어 있다. 공부를 열심히해서 어느 정도 대학을 가면 어느 정도의 회사를 가고 와 같은 그런 약속이다. 그리고 그런 계획이 깨졌을 때 굉장히 조급해지고, 불안하면서, 분노하게 되는 것이다.\n\n이런 한국의 불안에 대한 근본적인 해답으로 장동선 박사님은 다양성을 존중하는 자세에 대해 이야기한다. 사람들이 다들 비슷한 약속에 맞춰서 사는 그런 트랙이 있는 것이 아니라 다른 형태의 삶을 산다는 것을 인정할 수 있게 되면 이런 불안감을 줄일 수 있을 것이란 이야기이다. 한국은 그런 점에서 다양성과 자유가 굉장히 부족한 나라라고 이야기한다.\n\n결국 행복하게 잘 살기 위해서는 스스로 선택하는 자율성이 필요하고, 누군가 만들어놓은 틀 안에서 살아가지 않는 노력을 해야 한다는 것이다. 이런 이야기를 통해 나 역시도 이전에는 굉장히 우울했던 경우가 있었고 그런 사회적인 배경에서 비슷한 경험을 했었다는 생각을 하게 됐다.\n\n---\n\n## 외톨이? 고독사? 한국이 세상에서 가장 외로운 나라가 된 이유?\n\n[포스트 링크](https://www.youtube.com/watch?v=U5U_jK-xJjM)\n\n한국은 가장 불안한 나라에 이어서 가장 외로운 나라로 평가받고 있다. 대표적으로 한국은 집에서 혼자 있는 것을 가장 좋아하고, 가족과 같이 있어도 외롭다고 느낀다. 이는 집에서도 자기 모습이 아닌 상태로 살아가야 하는 경우가 많기 때문이다.\n\n그렇다면 한국인은 왜 집에서도 온전히 자신의 모습을 보이지 못할까? 그것은 다른 사람의 눈치를 많이 봐야 하기 때문이다. 남이 나를 어떻게 생각할까? 그런데 내가 하고 싶은 말은 무엇인가? 그것은 Destructive social shaming 즉 파괴적으로 사회적인 수치심을 주는 일이 굉장히 많이 일어나기 때문이라고 한다. 대표적인 예시로 연예인들이 연애 등에서 문제가 생기면 그것이 굉장히 큰 사회적인 이슈로 불거지면서 압박을 받게 되는 것을 든다. 이렇기 때문에 한국 사람들은 마음 속으로 꾹꾹 눌러두는 일이 많을 것이라 한다.\n\n이렇게 만성 스트레스를 받으면 사람은 해마가 작아져서 기억력이 나빠지고 학습 능력이 떨어지고, 편도체로 인해 우울 기능이 떨어지며, 전두엽에 악영향을 줘 판단력이 저하된다고 말한다.\n\n||자본주의|유교문화|\n|---|---|---|\n|**단점**|물질주의|눈치\u0026서열|\n|**장점**|개인표현|가족\u0026화합|\n\n이라는 가치들이 있을 때 이들 중에서 안 좋은 것만이 결합된 문화를 가지고 있다는 것이다. 한국 사회가 이런 외로움이 적어지기 위해 1편과 이어져서 놀라움과 예상하지 못한 새로운 인연들이 생기는 것이 중요하다고 이야기를 마치면서 외로움이 무엇인가에 대해 다시 생각해보는 계기가 됐다.\n\n---\n\n## 구글 검색에 블로그 노출시키기\n\n[포스트 링크](https://jsy1110.github.io/2022/google-search-console/)\n\n여태까지 약 4개월이 조금 안되는 기간동안 블로그를 운영하는 중인데, 내 닉네임으로 검색을 하는데 구글 검색창에 나오지 않는다는 사실에 무엇이 문제인지 고민이 많았다. 이전에 google search console에 인증을 해 놨으니 블로그가 검색에 노출되어야 한다고 생각했었고, 단순히 트래픽이 발생하지 않기 때문이라 생각했는데 그것은 아니라는 생각이 들었기 때문이다.\n\n이번에 url을 인덱싱함과 동시에 sitemap을 추가하고, robots.txt 파일 또한 추가해서 검색 엔진이 블로그를 크롤링할 수 있도록 설정을 마쳐둔 상태이다. 아직은 사이트맵 처리만 완료된 상태이고, 크롤링은 되지 않아 내가 수동으로 요청을 해 둔 인덱스만 생성이 돼있다. 이를 더 일찍 했으면 좋았을텐데 아쉬웠고, 개인 블로그를 운영하는 경우에 내가 구현하지 않은 것은 대부분의 경우에 돌아가지 않는다는 사실을 다시금 깨닫는다. 그래도 블로그를 운영하면서 인터넷에 대한 지식이 많이 쌓이고 있는 것을 느낄 수 있었던 귀한 경험이었다.\n\n---\n\n## 고루틴의 동작 원리에 관하여\n\n[포스트 링크](https://ykarma1996.tistory.com/188)\n\n얼마 전 당황해서 고루틴은 프로세스냐 스레드냐는 질문에 프로세스라는 대답을 한 적이 있다. 이는 고루틴은 경량 스레드이지만 스레드는 아니고 병렬보다는 동시성을 활용하기 위해 커널을 통하지 않고 내부적으로 관리하는 컨텍스트 스위칭을 하니까 프로세스라는 잘못된 결론에 도달했었기 때문이다.\n\n추가적으로 조사하면서 goroutine은 runtime scheduler에 의해 green thread로 관리되는 스레드이며, 결론적으로는 스레드라고 부를 수 있다. 다만 시스템콜을 직접적으로 사용하는 goroutine은 스레드라기보다는 프로세스 내에서 관리되는 경량 스레드이므로 양쪽에 속하지 않는다고 말할 수 있을 것 같다. 이런 포스트가 아니라 책을 통한 공부도 한번 쯤 깊게 해 볼 필요가 있을 것 같다.\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 3주차 포스트","subtitle":"","date":"2024-04-21T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-28-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-28-Post reviews.md","category":"WeeklyPosts","title":"4월 4주차 포스트","subtitle":"제목, 관리, 놀이, 스마트폰 사용량","content":"\n### 목차\n\n- [How to Write a Compelling Headline That Isn’t Clickbait](#how-to-write-a-compelling-headline-that-isnt-clickbait)\n- [당신은 충분히 관리하고 있지 않습니다](#당신은-충분히-관리하고-있지-않습니다)\n- [There's something about a run in the rain](#theres-something-about-a-run-in-the-rain)\n- [My Daily Smartphone Usage Reduced By 90% Using This Simple System](#my-daily-smartphone-usage-reduced-by-90-using-this-simple-system)\n\n---\n\n## How to Write a Compelling Headline That Isn’t Clickbait\n\n[포스트 링크](https://blog.medium.com/how-to-write-a-compelling-headline-that-isnt-clickbait-7cb816cec438)\n\n최근 글을 쓰면서 좋은 제목을 작성하는 것에 많은 고민을 하게 된다. 글의 내용을 잘 표현하면서도 사람의 눈길을 끌 수 있는 제목을 만드는 것은 프로그램에서 메소드 이름을 작성하는 것과 비슷하지만, 그것보다는 훨씬 더 어려운 일이다. 내 최근 글의 제목들에는 많이 발전하고 있지만 아직 과하게 어그로성이 짙거나, 글의 내용을 함축하지 못하기도 하고, 지나치게 설명이 모자랄 때도 있다.\n\n여기서 이야기하는 헤드라인의 지침은 다음과 같다.\n\n```markdown\n1. 독자가 일하게 만들지 말라 - 독자가 글에 관심을 가져야하는지 판단하는데 필요한 모든 정보를 제공하라.\n2. 청중에게 적합한 언어를 사용하라 - 일반 독자 대상이라면 전문 용어는 사용하지 말라.\n3. 흥미로운 것에 집중하라 - 모든 내용을 다룰 필요는 없다. 이야기의 가장 흥미로운 부분에 초점을 맞춰라.\n4. 중요성을 어필하라 - 이 글이 독자에게 왜 중요한지를 강조하라.\n```\n\n그리고 이를 활용하는 헤드라인 작성 방법 5단계를 다음과 같이 정리한다.\n\n```markdown\n1. 사실대로 말하라 - 헤드라인은 글의 내용을 정확하게 반영해야 한다.\n2. 흥미롭게 만들라 - 흥미로운 측면에 집중해서 독자가 읽고 싶을법하게 만들어라.\n3. 간결하게 작성하라 - 가능한 간결하면서 설득력이 있어야 한다.\n4. 단호하게 표현하라 - 주장을 하려는 글의 경우 단호해야 한다.\n5. 다른 사람에게 읽어달라 부탁하라 - 다른 사람에게 읽어보라고 부탁하면서 피드백을 받아라.\n```\n\n헤드라인을 요즈음 작성하는 데 도움이 많이 되는 내용이었다.\n\n---\n\n## 당신은 충분히 관리하고 있지 않습니다\n\n[포스트 링크](https://medium.com/onebigthought/youre-not-managing-enough-56dfc99519fd)\n\n암벽 등반에서 아래에서 등산가의 안전을 유지하기 위한 빌레이가 하는 일의 비유를 통해, 업무에서 관리자가 해야하는 일에 대해 이야기한다. 관리자는 상대에 대한 마이크로 관리를 하는 것은 지양해야하지만, 상대에게 성장할 수 있는 공간하는 것을 제공하고 격려하면서 기다리는 수동적인 위치에만 있어서는 안된다. 저자는 이를 위해 세가지 방법론을 제시한다.\n\n```markdown\n1. 명확성을 제공하라 - 명확한 목표, 동기, 기대치를 방법은 규정하지 않되 전부 제공하라.\n2. 액세스, 컨텍스트를 제공하라 - 상대가 필요한 정보에 접근할 수 있도록 하고, 그 정보가 어떤 맥락에서 필요한지를 제공하라.\n3. 계획을 세우라 - 상대가 성공적으로 일을 할 수 있도록 단계와 이정표를 세우라\n```\n\n그리고 위의 것들을 꾸준히 해야한다 이야기한다. 일종의 오픈소스 프로젝트를 한 것인 chat application의 경우 나도 이런 부분들이 모자랐기 때문에 실패했고 이를 개선하고 싶고 해당 방법론을 채용하려한다.\n\n---\n\n## There's something about a run in the rain\n\n[포스트 링크](https://medium.com/runners-life/theres-something-about-a-run-in-the-rain-7afbf4a79810)\n\n**우리는 늙었다고 노는 것을 멈추지 않는다. 다만 놀지 않기 때문에 늙어갈 뿐이다.**라는 조지 버나드 쇼의 유명한 문구로부터 시작하는 이 글은, 비가 올 때 달리기를 한 경험에 대해서 이야기한다. 달리기를 놀이가 아니라 수단으로 생각한다면 비가 오지 않을 때에만 달리기 할 것이지만, 놀이로 생각하기 때문에 본인은 비가 올 때에도 달리기를 할 수 있었다 이야기한다. 그리고 이를 통해 놀이의 중요성에 대해 이야기한다.\n\n나도 요즈음 글쓰기와 달리기를 놀이로써 즐기고 있기 때문에 많은 부분이 공감이 됐고, 내가 하는 일이 쓸모없는 일이 아니라는 위안을 얻을 수 있었다.\n\n---\n\n## My Daily Smartphone Usage Reduced By 90% Using This Simple System\n\n[포스트 링크](https://medium.com/publishous/the-dss-system-that-helped-me-cut-my-daily-smartphone-usage-by-90-aa2d88889e30)\n\n스마트폰 사용량을 줄이기 위한 방법으로 업무용과 개인용으로 나누어 사용하는 방법을 소개한다. 저자는 이를 나눈 뒤에 개인용 스마트폰의 경우 사용 시간 제한을 두면서 스마트폰 사용량을 줄였다고 이야기한다.\n\n나 역시도 비슷한 경험을 lenovo y700 태블릿을 구매하면서 느꼈다. 업무용으로 연락하는 것은 핸드폰에, 취미 생활과 공부라는 용도로 태블릿을 사용하도록 분리하면서 이전과 달리 이들을 사용하느라 쓸모없는 시간을 보내는 양이 많이 줄어들었다.\n\n핸드폰 같은 경우 아직 이를 더 줄이는 노력을 할 필요가 있다고 느끼고 이 때문에 폰을 분리하는 것도 고려해보려한다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 4주차 포스트","subtitle":"제목, 관리, 놀이, 스마트폰 사용량","date":"2024-04-28T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-05-05-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-05-05-Post reviews.md","category":"WeeklyPosts","title":"5월 1주차 포스트","subtitle":"히어로와 잡부, 자동화의 중용","content":"\n### 목차\n\n- [히어로를 채용하고 잡부를 만드는 스타트업](#히어로를-채용하고-잡부를-만드는-스타트업)\n- [루브 골드버그 장치와 같은 지나친 자동화를 경계하자](#루브-골드버그-장치와-같은-지나친-자동화를-경계하자)\n- [Golang: Improving Your Go Project with Pre-Commit Hooks](#golang-improving-your-go-project-with-pre-commit-hooks)\n\n---\n\n## 히어로를 채용하고 잡부를 만드는 스타트업\n\n[포스트 링크](https://eopla.net/magazines/15449)\n\n사람을 기반으로하는 스타트업에서 능력 있는 인재를 뽑은 다음에 팀으로 만드는 것에 실패하는 경우들에 대해 이야기한다. 문제를 해결할 수\n 있는 능력이 있는 사람은 누구나 히어로이고 그 사람을 뽑는 것은 일반적으로 다른 히어로가 나가는 것과 맞물리게 된다. 그러나 이 히어로가\n 나간 자리를 다시 채우는 경우는 없고, 그러면 이전의 사람이 했던 일들 중에서 다른 사람이 할 수 있는 일들이 떠넘겨지게 된다. 즉 히어로가\n 잡부가 되는 것이다.\n\n이를 방지하기 위해서 해당 포스트에서 제시하는 것은, 히어로가 퇴사 카드를 꺼내들기 전에 먼저 팀을 만들고 그가 불만이 있을 법한 사항들을\n 개선해주자는 것이다. 퇴사 카드를 꺼내든 이후에 연봉 협상과 같은 협상책을 제시하는 것은 이미 늦은 것이다. 이를 위해 할 수 있을 법한 일\n들로는 다음과 같은 것을 제시한다.\n\n1. 정기적인 개인면담\n2. 개인이 처한 상황에 대해 회사가 해줄 수 있는 창구마련\n3. 선심성 발행이 아닌 진심을 담은 회사 히어로서의 성과급 제도 발행 및 적용\n4. 외부 리뷰서비스나 커뮤니티의 지속적인 상황파악을 통한 개선점 도출 및 지속적인 피드백\n5. 히어로를 관리하는 관리자의 역량을 점검\n\n그리고 최종적으로 남은 사람들에 대해서도 배려해달라는 이야기로, 요 근래 스타트업에 지원하면서 가져야 할 마음가짐에 대해 생각해보는 글이\n 됐다.\n\n---\n\n## 루브 골드버그 장치와 같은 지나친 자동화를 경계하자\n\n[포스트 링크](https://itnext.io/rube-goldberg-cloud-architect-a5bbb357b54d)\n\n루브 골드버그 장치라는 보이기는 거창하나 하는 일은 아주 단순한 재미만을 추구하는 연쇄 반응 기계 만화의 비유를 통해 소프트웨어 산업에서\n 자동화를 할 때 주의해야 할 점들에 대해 이야기한다. 루브 골드버그 장치는 매우 복잡한 구조를 가지고 있지만, 그 구조를 이해하면 그것이\n 하는 일은 매우 단순하고 사람이 직접 하는 것보다 더 복잡하고 비효율적일 수 있다. 이처럼 소프트웨어 산업에서도 자동화를 할 때 자동화를\n 이룰 때 하는 이유와 그것이 하는 일이 실제로 가져다 주는 이득이 무엇인지를 잘 생각해야한다는 내용을 담고 있다.\n\n최근 오픈소스 프로젝트를 참가해보면서 소규모 프로젝트들에서조차 pre-commit과 같은 자동화 도구에 지나치게 많은 hook을 사용하고 있다고\n 느껴지는 지점들이 있었다. 처음에는 이것들이 굉장히 멋있고 개발에 도움이 된다고 생각했지만, 해당 장치들을 세팅할 시간에 실제로 코드를\n 작성하는 것이 낫겠다는 생각도 들었고 동시에 이들에 맞추어 코드를 수정하는 시간들이 코드의 품질에 도움이 되는 것인지에 대해 의문이\n 생기는 시점이었다. 이러한 부분들에 대한 경계 및 정도를 잘 판단하는 것이 중요하다는 것을 다시 한 번 느끼게 되었다.\n\n---\n\n## Golang: Improving Your Go Project with Pre-Commit Hooks\n\n[포스트 링크](https://goangle.medium.com/golang-improving-your-go-project-with-pre-commit-hooks-a265fad0e02f)\n\n그럼에도 불구하고 실제로 이들을 사용해보는 경험은 어느 정도 규모가 이미 자리잡은 시스템이 필요한 프로젝트에서는 도입이 필요하다고 생각\n한다. 내 채팅 어플리케이션용 api 서버 역시 개발이 약 3개월차가 되면서 작성한 line의 수가 12000줄을 넘어가고 지운 것이 6000줄이 될 정도\n로 양이 많아지고 있다. 이러한 상황에서 코드의 품질을 유지해야 개발 속도를 높일 수 있을 것이라 생각해서 pre-commit을 도입하게 됐다.\n\n다만 이를 동시에 containerization하는 IaC 역시도 도입하려는 생각을 원래는 하고 있었는데, 그럴 시간에 그냥 개발을 하는 것이 더 나을\n 것이라는 생각이 들었다. 어차피 내가 다른 개발 환경에서 작업할 일도 없고, 다른 사람과 협업할 일도 없을 가능성이 높은 상황인 프로젝트\n이니까.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"5월 1주차 포스트","subtitle":"히어로와 잡부, 자동화의 중용","date":"2024-05-05T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-05-12-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-05-12-Post reviews.md","category":"WeeklyPosts","title":"5월 2주차 포스트","subtitle":"rate limit, retry 전략, 자기연민","content":"\n### 목차\n\n- [Rate Limit이란](#rate-limit이란)\n- [Retry 전략: Exponential Backoff, jitter](#retry-전략-exponential-backoff-jitter)\n- [Self-compassion is the motivator you’re missing](#self-compassion-is-the-motivator-youre-missing)\n\n---\n\n## Rate Limit이란\n\n[포스트 링크](https://etloveguitar.tistory.com/126)\n\nrate limit은 서비스가 트래픽을 제어하기 위해 사용하는 방법 중 하나로, 서비스에 대한 요청을 제한하는 것이다.\n 예를 들어 서비스의 트래픽이 10초당 100개로 제한되어 있다면, 10초에 100개 이상의 요청을 보내면 서비스는 요청을\n 거부할 것이다.\n\nrate limit이 필요한 이유는 서비스의 안정성과 성능을 보장하고, 과도한 트래픽으로부터 서비스를 보호하는 등의\n 서비스의 안정성을 보장하기 위함이다. rate limit은 서비스의 트래픽을 제어하기 위해 throttling 방법이라 할 수\n 있으며 방법에는 다음과 같은 것들이 있다.\n\n 1. Hard throttling: 트래픽이 제한을 초과하면 요청을 거부한다.\n 2. Soft throttling: 트래픽이 제한을 특정 비율 이상 초과하면 요청을 거부한다.\n 3. Dynamic throttling: 트래픽이 제한을 초과해도 서버 상태에 따라 요청을 처리할 수 있다.\n\n---\n\n## Retry 전략: Exponential Backoff, jitter\n\n[포스트 링크](https://jungseob86.tistory.com/12)\n\nretry 전략은 서비스의 안정성을 보장하기 위해 사용하는 방법 중 하나로, 서비스에 대한 요청이 실패했을 때\n 다시 시도하는 방법이다. 예를 들어 통신 상태 장애로 인해 요청 혹은 응답이 실패했을 때, 일정 시간 후에\n 클라이언트/서버가 다시 같은 요청/응답을 시도하는 것이다.\n\nretry 전략에는 여러 가지가 있는데 그 중에서 exponential backoff과 jitter가 있다. exponential backoff은\n 재시도 간격을 지수적으로 증가시키는 방법이다. 예를 들어 1초, 2초, 4초, 8초, ... 와 같이 시간 간격을\n 늘려가며 재시도하는 것이다. 이 방법은 서버의 부하를 줄이고, 서비스의 안정성을 보장하기 위해 사용된다.\n\njitter는 재시도 간격을 랜덤하게 설정하는 방법이다. exponential backoff은 재시도 간격이 일정하게 증가하는\n 반면, jitter는 재시도 간격을 랜덤하게 설정하여 서버의 부하를 분산시키고, 서비스의 안정성을 보장하기 위해\n 사용된다.\n\n---\n\n## Self-compassion is the motivator you’re missing\n\n[포스트 링크](https://medium.com/behavior-design/studies-show-self-compassion-is-the-motivator-youre-missing-affbceaf5ee3)\n\n자기에 대해 비판적인 태도를 가지고 징계하거나, 자신을 비난하거나, 자신을 비굴하게 만드는 것은 자신의 성장과\n발전을 방해할 수 있으며, 오히려 자기에 대한 자비로운 태도를 가지는 것은 자신의 성장과 발전을 도울 수 있다는\n내용의 포스트이다.\n\n만약 본인이 아니라 친구가 실패하고 힘든 경험을 했을 때에 그 친구에게 꾸짖는 말을 하지 않을 것이라면, 그것은\n자신에게도 적용되어야 한다. 자기에게 자비롭게 대하고, 비판을 하기 전에 한번 숨을 돌리고 만약 친구에게라면\n어떻게 대할 지 한 번 생각해보는 것으로 자신에게도 자비롭게 대할 수 있다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"5월 2주차 포스트","subtitle":"rate limit, retry 전략, 자기연민","date":"2024-05-12T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-01-27-기술 블로그를 다시 시작하며","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-01-27-기술 블로그를 다시 시작하며.md","category":"신변잡기","title":"기술 블로그를 다시 시작하며","subtitle":"이번엔 다르다!","content":"\n## 기술 블로그를 다시 시작하며\n\n요 근래 구직을 하면서 많은 사람을 만나고, 들은 조언 중에 '기술 블로그를 작성하라'는 것이 있었습니다.\n\n단순히 구직을 목표로 이를 작성한다면 기술 블로그를 가꾸는 일은 제가 구직을 마치는 순간 쓸모없는 행위입니다. 그리고 제가 전에 큰 꿈을 꾸고 뭔가 쓰다가 방치해서 폐허만 남은 예전의 것과 동일한 것이 되겠죠. 마치 사람들이 새해가 되면 \"올해는 건강하게 살아야지!\"라고 다짐하고 이전의 계획표를 되돌아보고 \"또 실패했었지만, 올해는 다르다!\"라고 이야기 하는 것처럼이요.\n\n그렇기 때문에 기술블로그를 작성하는 것의 무거움을 이번에는 지난번보다 더 잘 알고 있어 겁이 나는 부분도 있었습니다. 다행인 점은 제가 요즘에 두렵다고 느껴지는 일들이 저에게 진짜로 도전해야하는 지점들이란 것을 깨달아 간다는 것이죠.\n\n그래서 원론으로 돌아와, 결국 제가 이 기술블로그를 성장시키기 위해 가장 중요한 것이 무엇인지에 대해서부터 고민해봤습니다. 그리고 다음과 같은 이유들을 생각할 수 있었습니다.\n\n1. 이 블로그 주인장은 하고 싶은 말이 더럽게 많다.\n2. 인간은 언어로 표현할 수 없는 것은 인지하지 못한다.\n\n첫 번째는 경박하고 두 번째는 굉장히 거창한 이유가 됐네요. 하루에 일기를 썼다하면 30분에서 한시간씩 붙들고 3천자씩 갈겨대는 인간이 대나무 숲에라도 \"임금님 귀는 당나귀 귀\"를 외쳐대고 싶은 소망을 해소하는 창구를 찾는 것은 당연할 것입니다. 그리고 일기는 그걸 쓰긴 좀 아쉬운 매체니까요.\n\n그리고 사람마다 다르겠습니다만, 저는 말이나 글로 표현할 수 없다면 지식을 온전히 습득했다고 할 수 없다고 생각하는 소위 꼰대스러운 기질도 가지고 있는 인간입니다.\n\n그러니 앞으로 제가 이 업계에서 계속 살아나가는 것이 목표라면, 가장 먼저 할 일은 꾸준히 새로운 지식을 습득하고 이를 통해 세 치 혀를 놀려가며 자신이 가진 이해의 모자람을 통감하며 작은 머리 속에 있는 헛소리를 끄집어내려 노력하는 것이겠지요.\n\n\"... 좋아합니다. 이번엔 진짜라구요!\"라는 강백호의 유명한 대사가 슬램덩크의 마지막을 장식했듯, 저 역시도 오늘이 많은 날이 지나 일기의 한 장을 돌아봤을 때 부끄러우면서도 한 편으로는 '진짜'가 되는 날이었음을 웃으며 되돌아볼 수 있기를 간절하게 소망합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","title":"기술 블로그를 다시 시작하며","subtitle":"이번엔 다르다!","date":"2024-01-27T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-01-31-코드와 글의 경계에서","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-01-31-코드와 글의 경계에서.md","category":"신변잡기","title":"코드와 글의 경계에서","subtitle":"나는 이 블로그를 왜 운영하려하는가","content":"\n## 서론\n\n이번에 아직 미완성이지만 의존성 역전패턴을 활용한 소프트웨어 설계 개선을 3일간 쓰면서 나름대로는 만족스러운 부분이 있었다고 생각합니다. 제가 느낄 때 이전까지는 제대로 이해하지 못한 부분이 있었는데, 이번에는 그 부분을 이해하는데 꽤 성공했다고 생각했거든요. 그래서 역시 글로 정리하는 과정은 도움이 되는구나! 할 수 있구나!라는 생각도 조금 들었습니다.\n\n막상 해당 글을 공개된 공간에 공유하고, 또 다른 사람들이 읽어주시면서 피드백을 받으니까, 아직도 부족한 부분이 많다는 것을 느끼게 되었습니다. 그 중에서 가장 많이 받은 지적 두 가지는 '코드가 없이 설계에 대해서 글로만 이야기한다'와 '글의 내용이 교조적이라 읽는 것이 불쾌하다'라는 것이었습니다. 이 두 가지 지적은 제가 글을 쓰는 방식에 대해서도, 글을 쓰는 목적에 대해서도, 그리고 글을 읽는 사람들에 대해서도 생각해볼 수 있는 계기가 되었습니다. 그래서 이번 글에서는 이 두 가지 지적에 대해서 제가 생각하는 것을 적어보려고 합니다.\n\n## 코드가 없이 설계에 대해서 글로만 이야기한다\n\n물론 코드가 없는 글로 이해하는 것 역시도 중요한 부분인 것은 사실입니다. 우리는 무언가를 이해할 때 디테일한 사례들을 들어가며 이해하는 것 역시 중요합니다만, 그렇다고 해서 디테일한 사례들만을 들어가며 이해하는 것은 오히려 이해를 방해하는 요소가 될 수 있습니다. 그래서 코드가 없는 글로 설계에 대해서 이야기하는 것은 중요한 부분이라고 생각합니다. 하지만 그렇다고 해서 코드가 없는 글로만 설계에 대해서 이야기하는 것이 좋은 것은 아닙니다. 코드가 없는 글로만 설계에 대해서 이야기하는 것은 설계에 대해서 이야기하는 것이 아니라, 공허하고 빈약한 이야기가 될 수 있습니다. 극단적으로는 제 생각이 들어있지 않고 그냥 뻔한 이야기만 남에게서 주워모아서 적은 글이 될 수도 있습니다.\n\n그러니 물론 제가 '여기까지 작성하고 이후는 코드를 작성한 부분에 들어갈 것이었는데...'라고 생각하고 있었더라도, 그 부분을 지나치게 뒤로 미뤄둔 것 역시도 좋은 글이 아니었다고 생각하게 됐습니다. 만약 제가 의존성 역전에 대한 인사이트를 찾기 위한 글을 찾아보는 사람이 됐다 했을 때 과연 제 글처럼 앞부분이 중언부언 늘어져있는 글을 인내심을 갖고 끝까지 봤을 것이냐하면 딱히 그러진 않았을 것 같거든요. 게다가 써놓은 것을 다시 읽어보면 제가 꽤나 자신에 가득찬 상태로 남에게 가르치려는 위에서 내려다보는 시선으로 받아들여지기도 했습니다. 아마 이 글이 제가 쓴 글이 아니었다면 제가 읽는 입장에서도 불쾌했을 것 같습니다.\n\n## 그렇다면 어떤 글을 써야 할 것인가\n\n이에 대해 많은 피드백을 받았습니다. 기억나는 것은 제가 이렇게 쓴 것의 중간 중간에 예시로 든 것을 실질적인 코드의 형태로 섞어쓰면 남의 것을 베껴 썼다는 공허한 느낌이 들지 않을 것 같다는 것하고, 실질적으로 코드를 작성하고 그 코드를 통해 설계에 대해서 이야기하는 것이 좋을 것 같다는 것이었습니다. 둘 다 너무 공감이 되는 것이었고, 둘 다 제가 생각하지 못했던 부분이었습니다. 둘 다 제가 앞으로 이 블로그에 글을 계속 써나가겠다고 하면 선택할 수 있는 훌륭한 방향들이지요.\n\n그렇기 때문에 여러 방향에 대해 제시받은 지금 시점에서 제가 가장 우선적으로 고민해야하는 것은 내가 여기에 왜 꾸준히 글을 쓰려하는 것인가?였습니다. 분명 최초에 하고자는 동기는 면접관에게서 이력서 및 포트폴리오가 모자라니, 블로그를 운영해보라는 조언을 받았기 때문이었습니다. 하지만 저는 그렇게까지 배움이 빠른 사람이 아니기에 좋은 조언이라 해서 이를 바로 수용하지는 못하는 편입니다. 그래서 며칠동안 해당 아이디어는 그냥 스쳐지나갔을 뿐이지요.\n\n그런데 제가 글을 작성하기 시작하게 된 것은 지금 하고 있는 공부란 것에서 뭔가 모자람을 느꼈기 때문입니다. 분명 저는 과제나 알고리즘 문제 해결의 형태로 꾸준히 코드를 작성하고 있고, 프로그래밍 관련한 교양 서적을 '실용주의 프로그래머', '프로그래밍 면접 이렇게 준비한다' 등을 읽은데다, 면접을 위한 cs 지식을 습득하기 위한 인터넷 서핑, 미디엄 구독과 같은 것들을 하고 있었습니다. 그런데도 불구하고 제가 뭔가 모자람을 느꼈던 것은, 제가 이러한 것들을 하면서도 제가 뭔가를 제대로 이해하고 있는 것 같지 않았기 때문이었습니다. 그런 제가 요즘 가장 활발히 하면서 만족하고 있는 행위인 글쓰기에 눈을 돌렸던 것은 어찌보면 일종의 도피였는지도 모르겠습니다.\n\n막상 글을 쓰다보니 남에게 설명하는 과정에서 제가 알고 있다 생각한 것 중 많은 부분이 사실은 모르는데 대충 넘어가고 있단 것을 알 수 있었고, 그 부분에 대해 해소가 되면서 진정한 이해에 도달하고 있다는 생각이 들었던 것은 굉장히 기뻤습니다. 사실 지금 이 글 역시도 어떤 생각이 다 완성돼서 글을 쓴다기보다는 일종의 생각을 정리하는 과정으로 글을 쓰는 중입니다. 이처럼 글을 쓴다는 것은 내가 안다는 것을 밖으로 끄집어내는 과정에서 그것이 사실은 착각이란 것을 깨닫는 가장 효과적인 방법이란 생각을 하고 있기 때문에 글을 쓰겠다고 결심하게 됐습니다.\n\n그렇다면 제가 써야 할 글은 아무래도 그런 것이겠지요. 내가 알게 됐다고 생각한 것들에 대해서 남에게 소개하는 글을 쓰자. 그리고 그 과정을 통해서 내가 사실은 제대로 알지 못한다는 사실을 깨닫자. 글을 쓰는 것은 제가 사용하는 일종의 정반합을 통한 깨달음으로 나아가는 학습법이라고 말할 수 있을 것 같습니다. 너무 거창한 이야기려나요\n\n## 앞으로 어떻게 할 것인가\n\n돌고 돌아서 결국 '하던대로 하겠다', '내가 옳음!'라고 들릴만한 소리를 한 것 같네요. 네, 제가 여태까지 써 오던 것과 같은 제재와 주제를 가지고 글을 꾸준히 써내려가보려고 합니다. 멋들어지는 거창한 표현으로 제 배출을 치장했지만, 사실 글을 쓰는 것은 제게 꽤나 즐거운 취미 생활이라고 느끼고 있기도 하거든요.\n\n다만 제가 기존에 글을 쓴 방식이 굉장히 공허하고, 문제가 있다는 것은 알았으니 그 부분에 있어서는 개선을 해나가려고 노력해보려 합니다. 결국 제가 쓰려고 하는 글은 큰 틀로 모아 프로그래밍과 코드에 대한 것이니만큼, 코드를 직접 작성하고 이를 통해 실존적인 이야기를 하기 위해 더 노력해보려고 합니다. 목표는 내일부터 시작하는 것입니다만, 의존성 역전 패턴 글 (1) ~ (3)의 구조를 아예 갈아 엎고 시작 부분에 의존성 역전 패턴을 사용하면 개선할 수 있는 코드를 작성하는 것부터 시작한 뒤에 이를 개선하는 것을 보여주고, 그 뒤에 제가 늘어놓았던 이야기를 덧붙이는 식으로 글을 쓰기만 해도 아무래도 덜 공허하고 빈약한 글을 완성할 수 있지 않을까 싶습니다. 그리고 여기에 덧붙여 가능하다면, 제 블로그가 갑자기 엄청난 유명세를 타서 많은 사람들이 방문하게 되는 미래가 오지 않는다는 가정하에, 이번에 했던 것처럼 꾸준히 다른 사람들이 드나드는 곳에 살며시 내려놓아두고 반응을 기대하며 두근두근 해보고 싶습니다. 제가 이런 생각에 도달하고, 개선점을 깨달을 수 있었던 것은 많은 분들께서 모자란 제 모습을 가엾게 여기고 고이 넣어주신 한마디씩의 피드백과 격려 덕분이었으니까요.\n\n그러니 뭐, 앞으로도 모자라지만 노력해보겠습니다. 이번과 같이 모자람이 있으면 '아직도 지난번에서 배운 것이 없느냐 못난 녀석!'하고 한마디 꾸짖어 주시고 가신다면 저는 덕분에 조금 덜 멍청한 사람이 될 수 있을 것 같습니다.\n\n그럼 이만 쓰겠습니다. 다음 글에서 뵙겠습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"코드와 글의 경계에서","subtitle":"나는 이 블로그를 왜 운영하려하는가","date":"2024-01-31T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-04-01-지난 3개월을 돌아보며","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-04-01-지난 3개월을 돌아보며.md","category":"신변잡기","title":"지난 3개월을 돌아보며","subtitle":"물방울이 흐르고 모여서 시냇물을 만든 이야기","content":"\n### 목차\n\n- [서론 - 짧고 굵었던 3개월](#서론---짧고-굵었던-3개월)\n- [초반 - 물줄기 만들기](#초반---물줄기-만들기)\n  - [시스템을 통해 일정 세우고 습관 만들기](#시스템을-통해-일정-세우고-습관-만들기)\n  - [내가 일기를 가장 먼저 습관화하려 했던 이유](#내가-일기를-가장-먼저-습관화하려-했던-이유)\n- [중반 - 무작정 부딪히기](#중반---무작정-부딪히기)\n  - [다양한 채용 과정 경험](#다양한-채용-과정-경험)\n  - [너는 아직 준비가 안됐다](#너는-아직-준비가-안됐다)\n- [후반 - 방향 설정하기](#후반---방향-설정하기)\n  - [내가 일하고 싶은 환경](#내가-일하고-싶은-환경)\n  - [방향 설정 이후의 결과](#방향-설정-이후의-결과)\n- [시냇물이 강줄기가 되도록](#시냇물이-강줄기가-되도록)\n- [참고자료](#참고자료)\n\n---\n\n## 서론 - 짧고 굵었던 3개월\n\n다시 프로그래머로 일하고 싶다고 마음 먹고 구직을 시작한 지 3개월이 지났습니다. 제가 프로그래머로 다시 일하고 싶다고 생각한 이유가 끊임없이 새로운 것을 배우는 것을 좋아하고 그런 환경에서 일하는 직업이라 생각했기 때문인데, 이번 3개월만 해도 제가 기대한 것보다 훨씬 더 많은 것들을 배울 수 있었네요.\n\n비록 최종 목표인 취업까지 도달하지는 못했습니다만, 여기에서 발걸음을 잠깐 멈추고 여태까지 걸어온 발자취를 한 번 돌아보면서 여정을 회고한 뒤 앞으로의 흐름에 대해 구상해보려 합니다. 마침 제가 직전에 지원한 회사에서 최종 면접을 마무리하면서 여기까지가 제 구직의 첫 장을 끝맺을 시점이라는 생각도 들었고 말이죠.\n\n---\n\n## 초반 - 물줄기 만들기\n\n이번 구직 기간 이전까지 학원 강사나 일용직 아르바이트 등의 일은 했지만, 오랫동안 멈춰있던 프로그래머로써의 기어를 다시 움직이려면 몸에 배어든 습관에서 벗어나 새로운 흐름을 만들어야겠다는 생각을 했습니다. 아무래도 손에서 놓은 공부도 다시 집어들어야하고, 그러려면 이전보다 높은 생산성을 회복할 필요가 있었기 때문입니다.\n\n저는 새로운 흐름을 만들려면 새로운 시스템과 습관이 필요하다 생각합니다. 원래 시스템에 노출된 상태에서 행동만 바꾸려하면 기존으로 복귀하기 쉽고, 이런 중력을 거스르는 것은 굉장한 인내력을 소모해서 오래 지속하기 힘들기 때문입니다. 그래서 새로운 시스템을 통해 어떤 상황에서도 프로그래밍과 관련한 행동에 큰 노력 없이 자연스럽게 노출되는 환경을 우선적으로 만들었습니다. 이를 위해 가장 먼저 세운 습관은 명상과 운동, 하루 일정 수립, 그리고 일기 쓰기였습니다.\n\n### 시스템을 통해 일정 세우고 습관 만들기\n\n일정을 세우기 위해서 여러 어플리케이션을 사용해 본 후에 '[TickTick](https://ticktick.com/)'을 이용하기로 결정했습니다. 제가 가지고 있는 전자기기인 태블릿, 핸드폰, pc 간에 동기화 지원이 잘 되기 때문에 어떤 상황에서도 일정을 확인하고 리마인드 받기 용이했기 때문입니다. 인터페이스가 중간에 계획을 수정하고 정리하는 것이 편리했던 것도 한 몫 했습니다.\n\n또한 진척을 추적하고 평가하는 것이 용이하단 것도 큰 장점이었습니다. 해당 어플리케이션에서 지원하는 **pomodoro**를 이용하면 하루에 집중 시간 측정이 가능해서 하루 동안 어느 정도로 생산적인 활동을 했는지 정량적으로 평가가 가능했습니다. 여기에 더해 **습관** 기능을 통해 반복적인 일정을 자동으로 수립하고 진행을 추적하는게 가능했습니다.\n\n![2월 마지막 주](https://imgur.com/jik2RiA.jpg)\n![습관 예시](https://imgur.com/J1DT71V.jpg)\n\n### 내가 일기를 가장 먼저 습관화하려 했던 이유\n\n이 때 가장 우선적으로 습관화하려 했던 것은 아침에 명상하고 일정을 세운 뒤 아침 운동을 하고, 하루가 끝나면 일기를 통해 진척을 정리하는 것이었습니다. 그러게 된 계기는 조승연의 탐구생활에서 [다음 영상](https://www.youtube.com/watch?v=-MAjsjDv_jA)을 보게 된 것이었습니다.\n\n해당 영상에서 뇌과학자인 장동선 박사께서는 기억은 다음의 3단계로 이루어진다고 말합니다.\n\n```md\n1. 부호화\n2. 저장\n3. 인출\n```\n\n여기서 핵심은 **인출**입니다. '우리는 흔히 카메라처럼 기억을 한다고 생각하지만, 사실은 영화 감독처럼 기억합니다.' 이 때문에 내가 내 삶에 있어서 어떤 기억을 남기느냐 하는 것을 잘 하려면 스스로의 기억을 찍는 영화 감독으로써 주도적으로 노력해야한다고 장동선 박사는 주장합니다. 그리고 그 예시로 조승연 작가가 초등학교 시절 집으로 가는 뒷골목을 무섭고 허름한 할렘가로 기억하던 트라우마를 깨기 위해 다시 방문했는데, 골목이 깨끗한 한강의 나들목이 된 경험을 이야기합니다.\n\n이처럼 만약 힘들고 고생했던 경험이 있다면 이를 잊으려고 하는 것은 오히려 본인을 괴롭게 할 가능성이 높다고 합니다. 안 좋은 기억을 끄집어내지 않고 없애려는 노력은 그 기억을 없애기보다는, 어디에도 내 삶의 이야기로 붙지 못하고 조각으로 남아 나를 힘들게 하게 되는 경우가 많기 때문입니다. 장동선 박사는 이 때문에 아픈 기억이더라도 이를 다시 꺼내서 여기에 의미를 부여하고 다시 저장하는 과정이 내 스스로의 정신 건강에서 나을 수 있다고 이야기합니다.\n\n요약하자면 다음 두가지를 실천하자는 것입니다.\n\n```md\n1. 안좋은 기억은 다시 꺼내서 그 기억의 무서움과 두려움을 약화시켜서 저장한다.\n2. 정말 아름다운 추억은 그것에 대한 감사함과 같은 긍정적인 감정을 더해 저장한다.\n```\n\n이를 실천하기 위한 방법으로 저는 일기를 통해 매일의 경험을 꺼낸 다음에, 감사와 함께 스스로에 대한 힘내라는 용기를 덧붙여 저장하고 있습니다. 그 덕분인지 많은 거절과 실패를 겪고 있음에도 좌절하지 않고 새로운 흐름을 만들 수 있었습니다.\n\n---\n\n## 중반 - 무작정 부딪히기\n\n이제 프로그래머로써의 기어가 다시 움직이기 시작하고 새로운 흐름이 만들어졌긴 했지만, 문제는 이 물줄기의 행선지가 정해져있지 않았다는 것이었습니다. 그렇다고 첫 구직 때처럼 단순히 알고리즘과 면접 때 나올 법한 cs 지식들을 공부하면서 충분한 준비가 됐다고 생각할 때까지 기다린 뒤에 지원을 하고 싶지는 않았습니다. 그래서 이번에는 무작정 부딪히기로 결정했습니다. 그럴 방법으로 선택한 것은 지원 공고가 올라온 회사들 중에서 제가 지원 조건을 만족하는 회사들에 전부 지원하는 것이었습니다.\n\n![지원 기록 일부 예시](https://imgur.com/ORNY2Ng.jpg)\n\n### 다양한 채용 과정 경험\n\n무수한 서류 탈락도 경험했습니다만, 운이 좋게도 통과한 경우에는 이후 전형에서 다양한 것들을 요구받았습니다. 가장 흔한 코딩 테스트부터 시작해서, 특정한 상황을 가정하고 그에 맞는 해결을 제시하라는 과제나, 웹 서버의 REST API를 설계하고 구현하기를 요구받기도 했습니다. 이런 과정들에서 요구하는 능력들은 대부분 제가 갖추지 못했던 것들이었어서 도전적이었고 진행하는 과정에서 많은 것을 배울 수 있었습니다.\n\n과제 없이 바로 면접을 진행하는 경우도 많았습니다. 이 과정을 통해서 회사에서 원하는 사람은 누구인지, 동시에 내가 그 사람들의 입장이었다면 어떤 사람과 일하고 싶을지에 대해 생각해볼 수 있었습니다. 가장 인상 깊었던 면접은 중간에 면접관께서 친절한 선배가 조언해 주듯이 다음 이야기를 해 주셨던 경험입니다. '나는 네가 마음에 들지만 아마 채용하지는 못할 것 같다. 그건 네가 말을 잘 못하기 때문이다. 이 부분을 고민해보고, 기술 블로그나 깃헙을 통해 프로젝트를 진행해서 이력서를 보완하는 게 좋을 것 같다.' 라는 제가 찾고 있던 현재 제 문제와 방향성에 대한 제안이었습니다.\n\n그 이후로 제가 면접에서 갖춰야 할 자세가 부족한 부분이 많고 어떤 것인지에 대해 되돌아 볼 수 있었고, 이를 통해 더 나은 대화를 하기 위해 노력했습니다. 대표적으로는 데일 카네기의 '인간 관계론'을 읽고 면접이나 일상 대화에서 상대와 더 좋은 대화를 나누는 방법에 대해 고민하고 적용했습니다.\n\n여기에 더해, 많이 미흡하고 부족한 점이 많았지만, 기술 블로그와 깃허브 레포지토리로 새로운 프로젝트도 시작했습니다. 이후에는 면접을 볼 때 이와 관련된 이야기를 하면서 좀 더 주도적으로 대화를 이끌어 나갈 수 있었고, 덕분에 제가 모자란 지점을 파악하기에도 용이했습니다.\n\n### 너는 아직 준비가 안됐다\n\n물론 가장 부족한 것은 프로그램을 구현하는 기량이었겠지만, 그 외에도 굉장히 다양한 능력과 고민의 결핍을 절감할 수 있는 시기였습니다. 다른 사람과 소통하는 능력, 자신을 표현하는 능력, 내가 하고 싶은 일은 무엇인가와 함께 일하고 싶은 사람은 누구인지에 대한 고민 등 많은 질문을 가지게 되고 이에 답하면서 다양한 역량을 키우고 스스로를 돌아볼 수 있었습니다. 새삼 내가 이런 부분들이 미흡한데 용케도 첫 직장을 구했었구나 싶은 생각도 들었습니다.\n\n이런 결핍들을 해소하기 위해 많은 책을 읽고, 사람을 만나고, 이를 글을 통해 질문하고 대답하면서 정리하려고 노력하고 있습니다. 돌아보니 제가 지난 3개월 간 읽은 책이 기록해 둔 것만 70권이 넘었네요. 이는 제가 지난 10년간 읽은 책 수보다도 많은 양입니다. 면접은 세기를 포기했지만 못 해도 20번 가량은 보지 않았을까 싶습니다. 여기에 더해 현재 분야에서 벗어나는 이야기도 듣고 싶어 한동안 만나지 못했던 친구들에게 연락했고 이를 흔쾌히 받아준 친구들 덕분에 많은 이야기를 들을 수 있었습니다.\n\n이런 노력들을 통해 많은 것을 배우고 있는데도 계속해서 모자란 것이 눈에 더 보이니 그야말로 '**[너는 아직 준비가 안됐다](https://www.youtube.com/watch?v=aeZWTUZcOCQ)**, 그것도 아주 많이'라고 밖에 할 수 없을 것 같네요. 다만 제가 할 수 있는 일은 이 밑 빠진 독이 채워지진 않더라도 그 안에 부스러기가 지나간 흔적이라도 남겨 변화하도록 노력하는 것이기에, 하루하루를 충실하게 보내려 하고 있습니다.\n\n---\n\n## 후반 - 방향 설정하기\n\n여러 경험을 하면서 제가 체감한 부족한 것들 중 핵심은 제게 방향성이 없다는 것이었습니다. 구직을 시작하면서 가장 먼저 읽은 책인 ['프로그래밍 면접 이렇게 준비한다'](https://kaestro.github.io/%EC%84%9C%ED%8F%89/2024/02/09/%EB%8F%85%ED%9B%84%EA%B0%90.html#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%B4%EC%A0%91-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%A4%80%EB%B9%84%ED%95%9C%EB%8B%A4)에서 한 첫 문구가 '구직을 시작하기 전에 너 자신을 알라'였던 것은 다시 봐도 정말 도움이 많이 되는 조언이었습니다.\n\n그래서 이번 구직 기간은 직업 탐색인 동시에, 자신에 대해 되돌아보는 소중한 시간이었습니다. 그리고 이 과정을 통해 다음과 같은 기준으로 방향을 설정하게 됐습니다.\n\n### 내가 일하고 싶은 환경\n\n제가 세운 기준은 다음과 같습니다.\n\n```md\n1. 백엔드 개발자로 일하고 싶다.\n2. 지속적인 유지보수에 관심을 가진 환경에서 일하고 싶다.\n3. 여러 사람이 소통을 통해 서로의 생각을 공유하고 발전하는 환경에서 일하고 싶다.\n```\n\n위의 기준을 세운 이유는 다음과 같습니다.\n\n우선 현재 제가 가장 경쟁력 있고, 관심있는 분야가 **백엔드 개발**입니다. 짧게나마 해당 분야에서 경력을 쌓아본 적도 있고, 다양하면서도 나날이 감당하기 힘들만큼 발생하고 있는 데이터들을 어떻게 처리하고 저장하는지에 대한 이야기들은 가슴이 설레고 재미있습니다.\n\n이 분야에서 선두 주자 중 한 명인 구글의 이야기를 한번 볼까요? 최초에 [page rank 알고리즘](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80%EB%9E%AD%ED%81%AC)을 기반으로 구글 매트릭스를 통해 혁신적인 검색 서비스를 구글은 제공했습니다. 그 때에도 엄청난 기존에 다루는 것보다 큰 규모의 데이터를 다루기 위해서 새로운 방식이 필요했었는데, 지금은 거기에서조차 벗어나 무시무시하게 데이터 규모가 성장하고 있고 이 속도를 기기는 따라잡지 못하고 있습니다. 그리고 이를 다루기 위해서 백엔드 개발자는 온갖 노력을 하게 됐습니다. 예를 들어 구글에서 제공하는 검색어 자동 추천 기능은 그저 감탄만 나오는 명품이라 생각합니다. 어떻게 하면 내가 작성하고 있는 string 입력에 대해 서버가 즉각적으로 반응하면서 사용자의 취향에 맞는 검색어를 추천 해 주는걸까요? 이처럼 데이터를 다루는 이야기는 끝이 없고, 이에 대해 알게 되고 공부하는 것은 참 즐겁습니다.\n\n그리고 이런 고도의 기술로 만드는 제품은 **지속적인 유지보수**가 필요하단 것을 배웠습니다. 가장 크게 영향을 준 것 중 하나는 ['구글 엔지니어는 이렇게 일한다'를 읽은 일](https://kaestro.github.io/%EC%84%9C%ED%8F%89/2024/03/14/%EA%B5%AC%EA%B8%80-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%8A%94-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%9D%BC%ED%95%9C%EB%8B%A4.html)이었습니다만, 이를 제가 작업하는 환경에 적용하면서 이것들의 필요성을 체험할 수 있었습니다.\n\n제가 현재 진행중인 [프로젝트](https://github.m/kaestro/ChatApplication)에서 가장 많은 시간을 쓰는 일은 코드 작성이 아니라 문서 작성입니다. 이 문서는 일단 여러 사람이 협업해야 되기 때문에 필요한 것이기도 하지만, 코드를 작성하는 것보다 이에 앞서서 계획하는 것이 더 중요하다는 것을 깨달을 수 있었기 때문입니다. 그렇지 않고 코드를 작성하다보면 계획 단계에서 방지할 수 있었을 문제들이 뒤늦게 발견되어 고치는 데 훨씬 많은 시간과 노력이 필요하기 때문입니다. 그리고 이를 팀원들 간에 공유해서 전체의 생산성을 높여야 한다는 것도 배웠습니다.\n\n예를 들어 제 프로젝트의 목표는 채팅 프로그램을 만드는 것이었지만, 구체적인 계획이 없었기 때문에 초반에 많은 시간을 낭비하고 이를 되돌리느라 고생하고 있습니다. 최초 계획에서는 kubernetes, azure를 통한 클라우드 서비스를 통해 serverless를 구축하겠다든가, kafka와 같은 메시지 큐를 도입하고, 채팅을 저장하는 데이터베이스로는 nosql인 mongoDB를 사용하겠다고 하기도 했습니다. 이 중 그 어떤 것에 대한 경험도 없고 그것이 무엇인지도 모르면서 말입니다. 그러니 구체적인 물건이 만들어지는 진척은 미비했고, 이것 저것 공부하기에 바빴는데도 결과물은 좋지 못했습니다.\n\n문서 작성을 팀원분들과 논의하고 진행하면서 현재 우리 선결 과제는 가용한 기술 스택으로 채팅에 필요한 MVP(Minimum Viable Product)를 작성하는 것이라고 목표를 정할 수 있었습니다. 그 이후로 이 최소한을 만들려고 노력하고 있는데 이조차도 쉽지 않은 것을 보면서 기존의 생각이 얼마나 경험이 부족한 상태에서 나온 것이고, 일을 진행하기에 앞서서 계획을 세우는 것이 굉장히 중요하단 사실을 깨달을 수 있었습니다.\n\n이 밖에도 issue, pull request, branch strategy, github actions, test code 작성 등 프로젝트가 장기화되면서 생산성을 높게 하려면 지속적인 유지 보수를 위해 이전에 git을 사용하면서 쓰지 않았던 기능들을 사용하게 되었습니다. 이런 경험들을 통해 이전보다 한층 더 나은 개발자로 성장했다고 생각합니다.\n\n그리고 제가 이렇게 성장할 수 있었던 것은 **혼자가 아니라 여러 사람과 소통하는 환경**이었기 때문이라고 생각합니다. 모자란 제 포트폴리오와 프로젝트들을 관심 가지고 봐주시고 조언해주신 면접관 분들부터 시작해서, 같이 프로젝트를 진행하고 있는 팀원들, 그리고 도움 요청에 흔쾌히 응해주신 지인분들까지. 이 모든분들의 호의 덕분에 혼자였으면 할 수 없었을 현재에 도달할 수 있었습니다.\n\n[셜록 현준님의 영상](https://www.youtube.com/watch?v=6Tl9vYmYvf8)에서 자주 언급하는 것이 인류는 사람간의 병렬 연결이 늘어나는 방향으로 발전해왔고, 이를 통해 인간의 창의성이나 생산성이 증대한다는 것입니다. 이번 구직 과정을 거치면서 평소보다 훨씬 많은 사람을 만났고, 대화를 나눈 덕분에 혼자 갇혀있었다면 배우지 못했을 가르침들을 얻을 수 있었습니다. 그래서 이번에 취업을 하게 되면 제가 일하는 공간은 여러 사람들 간에 소통이 활발하고, 이를 통해 생각을 공유하고 발전하는 병렬적인 연결이 이루어지는 환경이었으면 좋겠다고 생각합니다.\n\n### 방향 설정 이후의 결과\n\n그래도 이런 노력들이 도움이 됐는지 3월이 끝나기 전에 1개의 회사에서는 최종 합격을 연락 받기도 했고, 1개의 회사에서는 채용 전형의 최종 단계인 면접을 보기도 했습니다. 전자는 고민 끝에 제가 원하는 방향성과 맞지 않다고 생각해 과분한 제안이었음에도 죄송하지만 거절의사를 전달해야 했고, 후자는 아쉽게 탈락했지만 제 부족한 부분들에 대해 배울 수 있었던 소중한 경험이었습니다.\n\n그렇게 대단하다고 하긴 힘들겠습니다만 그래도 저에게는 이것이 지난 3개월 동안 물방울이 이리저리 부딪혀가며 모여 방향성을 획득한 시냇물이 만들어낸 작은 성과라고 생각합니다. 이제 앞으로 제가 맞게 나아가고 생각하는 지점들은 유지하되, 모자라다고 느낀 부분들은 더 나은 방향으로 방향을 바꾸어 시냇물이 올바르게 강으로 이어지도록 치수작업을 해나가려 합니다.\n\n---\n\n## 시냇물이 강줄기가 되도록\n\n더 잘할 수 있는 부분도 많았겠지만, 치열하고 내 인생에 온전히 집중해서 보냈다고 생각하기 때문에 후회 없이 만족스러운 3개월이었습니다. 이 정도만 해도 제가 소기에 프로그래머로써 다시 일하고 싶다라고 생각한 갈증에 대한 해소가 되는 가벼운 여우비 정도는 되지 않았나 싶습니다.\n\n다만 목마른 사람에게 모자란 물을 주면 갈증이 해소되기보다 더 많은 물을 갈망하게 되듯이, 더 많은 사람을 만나고 경험을 하고 싶다는 생각 또한 하게 됐습니다. 이를 위해 이번에 만들어진 물줄기가 강줄기로까지 이어지도록 앞으로도 계속해서 꾸준히 노력해야겠습니다.\n\n그리고 다시 한 번 이 모자란 물줄기에 한 컵씩 물을 보태주신 모든 분들께 감사드립니다.\n\n---\n\n## 참고자료\n\n1. [조승연의 탐구생활 - 상대방이 기억을 우기기 시작하면 이 영상을 보여주세요!](https://www.youtube.com/watch?v=-MAjsjDv_jA)\n2. [wikipedia - page rank 알고리즘](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%80%EB%9E%AD%ED%81%AC)\n3. [셜록 현준 - 한국 건축, 서양처럼 보존하지 못하고 재건축하는 이유는? 도시 재건축 VS 보존 문제!](https://www.youtube.com/watch?v=6Tl9vYmYvf8)\n\n---\n","layout":"default","recommended":true,"data":{"layout":"default","classes":"wide","title":"지난 3개월을 돌아보며","subtitle":"물방울이 흐르고 모여서 시냇물을 만든 이야기","date":"2024-04-01T00:00:00.000Z","categories":"신변잡기","recommended":true}},{"postName":"2024-04-02-재충전이란 무엇인가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-04-02-재충전이란 무엇인가.md","category":"신변잡기","title":"재충전이란 무엇인가","subtitle":"나에게 글쓰기는 휴식이다","content":"\n### 목차\n\n- [완전방전되어 재충전이 필요하다 느끼다](#완전방전되어-재충전이-필요하다-느끼다)\n- [의지력의 보충 $\\\\subset$ 재충전](#의지력의-보충-subset-재충전)\n- [방전은 무엇인가](#방전은-무엇인가)\n- [방전은 동시에 성장의 증거](#방전은-동시에-성장의-증거)\n- [내가 앞으로 해야할 것](#내가-앞으로-해야할-것)\n- [나에게 글쓰기는 휴식이다](#나에게-글쓰기는-휴식이다)\n\n---\n\n## 완전방전되어 재충전이 필요하다 느끼다\n\n최근 약 2달 반 동안의 구직과정을 보내면서 평소보다 많이 높은 피로감을 느끼면서 보냈습니다. 피로감이 높다는 것이 꼭 나쁜 것은 아닙니다. 강한 스트레스를 받고 있기 때문에 평소보다 더 많은 것을 빠르게 이루고 있으니까요.\n\n그렇지만 아무래도 제가 최종 목표로 삼았던 취업이 생각한 것보다 이른 시기에, 그것도 제가 상상했던 것보다 좋은 형태로 손에 거의 들어오기 직전까지 왔다가 빠져나가는 경험은 아무래도 상실감이 굉장히 크고 아쉬웠습니다. 특히 마지막에 진행한 채용 과정의 경우에는 많은 에너지를 쏟아넣느라 다른 것을 병행할 여유가 부족했기 때문에, 끝난 뒤에 다른 일로 이어나가기도 힘들었습니다. 물론 해당 과정이 끝나면 당락 여부에 상관 없이 휴식을 가지자는 생각이 있었던 영향도 있지만요.\n\n그래서 오랜만에 완전방전의 상태에 도달했고, 약 1주간의 휴식을 통해 기력이 돌아온 것을 느낄 수 있었습니다. 아침에 일어나면 계획을 수립하고 이를 완수하기 위해 시간이나 분 단위로 자신을 관리하던 나날에서 벗어나, 멍하니 보내는 시간을 좀 가졌더니 뭔가를 하고 있지 않으면 몸이 근질근질해서 못 참을 것 같은 상태로 복귀했으니까요.\n\n---\n\n## 의지력의 보충 $\\subset$ 재충전\n\n그래서 '이제 다시 이전처럼 취업과 훌륭한 소프트웨어 엔지니어가 되는 것을 목표로 생산성 높은 나날을 보내자!'라는 생각을 했는데 웬걸, 제 보충된 의지력은 여기로 향하지를 못하고 '유니콘 오버로드'라는 게임으로 흘러갔습니다.(여담이지만 유니콘 오버로드 진짜 갓겜입니다.) 하루에 한 시간을 집중해서 게임하는 것도 시간이 아깝거나 피곤해서 하지 못했던 제가 지난 1주일 동안만 플레이 시간을 약 40시간을 찍었습니다.\n\n분명 제 의지력이 보충된 것은 확실했습니다. 그렇다면 의지력이 아니라 무엇이 이전과 비교해서 방전된 상태여서 나는 목표로 향하지 못하고 있는 것인가라는 질문을 하게 됐습니다. 그리고 제가 이전에 생산성을 유지할 수 있었던 것은 의지력이 충만했던 것도 있지만, 그것을 넘어서는 다른 것들이 있었고 현재는 그것이 부족하기 때문이라는 결론에 도달했습니다.\n\n---\n\n## 방전은 무엇인가\n\n그렇다면 재충전에 대해서 이야기하기에 앞서 방전이 무엇인지부터 이야기해야 할 것입니다. 방전은 우리 주변에서 전자기기를 사용하면 흔하게 볼 수 있는 현상입니다. 내가 목표로 하는 행위를 하기 위해 기계가 가지고 있는 에너지를 사용하는 것이 방전입니다. 다시 말해, 방전이 일어나지 않으면 행동은 일어나지 않습니다.\n\n평소에 어느 정도 충전이 되어있는 기기를 충전하면서 사용하면 방전과 충전의 균형이 맞춰지지만, 이 균형이 무너지고 방전이 더 많이 일어나면 어느 순간 기기는 완전히 방전되고 사용할 수 없게 됩니다. 이 때는 사용을 중단하고 어느 정도 여유가 생길 때까지 충전을 해야 합니다.\n\n제가 지난 3달간 방전을 해 가면서 이루던, 그리고 앞으로도 할 행동은 취업과 소프트웨어 엔지니어가 되기 위한 것들이었습니다. 그리고 이것들은 세부적으로 다음 세 가지를 목표로 합니다.\n\n```md\n1. 목표 회사\n2. 목표 포트폴리오\n3. 목표 능력\n```\n\n이 중에서 저를 가장 밀어붙이는 역할을 한 것은 바로 지원한 회사들이었습니다. 지난 3개월 간 어떤 회사에 가고 싶은지에 대해서도 구체적인 그림이 그려져 있지 않아 수많은 곳에 지원했고 이 때문에 기존의 저라면 공부하지 않았을 영역들에도 손을 뻗어야 했습니다. 마케팅, 기술 블로그, 팀 프로젝트 구성, 기술 분석, 대화 방법, 블록 체인, 디자인 패턴과 같은 다양한 회사에서 요구하는 역량들은 끝이 없었고 이것들은 저에게 신선한 자극이 되어 주었습니다.\n\n하지만 요 근래 마지막으로 지원한 회사에 집중하느라 다른 회사에 지원할 여력이 부족하기도 했고, 개인적으로 한 번 스스로를 재정비하는 시간을 가지고 싶다는 이유로 추가적인 지원을 하지 않은 기간이 좀 됐습니다. 물론 그 덕에 블로그를 리뉴얼 할 수 있었고 새로운 게임도 즐길 수 있었지만, 이제 여행을 끝내고 일상으로 돌아가려면 다시 새로운 회사들에 지원을 해야한다는 결론에 도달했습니다.\n\n즉, 제가 방전한 것 중 보충하지 못한 것은 지원한 목표 회사였습니다.\n\n---\n\n## 방전은 동시에 성장의 증거\n\n방전된 목표가 충전되는 것이 쉬이 이루어 지지 않은 것은 동시에 제 성장의 증거라고도 생각합니다. 올해 처음에 구직을 시작하면서 회사들에 지원할 때는 무엇을 하고 싶은 지에 대해 방향을 잡지 못해 탐색을 하는 시기이기도 했습니다. 나는 어느 정도 규모의 회사에 가서 일하고 싶은가, 무슨 역할을 맡고 싶은지 잘 알지 못했고 이를 해결하기 위한 방법 중 하나로 여러 분야의 회사들에 지원한 점도 있기 때문입니다.\n\n다양한 분야를 학습하는 것도 재미있었지만, 제가 모든 분야의 전문가가 될 능력을 갖추지는 못한 만큼 방향을 선택해야 했고 되도록 인원 간에 상호작용이 잘 이루어지는 팀이 갖춰진 곳에서 백엔드 개발자로 일하고 싶다는 결론에 도달했습니다. 이는 여러 책을 읽고, 면접을 보고, 팀 프로젝트를 진행하면서 많은 사람 간에 상호작용이 활발히 이루어지는 환경에 있을 때 성장에 자극이 되고 좋은 소프트웨어 엔지니어가 된다는 목표에 도달할 수 있다 느꼈기 때문입니다.\n\n이렇게 방향이 좁혀지는 과정 자체도 방전이었지만, 이전보다 까다로운 욕구를 채워야 하기 때문에 충전에 들어가는 수고가 더 커질 수 밖에 없었다고 생각합니다. 제가 이제는 단순히 내가 할 수 있는 일인가를 기준으로 회사에 지원하던 시기와는 다른 사람이 됐기 때문입니다. 그렇기 때문에 이번에 충전 시간이 길어진 것은 어느 정도 동시에 성장의 증거라고 생각합니다.\n\n---\n\n## 내가 앞으로 해야할 것\n\n일단 방전된 의지력을 충전하는 데에는 성공했으니 적절한 목표만 주어지면 다시 나아가는 데는 문제가 없다 생각합니다. 다만 이전과는 달리 제 배터리에 담을 수 있는 목표로 삼을 회사의 수가 줄어든 만큼 하나 하나가 소중하기 때문에, 제 포트폴리오에 해당하는 것들에 대한 정비를 마무리 하는 것이 먼저라 생각합니다. 제 포트폴리오에 가장 중요한 것 둘을 꼽자면 하나는 이 블로그, 나머지 하나는 현재 팀 프로젝트로 진행 중인 ChatApplication입니다.\n\n다행히도 지난 주 블로그의 외관을 전반적으로 다듬는 것을 심심풀이로 해 놓은 덕분에 할 일이 하나는 줄었다고 할 수 있겠네요. 여담이지만 프론트 엔드 개발하는 것이 얼마나 어려운 지에 대한 편린을 엿볼 수 있었어서 제가 사용하는 웹사이트들을 개발하신 분들에 대한 존경의 마음이 들었습니다. 혼자였으면 아마 지금 수준에 도달하지 못했을텐데, 운이 좋게도 주변 분들께서 도와주신 덕분에 제가 목표로 한 형태의 것으로 일차적인 완성을 할 수 있었습니다.\n\n이제 다음 단계인 ChatApplication에서 현재 목표는 MVP(Minimul Viable Product)를 만드는 일이고, 이 중 제가 가장 먼저 해결할 일은 채팅에 해당하는 모듈 부분을 구현하는 것입니다. 소켓과 관련된 부분을 잘 알지는 못해 이와 관련해서 지난 주에 다른 프로젝트들을 좀 읽어봤는데 아직도 어려운 부분이 많습니다만, 일단은 이 부분을 완성하는 것을 이번 주 금요일까지 목표로 삼으려 합니다.\n\n그런 다음에는 이력서를 다시 점검하려 합니다. 여기까지 마무리 되면 빠르면 금주 주말 늦으면 다음주 초부터는 다시 새로운 저를 등 떠밀어 줄 회사들에 지원하면 되지 않을까 싶네요.\n\n여기에 하나 추가하자면, 여태까지의 구직 과정을 되돌아 보면서 점검하는 글을 하나 쓰려합니다. 되도록 포스팅하는 형태로 진행하고 싶은데 회사와 관련한 세부적인 이야기나 개인적인 이야기가 많이 들어갈 수 있어서 어떻게 해야할 지는 작성해보면서 결정해야겠습니다.\n\n---\n\n## 나에게 글쓰기는 휴식이다\n\n그냥 경험을 하고 나면 바로 배움으로 이어지면 좋을텐데, 애석하게도 제가 미련한 부분이 있어 꼭 글로 정리를 해야만 '아 맞다, 그러네'하고 깨달음으로 이어지는 경우가 많습니다. 굳이 비유하자면 경험을 제 곳간에 쌓을 때 바로바로 정리할 능력이 되지 못해서 따로 시간을 내서 청소를 해 두는 것이라 할 수 있겠네요.\n\n제가 존경하는 김영민 교수님의 말을 빌리자면, \"공부에 매진해본 사람만이 제대로 쉴 수 있습니다. 당겨진 활시위만이 이완될 수 있듯이, 공부라는 긴장을 해 본 사람만이 휴식이라는 이완을 체험할 수 있습니다.\" 최근 3달은 해본 적이 없는 다양한 경험을 하고 어려운 주제에 대한 글을 쓰면서, 제 긴장의 끈을 최대한 당겨 쉴 수 있는 기본기를 쌓는 시기였습니다. 이제는 퇴행을 통해 평소보다 쉬운 글을 쓰니, 제가 근래 가장 결핍돼 있었지만 무엇인지 알지 못했던 것이 진정한 휴식이었음을 알 것 같습니다.\n\n그러면 이제 다음 최고의 휴식을 경험하기 위해 충전된 것들을 방전시키기 시작해야겠습니다.\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"재충전이란 무엇인가","subtitle":"나에게 글쓰기는 휴식이다","date":"2024-04-02T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-04-23-저는 외로웠고, 이젠 아닙니다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-04-23-저는 외로웠고, 이젠 아닙니다.md","category":"신변잡기","title":"저는 외로워서 퇴사를 했고, 이젠 아닙니다","subtitle":"진정한 나로 있는다는 것","content":"\n### 목차\n\n- [2년 전 5월에 퇴사를 하다](#2년-전-5월에-퇴사를-하다)\n- [같이 있다고 해서 외롭지 않은 것은 아니다](#같이-있다고-해서-외롭지-않은-것은-아니다)\n- [저는 집에서도, 밖에서도 외로웠습니다](#저는-집에서도-밖에서도-외로웠습니다)\n- [저는 이제 더이상 외롭지 않습니다](#저는-이제-더이상-외롭지-않습니다)\n- [앞으로 내가 새로운 회사에 기대하는 것](#앞으로-내가-새로운-회사에-기대하는-것)\n- [마무리](#마무리)\n\n---\n\n## 2년 전 5월에 퇴사를 하다\n\n저는 2년 전인 2022년 5월, 졸업 후 1년 반에 걸친 구직 기간 끝에 취업에 성공한 회사를 1년 반이 조금 안 되는 시간을 다닌 끝에 퇴사했습니다. 그 이유가 일반적으로 말하는 사람들의 불만 때문은 아니었습니다. 회식 문화가 과하다든가, 업무가 많아 퇴근을 못한다든가, 야근도 많은데 포괄임금제였던 것도 아니었습니다. 오히려 팀원 분들은 친절하셨고, 업무 강도도 약했던데다가, 급여는 만족스러웠고 그 밖에 각종 복지도 좋았던 꽤나 훌륭한 회사였다고 생각합니다. 실제로 제 동기들 중에서 퇴사한 사람은 저 밖에 없었습니다.\n\n그렇지만 저는 그 회사를 다니는 시간이 너무 아쉽고 불행했다고 느꼈기 때문에, 어렵게 구했던 직장이고 이만한 곳에 다시 들어가기 힘들고 커리어에 손해가 될 것이란 사실을 알았지만 오랜 고민 끝에 퇴사를 결심했습니다. 당시에 저는 그 원인이 회사의 업무 강도가 지나치게 약해 제가 원하는 성장 욕구를 채워주지 못하는 부분 때문이라 생각했지만, 제가 그 때 그렇게 의욕 넘치게 배움을 갈망하고 있었던 것은 아니었기에 동시에 그것이 아니란 사실도 은연중에는 알고 있었습니다. 그렇게 제대로 된 이유를 모른 채, 제 첫 직장과의 인연은 찰나에 끝이 났습니다.\n\n---\n\n## 같이 있다고 해서 외롭지 않은 것은 아니다\n\n최근에 본 유튜브 영상 중에 조승연 작가와 장동선 박사가 찍은 한국인이 왜 외로운지에 대해 뇌과학적으로, 그리고 인문학적으로 이야기하는 [영상](https://youtu.be/U5U_jK-xJjM?si=o1Df9RKTanSTq3mX)이 있었습니다. 해당 영상에서 말하는 외로움은 일반적으로 생각하는 것과는 거리가 멀었고 제가 알고 있던 것과도 많이 달랐지만, 동시에 많은 공감을 할 수 밖에 없는 그런 것이었습니다.\n\n일반적으로 외로움이라고 하면 떠올리는 이미지는 혼자 있는 것, 사람이 없는 것, 사람들과 소통이 없는 것 등이 있습니다. 그런데 신기한 것은 한국 사람들은 전 세계에서 집에 있을 때 혼자 있는 것을 가장 좋아하는 사람들이라는 것입니다. 분명 혼자 있으면 외롭고 같이 있으면 행복해야 할 텐데, 정작 한국 사람들은 혼자 있을 때가 가장 행복하고 편안하다고 말합니다. 왜 그럴까요? 그 이유를 해당 영상에서는 함께 있다는 것과 외롭지 않은 것이 동치가 아니기 때문이라 말합니다.\n\n그렇다면 외로움이란 무엇일까요? 어떨 때 우리는 외롭다고 느끼는 걸까요? 무엇이 우리를 다른 사람과 있을 때 외롭게 만드는 걸까요? 이에 대한 정답으로 장동선 박사와 조승연 작가는 '외로움은 진정한 자신을 드러내지 못할 때 느끼는 것'이라고 말합니다. 다른 사람이 나를 어떻게 생각할 지에 대해 의식하고 자신을 꾸며내는 일을 집 밖에서도 하지만, 집 안에 들어와서도 계속해야하기 때문에 우리는 집에서도 혼자 있게 돼서야 외롭지 않게 되고 자기 자신으로 있을 수 있다 말합니다.\n\n저는 그 이야기를 듣고 제 자신의 삶을 되돌아보며, 제가 여기에서 말하는 외로운 사람의 정의에 부합하는 사람이었으며 제가 겪었던 감정들이 외로움이라 해석하는 것을 부정할 수 없다는 것을 깨달았습니다.\n\n---\n\n## 저는 집에서도, 밖에서도 외로웠습니다\n\n2년 전의 저는 그런 의미에서 굉장히 외로웠고, 심지어 제가 외롭다는 사실을 인지하지도 못했어서 최악인 상태였습니다. 그 때의 저는 회사, 집, 외부, 그 어느 곳에서도 다른 사람들이 나를 어떻게 생각할 지에 대해 의식하고 그에 맞게 행동하고 있었습니다. 분명 어디에 있든 사람들과 소통하면서 웃고 떠들고 있었기 때문에 외로운 사람이라고 생각하지 않았지만, 그것은 사실이 아니었습니다. 저는 그 가족을 포함한 그 누구와 있을 때도 저 자신으로 있지 못했습니다.\n\n앞의 영상에서 두 분은 진정한 자신으로 있는 것을 통해 외로움을 극복하기 위해서는 다양하고 다른 것을 인정하고 받아들이는 환경이 필요하다고 이야기합니다. 그리고 한국은 시스템이 너무 잘 갖춰져 있어 많은 것들이 예측 가능하기 때문에 다양성을 받아들이기 어렵다고 말합니다. MBTI와 같이 너가 누구냐에 대해서도 단순히 16가지로 분류해놓고 그 사람의 행동을 예측하려고 하는 것이 크게 유행하고 있는 것도 다른 사람의 행동이라는 복잡한 것을 통제하려는 욕망에서 나온 것이 아닌가 저는 생각합니다.\n\n저는 어려서부터 남들하고 다르니까 그걸 의식해서 남들과 비슷하게 보이려고 노력해야한다는 이야기를 집에서 많이 들으면서 자랐습니다. '네가 남들하고 다른건 알지?' '네가 언제까지 게임하고 만화 볼 것 같애? 다 나이 먹으면 그만할 건데 적당히 해라.' '그렇게 게임할 거면 차라리 내가 돈을 줄 테니까 집을 나가서 살아' 등등, 제가 집에서 들었던 말들은 제가 가진 개성을 부정하는 것들이었기에 저는 집에 있을 때 가장 외로웠고 문을 닫고 혼자 있을 때가 가장 행복했습니다. 그리고 제가 이런 이야기를 들어서 괴롭다는 이야기를 할 상대도 아무도 없었습니다.\n\n그렇다고 제가 회사에서 이런 개인적인 이야기를 하기를 원한다는 것은 아닙니다. 하지만 문제는 회사에서 일어나는 고민에 대한 이야기를 들어줄 사람 역시 없었다는 점입니다. 오히려 회사에서는 제가 가진 다양한 관심사에 대해 공유하는 사람이 많았기 때문에 그런 이야기를 하는 것은 어렵지 않았지만, 정작 더 중요한 회사 업무에 적응하고 성장하는 데에 있어서의 고민을 진지하게 털어놓을 수 있는 사람이 없다고 느꼈습니다. 당장에 저에게 눈앞에 주어지는 업무들을 처리하는 것은 어렵지 않았지만 그것이 제 이후의 커리어에 충분한 도움이 될 수 있는가, 그것이 부족하다면 나는 어떤 노력을 해야 하는가에 대한 이야기를 나눌 수 있는 사람이 없었기 때문입니다.\n\n그렇기 때문에 저는 회사에서도 외로웠고, 집에서도 외로웠습니다.\n\n---\n\n## 저는 이제 더이상 외롭지 않습니다\n\n퇴사를 한 이후에 저는 이전의 저라면 만나지 않았을 다양한 사람을 만나게 됐습니다. 그리고 그것은, 아마도 제 인생에서 만난 가장 큰 행운이자 축복 중 하나입니다. 주로 온라인을 통해서이긴 했습니다만, 예를 들면 우마무스메 프리티 더비를 같이 플레이했던 단톡방 멤버 분들처럼, 저와 마찬가지로 서브컬쳐 장르를 좋아하는 분들 같이 제가 가지고 있었던 다양한 관심사를 당당하게 드러낼 수 있는 사람들과 함께 있었기 때문에 지난 2년간은 외롭지 않고 너무나 행복한 나날들이었습니다.\n\n또한 제 진로에 대해서 이야기할 수 있는 사람들도 찾을 수 있었습니다. 현업으로 일하는 친구나 우연히 만난 온라인 상에서의 만남, 함께 팀 프로젝트를 진행하게 된 구직을 하면서 같은 고민을 하는 사람들과 이야기를 나누는 시간을 통해서 내가 가진 고민들에 대해 진지하게 토론해 볼 수 있었습니다. 그 밖에 책을 읽는 시간을 통해서도 제가 가지고 있는 고민들에 대해 이전보다는 더 깊이 있게 생각하고 막연한 두려움을 없앨 수 있습니다.\n\n이렇게 제가 가진 다양한 고민들과 성향에 대해서 스스로 고민하고 다른 사람과 공유하는 시간을 통해 저는 더 이상 외로운 사람이 아니게 됐습니다.\n\n---\n\n## 앞으로 내가 새로운 회사에 기대하는 것\n\n너무 무리인 바람일지도 모르겠습니다만, 저는 새로운 회사에 가서는 이전의 저처럼 외로움을 느끼지 않았으면 좋겠습니다. 다양한 성향의 사람들을 받아들일 수 있는 다른 사람을 수용하는 문화가 있었으면 좋겠습니다. 그리고 진로의 고민에 대해 털어놓을 수 있는 믿음직한 동료가 있었으면 좋겠습니다. 회사의 동료는 저의 상황에 대해 정확하게 파악하고 이에 대해 같이 공감하고 들어줬을 때 가장 믿음이 가는 사람이라고 생각하기 때문에 업무적으로 힘들거나 고민이 되는 순간에 도움을 주고 받을 수 있다면 가장 든든한 원군이 될 것이라 생각하기 때문입니다. 물론 이제는 제게도 밖에서 돌아오면 저를 그대로 받아주고 고민을 들어주는 따뜻한 공간이 생겼지만, 회사가 인생에서 차지하는 시간의 비중을 생각하면 회사에서 외롭지 않은 것이 제 인생이 얼마나 외롭지 않았느냐를 결정하는 데에 가장 큰 요소 중 하나라고 생각하기 때문입니다.\n\n그리고 그러기 위해서는 우선 저부터 다른 사람을 받아들일 수 있는 사람이 되려고 노력하고자 합니다. 다른 사람에게 진정으로 관심을 가지고 이야기를 들어주며 공감하는 사람으로써 주변 사람들이 외롭지 않을 수 있는 안전한 공간이 되어주고 싶습니다. 그래서 저처럼 외롭지만 외롭다는 사실조차 모르는 사람들이 제 덕분에 외롭지 않게 되었으면 좋겠습니다.\n\n---\n\n## 마무리\n\n외로움은 건강에 엄청나게 안 좋다는 결과들이 속속들이 나오는 중입니다. 극단적으로는 외로움이 매일 담배를 15개피 피는 것 만큼이나 건강에 치명적이라고도 이야기합니다. 그런 상황에서 한국이 전 세계에서 가장 외로운 나라라는 것은 우리 주변 사람들이 사실 알아채지 못했지만 많이들 아프고 괴로운 것이라 생각합니다. 2년 전의 제가 그랬듯이 말입니다.\n\n모두에게 진정한 자신을 드러낼 수 있는 안식처가 하나 쯤은 있기를, 그리고 없다면 생겨나는 축복이 함께하기를 바랍니다.\n","layout":"산문","recommended":true,"data":{"layout":"산문","classes":"wide","title":"저는 외로워서 퇴사를 했고, 이젠 아닙니다","subtitle":"진정한 나로 있는다는 것","date":"2024-04-23T00:00:00.000Z","categories":"신변잡기","recommended":true}},{"postName":"2024-04-26-5년 전, 그리고 5년 뒤의 나에게","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-04-26-5년 전, 그리고 5년 뒤의 나에게.md","category":"신변잡기","title":"5년 전, 그리고 5년 뒤의 나를 상상하며","subtitle":"얘야, 원래 인생이란 자기 생각대로 되지 않는 법이란다. 그래서 재밌는거 아니겠어","content":"\n### 목차\n\n- [5년 뒤에는 어떤 모습일 거라 생각하냐는 질문을 듣다](#5년-뒤에는-어떤-모습일-거라-생각하냐는-질문을-듣다)\n- [외부를 기준으로 목표를 정하던 5년 전의 나의 모습](#외부를-기준으로-목표를-정하던-5년-전의-나의-모습)\n- [5년 전의 내가 바라보고 있을 지금의 나](#5년-전의-내가-바라보고-있을-지금의-나)\n- [인생은 자기 생각대로 되지 않는 법이란다. 그래서 재밌는거 아니겠어?](#인생은-자기-생각대로-되지-않는-법이란다-그래서-재밌는거-아니겠어)\n- [5년 뒤의 나를 상상하며](#5년-뒤의-나를-상상하며)\n- [마치며](#마치며)\n\n---\n\n## 5년 뒤에는 어떤 모습일 거라 생각하냐는 질문을 듣다\n\n최근 5년 뒤에는 어떤 모습일 거라 생각하냐는 질문을 면접을 보면서 자주 듣는 편입니다. 단순히 내가 가지고 있는 미래에 대한 비전과 제가 되고 싶은 개발자의 모습이란 무엇이냐는 뜻으로 생각하고 여태 대답해왔지만, 저는 추구하고 싶은 개발자로써의 형태가 있는데도 이에 대답하는 것이 굉장히 힘들었습니다. 그것은 제가 삶에서 목표로 추구하는 것이 상상 가능한 형태를 이뤄내는 것을 넘어서, 제가 상상하지 못하는 영역에 도달하는 것을 이상적이라 생각하기 때문입니다.\n\n예를 들어 저는 5년 뒤에 '규모가 10명 이상인 팀의 시니어 백엔드 개발자로써 후배들을 가르치며 성장하는 개발자'가 된다면 현재를 기준으로 훌륭한 삶을 살았다 이야기할 수 있을 것입니다. 혹은 대기업을 가겠다든가, 트래픽이 현재의 페이스북만큼 발생하는 서비스를 유지보수하는 사람이 되고 싶다, 강남에 집을 갖고 싶다, 결혼을 하고 싶다 이런 것을 성취하면 그것 역시도 굉장히 멋진 일입니다. 그렇지만 이것들이 제가 가장 원하는 제 모습이냐하면 그렇지는 않습니다. 이런 가치들을 부정하고 추구하지 않는다는 의미가 아니라, 제가 이루고 싶은 목표는 이렇게 정량적으로 표현할 수 있는 것보다 정성적이고 추상적인 것이기 때문입니다.\n\n분명 제 인생에 있어서 추구하는 형태의 것이 없는 것이 아닌데 이를 남에게 말하는 것이 힘든 것을 보니, 제가 이에 대해 아직 잘 알고 있지 못하고 있구나라는 생각을 하게 되어 고민을 하기 시작하게 됐습니다.\n\n---\n\n## 외부를 기준으로 목표를 정하던 5년 전의 나의 모습\n\n이 고민을 해결하기 위해 가장 먼저 생각이 닿은 지점은, 5년 전의 나는 무엇을 목표로 하고 있었느냐 입니다. 지금으로부터 5년 전인 2019년의 저는 학교를 졸업하기 위해 수업을 듣거나, 네이버 클라우드 플랫폼에서 인턴을 하고 채용 전환에 실패해 실망하기도 하고, 과정에서 면접에 나올 법한 질문에 대답하기 위해 필요한 지식을 완벽하게 습득하려고 노력했습니다.\n\n그리고 저는 면접을 보게 될 때 어떤 질문이 나와도 완벽하게 답변할 수 있을 정도로 학습하려고 노력했고, 그것을 상반기의 공채 전까지 완료한 뒤 제 주변의 다른 친구들만큼 좋다고 평가받는 대기업 혹은 중견 기업에 취업하는 것을 목표로 했었습니다. 지금 와서는 좋은 생각은 아니었다 생각하지만, 그 때는 서류와 코딩 테스트를 통과하고 면접에서 탈락하는 경우가 많았어서 이를 보완하는 데 시간을 쓰자는 생각에 도달했었던 것 같습니다.\n\n이렇듯, 당시에 제가 추구하던 목표들은 제 안에서 나오는 것이 아니라 외부를 기준으로 하고 있었습니다. '내 주변 사람들은 어느 정도의 회사를 가니까, 어떤 시험을 볼 때 나한테 현재 모자란 부분은 어떤 것이니까, 보통 언제까지는 다들 취업하니까.' 그렇기 때문에 저는 제가 가지고 있는 것을 어떻게 활용하면 되는지, 내가 원하는 것이 무엇인지, 당장 내가 공부 외에 할 수 있는 것은 무엇인지에 대해 충분히 고민하지 않고 눈을 돌렸고 컴투스라는 당시의 저에게 과분한 회사에 취업했음에도 2년도 채 안되어 퇴사하게 되었습니다.\n\n---\n\n## 5년 전의 내가 바라보고 있을 지금의 나\n\n5년 전의 제가 현재의 저를 바라본다면 제 인생을 실패했다고 규정할 지도 모르겠습니다. 원하던 만큼 좋은 랩과 대학원에 들어가서 박사 학위를 얻은 것도 아니고, 그 진로를 포기했는데도 제 주변의 친구들과 비교했을 때 사회적으로 뒤쳐졌다고 할 법한 직장에 힘겹게 취업했는데, 그조차 2년도 안되어 퇴사했고, 그보다 더 긴 공백기를 가졌기 때문입니다. 그리고 아마 5년 전의 제가 아니라도 현재의 저를 보고 그렇게 생각할 사람이 꽤 많을 것이라 생각합니다. '그렇게 고생해서 겨우 좋은 대학 나와놓고 참 안타깝네.'와 같은 시선을 받을 것이란 것을 저도 알고 있습니다.\n\n그렇지만 저는 지금의 모습에 꽤나 만족스럽습니다. 매일 아침 저녁으로 운동하고, 관심 있는 일에 글을 쓰고, 나를 이해해주고 이야기를 들어주는 사람들과 함께 할 수 있고, 집에 와서 이전에는 하지 못했을 대화를 나눌 수 있게 된 제 자신이 자랑스럽습니다. 5년 전의 제가 생각했을 때 중요한 가치라고 생각했던 것이나 얻고 싶다고 생각했던 것은 그 어느 것에도 도달하지 못했고, 제 손에 쥐어진 것들은 어린아이의 잡동사니들로 보이는 것들 뿐이지만 저에게는 그 하나 하나가 모두 너무 소중한 보물입니다.\n\n---\n\n## 인생은 자기 생각대로 되지 않는 법이란다. 그래서 재밌는거 아니겠어?\n\n![중성마녀](/images/5년%20전,%20그리고%205년%20뒤의%20나에게/중성마녀.jpg)\n\n이전의 저는 외부의 기준을 바탕으로 인생의 계획을 수립하고 그것을 수행하는 능력이 나름 좋은 편인 사람이었다고 생각합니다. 운이 좋게도 제가 가지고 있는 역량이 사회에서 좋게 봐주는 것들이었기 때문에 힘들지는 않았지만, 적당한 노력을 통해 괜찮은 고등학교와 대학교에 들어갈 수 있었죠. 그렇기 때문에 인생이 자기 생각대로 되지 않았을 때에 이를 어떻게 대처해야하는 지에 대해 전혀 알지 못했고, 잠들어 있던 폭탄은 대학교 졸업을 앞둔 시기에 터졌습니다. 강한 번아웃, 무기력증, 그리고 우울증을 경험하게 된 것입니다.\n\n원하는 학점을 받지 못하고 원하는 대학원에 가지 못했을 때 이를 자신의 능력 부족이라고 받아들이기보다, '나는 할 수 있는 사람인데 노력이 부족해서 그렇다. 더 노력하고 몰아 붙여야 한다. 너는 그럴 능력이 있다'라는 자만심에 스스로를 계속해서 몰아붙인 저는 모든 일에 의욕을 잃고 방 밖을 나서기 조차 싫은 상태에 이르렀습니다. 그런 상황에서 제가 빠져나오는 데 성공할 수 있었던 것은 제 능력이 아니라, 주변에서 저를 가엾게 여기고 밖으로 이끌고 나와 위로해주고 이야기를 들어준 소중한 인연들 덕분입니다.\n\n그리고 이런 경험들을 지나오고 나니, 이제 인생이 자기 생각대로 되지 않는 다는 것을 어느 정도는 즐길 수 있게 됐습니다. 그리고 생각하는 방식도 달라지게 됐습니다. 사실, 인생이 자기 생각대로 된다면 그것은 정말로 재미없는 일 아닐까 생각합니다. 지금의 제가 가지고 있는 조막만한 시야에서 나오는 상상의 산물을 시간을 지나서도 벗어나지 못한다면 그것은 인생에서 발전이 부족한 것이라 생각하기 때문입니다. 영화를 볼 때 내용들이 다 예측 가능한 범주 내에서 나오면 뻔해서 하품이 나오는 것처럼, 인생이 계획대로만 되고 있다는 것은 내가 하품이 나올 정도로 너무 안전한 길을 걷고 있는 중이란 증거라고 요즘의 저는 생각하고 있습니다. 그렇기에 저는 그보다는 제 생각대로 되지 않는 손에 땀을 쥐게하는 인생을 살고 싶습니다.\n\n---\n\n## 5년 뒤의 나를 상상하며\n\n제가 지금 상상할 수 있는 5년 뒤의 이상적인 저의 모습은 그렇게 구체적이지는 않습니다. 그리고 그것은 제가 가지고 있는 식견이 아직 너무나 좁기 때문입니다. 그걸 말로 풀어놓으라 하면 아마 '시니어 백엔드 개발자가 돼서, 구글 같은 빅테크에 취업해, 좋은 동료들과 일할 수 있는 환경에서, 훌륭한 품질의 코드를 통해 성공적인 상품을 런칭하고, 젤다의 전설 같은 즐거운 신작 게임들을 플레이하면서, 지금 같은 블로그 글을 더 잘 쓰고 싶다.\" 정도일 것입니다.\n\n하지만 제가 그보다 더 바라마지 않는 것은 5년 뒤엔 현재 상상할 수 있는 그 어떤 것과도 다른 무언가가 되어 있는 것입니다. 그것은 어쩌면 개발자 중에서 다른 분야로 진출하는 것일 수도 있고, 심지어는 아예 다른 직업을 갖는다거나, 게임이 아닌 다른 취미 생활을 즐길수도 있고, 블로그가 아니라 유튜브 혹은 팟캐스트를 운영하는 것일 수도 있습니다. 심지어 여기 있는 것들은 아직까지 제 상상의 범주 안에 있는 것이니 이것을 뛰어넘는 아직 모르는 가슴이 두근거리는 것을 하고 있는 제가 된다면 그것이 가장 원하는 5년 뒤의 모습입니다.\n\n---\n\n## 마치며\n\n현재의 제 모습은 분명 5년 전의 제가 원하는 것도, 상상했던 것도 전혀 아닙니다. 하지만 저는 지금의 모습이 너무 좋습니다. 그리고 5년 뒤의 저 역시도 지금을 되돌아보면서 대화했을 때, '나도 내가 지금 이러고 살 줄 몰랐는데 내가 생각한 것보다 훨씬 마음에 들어'라는 말을 하는 사람이 되길 바랍니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"5년 전, 그리고 5년 뒤의 나를 상상하며","subtitle":"얘야, 원래 인생이란 자기 생각대로 되지 않는 법이란다. 그래서 재밌는거 아니겠어","date":"2024-04-26T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-04-29-나는 왜 방문을 열게 됐는가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-04-29-나는 왜 방문을 열게 됐는가.md","category":"신변잡기","title":"방문을 열자, 가족이 되었습니다","subtitle":"아파트에서 문을 열어놓는 것의 의미","content":"\n### 목차\n\n- [너 어제 밖에 나갔다 왔니?](#너-어제-밖에-나갔다-왔니)\n- [아파트, 방, 문, 단절](#아파트-방-문-단절)\n- [방 문을 열어 프라이버시를 잃고, 가족을 얻었습니다](#방-문을-열어-프라이버시를-잃고-가족을-얻었습니다)\n- [마치며](#마치며)\n- [참고자료](#참고자료)\n\n---\n\n## 너 어제 밖에 나갔다 왔니?\n\n저는 원래 집에 들어오는 순간 방에 들어가 문을 닫고, 일이 없으면 방에서 나오지 않는 사람이었습니다. 그것이 제가 히키코모리였다는 의미는 아닙니다. 친구들과 만나기 위한 외출은 종종 했으며 디스코드로 친구와 대화하며 게임을 하고, 회사를 나가서 일하는 등의 사회적인 활동도 충분히 했습니다. 한동안 집에 돌아왔을 때 제 방문은 항상 단단하게 걸어잠궈져 있었습니다. 요즘 많이 이야기되는 ['한국 사람은 집에서 혼자서 쉬고 있을 때 가장 행복하다고 느낀다'](집에선 쉬고 싶은 한국인…\"혼자 있을때 가장 즐겁다\" 40%)는 사람의 전형 중 하나가 저였다고 생각합니다.\n\n그러던 제가 굉장히 충격을 받았던 사건이 바로 어머니께 '어제 나갔다 왔어? 나갔는지 몰랐네'라는 이야기를 외박하고 집에 돌아온 다음날 오후에 집에 들어오면서 들은 일이었습니다. 전날 점심때 쯤 친구를 만나기 위해 집을 나섰다가 잠을 자고 돌아올 때까지 집에 있는 그 누구도 제가 집에 없다는 사실을 눈치채지 못했다는 이 사실은, 저에게 우리 가족은 서로에게 그로톡 무관심하지는 않은데 왜 집에 있는지와 같은 가장 기초적인 사실 조차 모를 정도로 소통이 불가능한 단절을 가운데에 두고 지내고 있게 됐는지에 대해 고민하게 만들었습니다.\n\n---\n\n## 아파트, 방, 문, 단절\n\n최근 셜록 현준님의 영상을 많이 보면서 현재 제 주거 공간이 어떻게 제 삶을 영향을 주는지 많은 생각을 하게 되었습니다. 이 중에서 굉장히 인상 깊게 들은 이야기 중 하나는 ['아파트 방들에는 거실을 향하는 창문이 필요하다'](https://m.blog.naver.com/hyunjoonyoo/221701794032)라는 말씀이었습니다. 해당 글에서 셜록 현준님의 주장은 다음과 같습니다.\n\n\"건축에서 벽은 공간을 나누고 단절하는 장치이며, 문은 벽을 뚫고 두 공간을 적극적으로 연결해주는 장치이고, 창문은 시각적으로만 소통하게 해주는 소극적 연결 장치이다. 사람 간에 가장 좋은 관계는 적당한 거리를 유지하는 것이다. 관계가 너무 가까우면 사생활이 없어지고, 관계가 끊어지면 외롭다. 적당한 거리를 유지해주는 건축 장치는 창문이다.\"\n\n저는 이 말씀을 듣고 항상 굳게 걸어잠겨 있는 제 방의 문을 되돌아보면서 우리 가족이 단절돼있던 것이 세대간의 차이를 이해하지 못하는 대화 같은 것에서도 기인하는 부분이 있겠습니다만, 그보다는 소통 자체의 총량이 모자란 것이 주 원인이라는 생각을 하게 됐습니다. 마치 제 블로그의 디자인이 변화하면 기존에 제가 작성해 뒀던 글이 주는 경험이 여태까지 주던 것과는 다르게 변하는 것과 동시에 이후에 작성한 글들이 변화했던 것처럼, 제 방의 디자인을 바꾸는 것을 통해 가족과 단절된 시간을 줄이고 연결되어 소통하는 시간을 늘리는 노력을 해야겠다는 결심을 하게 됐습니다.\n\n---\n\n## 방 문을 열어 프라이버시를 잃고, 가족을 얻었습니다\n\n유현준 교수님께서 가장 이상적인 소통 방식으로 방에 창문을 다는 것을 말씀하셨습니다만, 애석하게도 전세집인 이 아파트에 창문을 뚫는 시공을 하는 것은 불가능한 일입니다. 그래서 저는 차선책으로 제 방 문이 기본적으로는 열려있는 상태가 되도록 변화를 줬습니다. 이전에 방에 들어오면 문부터 닫았다면, 지금은 제가 방에서 혼자 조용하게 해야 집중해야 하는 시험을 보는 등의 일이나, 전화 통화 같이 프라이버시를 지켜줘야하는 상황이 아니면 대부분 문을 열어두고 있습니다. 그리고 변화가 찾아왔습니다.\n\n저는 이제 동생이 공부하다가 간식을 먹으려고 주방에 걸어가는 모습을 보고 같이 먹자고 이야기를 꺼낼 수 있게 됐습니다. 어머니께서 보고 있는 tv 프로그램에 어떤 사람이 나오고 있는지 알 수 있게 됐습니다. 식사 준비를 위해 칼질하는 소리를 듣고 옆에서 이를 도와줄 수 있게 됐습니다. 그렇게 저는 방 문을 열어 프라이버시는 잃었지만 대신 가족을 얻게 되었습니다.\n\n---\n\n## 마치며\n\n물론 집에 돌아와 나만의 온전한 시간을 갖는 것은 재충전을 하는 데에 있어 굉장히 중요합니다. 저 역시도 이런 글을 쓰는 게 가장 잘 되는 시간은 가족이 모두 잠들어 있는 새벽 시간에 혼자 음악을 틀어놓고 나만의 시간을 가지고 있을 때입니다. 하지만 저는 집에서 모든 순간에 혼자만의 시간을 추구하기보다는 가족과 함께 내 삶을 공유하고 소통하는 삶도 이루어 가족의 일원으로써 함께하고 외롭지 않은 삶을 살고 싶습니다. 그렇기 때문에 두렵지만 제 방 문을 가능한 열어두는 것을 선택했고 그 결정에 만족합니다.\n\n응답하라 1988과 같은 가족 드라마에서 나오는 가족들은 풍족하지도 못하고 갈등이 계속해서 발생하지만 그들이 끈끈하게 있을 수 있는 것은, 같은 공간과 시간을 요즘의 우리보다 훨씬 더 많이 공유하기 때문이라 생각합니다. 요즈음 그 시절 가족들은 다툼이 있었지만 더 시간을 공유하고 싶어하고 친했으며, 외롭지 않고 행복했다 느꼈던 것은 어쩌면 우리들의 아파트에는 벽이 있고 그 방문이 굳게 걸어닫혀있는 것이 기본 상태이기 때문은 아니었을까 하고 조심스레 생각해봅니다.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n\n## 참고자료\n\n- [집에선 쉬고 싶은 한국인…\"혼자 있을때 가장 즐겁다\" 40%](https://www.sedaily.com/NewsView/2D43FCI7Z5)\n- [창문으로 세상을 바꾸는 방법](https://m.blog.naver.com/hyunjoonyoo/221701794032)\n","layout":"산문","recommended":true,"data":{"layout":"산문","classes":"wide","title":"방문을 열자, 가족이 되었습니다","subtitle":"아파트에서 문을 열어놓는 것의 의미","date":"2024-04-29T00:00:00.000Z","categories":"신변잡기","recommended":true}},{"postName":"2024-05-07-from odds and ends to room","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-07-from odds and ends to room.md","category":"신변잡기","title":"정리를 통해 잠만 자는 공간에서 나로써 존재할 수 있는 공간으로","subtitle":"잡동사니에서 방으로","content":"\n### 목차\n\n- [정리를 통해 인생 최초로 내 공간을 얻다](#정리를-통해-인생-최초로-내-공간을-얻다)\n- [아시아 사람은 집에는 관심이 많으면서 정작 꾸미는데는 관심이 없다](#아시아-사람은-집에는-관심이-많으면서-정작-꾸미는데는-관심이-없다)\n- [마무리](#마무리)\n\n---\n\n## 정리를 통해 인생 최초로 내 공간을 얻다\n\n부끄러운 이야기입니다만, 며칠 전에서야 제 인생 처음으로 옷장과 방을 스스로 정리했습니다. 방을 청소하거나 정리해본 적이 여태까지 없다는\n 것은 아니라 이것들을 어떻게하면 내 생활 패턴에 어울리는 형태로 자리를 잡게 만들어 내 개성을 드러내는 공간으로 사용한 것은 이번이\n 처음이었습니다. 그런 과정을 통해 나는 여태까지 내 부모님이 만들어주신 방을 쓰거나 학교에서 제공하는 공동의 공간으로써 자연발생적인\n 방을 가졌던적은 있지만, 이번처럼 '내 공간'이라 할 수 있는 곳은 처음 사용해본 것 같다는 생각이 들었습니다.\n\n옷걸이 전반을 내가 원하는 순서대로 재배치하고 옷걸이에 올라가지 않는 옷은 분류하는 과정을 통하다보니 프로그래머로써의 관점에서 '디자인이\n 아니라 기능만이 중요한 운동복 같은 옷이라면 큐처럼 선입선출로 관리할 방법이 없을까?'와 같은 질문에 도달하기도 했습니다. 지구의 중력을\n 거스르는 일은 워낙에 대단한 일이기에 이에 도달하지는 못했지만, 옷 정리 트레이를 구매하고 이에 포개서 옷을 정렬해두니 제 개성이 드러나는\n 공간이 되는 것을 볼 수 있었습니다.\n\n제 공간에서 드러나는 개성은 유지 관리 용이한 시스템을 구축하는 것을 좋아한다는 점입니다. 그러기 위해 가장 많이 사용하는 물건은\n 접근성이 높은 공간에 사용 빈도가 낮은 물건은 접근성이 낮은 공간에 두고, 비슷한 성향의 물건들은 같은 곳에 관리합니다. 그리고 이 방이\n 단순히 제 노력만으로 유지되는 것이 아니라 적은 노력과 자연스러움으로도 유지될 수 있도록 박스, 트레이, 선반과 같은 도구로 시스템을\n 갖춰두었습니다.\n\n---\n\n## 아시아 사람은 집에는 관심이 많으면서 정작 꾸미는데는 관심이 없다\n\n얼마 전 외국인들이 가지는 의문 중에 아시아인들은 왜 집을 꾸미는 데에는 관심이 없느냐는 이야기를 본 적이 있습니다. 아시아인들이 집에\n 대해 보이는 관심은 지대한 데 반해, 정작 이를 꾸미는 노력은 서양 사람들이 바라볼 때 이해하기 힘들 정도로 부족하다는 것입니다. 해당 영상\n에서는 이에 대해 집은 '가격, 부지, 평수'와 같이 남들과 정량적으로 비교를 통해 계급을 나타내는 수단으로 사용할 수 있는 반면, 집을 꾸미는\n 것은 '개인의 취향과 개성을 드러내는 수단'이기 때문이라 이야기합니다.\n\n이에 대해 무조건적인 동의를 할 수는 없습니다만, 저와 제 가족의 사례로 놓고 봤을 때는 이 이야기가 어느 정도 맞다고 생각합니다. 저희\n 가족은 집에서 방을 단순히 잠을 자고 일어나 밖을 나가기 위해 정비하기 위한 일종의 전투기의 격납고 같은 공간으로써만 활용해 왔습니다.\n 제 가족에게 중요한 것은 해당 집이 역세권 몇분 거리인지, 서울에서 얼마나 떨어져있는지, 주변에 편의시설이 얼마나 있는지와 같은 외적인\n 요소 뿐이었습니다. 집을 꾸미는 것은 남들이 다들 하는 것을 따라하는 것이면 족했습니다. 그리고 이제는 그런 집에서 벗어나고 싶다고\n 생각하고 이를 위해 노력하려 합니다.\n\n---\n\n## 마무리\n\n정리와 내 물건들로 방을 꾸미는 것은 제 개성을 드러내는 것이며 동시에 방을 격납고가 아니라 내가 나로써 있을 공간으로 만들어주는 행위\n라는 사실을 이번 일을 계기로 깨달을 수 있었습니다. 정리를 하고 빈 공간이 생기니 이를 채우기 위한 아이디어가 떠오르고, 그것을 실행하니\n 또 다른 아이디어가 떠오르는 과정을 통해 제 방은 점점 더 나를 닮아가고 있습니다.\n\n그러다보니 현재 제 방에는 얼마 전까지는 없었던 스피커, 가습기, 옷장 정리 트레이, 피규어 같은 물건들이 들어오게 되었습니다. 그리고\n 이전에는 방을 단순히 잠을 자면 족하던 공간으로 생각했지만 이제는 제 방이 제가 나로써 가장 자연스럽게 존재할 수 있는 공간이 되었다고\n 생각합니다. 이제 곧 얼마 전 구매한 베개가 오면 그것들은 또 제 방을 더 나로써 가깝게 만들어줄 것이 즐겁게 기대되네요. 앞으로도 제 방을\n 더 나에게 가깝고 나로써 존재할 수 있는 공간으로 만들어가는 과정을 즐기며 이를 통해 나를 더 알아가고 싶습니다. 그러기 위해선 먼저\n 정리부터 시작해야 하겠지만요.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"정리를 통해 잠만 자는 공간에서 나로써 존재할 수 있는 공간으로","subtitle":"잡동사니에서 방으로","date":"2024-05-07T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-05-15-새로움을 경험하며 나를 돌아보다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-15-새로움을 경험하며 나를 돌아보다.md","category":"신변잡기","title":"비어있는 공백기가 아니라 충만했던 탐색기(1)","subtitle":"새로움을 경험하며 나를 돌아보다","content":"\n### 목차\n\n- [지난 2년의 공백기 동안 뭘하고 보내셨나요?](#지난-2년의-공백기-동안-뭘하고-보내셨나요)\n- [나에게 탐색기가 필요했던 이유](#나에게-탐색기가-필요했던-이유)\n- [굳이 새로운 환경을 찾은 이유](#굳이-새로운-환경을-찾은-이유)\n- [마치며](#마치며)\n\n---\n\n## 지난 2년의 공백기 동안 뭘하고 보내셨나요?\n\n구직을 위해 면접을 보면 제게 늘 물어보는 질문 중 하나가 있습니다. 그것은 '이전 직장을 퇴사한 이후에 공백기가\n꽤 긴데, 미기입 하신 건가요? 혹시 이 기간 동안에는 무엇을 하셨나요?'입니다. 이에 대해 저는 '그\n기간은 제게 있어서 자신을 되돌아보기 위해 기존에 하지 못했던 것들을 시도하고 새로운 사람들을 만나는 시간으로,\n경력적으로는 빈 기간이었을 수 있지만 제 인생에서는 충만했던 탐색기였습니다'라고 대답할 수 있지 않을까 싶습니다.\n\n---\n\n## 나에게 탐색기가 필요했던 이유\n\n전에 [저는 외로워서 퇴사했고, 이젠 아닙니다](https://kaestro.github.io/%EC%8B%A0%EB%B3%80%EC%9E%A1%EA%B8%B0/2024/04/23/%EC%A0%80%EB%8A%94-%EC%99%B8%EB%A1%9C%EC%9B%A0%EA%B3%A0,-%EC%9D%B4%EC%A0%A0-%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4.html)라는 글에서 밝혔던 것처럼, 저는 인간으로 살아가는 데 스스로를 힘들게 만드는\n요소들이 많았습니다. 다른 사람을 믿지 못해 제 고민을 이야기하지 않았고, 문제의 해결은 큰\n노력없이 시간이 해결해주기만을 기다렸습니다. 그리고 이런 방식은 저를 고립시키고, 더욱 더 외로워지게 만들었습니다.\n제게 변화가 필요했다는 것은 확실했고, 제가 이를 해결하기 위해 선택한 방법은 현재 속한 환경에서 벗어나는 것이었습니다.\n\n---\n\n## 굳이 새로운 환경을 찾은 이유\n\n기존의 환경 내에서도 변화를 이루는 것이 가능했을지도 모르지만, 저 같은 경우는 환경을 바꿀 때 생기는 변화들을 통해\n현재의 사람이 되어오는 자기 갱신의 경험들을 체험해온 것이 이런 도전을 선택하게 된 원인입니다. 구체적인 예시로 고등학교는\n공주에 있는 한일 고등학교라는 조그만 기숙학교를, 군 생활은 카투사(KATUSA)로 복무하면서 겪은 경험들이 기존의 환경과는\n완전히 달랐고 그곳에서 생활하면서 새로운 자신을 발견하는 경험들을 할 수 있었기 때문입니다.\n\n한일 고등학교는, 지금은 바뀌었을 것으로 생각되지만, 전원이 기숙사에서 생활하며 학원이 아니라 스스로 학습을 해야만\n하는 환경이란 점이 기존과 달랐습니다. 이는 중학교 때까지 무언가를 배우기 위해서는 항상 학원부터 찾았던 저에게는 큰 변화를\n가져왔습니다. 한일고를 다니면서 저는 매일 아침에 그 날의 할 일을 계획하고 실천하며 피드백하는 것을 습관으로 만드는 과정을\n거쳤고, 이를 통해 저는 스스로 문제를 해결할 줄 아는 사람이 되었습니다. 그리고 이를 통해 나름 괜찮은 대학에 진학할\n수 있었습니다.\n\nKATUSA는 Korean Augmentation To the United States Army의 약자로, 한국 군대의 병력을 미군에게 보조하는 역할을\n하는 군인들을 일컫는 말입니다. 해당 프로그램을 통해 저는 미국인들과 함께 생활하면서 다양한 문화를 경험하고\n새로운 사람들과 친구가 되는 경험을 통해 다름을 인정하고 존중하는 사람이 될 수 있었습니다. 낚시와 사냥을 좋아하는\n상사와 휴일에 화천 산천어 축제를 가거나, 서울 구경을 하면서 나에게 익숙한 것이 다른 사람에게는 독특하고 신기하며\n당연하지 않다는 사실을 배울 수 있었습니다. 이러한 경험들을 통해 저는 다름을 인정하고 존중할 수 있는 능력을 길렀기\n때문에 새로운 사람과 환경에서 변화하는 것에 대해 긍정적인 태도를 가지게 되었습니다.\n\n---\n\n## 마치며\n\n이처럼 기존에 속한 환경을 바꾸는 것을 통해 새로운 것을 체험하고, 자신을 되돌아보면서 재구축하는 경험은 저에게\n항상 긍정적인 변화를 가져다주었습니다. 그렇기 때문에 2년 전에 퇴사를 하고 탐색기를 가지기 위해 새로운 환경으로\n떠난 것은 제게 있어서 굉장히 인생을 충만하게 채워주었고, 이를 통해 새로운 나를 발견하고 성장할 수 있었다 생각합니다.\n\n다음 글에서는 이러한 탐색기를 통해 어떤 변화를 이루었는지, 그리고 이를 통해 얻은 것들이 무엇인지에 대해 이야기해보겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"비어있는 공백기가 아니라 충만했던 탐색기(1)","subtitle":"새로움을 경험하며 나를 돌아보다","date":"2024-05-15T00:00:00.000Z","categories":"신변잡기","series":"비어있는 공백기가 아니라 충만했던 탐색기","seriesIndex":1}},{"postName":"2024-05-16-새로움을 경험하며 나를 돌아보다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-16-새로움을 경험하며 나를 돌아보다.md","category":"신변잡기","title":"비어있는 공백기가 아니라 충만했던 탐색기(2)","subtitle":"소중한 것을 손에서 놓아보다","content":"\n### 목차\n\n- [더욱 더 새로운 사람을 만나고, 안 하던 것을 하는 환경으로 저를 밀어넣었습니다](#더욱-더-새로운-사람을-만나고-안-하던-것을-하는-환경으로-저를-밀어넣었습니다)\n- [직업을 탐색하는 기간을 가졌습니다](#직업을-탐색하는-기간을-가졌습니다)\n- [내가 손에서 놓은 것의 가치를 알게 되었습니다](#내가-손에서-놓은-것의-가치를-알게-되었습니다)\n- [마치며](#마치며)\n\n---\n\n## 더욱 더 새로운 사람을 만나고, 안 하던 것을 하는 환경으로 저를 밀어넣었습니다\n\n저는 원래 새로운 사람을 많이 만나지 않는 편이고 먼저 연락도 잘 하지 않는 사람이었습니다. 일년 동안 일을 제외하고는\n누군가 소개해주는 것이 아니라면 새로운 사람을 만나지 않는 것이 대부분이었죠. 게임을 취미라고 했지만,\n하던 게임의 하던 캐릭터를 반복하는 안전한 환경에서만 즐기는 편이었습니다. 그리고 가장 먼저 바꾼 것이 이런\n환경이었습니다.\n\n저는 카카오톡 오픈 채팅의 다양한 채팅방에 들어가며 새로운 사람들을 만나기 시작했습니다. 단순히 채팅방에서만\n대화하는 것을 떠나 함께 만나서 식사를 하고, 커피를 마시며 대화를 나누는 시간을 가졌습니다. 또 장르를 막론하고\n젤다의 전설, 우마무스메 프리티 더비, 몬스터 헌터와 같은 전혀 다른 게임을 즐기며 게임에 대한 넓은 시야를\n얻을 수 있었습니다.\n\n이런 기존과 다른 다양한 것을 하는 것이 강제된 환경에서 저는 새로운 사람들을 만나고, 경험을 하며 이전에는 생각지도\n못했던 자신이 만들어지는 것을 확인할 수 있었습니다.\n\n---\n\n## 직업을 탐색하는 기간을 가졌습니다\n\n그런 다음에는 과연 개발자가 제게 맞는 직업인지, 혹은 다른 직업을 찾아보는 것이 좋을지에 대해 확인하기 위해\n다양한 직업을 경험해보기로 했습니다. 일용직으로 물류센터에서 근무하거나, 학원에서 선생으로 근무하고, 돈을 받고\n글을 쓰는 일을 해보기도 했습니다. 해당 직업들의 경험들은 모두 제게 새로운 경험이었음과 동시에 맞는 부분이 있어\n평생을 이 직업으로 살아가는 것도 나쁘지는 않겠다는 생각이 들었습니다.\n\n하지만, 이런 경험들을 통해 제가 가장 만족스러워하는 일은 개발자로서의 일이었음을 알게 되었습니다. 개발자가 되어\n버그를 찾고 머리를 쥐어 뜯으며 해결하거나, 어제와 달라진 오늘의 새로운 기술을 습득하고, 이를 통해 다른 사람들과\n함께 상품을 만드는 것을 할 때 가장 자기 갱신의 체험을 많이 할 수 있었고 그 과정이 즐거웠기 때문입니다.\n\n그렇게 기존과 다른 곳에서 오랜 기간 방황을 한 끝에 저는 기존의 환경이 제가 가장 원하는 것임을 깨달았고, 현재는\n개발자로서 복귀하기 위해 노력하는 중입니다.\n\n---\n\n## 내가 손에서 놓은 것의 가치를 알게 되었습니다\n\n자신이 가진 것의 가치를 알기 위해서는 그것을 손에서 놓아봐야 한다고 합니다. 지난 약 2개월의 기간은 제게 있어서\n그것을 실천하고, 그 빈자리를 여러 가지 다른 것들로 채워보는 시간이었습니다. 그리고 이런 경험들을 통해 제 빈자리를\n메워줄 수 있는 가장 잘 맞는 것이 제가 원래 가지고 있던 것이었다는 것을 깨달을 수 있었습니다.\n\n그렇다고 단순히 제가 멀리 돌아오기만 한 것은 아닙니다. 대신 저는 다양한 경험들과 사람들을 만나면서 새로운 도전을\n하고 실패하는 과정을 두려워하지 않는 성정을 가지게 되었습니다. 그리고 이전처럼 문제가 해결되기를 기다리는 것이 아니라\n먼저 나서서 해결하려는 자세를 가지게 되었습니다.\n\n---\n\n## 마치며\n\n이처럼 기존의 환경을 떠나 새로운 것을 경험하고, 자신을 되돌아보며 재구축하는 경험은 저에게 항상 긍정적인 변화를\n가져다주었습니다. 그렇기 때문에 2년 전에 퇴사를 하고 탐색기를 가지기 위해 새로운 환경으로 떠난 것은 제게 있어서\n인생을 한번 다시 채우기 위해 우선 비우고 정리하는 시간이었다고 생각합니다. 그리고 이제는 정리해둔 공간을 다시\n채워나가기 위해 노력해야겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"비어있는 공백기가 아니라 충만했던 탐색기(2)","subtitle":"소중한 것을 손에서 놓아보다","date":"2024-05-16T00:00:00.000Z","categories":"신변잡기","series":"비어있는 공백기가 아니라 충만했던 탐색기","seriesIndex":2}},{"postName":"2024-05-16-작고 소중한 28회","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-16-작고 소중한 28회.md","category":"신변잡기","title":"작고 소중한 28회의 클릭","subtitle":"최초의 구글 서치 콘솔 업적","content":"\n### 목차\n\n- [작은 업적을 달성하는 성취감](#작은-업적을-달성하는-성취감)\n- [읽어주신 분들에게 감사의 말씀을 드리고 싶습니다](#읽어주신-분들에게-감사의-말씀을-드리고-싶습니다)\n- [다음에는 30, 40회를 목표로](#다음에는-30-40회를-목표로)\n\n---\n\n## 작은 업적을 달성하는 성취감\n\n5월 15일 뜻밖에 구글 서치 콘솔에서 '축하드립니다'로 시작하는 메일이 와 있었습니다. 무슨 일인지 궁금해서 열어보니,\n제가 운영하는 블로그에서 구글의 검색 엔진을 통해 유입된 클릭 수가 지난 28일간 20회를 넘은 업적을 달성했다는\n내용이었습니다.\n\n![20회 달성 업적](/images/구글서치%20첫%2028일/20회%20업적.png)\n\n유튜브에서 조회수가 20회를 넘었다면 그것이 대단한 것은 못되는 것처럼, 제가 모든 조회수를 현재는 추적할 방법이\n없습니다만 블로그의 클릭 수가 20회를 넘었다는 것은 그리 큰 일이 아닌 것 같습니다. 그럼에도 불구하고 이런 조그만\n업적을 달성했다는 것이 뿌듯하게 느껴졌습니다.\n\n---\n\n## 읽어주신 분들에게 감사의 말씀을 드리고 싶습니다\n\n구글 서치 콘솔에 등록한 지는 얼마 되지 않았습니다만, 그 이전에도 제 모자란 블로그를 방문해 주시거나, 이를 퍼나른\n커뮤니티의 글들을 읽어주시고 댓글을 달아주신 분들에게 꼭 감사의 말씀을 전하고 싶습니다. 그 분들의 따뜻한 격려의\n말씀들이 없었다면 이 작은 성취조차 달성하지 못했으리라 생각합니다. 그러니 이 조그만 업적 달성은 저만의 것이 아니라\n읽어주신 분들과 함께한 것이라 생각하고, 이에 보답하기 위해 더 나은 글을 쓰고자 노력해야겠다는 생각을 하게 됩니다.\n\n---\n\n## 다음에는 30, 40회를 목표로\n\n![28회 클릭 횟수](/images/구글서치%20첫%2028일/28회.png)\n\n이번에는 30회에 아쉽게 조금 미치지 못했지만, 다음에는 30회 그리고 더 나아가 40회 이상의 클릭 수를 달성할 수\n있도록 정진하고 싶습니다. 나름 자신 있는 3편의 글을 써 둔 것이 있고 올릴 순간을 보고 있으니 이 글들이 더 많은\n분들에게 도움이 되고, 그에 대한 보답으로 클릭 수가 더 많이 증가할 수 있으면 좋겠네요.\n\n그럼 이번에도 읽어주셔서 감사하고, 앞으로도 더 나은 글을 쓰기 위해 노력하겠습니다. 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"작고 소중한 28회의 클릭","subtitle":"최초의 구글 서치 콘솔 업적","date":"2024-05-16T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-05-01-수단이 아닌 목적으로써의 면접을 위하여","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/수단이 아닌 목적으로써의 면접을 위하여/2024-05-01-수단이 아닌 목적으로써의 면접을 위하여.md","category":"신변잡기","title":"합격보다 소통을 목표로 하는 면접을 위하여(1)","subtitle":"20번의 면접을 통해 느낀 면접 탐구자의 소회","content":"\n### 목차\n\n- [4개월간 총 17번의 면접을 기록한, 전문가가 아니라 탐구자](#4개월간-총-17번의-면접을-기록한-전문가가-아니라-탐구자)\n- [공개 채용 vs 수시 채용](#공개-채용-vs-수시-채용)\n- [합격을 위한 수단으로써 면접은 괴롭고, 서로에게 해롭다](#합격을-위한-수단으로써-면접은-괴롭고-서로에게-해롭다)\n- [마치며](#마치며)\n- [참고 자료](#참고-자료)\n\n---\n\n## 4개월간 총 17번의 면접을 기록한, 전문가가 아니라 탐구자\n\n이번에 문득 제가 면접을 몇 번이나 봤는가 회고하는 시간을 가진 적이 있습니다. 그리고 지난 약 4개월 간 제가 기록해 둔 면접들은 1, 2차와 같은 것을 구분하지 않고 별개의 회사를 기준으로 할 때 17번인 것을 확인할 수 있었습니다. 가능한 빠짐없이 기록해두려 노력했습니다만, 제가 놓친 것이 있을 수 있는 것을 감안하면 아마도 20번에 가까운 면접을 보지 않았을까 싶습니다.\n\n그러면 나는 면접의 전문가인가?라고 생각했더니 전문가라하면 적은 횟수에 빠른 합격을 하는 사람을 말하는 것이라는 생각이 들어 고작 중간 면접 1번, 가기를 선택하지 않은 최종 면접 1번을 합격한 저는 이에 부합하지 못하단 생각이 들었습니다. 그러니 굳이 표현하자면 저는 면접의 전문가라기보다는 아마도 탐구자라 부르는 것이 맞지 않을까 싶습니다.\n\n이런 과정을 통해 저는 과거의 면접과 현재의 면접은 많은 부분에서 달라지고 있다고 생각합니다. 탐구자로써 제가 면접에 대해 어떻게 생각하느냐에 대해 짧은 식견에 대해 이야기하자면, 공개 채용이 사라지고 수시 채용이 늘어가고 있는 것은 면접의 목적이 달라지고 있다는 것을 말하며 이는 면접을 보는 입장에서도 그렇고 동시에 면접을 치루는 입장에서도 그럴 것이라 믿습니다.\n\n---\n\n## 공개 채용 vs 수시 채용\n\n공개 채용과 수시 채용은 그 목적이 다르고, 이 때문에 다른 형태로 진행이 됐다고 봅니다. 둘 다 회사에서 현재 필요로 하는 인재를 발굴하는 것이 목표인 것은 동일하지만 공개 채용에서는 교육을 통해 회사 전반의 업무를 두루 수행할 수 있어 교육이 끝난 시점에 부서별 필요에 따라 투입할 수 있는 인재를 찾는 것이 목표였다고 생각하는 반면, 수시 채용에서는 회사에서 현재 가지고 있는 특정한 문제를 해결할 수 있는 능력을 가지고 있는 인재를 찾는 것이 목표라는 것이 제 생각입니다.\n\n그렇기 때문에 전통적인 공개 채용은 회사와 지원자의 입장에서 상대에 대해 자세히 알고 있을 필요가 없었고, 사람을 채용할 때 선호하는 인재상은 어느 곳에 두어도 무난한 사람이며 지원자도 단순히 금전이나 복지와 같은 조건만을 기준으로 더 좋은 회사를 우선시하게 됩니다. 그리고 이런 성향이 개개인이 가지고 있는 세부적인 능력이나 경험보다 좀 더 일반적인 것들에 대한 평가를 할 수 있는 방식으로 면접이 진행되도록 만들었다 생각합니다.\n\n대표적인 것이 이제 상대가 존경하는 인물이나 성장 과정 등에 대한 기술, 그리고 본인이 생각하는 장단점을 말하라는 질문 등입니다. 회사들이 이런 질문을 했던 배경에는 기존에는 채용자가 입사해서 특정한 역할을 해내기를 기대하기 보다는 들어온 뒤 회사의 니즈에 맞춰 새로 교육하고 필요한 부품으로 완성해 임의의 분야에 투입하는 것을 목표로 했기 때문입니다.\n\n반면에 수시 채용은 양쪽 모두 상대에 대해 더 자세히 알아야 할 필요가 있고, 이는 채용의 목적이 회사가 가지고 있는 특정한 문제를 해결할 수 있는 사람을 채용하는 것이기 때문입니다. 이 때문에 회사는 지원자에게 자신이 가지고 있는 문제에 대해 더 자세히 설명할 필요가 생겼고, 지원자는 자신이 해당 문제를 해결할 수 있는지와 그업무를 하길 원하는지에 대해 생각해야할 필요가 있다고 봅니다. 그렇기에 채용 공고에서 회사들이 이전보다 세부적인 업무 내용이나 능력을 기술하고 요구하는 것은 단순히 회사들이 사람을 뽑을 때 더 까다로워졌다기 보다는 현재 회사가 마주하고 있는 문제를 해결하기 위해 필요한 능력들에 대한 상술이지 않을까 생각합니다.\n\n둘 다 회사가 지향하는 바와 필요로하는 사람의 능력이 다르기 때문에 목적이 다를 뿐이지 어느 것이 더 우월하다고 말할 수는 없을 것입니다만, 요새 수시 채용이 늘어나고 있는 것은 세태가 파편화되고 있는 것과 연관이 있다 생각합니다. 유튜브와 틱톡 등을 통해 사람들은 tv와 공중파를 통해 모두가 비슷한 관심사를 공유하던 것에 비해 다양한 성향을 가지게 됐고 그만큼 회사들도 다양한 문제를 마주하게 되었습니다. 이런 상황에서 공개 채용은 회사가 가지고 있는 문제를 해결할 수 있는 사람을 찾기 어려워지고, 이에 대한 대안으로 수시 채용이 늘어나고 있는 것이 아닐까 생각합니다.\n\n제가 최근 진행했고, 진행하게 될 채용은 전부 수시채용이기 때문에 여기서부터는 수시 채용에 대한 이야기만을 이어나가겠습니다.\n\n---\n\n## 합격을 위한 수단으로써 면접은 괴롭고, 서로에게 해롭다\n\n면접을 합격을 위한 수단으로 생각하면 굉장히 괴로운 것이 사실입니다. 합격이란 사전적으로 ['일정한 조건을 갖추어 어떠한 자격이나 지위 따위를 얻음'](https://ko.dict.naver.com/#/entry/koko/7b6f1c8807ce40e29f1afc348dd18b5f)을 말합니다. 취업 면접에서 상대가 제시하는 잡 포지션을 얻기 위해 노력하는 것은 당연한 일입니다만, 이를 유일한 목적으로 삼는 순간 자신은 완전한 을의 상태가 되어 스스로에 대해 생각하는 것을 하기 힘들어지고 대화의 중심을 상대에게 두게 됩니다. '이렇게 말하면 면접관이 나를 좋게 생각해 줄까?' 혹은 '이런 말을 하면 나를 안 좋게 생각하지는 않을까?'와 같은 생각을 통해 말입니다.\n\n그런데 문제는 본인이 무슨 노력을 하더라도 상대가 본인에게 가지게 되는 생각은 그 짧은 순간의 기지나 재치로 결정되기 보다는 평소에 자신이 어떤 사람이냐가 결정하는 것이 대부분이고, 나머지도 상대가 이를 어떻게 받아들이느냐에 달려있지 상대의 눈치를 보는 것에 달려있지 않다는 것입니다. 설사 상대의 눈치를 보고 원하는 사람임을 꾸며내어 합격을 받았다고 해도 그것은 본인이나 회사의 입장에서 불행한 관계가 될 가능성이 높다 생각합니다.\n\n이는 마치 소개팅 자리에서 내향적이고 집에서 생활하는 것을 좋아하는 집순이나 집돌이가 외향적인 상대에 맞추어 '저는 봄에 벚꽃놀이를 꾸준히 나갈 정도로 활발해요!'라고 말하고 연애 관계를 시작하게 된 뒤에 원치 않는 바깥 활동으로 인해 불행해지는 것과 비슷한 상황이 아닐까 싶습니다. 반대로 외향적인 상대 역시도 상대가 은연중에 내뿜는 불편함의 아우라를 느낄 수도 있고, 그렇지 않더라도 어느 순간 폭발하는 연인의 모습에서 당혹을 감출 수 없을 것입니다. '네가 이런 것 좋아한다고 했잖아?'\n\n---\n\n## 마치며\n\n약 20번의 면접을 치룬 그리고 앞으로도 많은 면접을 진행해야 할 탐구자로써 제가 처음에 가지고 있었던 면접에 대한 인상은 진행을 할수록 변했고, 그것은 우리가 세태가 파편화되는 것에 맞추어 변화하는 생물인 것처럼 회사 역시도 변화하기 때문이라 생각합니다. 하지만 이전의 면접에서 모든 주도권이 회사에 있었던 것과는 달리 요즘의 변화에 맞추어 생각을 바꾸면, 면접은 지원자가 주도권을 가져와 회사와의 소통을 진행하고 서로에 대해 더 잘 알게 되어 만족할 수 있는 관계를 만들어 나갈 수 있는 기회가 될 수도 있지 않나하고 생각을 하게 됐습니다. 물론 이를 위해서는 양측이 서로에 대해 더 관심을 가지고 시간을 들여야 하지만 말입니다.\n\n다음에는 이러한 면접을 준비하고 진행하는 방법과 이를 통해 제가 원하는 회사에 대해 한 번 이야기해보고 싶습니다.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n\n## 참고 자료\n\n- [네이버 국어사전 - 합격](https://ko.dict.naver.com/#/entry/koko/7b6f1c8807ce40e29f1afc348dd18b5f)\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"합격보다 소통을 목표로 하는 면접을 위하여(1)","subtitle":"20번의 면접을 통해 느낀 면접 탐구자의 소회","date":"2024-05-01T00:00:00.000Z","categories":"신변잡기","series":"합격보다 소통을 목표로 하는 면접을 위하여","seriesIndex":1}},{"postName":"2024-05-02-수단이 아닌 목적으로써의 면접을 위하여(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/수단이 아닌 목적으로써의 면접을 위하여/2024-05-02-수단이 아닌 목적으로써의 면접을 위하여(2).md","category":"신변잡기","title":"합격보다 소통을 목표로 하는 면접을 위하여(2)","subtitle":"불명확한 환경에서 자신을 알아내기 위해 안전지대를 벗어나고, 이를 꾸며서 표현하는 방법","content":"\n### 목차\n\n- [명확한 기준이 있었던 학창시절과 취업시장은 다른 전략이 필요하다 생각합니다](#명확한-기준이-있었던-학창시절과-취업시장은-다른-전략이-필요하다-생각합니다)\n- [스스로 기준을 세우기 위해서는 자신에 대해 알아야 한다 생각합니다](#스스로-기준을-세우기-위해서는-자신에-대해-알아야-한다-생각합니다)\n- [저는 우선 자신에 대해 알기 위해 지금의 환경을 벗어났습니다](#저는-우선-자신에-대해-알기-위해-지금의-환경을-벗어났습니다)\n- [자기 자신을 매력있게 꾸며서 표현하고 노출했습니다](#자기-자신을-매력있게-꾸며서-표현하고-노출했습니다)\n- [마무리](#마무리)\n- [참고 자료](#참고-자료)\n\n---\n\n## 명확한 기준이 있었던 학창시절과 취업시장은 다른 전략이 필요하다 생각합니다\n\n제가 생각할 때 대부분의 사람이 면접 그리고 구직의 과정에서 가장 먼저 하는 것은 보통 자신이 가고 싶은 기업을 정하는 것이라고 생각합니다. 본인이 가고자 하는 기업의 연봉, 복지, 이름 등의 수준을 자신이 현재 한국 내에서 차지하는 지위 정도라면 어느 정도의 대우를 받는 것이 일반적이라는 사실을 통해 이보다 더 좋은 조건을 가진 기업을 도전할 것인지와 같은 것을 결정합니다.\n\n이는 마치 한국 사회에서 중학교 시절 성적을 통해 고등학교를 정하고, 고등학교 시절 성적을 통해 대학교를 정하는 것과 비슷하게 회사를 정하는 것이라고 생각합니다. 그 과정이 여태까지는 맞는 방식이었기 때문에 해오던 방식대로 결정을 내리는 것은 처음에는 맞다 생각하고 저 역시도 그런 시절이 있었습니다.\n\n그러나 이러한 방식은 교육과정이라는 울타리와 시험이라는 명확한 기준이 있기 때문에 가능했던 것이고 기존의 공채 위주의 시장은 비슷한 전략이 통했던 것이지만, 현재의 취업 시장에서는 이러한 기준이 점점 사라지고 있기 때문에 이러한 전략이 더 이상 통하지 않는다고 생각합니다.\n\n---\n\n## 스스로 기준을 세우기 위해서는 자신에 대해 알아야 한다 생각합니다\n\n이러한 이유들로 자신의 구직이 성공했는지를 판단하는 기준은 스스로가 세워야 한다고 생각합니다. 저를 기준으로 이야기하면 제 첫 직장은 사회적으로 봤을때 최고는 아니더라도 꽤나 상위권에 속하는 회사였습니다. 매년 수천억에 가까운 매출이 나오고, 서울에 거의 건물 한 채를 다 쓰는 천명이 넘는 인원이 다니는 회사이며, 월급이나 복지 역시 훌륭했습니다.\n\n이 회사에 들어가는 데에 제가 1년이 조금 넘는 수험생과 같은 생활을 했고, 합격 당시에 집에 온 과일 박스를 보며 어머니는 감동에 말을 잇지 못하실 정도였습니다. 그리고 저는 그 회사를 2년도 채 다니지 못하고 퇴사하게 되었습니다.\n\n그렇게 된 원인을 지금에와서는 제가 정량적으로 측정 가능한 월급과 같은 가치만을 남들과 비교해서 판단의 기준으로 삼고, 정작 본인이 어떤 사람인지와 같은 정성적이고 복잡한 가치에 대해서는 눈을 돌렸던 데에 있다고 생각합니다. 그렇지만 저는 이러한 방식이 학교를 벗어난 순간부터는 옳지 못하다고 생각합니다.\n\n대학교까지는 모든 것이 표준화와 획일화가 돼있던 것과 달리, 대학 이후의 삶은 개별적이고 파편화되어있으며 예측불가능합니다. 그리고 저는 그것이 단순히 누군가는 일을 많이하고 돈을 더 버는 것을 선호한다거나 워라밸이 좋은 회사를 선호하는 것보다는 '어떤 사람과 함께 일하고 싶은가'와 같은 질문에 대한 대답을 할 필요가 있으며, 그렇기 때문에 자기 자신의 삶을 온전히 보내기 위해서는 우선 자신이 어떤 사람인지 알아야 한다고 생각합니다.\n\n그렇지만 자신을 알아야 한다 해서 MBTI와 같은 또다른 피상적인 것에 사로잡혀서는 안됩니다. 인간의 수많은 형태를 폭력적으로 이분법을 네번 중첩해서 구분할 뿐인 방식으로 자신에 대해 이해하는데 성공했다고 착각하게 하는 편안함에 도피하지 않고 진정으로 자기 자신을 이해하기 위해 힘든 순간들을 버텨내야 합니다. 그러기 위해서는 안전 지대를 벗어나 자신을 익숙하지 않은 상황에 노출시키고 시행착오를 겪으면서 자신의 반응을 관찰하고 해석해야 자신에 대해 알 수 있다고 생각합니다.\n\n---\n\n## 저는 우선 자신에 대해 알기 위해 지금의 환경을 벗어났습니다\n\n자신을 알기 위한 방법에는 여러가지가 있을 수 있겠습니다만, 제가 선택한 방법은 가장 익숙한 환경을 벗어나는 것이었습니다. 가장 잘하는 정형화된 시험을 책상에 앉아 오랜 시간 엉덩이를 무겁게 하고 공부해서, 준비한 범위 내에서 질문을 하는 시험들에 대비하는 것을 그만뒀습니다. 왜냐하면 제가 그것을 잘 하고 싫어하지 않는다는 사실은 이미 알고 있었기 때문에 더 해보지 않아도 알 수 있는 저의 일부분이었기 때문입니다.\n\n이를 벗어나기 위한 수단으로 선택한 것이 새로운 사람을 만나고, 책을 읽는 것이었습니다. 저는 이 두가지를 하는 것은 다른 사람의 삶에 잠시 깃들어서 자신과 다른 관점에서 생각해보고, 자신에게 돌아와 스스로의 삶을 다시 바라보는 것이라고 생각합니다. 그리고 이를 통해 기존에 가지고 있지 못했던 새로운 관점으로 자신을 평가하고 이전에 몰랐던 자신의 모습을 발견할 수 있다고 생각합니다.\n\n오랜 시간 동안 만나지 않아서 변화한 친구들, 온라인에서 같은 관심사를 매개로 만난 모르는 사람들, 평소에 관심이 없던 분야의 책과 같은 지금의 내가 익숙한 환경에서 벗어나는 것을 통해서 저는 현재 자신에 대해 더 잘 알 수 있게 되었습니다. 그리고 이를 통해 자신이 어떤 일을 하고 싶은지, 어떤 사람과 함께 일하고 싶은지에 대한 기준을 세울 수 있게 되었습니다.\n\n---\n\n## 자기 자신을 매력있게 꾸며서 표현하고 노출했습니다\n\n그런 다음에는 자기 자신을 매력적으로 꾸미고 표현해서 외부에 노출해야 한다고 생각합니다. 여기서 꾸민다는 표현에 대해 부정적인 입장이신 분이 계실 수 있을 것으로 알고 있습니다. 그런 분들께서는, 진정한 능력이 있는 사람은 꾸미지 않아도 눈에 띄고 주변에서 인정해줄 것이라는 믿음이 있고 이를 여태까지 실천하는데 성공하신 멋진 삶을 살아오신 분들이라 생각합니다. 물론 그런 압도적인 능력을 통해 성과를 계속해서 얻는데 성공하신 실력자분들과는 상관없는 이야기일 수도 있습니다만, 저와 같이 비교적 평범한 수준의 사람은 자신을 있는 힘껏 꾸미기 위해 노력해야한다고 생각합니다.\n\n다만 그것이 거짓을 말하거나 부풀린다는 것과는 다릅니다. 그보다는 자신의 능력이 낳을 수 있는 가치를 알기 쉬운 형태로 상대에게 변환할 수 있는 경우의 수를 직접적으로 제시하는 것을 말합니다. 마치 현대차 아이오닉 광고에서 [인공지능이 아니라 시각 장애인에게 자유를 판매](https://www.youtube.com/watch?v=d6e41W6ZjtY)하는 것이나, 슬랙이 [채팅 프로그램이 아니라 생산성을 판매](https://www.youtube.com/watch?v=B6zVzWU95Sw)하는 것과 같이 말입니다.\n\n이처럼 자신을 꾸민다는 것은 무슨 능력을 가지고 있다고 말하는 것이 아니라 이를 통해 자신이 어떤 일을 할 수 있다, 혹은 문제를 해결할 수 있다라고 꾸며서 표현할 줄 아는 능력이 필요하고, 이를 상대가 편하게 접근할 수 있는 환경을 통해 제공해야 한다고 생각합니다. 이와 관련한 자세한 설명은 스틱!이라는 칩 히스의 마케팅과 관련한 책에서는 이를 SUCCESs(Simplicity, Unexpectedness, Concreteness, Credibility, Emotions, Stories)라고 표현하고 있으니 참고하시면 도움이 되시지 않을까 싶습니다.\n\n---\n\n## 마무리\n\n원래 이렇게까지 길게 쓰려고 했던 글이 아니었는데 어쩌다보니 분량 조절에 실패해서 3편까지 이어지게 됐네요. 되도록이면 그래도 3편에서 지난번에 이야기했던 대로 제가 면접을 준비하고, 준비하기 편했던 회사에 대해 이야기하려고 합니다. 그리고 이를 통해 어떤 회사들과 면접 혹은 채용 과정을 진행하는 과정이 만족스러웠고 무엇을 배웠는지에 대해 이야기하려고 합니다. 써놓고 보니 4편도 작성하게 될 수도 있겠다는 불안한 기분이 엄습하는군요.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n\n## 참고 자료\n\n- [아이오닉 5 로보택시 운전면허 도전](https://www.youtube.com/watch?v=d6e41W6ZjtY)\n- [So Yeah, We Tried Slack](https://www.youtube.com/atch?v=B6zVzWU95Sw)\n- [스틱! - 칩 히스](https://product.kyobobook.co.kr/detail/S000200037580)\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"합격보다 소통을 목표로 하는 면접을 위하여(2)","subtitle":"불명확한 환경에서 자신을 알아내기 위해 안전지대를 벗어나고, 이를 꾸며서 표현하는 방법","date":"2024-05-02T00:00:00.000Z","categories":"신변잡기","published":true,"series":"합격보다 소통을 목표로 하는 면접을 위하여","seriesIndex":2}},{"postName":"2024-05-03-수단이 아닌 목적으로써의 면접을 위하여(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/수단이 아닌 목적으로써의 면접을 위하여/2024-05-03-수단이 아닌 목적으로써의 면접을 위하여(3).md","category":"신변잡기","title":"합격보다 소통을 목표로 하는 면접을 위하여(3)","subtitle":"나에게 관심을 가져주는 기업과의 면접","content":"\n### 목차\n\n- [대화의 기본은 상대방에게 관심을 가져주는 것이다](#대화의-기본은-상대방에게-관심을-가져주는-것이다)\n- [나에게 관심을 가져주는 기업과의 면접 vs 나에게 관심을 가져주지 않는 기업과의 면접](#나에게-관심을-가져주는-기업과의-면접-vs-나에게-관심을-가져주지-않는-기업과의-면접)\n- [스스로를 드러내는 기업과의 면접 vs 스스로를 드러내지 않는 기업과의 면접](#스스로를-드러내는-기업과의-면접-vs-스스로를-드러내지-않는-기업과의-면접)\n- [마무리](#마무리)\n\n---\n\n## 대화의 기본은 상대방에게 관심을 가져주는 것이다\n\n상대방에게 관심을 가지는 것이 대화의 기본이라고 저는 생각합니다. 면접을 기준으로 이야기하면 상대편이 공개하는 정보만을 피상적으로\n 파악하고 대화에 나서는 것이 아니라, 그 정보를 기반으로 드러내지 않은 것들에 대한 질문을 던지는 것이 관심을 가지는 방법이라고 생각\n합니다.\n\n이런 질문을 맞이했을 때 때로는 다른 사람의 시선으로 본 사실로부터 알아낼 수 있는, 본인도 생각하지 못했던 사실을 알게 되는 경우도\n 많았습니다. 이런 대화를 경험했을 때는 몰랐던 자신의 모습을 발견하고 그것을 통해 자신을 더 잘 이해할 수 있게 되는 체험을 하게\n 되기도 합니다. 반면에 관심을 이 없는 대화를 진행했을 때 그 경험은 서로 준비한 대답을 주고받는 것에 그치게 되기 때문에 상대방이\n 꾸며낸 모습만을 보게 됩니다.\n\n그렇기 때문에 상대에게 관심을 가지고 대화를 나누어야 진정으로 서로를 이해할 수 있고 서로에게 도움이 되는 대화를 할 수 있습니다. 즉,\n 대화를 통해 서로간에 소통이 이루어지기 위한 가장 기본적인 요소는 상대에게 관심을 가지는 것이라고 저는 생각합니다.\n\n---\n\n## 나에게 관심을 가져주는 기업과의 면접 vs 나에게 관심을 가져주지 않는 기업과의 면접\n\n이력서란 것을 결국 수십, 수백개씩 보기 때문에 그 안에 담긴 정보들이 비슷비슷해 채용 담당자라면 이를 파헤치고 옥석을 가리기 위해 노력하는\n 것이 굉장히 괴로운 일이란 것은 저도 백번 이해합니다. 제가 동일한 입장이더라도 이력서를 보는 것은 굉장히 힘들고, 특히 저처럼 이력서 안에\n 자신을 잘 정제해서 담아내는 능력이 부족해서 상대에게 제대로 전달하지 못하는 경우에는 더욱 힘들 것이라 생각합니다. 그렇기 때문에 면접을\n 보는 과정에서 저에게 관심을 가져주고 조사를 통해 질문을 준비해 온 기업과 그렇지 않은 기업의 차이는 굉장히 크게 받아들여졌습니다.\n\n심할 정도로 저에게 관심을 가져주지 않는 면접의 경우 면접관이 현장에서 이력서를 받아보고 질문을 던지는 것에 그치는 경우도 있었습니다. 그럴\n 경우에 받은 질문에는 본인의 성격은 어떠냐, 동생은 있냐는 질문이 있었습니다. 그런 질문을 통해 사람의 성격을 파악할 수 있을지는 모르겠\n습니다만, 이렇게 만나보기 전에 관심이 있는 것도 아니어서 저를 알아보고 오지도 않았는데 면접을 보자는 제안을 받아 진행한 경우에는 대부분\n 경험이 좋지 않았습니다.\n\n반면에 저에게 관심을 가져주는 면접의 경우에는 이력서에 적힌 내용과 블로그, 깃허브 등을 통해 저를 파악하고 그것을 기반으로 제가 드러내지\n 않은 내용들에 대해서 질문을 던지는 경우가 많았습니다. 예시를 들자면 '외로워서 이전에 퇴사하셨다고 이야기하셨는데, 지금 이전의 회사로\n 돌아가신다면 동일한 일이 반복될 것이라 생각하세요? 이번에는 어떤 점이 다를 것이라 생각하세요?'와 같은 질문을 받기도 했습니다. 이런\n 저에 대한 진정한 관심을 보여주는 질문을 하면 저 역시도 해당 기업에 신뢰를 가질 수 있고, 기업 역시도 제가 준비한 꾸며낸 모습이 아닌\n 감춰둔 내면을 볼 수 있기에 서로에게 이득이 되는 대화가 될 수 있다고 생각합니다.\n\n---\n\n## 스스로를 드러내는 기업과의 면접 vs 스스로를 드러내지 않는 기업과의 면접\n\n회사 내의 업무만을 처리하는 것으로도 감당하기 힘들 정도의 격무에 다들 시달리고 있기 때문에 따로 준비하기 힘들다는 것은 알지만,\n 그렇더라도 본인을 드러내는 기업과 드러내지 않는 기업은 지원자에게 큰 차이로 다가옵니다. 우리가 마치 소개팅과 같이 중요한 상대방과의\n 만남을 앞두고 있을 때 본인의 멋진 점을 어필하기 위해 드러내는 방법을 고민하고 꾸미는 것처럼, 기업 역시도 본인이 원하는 인재를 영입하기\n 위해서는 자신이 매력있는 기업이라는 것을 보여주어야 한다고 생각합니다.\n\n이 때 매력을 단순히 금전적인 것이나 복지 등으로 한정해서 생각해서는 안된다 생각합니다. 복지와 금전적인 보상은 정량적으로 서열을 매길 수\n 있기 때문에 이를 통해서는 본인보다 높은 보상을 제시할 수 있는 기업을 찾기도 쉽고, 이것만을 경쟁력으로 삼는다면 인재는 더 높은 서열의\n 기업들에 지원하게 될 것이기 때문입니다. 이 때문에 기업 역시도 본인이 금전적인 것 뿐 아니라 기업 문화나 서로를 존중하는 분위기와 같은\n 정성적인 것들을 기르고 드러내기 위해 노력해야 한다고 생각합니다.\n\n주의할 점은 이런 정성적인 문화와 같은 것은 단순히 보도자료를 한 두번 채용 페이지에 적어놓는 것으로 충분히 어필하는 것이 불가능하다는 점\n입니다. 마치 우리가 사람의 성격을 판단할 때 그 사람의 말이 아니라 행동을 보고 판단하는 것처럼 기업 역시도 본인이 어필하고 싶은 것을\n 행동으로 보여주어야 한다고 생각합니다. 그리고 이를 꾸준히 밖으로 표현하는 방법에 대해 고민하고 실천해야 한다고 생각합니다.\n\n---\n\n## 마무리\n\n취업을 위한 면접에 대해서 부정적인 생각을 가지고 있는 사람이 많고 그럴만한 경험을 실제로 많이 하는 것이 사실입니다. 하지만 서로에게 충\n분한 관심을 가지고 단순히 취업을 위한 과정이 아니라 새로운 사람을 만나 본인에 대한 이야기를 나누는 시간이라 생각하면, 면접이라는 과정은\n 스스로에 대해 더 잘 이해하도록 많은 회사들에서 자발적으로 시간을 써가며 도움을 주는 것으로도 볼 수 있다고 저는 느껴졌습니다.\n 사실 인생에서 유명인이 아닌 이상 우리 얘기를 받아적기까지 하면서 들어주는 호사를 언제 느껴볼 수 있겠어요?\n\n그러니 면접을 통과점으로만 생각하기보다 서로에게 관심을 가지고 대화를 나누는 시간으로 생각하면, 그 과정에서 많은 것을 얻을 수\n 있다 생각합니다. 독자 분들께 앞으로 있을 많은 면접들이 관심으로 가득한 진정한 소통을 통해 서로에게 도움이 되는 시간들이 되기를 바랍니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"합격보다 소통을 목표로 하는 면접을 위하여(3)","subtitle":"나에게 관심을 가져주는 기업과의 면접","date":"2024-05-03T00:00:00.000Z","categories":"신변잡기","published":true,"series":"합격보다 소통을 목표로 하는 면접을 위하여","seriesIndex":3}},{"postName":"2024-02-04-게임에서 체감한 기술의 발전","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-02-04-게임에서 체감한 기술의 발전.md","category":"게임이야기","title":"페르소나 3 리로드에서 느낀 기술의 발전","subtitle":"","content":"\n요 근래 의존성 역전에 관한 글을 쓰게 돼서일까요, 게임을 하다가 혹시 이런 것이 가능해진 것이 인터페이스를 활용한 의존성 역전이 적용됐기 때문이 아닐까 하는 생각이 문득 뇌리를 스치고 지나갔습니다. 다만 기존의 딱딱한 글에 엮어서 붙이기에는 어렵기 때문에, 따로 글을 작성해보려 합니다. 당연히 제가 내부 코드를 읽어본 것은 아니기 때문에, 그저 그런 것이 아닐까?하는 유쾌한 상상 정도라고 봐주시면 감사하겠습니다.\n\n페르소나 5 로얄이라는 게임을 혹시 해 보신 분이 계신가요? 이거 진짜 갓겜입... 이게 아니라, 페르소나 5 로얄은 나름 jrpg의 마스터피스 중 하나로 꼽히는 게임입니다. 제가 jrpg가 취향이 아니어서 많이 플레이하지는 않았습니다만, p5r(이제부터는 이렇게 축약하도록 하겠습니다)는 너무나도 플레이하는 경험이 황홀했었죠. 중요한 장면에서 흘러나오는 웅장하면서도 가슴 뛰는 bgm, 스테이지를 진행하면서 하나씩 추가되는 새로운 전투와 육성 요소, 그리고 캐릭터들의 성장과 이야기가 너무나도 매력적이었습니다. 혹시 아직 플레이해보지 않으신 게이머 분들이 계시다면, 꼭 한 번 플레이해보시길 추천드립니다.\n\n잡설은 여기까지로 하고, 아직까지 플레이 타임이 겨우 2시간 반 밖에 되지 않았습니다만 p3r(페르소나 3 리로드)는 p5r과 비교해서 게임의 굉장히 초반부부터 인상깊은 변화가 하나 눈에 띄었습니다. 그것은 텔레포트를 할 수 있는 지역의 디테일이 확장됐다는 점입니다.\n\np5r은, 제 기억이 틀리지 않았길 바랍니다만, 동일한 장소 내에서 텔레포트를 할 수 있는 디테일이 아쉬운 부분이 있었습니다. 카페 르블랑은 주인공이 주로 거주하는 2층의 다락방과 1층의 가게으로 구성돼 있습니다. 그런데, 유저가 텔레포트 기능을 통해 도착 가능한 구역은 정확하게 기억은 안 나지만 입구 아니면 가게 1층으로 기억합니다. 즉 2층으로 바로 이동할 수 없었던 것이죠. 그러나 p3r은 이 부분이 확장돼서, 기숙사 내부의 자기 방으로 텔레포트가 가능해졌습니다. 저는 이 부분이 굉장히 인상 깊었습니다.\n\n단순히 공간을 프로그래밍하는 과정에서 더 많은 노가다가 들어갔을 수도 있겠습니다만, 아틀라스는 요즘들어 굉장히 많은 게임을 쏟아내고 있는 게임사입니다. 페르소나 5 택티카, 페르소나 3 리로드에 이어서 곧 유니콘 오버로드라는 새로운 ip의 출시도 목전에 두고 있는 상황이죠. 비록 페르소나 5 택티카의 최적화는 아쉬운 부분이 조금 있기는 했습니다만, 전반적으로 요즘 아틀라스에서 출시하고 있는 게임들은 완성도가 높고 전방위적으로 발전중이라는 것을 느낄 수 있었습니다. 그러니 아마 이런 확장성을 통해 게임의 퀄리티를 높이고 개발 과정을 효율적으로 만드는 데 성공하지 않았을까?하는게 이제 제 단편적인 지식내에서 해볼 수 있었던 일종의 망상입니다.\n\n이렇게 좋은 프로그래밍 디자인이 확장성을 통해 게임의 퀄리티와 유저 경험, 그리고 개발의 용이성을 높여줄 수 있겠구나!라는 생각이 드는 것을 보면 굉장히 즐겁고 나도 저런 일을 언젠가 하고 싶다!라는 생각을 하게 됩니다. 그리고 그러려면 이제 계속해서 공부하는 것을 멈추지 않고 노력해 나가야겠지요.\n\n아마 제가 상상하는 의존성 역전과는 다르게, 실제로는 이보다 훨씬 더 복잡하고 아름다운 방식으로 아틀라스의 개발자 분께서는 게임에 확장성을 부여하셨을 것이라는 생각이 들고 그런 생각이 드니 게임을 플레이하는 즐거움이 이전보다 늘었다는 생각이 듭니다. 앞으로 이 게임이 제게 얼마나 많은 새로운 경험과 즐거움을 가져다 줄 지, 그리고 개발을 공부하는 것이 게임을 더 즐길 수 있게 만들 수 있을지 기대가 되네요.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"페르소나 3 리로드에서 느낀 기술의 발전","date":"2024-02-04T00:00:00.000Z","categories":"게임이야기","subtitle":""}},{"postName":"2024-04-10-유니콘 오버로드 리뷰 - 2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-10-유니콘 오버로드 리뷰 - 2.md","category":"게임이야기","title":"전투로 극복한 rpg의 한계","subtitle":"유니콘 오버로드 리뷰(2)","content":"\n### 목차\n\n- [게임 정보](#게임-정보)\n- [rpg에서 성장의 매력, 그리고 한계](#rpg에서-성장의-매력-그리고-한계)\n- [그러면 캐릭터를 많이 쓰면 되잖아?](#그러면-캐릭터를-많이-쓰면-되잖아)\n- [그렇지만 조작할 것은 적게](#그렇지만-조작할-것은-적게)\n- [그러면서 억까도 적게](#그러면서-억까도-적게)\n- [마무리](#마무리)\n\n---\n\n## 게임 정보\n\n- **게임명**: 유니콘 오버로드\n- **제작사**: 바닐라웨어\n- **유통사**: ATLUS\n- **장르**: SRPG, JRPG, 오픈월드\n\n---\n\n## rpg에서 성장의 매력, 그리고 한계\n\nrpg의 매력 중 큰 비중을 차지하는 요소 중 하나는 성장입니다. 우리는 캐릭터를 플레이 하면서 각종 스탯이 오르거나, 장비를 획득하고, 동료를 얻으면서 성장하는 것을 경험합니다. 대부분 경우 성장을 통해 힘이나 지능과 같은 전투에서 필요한 스탯이 올라서 구체적인 강함이 늘어나지만, 그것이 아니라도 동료 캐릭터와의 인연도나 새로운 물건을 만들 수 있게 되는 등 다양한 방식으로도 성장을 경험할 수 있습니다. 그리고 이전보다 더 나아진 캐릭터를 보면서 뿌듯함을 느끼는 것은 rpg의 매력 중 하나입니다.\n\n하지만 그것은 동시에 rpg란 게임이 가지는 한계이기도 합니다. 게임은 끝이 있기 마련이고, 더 이상 목표를 제시해주기 힘든 시점에 도달하면 그동안 성장을 위해 해왔던 컨텐츠들이 더 이상 재미를 제공하지 못하는 순간이 오게 됩니다.\n\n![토끼공듀](https://i.namu.wiki/i/RuVq_fIkWuGcG9lq9h_ugJYQO9EyYLRYVZlNH2FRqkOFDaQ9CeqeHjQr0h5dCE1djxbJCsA8bsfXX4tZ3L_qgg.webp)\n\n전설의 무기가 있으면 무슨 소용일까요? 우리가 캐릭터를 키메라로 만들지 않는 한 우리 캐릭터가 들 수 있는 검은 최대 두개 뿐입니다.(입으로 칼을 무는 조로는 예욉니다.) 캐릭터가 쓸 수 있는 모자는 하나 뿐입니다. 우리의 동료가 될 수 있는 친구의 수는 한계가 있습니다. 곧 끝날 것을 아는 데 새로 얻은 장비나 캐릭터를 추가로 성장시킬 수 있다는 이야기는 매력적이라기보다 보상이 모자란 공수표처럼 느껴지기까지 합니다. 이처럼 어느 시점에 도달하면 rpg에서 성장은 더이상 매력으로 다가오지 않고 우리에게 숙제이자 부담으로 다가오는 순간이 찾아옵니다.\n\n---\n\n## 그러면 캐릭터를 많이 쓰면 되잖아?\n\n![유닛 구성](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%EC%9C%A0%EB%8B%9B%20%EB%A6%AC%EC%8A%A4%ED%8A%B8.jpg?raw=true)\n\n위의 이미지는 제가 유니콘 오버로드의 엔딩을 본 시점에서 제가 사용하던 병종 구성입니다. 유니콘 오버로드는 최대 10개 분대, 각 분대당 최대 5명의 유닛을 사용할 수 있습니다. 그렇기 때문에 최대 50명의 유닛을 사용할 수 있습니다. 자신이 보유한 캐릭터들 중에서 50명을 선택해서 10개의 분대를 꾸리는 조합의 경우의 수는 무려 4537555나 됩니다. 그리고 이 정도면 어지간하면 본인의 마음에 드는 조합이 하나는 있을 것입니다.\n\n네? 이걸 어떻게 키우냐구요? 그래서 준비했습니다. 유니콘 오버로드는 다양한 필드 반복 컨텐츠를 통해 빠른 레벨업이 가능한 소위 '쩔'이 가능한 시스템과 경험치 책이 존재하며, 후반부에 얻을 수 있는 캐릭터일수록 높은 레벨로 시작하는 등의 편의성을 제공합니다. 거기다가 47종이나 되는 병종이 존재해서 새로운 적에 맞춘 새로운 아군의 조합을 만들어내는 재미도 있습니다. 이 게임의 대부분의 캐릭터는 어느 시점에 들어오더라도 당장 사용할 곳이 있으며, 그러는 데에는 많은 노력이 필요하지 않습니다.\n\n여기에 더해 이 게임은 매력적인 아이템이 굉장히 많습니다. 유니콘 오버로드는 단순히 스탯을 올려주는 장비를 구성하는 데에서 그치지 않고, 유틸성이 높은 스킬들을 제공하는 다양한 장비들을 통해 같은 병종이라도 전혀 다른 운용 방식으로 활용할 수 있는 재미를 제공합니다. 체력이 낮을 수록 강해지는 캐릭터에게 단 한번 즉사를 면하고 체력 1이 남는 스킬이 주어진다면 어떨까요? 자힐은 없지만, 힐을 받으면 광역 힐을 주는 캐릭터에게 힐을 할 수 있는 능력을 부여하는 아이템을 준다면요? 명중률이 떨어지는 대신 확정적으로 치명타가 발생하는 스킬과 명중 보정이 확정인 스킬을 번갈아 사용해서 딜러에게 치명타시에 강력한 딜러에게 버프를 준다면요? 이 역시 유니콘 오버로드가 가지고 있는 많은 캐릭터를 사용하는 전투 방식이 아니었다면, '그래서 이걸 누구 주는데?'라는 질문에 대답하지 못했을 것입니다.\n\n---\n\n## 그렇지만 조작할 것은 적게\n\n그치만 그 많은걸 복잡하게 어떻게 조작할건데? 그러기 머리 아파서 난 srpg가 싫어. 그래서 준비했습니다. 아무것도 조작하지 마세요. 유니콘 오버로드는 매 턴 어느 스킬을 누구에게 사용해야할지 고민하고 그 결과에 대해 예상해야 했던 기존의 srpg와는 전혀 다른 전투 방식을 채택합니다. 그것은 바로 자동전투입니다.\n\n![필드 구성](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%ED%95%84%EB%93%9C%20%EA%B5%AC%EC%84%B1.jpg?raw=true)\n\n유니콘 오버로드의 전투는 srpg라기보다는 rts의 것을 많이 닮아 있습니다. 플레이어는 전투에서 공용으로 사용하는 재화인 '브레이브 포인트'를 소모해서 분대를 소환하거나 스킬을 사용할 수 있습니다. 이를 이용해 소환한 유닛을 스타크래프트에서 어택땅하듯이 이동해서 서로 유닛이 겹치게 되면 서로의 전투 결과가 시뮬레이트 되며 승패가 결정됩니다. 이 때 승리한 유닛은 추가 행동의 권리가 주어지고 브레이브 포인트를 일정 수치 획득하게 되며, 패배한 유닛은 행동 불가 상태가 되고 그 상태에서 연전을 하게 될 경우 불리한 전투를 진행하게 됩니다.\n\n이런 두가지 반대되는 복잡함과 간단함을 동시에 추구하고 밸런스를 맞추는 데 성공했기 때문에 유니콘 오버로드의 전투는 적당히 도전적이면서도 쉽게 접근할 수 있기 때문에 매력적입니다. 유니콘 오버로드의 전투는 이 조화를 통해 많은 캐릭터를 사용하더라도 그것이 복잡하게 느껴지지 않고, 오히려 캐릭터를 더 많이 사용하고 싶게 만들어줍니다.\n\n---\n\n## 그러면서 억까도 적게\n\n![감나빗](https://img3.ruliweb.com/data/review/2016/10m/xcm/xcm_06.jpg)\n\n감나빗으로 대표되는 srpg의 소위 억까는 유저들이 해당 장르를 기피하는 이유 중 하나입니다. 이는 본인이 잘못한 것이 없이 올바른 전략을 취했음에도 불구하고 랜덤한 요소로 인해 예측과 다른 결과가 나오는 불쾌한 경험을 제공하기 때문입니다. 하지만 유니콘 오버로드에서는 이런 불쾌한 예측 불가능한 요소를 최대한 줄이고 모든 변수를 유저에게 유리한 방향으로 조작하려고 노력했습니다. 유저는 모든 전투가 일어나기 전에 그 결과를 정확하게 알 수 있고, 원하지 않는 결과가 나올 경우에는 여기에 개입하여 원하는 결과를 얻기 위한 다양한 수단을 사용할 수 있습니다.\n\n![전투 예시](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%EC%A0%84%ED%88%AC%20%EC%98%88%EC%8B%9C.jpg?raw=true)\n\n유저는 전투 결과를 수행하지 않고 전투 결과를 확인한 상태에서 전투 결과에 영향을 미치는 소모품을 사용하거나 배치를 변경할 수 있고, 발동하는 스킬의 종류와 순서 및 대상을 변경할 수 있는데다가 급기야는 여러 상성에 대응할 수 있는 분대를 묶어서 전투에 투입해서 자신이 원하는 병종간의 전투만 이루어지도록 할 수도 있습니다. 이 때문에 사실상 억까가 존재하지 않고, 설사 불리한 상황을 마주하더라도 유저 스스로 잃을 것 없이 얻을 것만 있는 묘수를 찾아낼 수 있는 시스템은 굉장히 매력적입니다.\n\n---\n\n## 마무리\n\nrpg의 성장과 srpg의 묘수는 게임의 핵심적인 매력이지만 동시에 그 게임의 한계를 결정짓는 요소이기도 했습니다. 바닐라웨어는 유니콘 오버로드에서 이 한계를 극복하기 위해 택틱스 오우거식 전투를 도입해 매력적인 srpg의 새로운 방향을 제시하는데 성공했다고 생각합니다. 거기다가 게임 전반적으로 유저가 불쾌할만한 요소들을 가능한 줄이고, 유저에게 유리하면서도 적당히 도전적으로 느껴지게 하기 위한 고민을 전반적으로 많이 느낄 수 있었던 수작이라고 생각합니다. 그렇기에 유니콘 오버로드는 srpg의 팬이라면 꼭 해봐야하면서 동시에 srpg를 평소에 즐기지 않던 분도 굉장히 쉽고 재밌게 할 수 있는 게임이니 꼭 한번 해보시길 추천드립니다. 긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"전투로 극복한 rpg의 한계","subtitle":"유니콘 오버로드 리뷰(2)","date":"2024-04-19T00:00:00.000Z","categories":"게임이야기","published":true,"recommended":true,"series":"유니콘 오버로드 리뷰","seriesIndex":2}},{"postName":"2024-04-10-유니콘 오버로드 리뷰","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-10-유니콘 오버로드 리뷰.md","category":"게임이야기","title":"오픈월드를 통한 srpg의 한계 극복","subtitle":"유니콘 오버로드 리뷰(1)","content":"\n### 목차\n\n- [게임 정보](#게임-정보)\n- [오랜만의 즐거운 srpg](#오랜만의-즐거운-srpg)\n- [오픈 월드에는 물음표가 있다](#오픈-월드에는-물음표가-있다)\n- [유니콘 오버로드는 잘 만든 엘든링식 오픈월드 게임이다](#유니콘-오버로드는-잘-만든-엘든링식-오픈월드-게임이다)\n- [오픈월드로 srpg의 한계를 극복하다](#오픈월드로-srpg의-한계를-극복하다)\n- [참고자료](#참고자료)\n\n---\n\n## 게임 정보\n\n- **게임명**: 유니콘 오버로드\n- **제작사**: 바닐라웨어\n- **유통사**: ATLUS\n- **장르**: SRPG, JRPG, 오픈월드\n\n---\n\n## 오랜만의 즐거운 srpg\n\n![image](https://imgur.com/24xT1Zy.jpg)\n\n가장 좋아하는 게임을 꼽으라면 항상 가장 먼저 꼽는 게임이 엑스컴 2이고, 파이어엠블렘 시리즈도 즐기는 srpg의 팬으로써 이번에 새로 나온 바닐라웨어의 신규 IP 유니콘 오버로드는 굉장히 즐거운 게임이었습니다. 비주류 장르인 srpg는 simulation rpg 혹은 strategy rpg의 약자로, 일종의 현대식 체스나 장기 같은 게임이라 할 수 있습니다.\n\n체스와 장기 같은 게임을 즐기는 분들은 그 무궁한 전략성에 매료돼 아직도 플레이하지만, 이런 머리 쓰는 것은 좋아하지 않는다며 피하는 분도 많듯이 srpg 역시도 그런 특성을 가지고 있습니다. 이 때문에 srpg는 현대에는 마니악한 장르로 분류되며 이번에 조금 화제가 됐다고 하지만 얼마 전 [유니콘 오버로드의 판매량은 50만 장](https://thisisgame.com/webzine/nboard/6/?n=186957)을 겨우 넘긴 것으로 알려져 있습니다. 그만큼 일반적으로 srpg라는 장르는 피곤한 장르라는 것이 일반적인 인식입니다.\n\n이런 srpg의 단점을 회피하려는 시도는 대부분 srpg의 's' 부분에서 힘을 빼고 'rpg'에 치중하는 노력으로 이루어져 왔다 생각합니다. 그 대표 주자가 파이어 엠블렘 - 풍화설월입니다. 풍화설월은 기존의 파이어 엠블렘 제작진인 인텔리전트 시스템즈가 아닌 코에이 테크모가 제작한 작품으로, 기존의 파이어 엠블렘과 비교해 서사와 캐릭터성에 더 집중한 작품으로 평가받고 있으며 시리즈 최초로 400만장 이상의 판매량을 기록할 정도로 흥행에 성공했습니다.\n\n이런 게임들 역시도 재밌는 것은 사실이지만, 저는 srpg의 's' 부분에 더 흥미를 느껴 플레이를 하는 사람인 만큼 이런 경향에는 아쉽다고 생각했습니다. 그런데 유니콘 오버로드는 이런 srpg의 's' 부분을 놓치지 않으면서도, 기존에 유저들에게 불호인 요소를 개선함과 동시에 잘 짜여진 **오픈월드**를 통해 모험의 재미를 더한 신선한 작품이어서 플레이하는 내내 즐거웠습니다. 한동안은 후유증 때문에 다른 게임을 즐기기 힘들 것 같네요.\n\n---\n\n## 오픈 월드에는 물음표가 있다\n\n유니콘 오버로드가 어떤 점에서 잘 만든 오픈월드라고 생각하는지에 대해 이야기하기 위해 지루하지만, 제가 생각하는 잘 만든 오픈월드가 가져다 주는 장점부터 이야기하려 합니다. 여기 챕터는 소제목의 상술이니 관심이 없는 분은 다음으로 넘어가셔도 좋습니다.\n\n오픈 월드 게임의 장점에는 많은 것이 있습니다만 제가 생각할 때 선형적인 게임과 비교해 가장 큰 차별점은 플레이어가 행동하는 공간에 미지의 요소를 남겨둔다는 점이라 생각합니다. 가장 유명한 오픈월드 게임인 젤다의 전설 - 야생의 숨결은 이를 플레이어의 시야가 닿는 공간에 이동하다보면 너머를 엿볼 수 있는 [삼각형의 산을 통해서 구현](https://youtu.be/CZzcVs8tNfE?si=z4-aptPDreFtVRJ-\u0026t=311)했습니다. '저 산 너머에는 뭐가 있을까?'라는 호기심은 게임을 하는 내내 플레이어가 공간을 탐험하는 것을 즐겁게 만들어주고 지루하지 않게 만들어줍니다. 만약 젤다에서 나오는 수백개의 사당이나 던전이 선형적으로, 혹은 탁 트인 평면에서 늘어져서 제시됐다면 그것에서 나오는 예측 가능성 때문에 '또 사당이야?'와 같은 생각에 플레이어가 금방 지루해지게 만들었을 것입니다.\n\n이렇듯 미지의 것이 물음표가 되기 위한 요소 중 하나는 예측 불가능성이기 때문에, 한가지의 이벤트만 반복적으로 나타나서는 안됩니다. 우리 눈 앞의 산 뒤에는 사당이나 몬스터 무리가 있거나, 코로그가 있을 수도 있습니다. 그리고 그것은 심지어 때론 있을 법한 공간인데 잘 보이지 않게 감춰져있어 우리가 이를 찾아 헤메도록 만들기도 합니다. 있을거라 상상하지도 못한 곳에 실수로 떨어졌는데 우연히 발견했다고 느껴질 만한 곳에도 경험을 만들어줘야 합니다. 그렇기 때문에 성공적인 오픈월드 게임을 만들려면 단순히 유저에게 보일락말락 하는 곳에 물음표를 놓는 것에 그칠 것이 아니라 다채로운 색깔의 물음표를, 때로는 찾기 쉽게 때로는 찾기 어렵게 놓아야 합니다.\n\n최근에 모험의 재미를 느낄 수 있도록 잘 만든 오픈월드 게임이라는 평가를 받는 엘든 링의 경우 역시도 다양한 종류의 물음표를 잘 활용했다고 이야기 할 수 있습니다. 대신 젤다의 오픈월드는 삼각형의 형태로 물음표를 반 쯤 가렸다면, 엘든 링은 프롬 소프트가 가장 잘하는 방식으로 같은 결과를 만들었습니다. 변화 무쌍한 미로 같은 느낌의 맵 디자인이 바로 그것입니다. 유저에게 탁 트인 시야를 제공하기보다는 적당한 시야를 오밀조밀하게 제한하면서 제공하고, 트인 공간에는 몬스터 무리, npc, 보스 등이 있도록 하는 형태로 엘든링의 오픈월드는 구성되어있다고 저는 해석합니다. 이 때 던전, 필드 보스, npc, 함정과 같은 다양한 형태의 물음표를 프롬소프트는 엘든링의 세계를 통해 유저들에게 제공합니다.\n\n이런 궁금증을 자아내지 못하는 오픈월드 게임이 저는 일반적으로 '유비식 오픈월드'라고 불린다 생각합니다. 유저는 빽빽하게 들어찬 할일을 부여받고, 무엇을 어디에서 할 지에 대해 완벽한 예상이 가능한 게임을 진행하게 됩니다. 게임이 쾌적하고 문제도 적지만, 그렇기 때문에 금방 익숙해지고 따분해집니다. 이 뒤에 무슨 일이 일어날 지 우리는 알고 있으니까요. 유비식 오픈월드 게임을 진행하다보면 내가 세상을 구하는 주인공으로 여행을 하는 것인지, 얘네들 심부름 꾼인지 헷갈릴 정도입니다.\n\n---\n\n## 유니콘 오버로드는 잘 만든 엘든링식 오픈월드 게임이다\n\n유니콘 오버로드의 오픈월드는 엘든링을 닮은 지점이 좀 있다고 느꼈습니다. 그렇게 생각하게 된 특징들에는 다음과 같은 것들이 있습니다.\n\n1. 레벨에 따라 들르는 지역들이 구분돼 있다.\n2. 이를 어기면서 플레이하는 것에 제약이 없다.\n3. 선형적인 진행을 안내한다.\n4. 하지만 그 진행에서 벗어나도록 근처에 유혹을 흩뿌려둔다.\n\n오픈월드를 어떻게 정의하느냐에 따라 다르겠습니다만, 저는 엘든링의 기본적인 골자는 다크 소울에서 크게 벗어나지는 않았다고 생각합니다. 게임이 기본적으로 가야하는 여러개의 점들이 있고, 다만 이들을 명백한 한개의 길이 아니라 여러개의 갈림길을 제공하기 때문에 우리는 방향을 선택할 수 있고 자유롭다 느낍니다. 이는 명백히 젤다의 전설, 스카이림과 같이 '그냥 너 하고싶은거 다 해'라고 하는 오픈 월드 게임과 지향점이 다릅니다.\n\n이 방향성을 선명하게 보여주는데도 우리가 엘든링에서 모험을 하고 샛길에 빠지는 것은, 그 방향이 보이는 지점 옆에 재밌어 보이는 다른 지점들이 계속해서 눈에 잘 보이게 드러나기 때문입니다. 젤다의 전설은 대부분을 미지로 뒀다면, 엘든링은 눈에 잘 보이는 여러가지 것들을 앞에서 흔들어 우리를 유혹하고 가장 핵심적인 것을 눈에 잘 보이지 않고 획득하기 어렵게 감추어둡니다. 그러면 우리는 자연스레 눈에 보이는 것들을 먼저 해결하게 되는 경향이 있습니다. 그러다가 이제 '아 맞다, 근데 내가 할 일이 이게 아니었을텐데?'라는 생각이 들면서 다시 미지로 탐험을 시작하게 되는 것이죠. 엘든링을 하셨다면 우리가 보스로 가는 길에 눈에 띄는 샛길이나 오브젝트들을 보고 '아 이건 뭐지?'라는 생각을 했던 경험이 있으실 것입니다.\n\n유니콘 오버로드는 그런 점에서 궤가 비슷합니다. 유니콘 오버로드에서 메인 엔딩을 보는 직선 루트는 명백합니다. 하지만 길에다 꼭 갈림길을 두고, 길에서 살짝 벗어나서 눈에 닿는 곳에 우리를 유혹하는 매력적인 아이템이 나올 것 같이 생긴 샛길이나 오브젝트를 세워둡니다. 심지어 이 게임은 일부 오브젝트를 명시적으로 '지금 말고 조금 있다가 돌아와봐'라면서 해결할 수 없는 의문 상태로 남겨둡니다. 이것은 마치 할로우 나이트와 같은 메트로베니아 게임에서 자주 유저들에게 지속적인 탐험 욕구를 끌어내는 방법입니다. 이렇게 샛길을 가다보면 새로운 아이템을 만나고, 새로운 캐릭터를 얻게 되고, 새로운 전투 상황을 경험하는 모험을 체험할 수 있습니다. 그리고 그 곳을 다시 돌아오게 됐을 때도 새로운 경험을 하게 됩니다. 그렇기 때문에 유니콘 오버로드는 굉장히 선형적이지만, 동시에 오픈월드의 모험을 느낄 수 있도록 설계됐습니다.\n\n이 게임 맵 디자인의 추가적인 장점은, 야생의 숨결처럼 중앙에서 시작해 주변을 여행하는 루트로 맵을 구성했다는 점입니다. 이 때문에 유저는 자연스럽게 이전에 너무 강해서 지나가지 못했던 막혀있던 모험지역들을 아까 들렀던 곳을 자연스럽게 지나다가 도전하는 경험을 하게 되어 맵에 남겨두고 온 궁금증들을 자연스럽게 해소할 수 있습니다. 거기에 더해 클리어하지 못해 남겨두고 온 지역의 보상들은 다른 일반적인 것보다 훨씬 특별한 경우가 많기 때문에 저는 이에 혹해서 맵을 이잡듯이 뒤지게 됐습니다.\n\n한 가지를 더 첨언하자면, 유니콘 오버로드는 2d로 구성된 오픈월드 게임이란 것이 제게는 장점이 굉장히 큰 게임이었습니다. 여타의 오픈월드 rpg 게임들은 3d로 복잡한 맵의 구조를 갖추고 있어 저 같은 사람은 맵에 숨겨진 요소들을 찾기가 거의 불가능해 모험의 재미를 못 느끼고 공략을 뒤지는 경우들도 종종 있었습니다. 공략을 보고도 이걸 대체 어떻게 찾으란거지?싶을 때도 많았습니다. 대표적으로 기억나는게 야생의 숨결에서 절벽에서 뛰어내려서 창을 꽂으면 열리는 사당입니다. 그런데 이 게임은 2d입니다. 그냥 픽셀 밟다보면 언젠가 답이 나옵니다. 그래서 모험의 재미를 느끼는 것이 익숙하지 않으신 분들도 쉽게 모험의 재미를 느낄 수 있습니다.\n\n---\n\n## 오픈월드로 srpg의 한계를 극복하다\n\n개인적인 srpg 게임의 한계라 느끼는 시점은 내 캐릭터들이 지나치게 강해지는 순간이라 생각합니다. srpg는 기본적으로 내가 상대에 비해 더 적은 수의 병력을 지형과 상성, 전략을 통해 순간적인 우세를 쌓아가면서 이득을 보는 것이 전투의 묘미라고 생각합니다. 그리고 이것은 대부분의 경우 상대와 나의 일방적인 교환비를 통해 이루어집니다. 좁은 공간으로 상대의 일부 유닛에게만 교전을 건 뒤, 광역기를 사용하면 순간적으로 내가 상대보다 더 많은 병력을 보유하게 되는 것이 대표적인 예시라 할 수 있습니다.\n\n그런데 rpg 게임의 특성상 유저가 성장하지 않는다면 그건 그것대로 재미가 떨어지기 때문에 캐릭터들은 성장해야하고, 최종적으로는 적보다 강해지는 순간이 옵니다. 그리고 그 시점부터 srpg에서 전략은 사라지고 반복 노동이 되는 경우를 벗어나는 게임을 저는 아직 보지 못했습니다. 그 시점부터 유저는 적보다 열세의 병력을 전략으로 뒤집는 것이 아니라, 무적의 엑스컴 정예병사(?)를 이끄는 지휘관으로 외계인을 학살하게 됩니다. 이 부분은 유니콘 오버로드 역시도 마찬가지였습니다.\n\n하지만 저는 이 게임을 엔딩을 보는 시점까지 즐길 수 있었습니다. 그 이유는 이 게임이 오픈월드로 구성돼있기 때문입니다. 아 내가 지난번에 지나온 거기로 다시 가면 뭔가 있었던 것 같은데? 아래에 있는 저기 들렀다 가면 좋은 무기 하나 먹을 수 있을 것 같은데? 아니 이 아이템은 대체 어디 숨겨져 있는거야? 하는 생각을 가지고 온 맵의 픽셀들을 뒤지다보면 시간가는 줄 모르고 정신 차리면 엔딩까지 가게 되는 것이죠.\n\n이런 잘 만든 오픈월드의 도입을 통해 만들어진 유니콘 오버로드의 세계는 분명 젤다와 같은 엄청나게 훌륭한 오픈월드냐 하면 그정도는 아닌 것은 사실입니다만, 굉장히 잘 만들어진 2d 오픈월드 srpg 게임이라는 점에서 굉장히 훌륭하다고 평가합니다.\n\n---\n\n## 참고자료\n\n- [GMTK - How Nintendo Solved Zelda's Open World Problem](https://www.youtube.com/watch?v=CZzcVs8tNfE)\n- [Thisisgame - 유니콘 오버로드, 50만장 판매 돌파](https://thisisgame.com/webzine/nboard/6/?n=186957)\n\n---\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"오픈월드를 통한 srpg의 한계 극복","subtitle":"유니콘 오버로드 리뷰(1)","date":"2024-04-10T00:00:00.000Z","categories":"게임이야기","recommended":true,"series":"유니콘 오버로드 리뷰","seriesIndex":1}},{"postName":"2024-04-20-우마무스메 개론-1","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-20-우마무스메 개론-1.md","category":"게임이야기","title":"200만원으로 우마무스메 12/15관을 달성한 비결","subtitle":"우마무스메 개론(1)","content":"\n### 목차\n\n- [우마무스메는 운빨 망겜이 아니다](#우마무스메는-운빨-망겜이-아니다)\n- [자기소개](#자기소개)\n- [완벽한 도자기를 깎는 것이 최적의 방법은 아니다](#완벽한-도자기를-깎는-것이-최적의-방법은-아니다)\n- [최적해는 인자작 복리를 이용하는 것이다](#최적해는-인자작-복리를-이용하는-것이다)\n  - [증조부 인자작 한 것 예시](#증조부-인자작-한-것-예시)\n\n---\n\n## 우마무스메는 운빨 망겜이 아니다\n\n우마무스메는 수많은 확률의 누적으로 이루어진 게임입니다. 게임을 하기 위해 갖춰야하는 장비와 캐릭터에 해당하는 우마무스메와 서포터 카드를 뽑는 것은 가챠를 통해서 얻고, 육성을 하는 과정의 모든 턴에 발생하는 이벤트는 확률에 의해 결정되는데, 스킬을 획득하는 것도 확률, 발동하는 것도 확률, 적성이 올라가는 것도 확률, 자기보다 강하거나 약한 상대를 만나는 것도 확률, 어느 레인에 걸리는지도 확률, 늦은 출발을 하느냐도 확률입니다.\n\n이 때문에 사람들은 소위 우마무스메를 현대적으로 해석한 서브 컬쳐 파칭코 혹은 디아블로라고도 합니다. 유저가 게임의 결과에 대해 가질 수 있는 통제권이 마치 슬롯머신에서 레버를 당기는 횟수를 제외하고 없는 것과 마찬가지로 육성 횟수와 참여 횟수와 같은 시행횟수를 늘리는 것 뿐이라는 것이 그 이유입니다. 그러나 저는 이것이 잘못된 해석이라고 생각합니다.\n\n우마무스메는 분명 확률의 누적으로 이루어진 게임입니다만, 유저가 노력을 통해서 유리한 결과가 일어나도록 확률을 조작할 수 있는 여러 가지 방법이 존재하고, 이를 과학적으로 접근해서 육성에 방향성을 주는 것을 통해 유저는 게임을 유리한 방향으로 통제할 수 있습니다. 이는 마치 포커와 같은 게임이 분명 확률의 누적으로 이루어져 있고 그 운을 뛰어넘는 것은 불가능하지만, 승률이 높은 사람이 존재하는 것과 마찬가지입니다.\n\n이 글에서는 우마무스메를 과학적으로 접근해서 승리를 단순히 운에 맡기지 않고, 원리에 대한 이해와 이를 이용한 전략 수립 및 실천을 통해 고수 트레이너가 되는 방법을 이야기해보려 합니다.\n\n---\n\n## 자기소개\n\n제가 가장 좋아하는 우마무스메는 킹 헤일로, 그 이유는 쏟아지는 중압감과 실패 속에서도 좌절하지 않고 끝까지 도전해서 마침내 우승을 쟁취하는 킹에게 감동받았기 때문입니다. 그 다음은 파인 모션입니다. 우마무스메 프리티 더비라는 게임은 킹이 아니라 하더라도 수 많은 우마무스메들이 힘겨운 순간들을 견디고, 끝까지 도전해서 목표를 쟁취하는 노력하는 모습이 너무나도 감동적이기 때문에 하나하나가 너무 매력 넘치고 비록 플레이하면서 괴로울 때도 많았지만 제 인생에서 가장 좋아하는 게임 중 하나입니다.\n\n저는 우마무스메 프리티더비를 키타산 블랙 서포터카드 픽업 당시 시작해 1차 타우러스 챔피언스 미팅부터 참가해 2차 레오배까지 총 16회의 챔피언스 미팅 중 15회에 참가해 12회의 플래티넘을 달성한 트레이너입니다. 제가 플래티넘을 달성한 챔피언스 미팅은 1차는 제미니, 캔서, 버고, 리브라, 스콜피오, 사지타리우스, 피스케스, 아쿠아리우스, 카프리콘이며 2차는 타우러스, 제미니, 레오배입니다.\n\n![플래티넘 칭호 일부](/images/우마무스메%20개론/플래티넘%20칭호%20일부.png)\n\n우승시에 사용한 우마무스메는 1착 기준으로 응원단장 킹 헤일로, 발렌타인 미호노 부르봉, 스마트 팔콘, 나리타 타이신, 세이운 스카이, 수영복 마루젠스키, 골드 쉽이 있습니다. 특히 아오하루배는 전관을 도주로 플래티넘을 달성하기도 했습니다. 관련된 영상이 궁금하신 분은 [다음 유튜브 영상들](https://www.youtube.com/@prosy1719/videos)을 참고해주세요.\n\n---\n\n## 완벽한 도자기를 깎는 것이 최적의 방법은 아니다\n\n우마무스메를 플레이 할 때 '완벽한 도자기를 깎는 것'과 같이 하시는 분들이 꽤나 많습니다. 인터넷에서 돌아다니는 공략들을 통해서 어느 스탯과 스킬을 보유하고 있어야 하는 지에 대한 가이드를 찾고, 그 기준에 부합할 때까지 우마무스메를 육성하는 것입니다. 특히 이 공략들은 소위 미래시라 불리는 일본 서버를 플레이한 경험자들이 자신의 체험을 통해 제시한 것이기 때문에 이를 무비판적으로 수용하고 그것이 안 나오면 '나는 이렇게 노력하는데 운이 없어서 이길 수 없다'라고 생각하거나, 그것이 나왔는데도 질 경우 '나는 잘 했는데 운빨 망겜이라 계속 진다'라고 생각하기도 합니다.\n\n얼핏 합리적으로 보이는 이 육성 방법에는 문제점이 몇 가지 있습니다.\n\n1. 우마무스메에 완벽함은 시스템적으로 존재할 수 없다.\n2. 완벽함의 기준에 대한 검증이 부족하다.\n3. 완벽함을 달성하는 것은 너무 확률이 낮기 때문에 시간이 많이 필요하다.\n4. 한국 서버와 일본 서버의 환경이 다르기 때문에 강한 우마무스메의 형태와 편성이 다른 경우가 많다.\n\n우마무스메 프리티더비는 완벽한 플레이가 불가능한 게임입니다. 그렇기 때문에 저는 이 게임에서 가장 중요한 것 중 하나는 스스로의 타협 지점에 대해 설정해 두는 것이라 생각합니다. 포커를 플레이할 때 본인의 칩이 떨어져가서 쫓기듯이 올인 배팅을 하는 것이 아니라, 자신이 생각해 둔 한계 지점을 기반으로 게임을 빌드업해 나가듯이 본인이 멈춰야 하는 지점에 대해 생각해야합니다.\n\n타인이 정한 기준의 완벽함을 달성하더라도 그것은 해당 기준을 완벽하게 만족한다는 것이지, 최강의 우마무스메를 육성하는데 성공했다는 것과는 다릅니다. 과거의 데이터만을 기반으로 이를 목표를 수립하고 현재에 대한 피드백을 하지 않는 것은 굉장히 문제가 있는 접근 방법입니다. 한국 서버는 일본 서버와 달리 시기적으로 일찍 유저들이 학습한 개념적인 부분을 활용하는 경우가 굉장히 잦습니다. 대표적인 것이 1차 캔서배 스마트 팔콘입니다. 일본에서 1차 캔서배 때 스마트 팔콘은 소위 '뚜껑'이라고 불리는 용도로 제한적으로 사용됐지만, 한국에서는 1차 캔서배부터 스마트 팔콘을 에이스로 활용한 전략이 활발하게 사용되었습니다.\n\n이런 이유들 때문에 단순히 남이 정해준 기준을 만족하는 완벽함을 추구하는 것은 최적의 방법이 아니며, 오히려 스스로 타협 지점을 설정하고 이를 기반으로 피드백을 통해 육성 방향을 조정하는 능력을 키우는 데 방해가 되기 때문에 이를 지양해야 한다고 저는 생각합니다. 제가 남들처럼 남이 짜 준 청사진을 기반으로 완벽한 도자기를 깎는 방식으로 게임을 플레이했다면, 200만원으로 15관 중 12관을 달성하는 것은 불가능했을 것입니다.\n\n---\n\n## 최적해는 인자작 복리를 이용하는 것이다\n\n제가 생각하는 우마무스메를 플레이하는 최적의 방법은 인자작을 통한 복리를 이용하는 것입니다. 인자작이란 출주마가 아니라 짧게는 출주마의 부모, 더 나아가서는 조, 증조, 증증조, 증증증조 부모를 육성하는 것을 말합니다. 이 말을 보자마자 '이거 사람 아니야, 말 악귀야. 그걸 어떻게 해?'라고 생각하는 분들이 있을 겁니다. 그렇게 시간이 오래 걸리는 일을 어떻게 해? 하지만 이 게임의 원리를 이해하시면 이것이 오히려 시간을 절약하는 방법이라는 것을 알 수 있습니다.\n\n우마무스메의 인자 시스템의 복리적인 측면에 대해 간략하게 설명하면, 동일한 것이 부모/조부에 중복해서 걸려있는 횟수가 높을수록 인자로 남을 확률이 높아지는 로직으로 이루어져 있습니다. 이 때문에 단순히 여러 스킬이 붙은 단 하나의 우마무스메 인자를 만들어내는 것을 목표로 하는 것이 아니라, 여러 우마무스메를 번갈아가면서 육성하면서 오래 쓸 수 있는 핵심 인자가 중첩되도록 하는 것이 중요합니다.\n\n### 증조부 인자작 한 것 예시\n\n![증조부 네이처](/images/우마무스메%20개론/증조부%20인자%20예시.png)\n\n이를 통해 훌륭한 증증조부가 발생하면 이를 통해 좋은 증조부가, 조부가, 부모가, 출주마가 발생합니다. 그리고 이들 중에서 활용할 수 있는 우마무스메의 갯수가 늘어납니다. 즉, 인자작의 복리를 적용한 인자작을 하게 되면 단순히 즉전감으로 활용하기 위한 조부모, 부모, 출주마 셋만을 목표로 하는 육성에 비해 유효 육성의 횟수가 압도적으로 높아지게 됩니다. 즉, 시간을 훨씬 더 효율적으로 사용할 수 있게 되기 때문에 같은 시간 동안 더 많은 우마무스메를 육성하는 것과 동일한 효과를 얻을 수 있으며 이는 복리의 특성상 시간이 지날수록 더 큰 효과를 가져다 줍니다.\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"200만원으로 우마무스메 12/15관을 달성한 비결","subtitle":"우마무스메 개론(1)","date":"2024-04-20T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":1}},{"postName":"2024-04-27-우마무스메 개론-2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-27-우마무스메 개론-2.md","category":"게임이야기","title":"인자작 없는 육성은 도박이다","subtitle":"우마무스메 개론(2)","content":"\n### 목차\n\n- [간단한 계산으로 이해하는 타협의 이유](#간단한-계산으로-이해하는-타협의-이유)\n- [유효 육성 횟수를 올리는 방법: 6일이냐, 2일 혹은 2육성이냐](#유효-육성-횟수를-올리는-방법-6일이냐-2일-혹은-2육성이냐)\n- [스킬을 포함하면 최소 20일이 걸리는 육성시간](#스킬을-포함하면-최소-20일이-걸리는-육성시간)\n- [평균적으로 생각하는 인자작으로 충분한 우마무스메를 육성하는 것은 도박이다](#평균적으로-생각하는-인자작으로-충분한-우마무스메를-육성하는-것은-도박이다)\n\n---\n\n## 간단한 계산으로 이해하는 타협의 이유\n\n우마무스메라는 게임은 수많은 확률의 교집합으로 이루어져있고, 이 때문에 타협을 할 기준을 정해두지 않으면 이는 단순히 운을 믿고 도박을 하는 것과 다를 바가 없다고 저는 생각합니다. 이를 위해 그랜드라이브 막바지 시점(2024-04-27)에서 충족 가능한 에이스마의 예시를 통해 왜 그런지 한번 이야기해보려 합니다.\n\n만약 본인이 이번 챔피언스 미팅인 [카프리콘배(2024-05-04 ~ 2024-05-10)](https://namu.wiki/w/%EC%9A%B0%EB%A7%88%EB%AC%B4%EC%8A%A4%EB%A9%94%20%ED%94%84%EB%A6%AC%ED%8B%B0%20%EB%8D%94%EB%B9%84/%EC%9D%B4%EB%B2%A4%ED%8A%B8/%EC%B1%94%ED%94%BC%EC%96%B8%EC%8A%A4%20%EB%AF%B8%ED%8C%85/2%ED%9A%8C%EC%B0%A8#s-2.9)에 출주시킬 우마무스메 중 하나로 킹 헤일로를 선택했다고 가정해보겠습니다. 보통 이야기하는 좋은 우마무스메의 기준이 되는 몇 가지를 예시로 이것이 얼마나 이루어지기 힘든지 한 번 살펴보겠습니다.\n\n```markown\n1. 잔디/단거리 적성이 S이다\n2. 스피드 1500 이상/파워 1100 이상이다\n3. 강공책, 전광석화를 보유하고 있다\n4. 좌회전, 겨울, 맑음, 양호한 경기장과 같은 패시브 스킬을 보유하고 있다.\n5. 직선 주파, 추입 직/코, 단거리 직/코, 꼬리올리기와 속/가속기를 보유하고 있다.\n```\n\n추가로 각각에 따른 가정을 해보겠습니다.\n\n```markown\n1. 잔디/단거리 적성이 S가 될 확률은 육성마다 각각 25%이다.\n2. 스피드 1500 이상 \u0026 파워 1100 \u0026 지능 1000 이상이 될 확률은 육성마다 약 20%이다.\n3. 금딱 스킬을 획득할 확률은 각각 60%이다.\n```\n\n그렇다면 위의 가정을 기준으로 잔디/단거리 둘 중 하나라도 적성이 S이면서, 스피드 1500에 파워 1100인 우마무스메가 필수 금딱 스킬을 모두 보유할 확률은 다음과 같습니다.\n\n$$(0.25 + 0.25 - 0.25^2) \\times 0.2 \\times 0.6^2$$\n$$=0.0315=3.15\\%$$\n\n즉, 모든게 다 완벽하게 갖춰진 상태에서 여러분들이 보통 기본적이라고 생각하는 우마무스메를 육성하는 데에는 못해도 30번 정도의 육성이 필요할 것이란 뜻입니다. 보통 잘 갖춰진 육성을 하는 데에 렌탈을 포함해야하는 것을 감안하면 이는 타협하지 않을 때 단순히 '기초적인' 우마무스메를 육성하는데 인자작을 제외한 본 육성에만 렌탈을 모두 소모하는 것을 가정했을 때 후보로 고려해볼 수 있을 정도는 되는 우마무스메를 육성하는데에 평균 6일의 시간이 필요하단 뜻입니다.\n\n여기에 더해 각종 패시브 스킬과 직/코, 속/가속기를 갖추는 것은 더욱더 어려울 것입니다. 이러한 이유로 타협을 할 기준을 정해두지 않으면 이는 단순히 운을 믿고 도박을 하는 것과 다를 바가 없다고 저는 생각합니다. 이것이 제가 보통 이야기하는 완벽한 우마무스메를 육성하는 것을 목표로 하지 않고 제 나름의 타협을 하는 이유입니다.\n\n---\n\n## 유효 육성 횟수를 올리는 방법: 6일이냐, 2일 혹은 2육성이냐\n\n그런데 여기서 우리가 확률을 높일 수 있는 몇가지 방법이 있습니다. 그 중 하나는 바로 좋은 인자를 사용하는 것이고, 나머지의 예로는 넓은 기준을 사용하는 것입니다. 보통 챔피언스 미팅에서 주전 멤버로 사용하는 우마무스메의 경우 유효 적성을 둘 중 하나를 S로 사용하는 것을 필수로 하는 편이기 때문에 이를 기준으로 한 번 이야기해보면 다음과 같습니다.\n\n만약 단거리 혹은 잔디 적성 S가 나올 확률을 10%씩 올릴 때마다 방금 기준의 우마무스메를 육성 성공할 확률은 3.69%, 4.23%로 상승하며, 이는 둘을 동시에 10%씩 올릴 때마다 4.15%, 5.02%로 상승합니다. 이 게임에서 [적인자 계승 확률 변동폭](https://www.fmkorea.com/5022035640)을 감안할 때, 이는 적인자가 2성인 인자를 3성으로 하나 바꿀 때마다 유효 육성 횟수가 약 3배 증가하기 때문에 필요 육성 횟수가 약 1/3 감소하는 효과가 발생합니다. 참고로 1성 인자와 3성 인자의 차이는 약 15배 정도입니다.\n\n이는 다시 말해 후보로 사용해 볼 수 있는 우마무스메를 육성하는 데에 적인자 1, 2성 하나를 교체할 때마다 6일 걸리던 시간을 2일이나 심지어는 하루 2회 육성으로 단축할 수 있다는 소리가 되고, 다시 말해 그만큼 완성도가 높은 육성을 할 가능성이 올라간다는 뜻입니다. 이 때문에 본인이 거리 혹은 마장 적성 둘 중 하나를 S로 사용하는 것을 필수로 삼는다면, 자신이 사용하는 적인자의 상태부터 점검하는 것이 급선무라 할 수 있습니다. 그리고 다른 백인자나 청인자를 포기하더라도 적인자의 성급을 높이는 타협을 하는 것이 필수적이라 할 수 있습니다.\n\n다음은 제가 실제로 사용했던 적인자 중 하나인 청1 적3 직부모인자의 예시입니다.\n\n![청1 적3 직부모인자](/images/우마무스메%20개론/예시%20청1%20적3%20인자.jpg)\n\n---\n\n## 스킬을 포함하면 최소 20일이 걸리는 육성시간\n\n그런 의미에서 스킬은 적인자보다는 확률이 널널하다고 말할 수 있습니다. 적성은 오로지 계승에 의존해야하는데 반해 스킬은 계승이나 악곡과 같은 시나리오 이벤트, 스킬 힌트, 레이스 보상, 랜덤 카드 이벤트 등 다양한 방법으로 얻을 수 있기 때문입니다. 그렇지만 이 역시도 필수적으로 획득해야하는 흰딱 스킬이라는 것이 가끔은 존재합니다. 대표적으로 추입마인 킹 헤일로의 경우 '직선주파' 혹은 '뒤처지기 방지'와 같은 스킬을 획득하는 것을 필수로 여기는 경우가 많습니다.\n\n그나마 각질 스킬이고 널리 쓰이는 카드인 Mr.CB의 스킬 힌트로도 획득 가능한 직선주파 스킬을 획득하는 확률을 높게 쳐서 40%라고 가정하더라도, 인자작이 되어있지 않을 때 파인 모션, 토카이 테이오, 오구리 캡 이외의 카드로 힌트를 통해 획득하는 것이 불가능하다 봐야하는 뒤처지기 방지의 경우 획득 확률을 10% 정도로 가정했을 때 둘 중 하나의 유효 흰딱 가속기를 획득할 확률은 다음과 같습니다.\n\n$$0.4 + 0.1 - 0.4 \\times 0.1 = 0.46 = 46\\%$$\n\n이는 아까의 기준과 합쳐 생각했을 때 보통 생각하는 '출발선에 서는 우마무스메'의 기준인 '잔디/단거리 적성이 S이고, 스피드 1500 이상\u0026 파워 1100 이상이며,  강공책, 전광석화를 보유하고 있는'데다가 '직선주파 혹은 뒤처지기 방지'와 같은 추가적인 가속도를 가지고 있는 우마무스메를 육성할 가능성은 평균적으로 1.45% 정도밖에 되지 않는다는 사실을 의미합니다. 이는 100번의 육성을 했을 때 1번 정도의 확률로만 나올 수 있는 것을 의미하며 곧 렌탈을 통해 육성을 하려할 경우 육성마 하나에 약 20일의 시간이 필요하단 사실을 의미합니다.\n\n---\n\n## 평균적으로 생각하는 인자작으로 충분한 우마무스메를 육성하는 것은 도박이다\n\n위의 계산들을 통해 사람들이 평균적으로 생각하는 인자작의 수준으로 챔피언스 미팅에서 충분히 쓸만하다고 평가하는 우마무스메의 출발선 정도의 우마무스메를 키우는 것이 거의 불가능하다는 사실을 아실 수 있을 것이라 생각합니다. 챔피언스 미팅의 주기는 보통 한달인 30일 정도이기 때문에, 주자 하나를 테스트하는 것이 가능한 정도까지 육성하는데에만 그것도 적성을 거리와 마장 둘 중 하나만 타협해서 붙여도 약 20일이 걸린다면 셋이나 되는 주자를 육성하는 것은 불가능에 가까우며 사실상 도박에 가깝다 할 수 있습니다.\n\n그런데 20일을 주자로 사용할 우마무스메가 아니라 인자로 사용할 우마무스메를 육성하는 데에 사용한다면 확률을 획기적으로 끌어올릴 수 있게 되고, 이는 렌탈을 이용해서 고점마를 육성하는 것이 아니라 인자작을 하는 데 사용하는 것이 훨씬 효율적이란 사실을 의미합니다. 이러한 이유로 저는 사람들이 평균적으로 '충분하다'라고 평가하는 인자작의 수준은 충분에서 거리가 멀며 본인이 생각하는 것보다 훨씬 도박에 가깝다 생각합니다. 그러므로 본인이 진지하게 챔피언스 미팅에 출전하고자 하는 트레이너이고 인자작을 남들만큼 했다고 생각한다면, 그것이 충분한 것에서 많이 모자라며 훨씬 공을 들일 필요가 있습니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인자작 없는 육성은 도박이다","subtitle":"우마무스메 개론(2)","date":"2024-04-27T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":2}},{"postName":"2024-05-04-우마무스메 개론-3","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-05-04-우마무스메 개론-3.md","category":"게임이야기","title":"전술을 수립하고 룸매치를 통해 최종 점검하자","subtitle":"우마무스메 개론(3)","content":"\n### 목차\n\n- [역대급 팀이 있어도 클린스만은 아시안컵을 우승하지 못했다](#역대급-팀이-있어도-클린스만은-아시안컵을-우승하지-못했다)\n- [자신의 에이스 우마무스메의 승리 플랜은 무엇인가](#자신의-에이스-우마무스메의-승리-플랜은-무엇인가)\n- [초반에 경합을 발생시킬 것인가, 아니면 후반에 승부를 가릴 것인가](#초반에-경합을-발생시킬-것인가-아니면-후반에-승부를-가릴-것인가)\n- [룸매치와 실전을 통해 환경을 최종 점검하자](#룸매치와-실전을-통해-환경을-최종-점검하자)\n- [마치며](#마치며)\n\n---\n\n## 역대급 팀이 있어도 클린스만은 아시안컵을 우승하지 못했다\n\n최근 한국 사람들을 경악케 한 사건이 하나 있었습니다. 소위 황금세대라고도 불리는 역대급 선수들로 구성된 한국 아시안컵 축구 대표팀이\n 결승에서 석패를 한 것도 아니라, 4강 진출에 그쳤을 뿐 아니라 내적인 경기력도 참담했다는 점입니다. 그리고 그 주 요인으로 꼽힌 것은 바로\n 감독인 클린스만의 전술 부재였습니다. 그리고 우마무스메 프리티 더비 역시 마찬가지로 올바른 전략 전술을 수립하지 않는다면 어떤 역대급\n 우마무스메를 육성하는 데 성공하더라도 이를 활용하지 못하고 무용지물로 만들 수도 있습니다.\n\n이 때문에 이 게임의 기본적인 전략을 이해하고 자신의 전략을 수립하는 것이 중요합니다. 이번에는 이를 위한 방법을 이야기해보려 합니다.\n\n---\n\n## 자신의 에이스 우마무스메의 승리 플랜은 무엇인가\n\n이 게임에서 가장 먼저 이해해야하는 것은 자신이 에이스 주자로 사용할 우마무스메가 어떤 승리 플랜을 이해하는 것입니다. 2차 카프리콘 배의\n 추입마였던 두 다른 승리 플랜을 가지고 있는 우마무스메인 나리타 타이신과 응원단장 킹 헤일로와 같은 사례를 놓고 보면 이는 극명하게\n 드러납니다.\n\n나리타 타이신의 가장 큰 장점은 순위조건이 부재하고 위력은 조금 약하지만 최속의 타이밍에 발동하는 육박하는 그림자라는 현재 유일무이한\n 금딱 가속기를 내장하고 있으며, 이를 뒷받침하기 위해 다른 추입마들에 비해 비교적 빠른 중반 타이밍에 발동하는 속도 증가 고유기인\n Nemesis를 보유하고 있다는 점입니다. 즉 나리타 타이신은 여타 골드쉽으로 대표되는 롱스퍼트형 추입마들과 동일한 승리 공식을 가지고\n 있습니다. 추입마이지만 앞 각질을 중반 타이밍에 빠르게 치고 나와 그들과 비슷한 위치에서 뛰쳐나간다는 점입니다.\n\n반면 킹 헤일로는 원본마가 그러했듯 굉장히 낭만 넘치는 승리 플랜을 가지고 있습니다. 타카마츠노미야 기념에서 마생 최초이자 마지막 g1 우승\n을 이룬 킹 헤일로는 해당 경주에서 종반부에 이길 수 있다고 상상하기 힘들 정도로 뒤에 위치하고 있었지만, 말도 안되는 속도로 가장 바깥에서\n 치고 들어오며 나머지 경쟁자들을 휩쓸어버리는 경주를 했습니다. 이 경기를 모티프로 한 응원단장 킹 헤일로는 후반부까지 뒤에서 힘을 모은 뒤\n 마지막 순간에 폭발적인 속도로 앞으로 나아가는 승리 플랜을 가지고 있습니다.\n\n이 두가지 다른 우마무스메가 각각 승리하기 위해서는 어떤 승리 플랜을 사용하는 것이 좋을까요? 저는 나리타 타이신은 초중반에 경합이\n 발생하는 편성 상에서, 킹 헤일로는 가능한 적은 경합만 이루어진 상태로 후반부에 승부를 가리는 편성을 사용하는 것이 좋다고 생각합니다.\n 그렇다면 각각의 승리 플랜에 맞는 편성은 어떤 구성을 의미하는 것일까요?\n\n---\n\n## 초반에 경합을 발생시킬 것인가, 아니면 후반에 승부를 가릴 것인가\n\n우마무스메라는 게임은 경합이 이루어지는 구간이 일반적으로 초반, 중반, 후반 한번씩으로 나누어져있는 게임입니다. 이 때 초반부터 경합이\n 나기 위해서는 자신과 같은 혹은 바로 앞의 각질의 숫자가 얼마나 있느냐에 따라 결정됩니다. 이 때문에 추입마인 나리타 타이신이 초, 중반부에\n 경합이 이루어지려면 선/추입의 숫자가 많은 편성을 사용하는 것이 좋습니다. 만약 선/추입의 숫자가 적은 도주/선행이 총 여섯 이상인 편성에서\n 경주를 하게 된다면 나리타 타이신의 최대 강점 중 하나인 '7위에서 추격이 활성화 됐을때 발동하는 nemesis'를 사용할 수 없게 될 가능성이\n 높아지기 때문입니다.\n\n반면 킹 헤일로는 중반에 순위조건을 가지고 치고 나가는 스킬도 부재할 뿐더러, 오히려 보유한 고유기는 '진행 거리 비율 50% 이하일 때 순위\n 비율 70%(6~9위)를 유지' 했을 때 발동합니다. 즉 킹 헤일로는 레이스의 전반부에 절대로 앞으로 나서서는 안됩니다. 만약 선/추입이 총 다섯\n 이상인 편성에서 경주를 하게 된다면 초, 중반 경합의 과정에서 킹 헤일로는 본인의 고유기를 사용할 수 없게 될 가능성이 높아집니다. 이 때문에 킹 헤일로는 본인을 제외하고는 도주/선행 위주로 구성된 편성을 사용하는 것이 좋습니다.\n\n|  | 나리타 타이신 | 킹 헤일로 |\n|:---:|:---:|:---:|\n| 승리 플랜 | 초중반에 경합 | 후반에 승부 |\n| 유리 구성 | 도주/선행 5 이하 | 도주/선행 6 이상 |\n| 추천 편성 | 선/추입 둘 이상 | 킹 제외 도주/선행 |\n\n---\n\n## 룸매치와 실전을 통해 환경을 최종 점검하자\n\n이제 자신의 우마무스메가 어떤 승리 플랜을 가지고 있는지, 그에 맞는 편성은 무엇인지 알게 되었습니다. 특히 룸매치의 경우 실전에서 결승에서\n 만날 수 있는 수준의 트레이너와 보통 경쟁하게 되기 마련입니다. 그 사람들이 현재 주로 사용하는 편성은 어떻게 되는지 확인하고, 주로\n 나오는 편성에 대응해서 내 에이스 우마무스메가 승리하기에 유리한 조합을 찾아내는 것이 중요합니다. 예를 들어 룸매치에서 선/추입이 3 이상인\n 경주가 거의 나오지 않는다면 오히려 본인이 킹 헤일로를 사용하더라도 선/추입마를 하나 더 포함하는 편성을 사용하는 것이 좋을 수도 있습니다.\n\n또한 룸매치는 평균 이상의 트레이너와 경쟁한다는 것을 감안해서, 실전에서 확인을 통해 예측한 환경과 현실이 얼마나 일치하는지를 확인할\n 필요도 있습니다. 이 과정을 통해 자신의 편성이 실전에서 얼마나 효과적인지를 확인하고, 필요하다면 편성을 수정하는 것도 중요합니다. 이를\n 위해 저는 함께 게임하는 분들과 실전 환경의 통계를 수집하고 분석해서 편성을 최적화하기도 했습니다. 특히 본인의 통계는 편향성이 있을 수\n 밖에 없기 때문에, 서클원과 같이 다른 사람들의 통계를 함께 수집하고 분석할 수 있다면 이는 승리에 큰 도움이 됩니다.\n\n---\n\n## 마치며\n\n최대한 많은 내용을 담으려고 노력하기는 했지만, 우마무스메 프리티 더비가 워낙에 파고들 것이 많은 복잡한 게임이기 때문에 다루지 못한\n 이야기들도 많아 아쉬움만 남습니다. 다만 어디까지나 개론의 성격으로 기초적인 이론을 모르고 계신 분들께 조금이라도 도움이 됐으면 하는\n 생각에 모자란 펜을 들고 이 글을 쓰게 되었습니다.\n\n우마무스메는 분명 운빨 망겜이 맞습니다. 하지만 그 운을 최대한 자신에게 유리하게 끌어들이는 데 성공하셨다면 모두가 어엿한 트레이너라고\n 생각합니다. 긴 글 읽어주셔서 감사하고 앞으로도 우마무스메 프리티 더비를 즐기는 모든 분들이 행복한 경주를 즐길 수 있기를 바랍니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"전술을 수립하고 룸매치를 통해 최종 점검하자","subtitle":"우마무스메 개론(3)","date":"2024-05-04T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":3}},{"postName":"2024-05-18-게임에서 볼 수 있는 두려움의 활용","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-05-18-게임에서 볼 수 있는 두려움의 활용.md","category":"게임이야기","title":"게임은 어떻게 두려움을 통해 유저를 영웅으로 만드는가","subtitle":"손실 회피 경향을 통해 살펴본 게임 속 두려움","content":"\n### 목차\n\n- [게임에서 볼 수 있는 두려움의 종류들](#게임에서-볼-수-있는-두려움의-종류들)\n- [두려움이란 무엇이고 어디서 오는가](#두려움이란-무엇이고-어디서-오는가)\n- [게임은 두려움으로 어떻게 유저를 영웅으로 만드는가](#게임은-두려움으로-어떻게-유저를-영웅으로-만드는가)\n- [마치며](#마치며)\n\n---\n\n## 게임에서 볼 수 있는 두려움의 종류들\n\n[![nameless name](https://img.youtube.com/vi/WrWga0k-fzE/hqdefault.jpg)](https://www.youtube.com/watch?v=WrWga0k-fzE)\n\n오늘 걸즈 밴드 크러시라는 애니메이션을 보다가 나온 두려움을 안고 하고 싶은 것을 하는 용기에 대해 이야기하는\n것을 보고 큰 감명을 받고, 저는 그런 두려움을 어디에서 극복하는지에 대해 생각해보았습니다. 그리고 그것이 게임에서\n활용되는 경우가 굉장히 많고 제가 이를 극복하는 과정을 통해 영웅이 되는 것을 느끼는 즐거움을 경험한다는 사실을\n깨달을 수 있었습니다.\n\n게임에서는 다양한 형태의 두려움을 볼 수 있습니다. 부쉬 속 정글러어어, 모르면 맞아야지, 감나빗!, 상상 속의\n니비루, 차오르는 스트레스 수치와 깎여나가는 체력. 이처럼 게임에서는 다양한 형태의 두려움을 경험할 수 있고 우리는\n이를 극복하며 게임을 즐기게 됩니다.\n\n---\n\n## 두려움이란 무엇이고 어디서 오는가\n\n그런데 두려움이란 무엇이고 어디서 오는 것일까요? 저는 두려움이란 생물이 가진 손실 회피 본능을 구체화 시켜 놓아\n생존율을 높이기 위해 발생한 감정이라고 생각합니다. 즉 손해를 보는 것이 생존과 직결되는 상황에서 이를 회피하기\n위해 두려움이라는 감정이 발생한다는 것이 제 주장입니다.\n\n제 생각이 맞다면 두려움이 발생하기 때문에 우리는 손실이 발생할 수 있는 상황에서 안전한 선택을 하도록 유도되며,\n이를 통해 두려움을 받아들이는 객체들이 생존을 더 잘 할 수 있게 되면서 진화를 거듭한 겁쟁이들의 후손이 우리일 것입니다.\n게임이랑 다르게 우리는 현실에서 위험한 상황을 맞이했을 때 이를 맞부딪혔다가 실패할 경우 죽음까지는 아니더라도\n복구하기 어려운 손실을 입게 될 수도 있으니까요.\n\n---\n\n## 게임은 두려움으로 어떻게 유저를 영웅으로 만드는가\n\n왜 게임에서는 우리가 현실에서 피하기 위해 노력하는 두려움을 활용할까요? 저는 게임이 현실에서는 불가능한 체험을\n제공하는 것을 목표로 하기 때문이라고 생각합니다. 현실에서 우리는 진상 손님을 만났을 때 손님은 왕이라며 요구에\n응해야 하거나, 길에서 담배를 피우는 중고등학생 무리를 만났을 때 무리를 피해야 하는 등의 상황에서 두려움에 굴복하고\n피해나가야 합니다. 하지만 우리는 가슴 한 구석에서는 그런 두려움을 극복하고 마주해서 이겨내는 영웅이 되는 것을\n꿈꾸곤 합니다.\n\n그리고 게임은 여러 종류의 적당히 극복 가능한 두려움을 곳곳에 배치하여 우리에게 도망치지 않고 맞서 싸우도록 유도합니다.\n유저는 이 두려움으로부터 도망치는 현실에서의 자신이 아니라, 모두가 한 명의 영웅이 되어 시련을 극복하고 특별한\n한 사람이 되는 경험을 통해 게임을 즐깁니다.\n\n---\n\n## 마치며\n\n오늘은 게임에서 두려움이 어떻게 유저를 영웅으로 만드는지에 대해 이야기해보았습니다. 두려움은 우리가 손실을\n회피하기 위해 발생하는 감정이라고 생각하며, 게임에서 두려움은 현실에서와 달리 극복 가능한 상황으로 제공되어\n유저가 영웅이 되는 장치로 활용됩니다.\n\n다음에는 게임에서 활용되는 두려움의 구체적인 성공 사례 및 실패 사례들을 통해 두려움을 활용하는 방법에 대해\n이야기해보겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"게임은 어떻게 두려움을 통해 유저를 영웅으로 만드는가","subtitle":"손실 회피 경향을 통해 살펴본 게임 속 두려움","date":"2024-05-18T00:00:00.000Z","categories":"게임이야기","series":"게임이 두려움을 통해 유저를 영웅으로 만드는 방법","seriesIndex":1}},{"postName":"2024-04-20-걸즈 밴드 크라이","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/애니 이야기/2024-04-20-걸즈 밴드 크라이.md","category":"ETC","title":"반항이 소멸하는 세상에서 가운데 손가락을 치켜세우는 소녀들","subtitle":"걸즈 밴드 크라이","content":"\n저는 나잇값을 못하는 사람입니다. 아직도 이런 가사의 노래를 들으면 가슴이 두근거리고 발을 쿵쿵 구르며 뛰쳐나가고 싶은 생각에 설레기 때문입니다.\n\n```plaintext\n아무리 기다린들 변하는 게 없다면 이놈이고 저놈이고 손에 닿지 않아\n애초에 누군가의 탓이라고 말한들 이 고통은 사라지지 않아\n\n가만히 무릎을 끌어안고 앉아 있을 뿐인\n그런 매일에 안녕을 고하고 싶다고 염원해\n\n신 따위는 조금도 믿지 않는 주제에\n\n시끄러워\n\n날 내버려 둬\n\n혼자가 아니라며 누군지도 모르는 이가\n목이 쉬도록 노래하고 있어\n\n그런 말에 구원받는 생명도 있겠지\n\n모르겠어\n\n그렇구나\n\n그랬나?\n\n잊어버렸어\n\n귀찮아\n\n부수고 싶어\n\n용기도 없이\n\n살아가는 이유란 녀석을 누군가 내게 알려줘\n대체품 따위는 얼마든지 굴러다니니까\n\n자신답게 굴란 말은 그리 쉽게 할 수 없잖아\n할 수만 있다면 되찾아\n\n꿈으로 넘쳐 흐르고 있다 해도 진실이니까\n\n거기 누구없나요?\n```\n\n록은 반항의 음악이고 애니메이션 '걸즈 밴드 크라이'는 오랜 기간 억압받아온 소녀들이 모여 스스로에게 하던 거짓말을 그만두고, 거대한 세상 앞에 자신들의 조그맣고 너덜너덜해진 반항의 기치를 들어올리는 밴드의 이야기를 하고 있습니다.\n\n학교에서 이지매당한 사실을 덮어두고 학교를 다니기를 종용하는 가정에서 도망쳐나와 스스로를 증명하기 위해 아르바이트와 입시학원을 병행하는 소녀. 위대한 가업을 이어받을 인재라며 자신이 하고 싶은 게 뭔지도 모르는 순간부터 할 일을 강요받고 이를 순순히 따르는 자신을 평생 연기 해온 소녀. 자신은 틀리지 않았는데 마치 자신이 잘못했던 것처럼 몰아가는 세상에 지고 싶지 않은 소녀.\n\n이렇게 많은 방식으로 억압받아온 소녀들이 모여서 서로의 상처를 보듬어주는 안식처로 만들어낸 밴드의 세상을 향해 외치는 쌓여있는 이야기, 그것이 애니메이션 걸즈 밴드 크라이의 밴드 토게나시 토게아리의 음악입니다. 그리고 그것은 동시에 자신들처럼 고통받는 세상 사람들에 대한 응원입니다. '지지 마. 가운데 손가락을 치켜세우고 살아.'\n\n하지만 현실은 너무 무자비하고 무신경하게 그녀들을 보이지 않게 때로는 들리지 않게 짓눌러옵니다. 나도 모르게 음악에 빠져서 수십시간을 열정적으로 보냈지만 그것에 즐거워하기보다 교과서 한쪽을 더 읽을 시간을 낭비했다며 자책하거나, 어둠 속에서 혼자서는 전등도 달지 못하는 무력함에 평생 어둠 속에서 벗어나지 못할 것이라 괴로워합니다. 세상은 그들에게 조용히, 들리지 않는 목소리로 속삭입니다. '나잇값 못하게 왜 그래?'\n\n손가락 하나를 가볍게 찍어내리는 것만으로도 그들을 짓뭉게버릴 수 있을 정도로 강자인 세상과 그걸 등에 업고 있는 사람들 앞에서 약자인 그녀들이 할 수 있는 것은 다만 가운데 손가락을 치켜세우는 것 뿐입니다. 아니, 양손을 번쩍 들어올려 두 새끼 손가락을 들어올리는 것뿐입니다. 그리고 힘껏 연주해서 그 시끄러운 속삭임을 꿰뚫고 그들과 비슷한 처지의 억압받는 사람들에게 도달하기를 간절하게 소망하는 것 뿐입니다. 나약한 주제에 거짓말을 하지 못해 삐딱해지고 배배꼬여가면서도 자신을 굽히는 것은 절대 싫기 때문에 노래하는 것 뿐입니다.\n\n우리는 지금 반항의 정신이, 록 스피릿이 붕괴해가는 세상에서 살아가고 있습니다. 세상에 이런 성가신 음악은 사실 더이상 필요하지 않고 록은 이제 끝났다고들 말합니다. 하지만 스스로 끝이라 말하기 전에는 정말로 끝나는 것이 아니니까요. 완전 제멋대로에 엄청 이기적인 사람이 되어, 세상에 지지 않기 위해 함께 가운데 손가락을 치켜세우는 것은 어떨까요?\n\n[![void](https://img.youtube.com/vi/pA-pzhQQFBA/hqdefault.jpg)](https://youtu.be/pA-pzhQQFBA?si=J04-E50tMQyIDffd)\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반항이 소멸하는 세상에서 가운데 손가락을 치켜세우는 소녀들","subtitle":"걸즈 밴드 크라이","date":"2024-04-20T00:00:00.000Z","categories":"ETC"}}],"categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"latestPostsByCategory":[{"category":"ETC","posts":[{"postName":"2024-05-04-최근 내 삶을 바꾼 제품들","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/etc/2024-05-04-최근 내 삶을 바꾼 제품들.md","category":"ETC","title":"최근 내 삶을 바꾼 제품들 총 6선","subtitle":"전구, AI에서 태블릿 pc까지","content":"\n### 목차\n\n- [개요](#개요)\n- [multiscreen block - 도둑맞은 집중력을 찾아서](#multiscreen-block---도둑맞은-집중력을-찾아서)\n- [샤오미 홈 다기능 충전식 데스크 램프 MJTD05YL - 형광등이 없는 밤을 팔다](#샤오미-홈-다기능-충전식-데스크-램프-mjtd05yl---형광등이-없는-밤을-팔다)\n- [ticktick - 자유롭게 정리하고 추적하는 일정 관리](#ticktick---자유롭게-정리하고-추적하는-일정-관리)\n- [copilot - 내 생각을 나보다 더 잘 알고 일을 마쳐두는 비서](#copilot---내-생각을-나보다-더-잘-알고-일을-마쳐두는-비서)\n- [보성 녹차 - 하루에 물을 1.5L씩 마시는 삶을 살게 되다](#보성-녹차---하루에-물을-15l씩-마시는-삶을-살게-되다)\n- [lenovo y700 2세대 - 카카오톡이 없는 7인치 만능 노트](#lenovo-y700-2세대---카카오톡이-없는-7인치-만능-노트)\n- [마치며](#마치며)\n\n---\n\n## 개요\n\n최근에 구매하거나 무료로 사용하고 있는 제품들에서 삶이 바뀌는 경험들을 한 것들이 있어 이를 공유하고, 가능하면 다른 분들은 어떤 것들을 사용하고 계신지 경험을 나누고 싶어 작성하게 됐습니다. 돈 받고 하는 광고면 좋을텐데 애석하게도 그 어느 물건도 금전을 제공받지 못한 순수한 제 주머니에서 나온 돈으로 구매해서 사용했습니다. 정리 순서는 무료부터 약 40만원대의 제품까지 가격순으로 정리했습니다.\n\n---\n\n## multiscreen block - 도둑맞은 집중력을 찾아서\n\n[공식 홈페이지](https://multiscreenblank.nookkin.com/)\n\n모니터 중 자신이 선택한 것이 검은색으로 바뀌는 프로그램입니다. 최근 집중력이 떨어진 것인지, 데스크톱에서 작업을 할 때 두 대의 모니터가 동시에 떠 있는 것이 방해가 될 때가 많아서 찾아 사용중인 어플리케이션입니다. 원래는 물리적인 방식으로 껐다 키면 이것 때문에 그래픽 카드에서 설정이 오고가고하는 딜레이도 있어 불편한 점이 꽤 많았어서 귀찮아 끄지 않을 때도 많았습니다. 사용한 이후로는 대부분의 경우에는 한 대의 모니터만을 사용하고 특별히 필요하다 싶을 때에만 두 대의 모니터를 사용하게 되어 집중력이 떨어지는 경우가 줄어들었습니다. 무료로 사용할 수 있으며, 사용법도 굉장히 간단합니다.\n\n---\n\n## 샤오미 홈 다기능 충전식 데스크 램프 MJTD05YL - 형광등이 없는 밤을 팔다\n\n![램프](https://image6.coupangcdn.com/image/vendor_inventory/1b74/7b08a9f5ad9c3d1ef0a668fecf6853e8a0e0ea421c86eebff02baf8b9064.jpg)\n\n형광등부터 시작해 수면등까지 총 4종류의 빛을 제공하는 이 램프의 특징은, 구 형태의 강력한 자석과 함께 사용 가능하단 점입니다. 이 때문에 사진에 보이는 것과 같이 스탠드에 꽂아서도 사실상 전방위로 회전 가틍하고, 침대와 같은 곳에 꽂아서 사용 가능한 클립도 있으며, 아예 거치하지 않고 손전등처럼 사용할 수 있습니다.\n\n이게 뭐가 그렇게 대단한 기능일까 싶었는데 실제로 사용해보니 이게 생긴 이후로 해가 떨어진 이후에 아예 형광등을 사용하지 않는 생활을 하는 것이 가능해졌습니다. 잠을 자는 흐름에 있어서 형광등과 같은 백색광에 적게 노출돼야한다는 말이 많은데, 실제로도 이를 이용하면서부터 수면 퀄리티가 꽤나 비약적으로 향상되는 것을 확인할 수 있었습니다.\n\n---\n\n## ticktick - 자유롭게 정리하고 추적하는 일정 관리\n\n[공식 홈페이지](https://ticktick.com/)\n\n어렸을 때 프랭플린 플래너를 쓰던 입장에서 이와 같이 내 일정을 자유롭게 관리할 수 있으면서, 디지털의 장점을 누릴 만한 일정 관리 어플리케이션은 없는가에 대해 많이 고민했었습니다. 그러던 중에 발견한 ticktick은 이 모든 것을 만족시켜주는 어플리케이션입니다. 무료로 사용할 수 있으며, 유료로 사용하면 더 많은 기능을 사용할 수 있습니다.\n\n이 어플리케이션의 장점은 다음 정도가 있습니다.\n\n1. 내가 생각한 것은 거의 다 되는 ux\n2. 다양한 플랫폼의 싱크 지원\n3. pomodoro, eisenhower matrix 등의 기능 지원\n4. 습관을 통한 자동 일정 추가\n5. 구글 캘린더와의 연동\n\n최근에 사용해 본 일정 관리 어플리케이션들 중에서 가장 만족스러운 어플리케이션이고, 이를 통해 생산성을 많이 향상시킬 수 있었습니다.\n\n---\n\n## copilot - 내 생각을 나보다 더 잘 알고 일을 마쳐두는 비서\n\n[공식 홈페이지](https://copilot.github.com/)\n\n사실 코파일럿을 사용하는 것의 장점은 다음 스크린 샷 하나면 다 설명이 되지 않나 싶습니다.\n\n![코파일럿 사용 예시](https://travis.media/images/2021/11/github-copilot-suggesting-array-function@2x.jpeg)\n\n내가 생각한 것들을 코드로 만들어내는 데 있어서 작성하려는 것을 나보다 한 발 앞서 미리 완성해놓고 대기하는 코파일럿은 가히 혁명적이고, vscode와 연동해서 사용하면 가져다주는 편의성은 다른 llm과 비교해 압도적입니다. 특히 copilot을 제대로 활용하기 위해서는 예시에서와 같이 컴퓨터가 아니라 '사람이 이해할 수 있을 법한' 네이밍을 사용해야 하기 때문에 단순히 코드 작성 시간이 줄어드는 것을 넘어서 코드의 가독성이 높아지는 것도 장점입니다.\n\n---\n\n## 보성 녹차 - 하루에 물을 1.5L씩 마시는 삶을 살게 되다\n\n요 근래 다이어트를 하면서 몸에 좋다는 물건들을 좀 찾다가 녹차가 효능이 있다는 이야기를 듣고 이참에 탄산 음료를 줄이고자 마시게 된 제품입니다. 이건 종류가 워낙 다양하고 섭취할 방법도 많으니 이미지는 첨부하지 않도록 하겠습니다.\n\n제가 음용중인 제품은 1.5L 페트병으로 녹차를 아예 우려서 주는 것인데, 이를 구매하기 시작한 이후로 1주일에 거의 꼬박꼬박 10 페트병을 마시고 있네요. 사실 어찌보면 장기적으로 봤을때 가장 비싼 물건입니다... 그래도 이 때문에 살이 빠지고 있는지는 모르겠지만 마시기 시작한 이후로 탄산 음료 섭취량이 줄어들었기 때문에 이것만으로도 만족스러운 효과를 느끼고 있습니다.\n\n---\n\n## lenovo y700 2세대 - 카카오톡이 없는 7인치 만능 노트\n\n![y700 2세대](https://encrypted-tbn0.gstatic.com/shopping?q=tbn:ANd9GcRrU5ofqgLSycb_EEDsEu361IqlTGj4jG1Ys4A9TyaMjxBpC9TexBfbpSkdqvEZ-7UnjaqA2SMonqGcSQMhmD1kYnOOFlLTjA32V_OYjCtE6HjSjOlui6gCUFZ-_mW0z4VUs7YPuuA\u0026usqp=CAc)\n\ne북리더를 e잉크 제품으로 읽는 것도 좋지만, 저는 웹싸이트에 작성된 글을 읽거나 태블릿으로 일기 작성 및 필기를 하는 등의 만능 노트로 사용할 가성비 좋은 물건이 필요했습니다. 그런 의미에서 본래는 게이밍을 목적으로 만들어진 기기이지만, 7인치라는 사이즈는 이동중에 사용하기에도 적당할 정도이기 때문에 제가 기존에 사용하던 10인치 이상의 태블릿을 사용할 때와 다른 만족감을 느낄 수 있었습니다.\n\n특히나 안드로이드 제품이기 때문에 카카오톡을 사용하지 못한다는 시점에서 책을 읽거나 할 때 집중력을 산만하게 만드는 요소가 줄어들어 더욱 만족스러운 사용 경험을 할 수 있었습니다. 게다가 전용 펜도 꽤나 유용하고 e 잉크 제품과는 달리 인터넷 서핑을 통해 정보를 찾을 때에도 사용이 용이하단 점이 굉장한 장점입니다.\n\n---\n\n## 마치며\n\n이상이 제 최근 삶을 가장 크게 바꿨다고 생각되는 구매/사용 목록 총 6가지였습니다. 혹시 읽으신 분들께서도 최근 구매한 물건이 일상을 크게 변화시킨 경험이 있으시면 댓글로 공유해주시면 꼭 한번 사용해보고 싶네요. 읽어주셔서 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"최근 내 삶을 바꾼 제품들 총 6선","subtitle":"전구, AI에서 태블릿 pc까지","date":"2024-05-04T00:00:00.000Z","categories":"ETC"}},{"postName":"2024-04-20-걸즈 밴드 크라이","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/애니 이야기/2024-04-20-걸즈 밴드 크라이.md","category":"ETC","title":"반항이 소멸하는 세상에서 가운데 손가락을 치켜세우는 소녀들","subtitle":"걸즈 밴드 크라이","content":"\n저는 나잇값을 못하는 사람입니다. 아직도 이런 가사의 노래를 들으면 가슴이 두근거리고 발을 쿵쿵 구르며 뛰쳐나가고 싶은 생각에 설레기 때문입니다.\n\n```plaintext\n아무리 기다린들 변하는 게 없다면 이놈이고 저놈이고 손에 닿지 않아\n애초에 누군가의 탓이라고 말한들 이 고통은 사라지지 않아\n\n가만히 무릎을 끌어안고 앉아 있을 뿐인\n그런 매일에 안녕을 고하고 싶다고 염원해\n\n신 따위는 조금도 믿지 않는 주제에\n\n시끄러워\n\n날 내버려 둬\n\n혼자가 아니라며 누군지도 모르는 이가\n목이 쉬도록 노래하고 있어\n\n그런 말에 구원받는 생명도 있겠지\n\n모르겠어\n\n그렇구나\n\n그랬나?\n\n잊어버렸어\n\n귀찮아\n\n부수고 싶어\n\n용기도 없이\n\n살아가는 이유란 녀석을 누군가 내게 알려줘\n대체품 따위는 얼마든지 굴러다니니까\n\n자신답게 굴란 말은 그리 쉽게 할 수 없잖아\n할 수만 있다면 되찾아\n\n꿈으로 넘쳐 흐르고 있다 해도 진실이니까\n\n거기 누구없나요?\n```\n\n록은 반항의 음악이고 애니메이션 '걸즈 밴드 크라이'는 오랜 기간 억압받아온 소녀들이 모여 스스로에게 하던 거짓말을 그만두고, 거대한 세상 앞에 자신들의 조그맣고 너덜너덜해진 반항의 기치를 들어올리는 밴드의 이야기를 하고 있습니다.\n\n학교에서 이지매당한 사실을 덮어두고 학교를 다니기를 종용하는 가정에서 도망쳐나와 스스로를 증명하기 위해 아르바이트와 입시학원을 병행하는 소녀. 위대한 가업을 이어받을 인재라며 자신이 하고 싶은 게 뭔지도 모르는 순간부터 할 일을 강요받고 이를 순순히 따르는 자신을 평생 연기 해온 소녀. 자신은 틀리지 않았는데 마치 자신이 잘못했던 것처럼 몰아가는 세상에 지고 싶지 않은 소녀.\n\n이렇게 많은 방식으로 억압받아온 소녀들이 모여서 서로의 상처를 보듬어주는 안식처로 만들어낸 밴드의 세상을 향해 외치는 쌓여있는 이야기, 그것이 애니메이션 걸즈 밴드 크라이의 밴드 토게나시 토게아리의 음악입니다. 그리고 그것은 동시에 자신들처럼 고통받는 세상 사람들에 대한 응원입니다. '지지 마. 가운데 손가락을 치켜세우고 살아.'\n\n하지만 현실은 너무 무자비하고 무신경하게 그녀들을 보이지 않게 때로는 들리지 않게 짓눌러옵니다. 나도 모르게 음악에 빠져서 수십시간을 열정적으로 보냈지만 그것에 즐거워하기보다 교과서 한쪽을 더 읽을 시간을 낭비했다며 자책하거나, 어둠 속에서 혼자서는 전등도 달지 못하는 무력함에 평생 어둠 속에서 벗어나지 못할 것이라 괴로워합니다. 세상은 그들에게 조용히, 들리지 않는 목소리로 속삭입니다. '나잇값 못하게 왜 그래?'\n\n손가락 하나를 가볍게 찍어내리는 것만으로도 그들을 짓뭉게버릴 수 있을 정도로 강자인 세상과 그걸 등에 업고 있는 사람들 앞에서 약자인 그녀들이 할 수 있는 것은 다만 가운데 손가락을 치켜세우는 것 뿐입니다. 아니, 양손을 번쩍 들어올려 두 새끼 손가락을 들어올리는 것뿐입니다. 그리고 힘껏 연주해서 그 시끄러운 속삭임을 꿰뚫고 그들과 비슷한 처지의 억압받는 사람들에게 도달하기를 간절하게 소망하는 것 뿐입니다. 나약한 주제에 거짓말을 하지 못해 삐딱해지고 배배꼬여가면서도 자신을 굽히는 것은 절대 싫기 때문에 노래하는 것 뿐입니다.\n\n우리는 지금 반항의 정신이, 록 스피릿이 붕괴해가는 세상에서 살아가고 있습니다. 세상에 이런 성가신 음악은 사실 더이상 필요하지 않고 록은 이제 끝났다고들 말합니다. 하지만 스스로 끝이라 말하기 전에는 정말로 끝나는 것이 아니니까요. 완전 제멋대로에 엄청 이기적인 사람이 되어, 세상에 지지 않기 위해 함께 가운데 손가락을 치켜세우는 것은 어떨까요?\n\n[![void](https://img.youtube.com/vi/pA-pzhQQFBA/hqdefault.jpg)](https://youtu.be/pA-pzhQQFBA?si=J04-E50tMQyIDffd)\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반항이 소멸하는 세상에서 가운데 손가락을 치켜세우는 소녀들","subtitle":"걸즈 밴드 크라이","date":"2024-04-20T00:00:00.000Z","categories":"ETC"}},{"postName":"2024-03-17-용어 정리","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/kubernetes/2024-03-17-용어 정리.md","category":"ETC","title":"kubernetes 용어 정리","subtitle":"pod, deploy, service, configmap","content":"\n## Pod\n\n* 쿠버네티스에서 가장 작은 배포 단위.\n* 하나 이상의 컨테이너로 구성될 수 있으며, 컨테이너는 동일한 호스트에서 실행된다.\n* 컨테이너는 동일한 네트워크 네임스페이스를 공유하며, 동일한 IP 주소와 포트 범위를 사용한다.\n\n## Deployment\n\n* 파드를 관리하는 리소스.\n* 파드를 생성하고 업데이트하며, 파드의 상태를 모니터링한다.\n* 파드의 수평적인 스케일링을 지원한다.\n* 파드에 문제가 발생하면 자동으로 복구한다.\n\n## Service\n\n* 파드의 네트워크 엔드포인트를 노출하는 리소스.\n* 클러스터 내부 또는 외부에서 파드에 접근할 수 있도록 IP 주소와 포트를 제공한다.\n* 클러스터 내부에서 사용 가능한 고유 도메인 이름을 제공한다.(DNS)\n\n* Service 타입\n  * ClusterIP: 클러스터 내부에서만 접근 가능한 서비스\n  * NodePort: 클러스터 외부에서 접근 가능한 서비스\n  * LoadBalancer: 클러스터 외부에서 접근 가능한 로드 밸런서 서비스\n  * ExternalName: 클러스터 내부에서 외부 서비스에 접근 가능한 서비스\n  * Headless: 클러스터 내부에서 파드의 IP 주소를 직접 사용할 수 있는 서비스\n  * Service Mesh: 서비스 메시를 사용하는 서비스\n  * ...\n\n## ConfigMap\n\n* kubectl create configmap\n* 파드에서 사용하는 환경 변수, 설정 파일 등을 저장하는 리소스.\n* 파드가 실행될 때 ConfigMap을 참조하여 환경 변수나 설정 파일을 사용할 수 있다.\n* 파드가 실행 중일 때 ConfigMap을 수정하면 파드가 자동으로 변경된 값을 사용할 수 있다.\n* ConfigMap을 사용하면 파드의 설정을 중앙에서 관리할 수 있다.\n","layout":"default","recommended":false,"data":{"title":"kubernetes 용어 정리","subtitle":"pod, deploy, service, configmap","date":"2024-03-17T00:00:00.000Z","layout":"default","categories":"ETC"}},{"postName":"2024-03-12-chatper2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/kubernetes/2024-03-12-chatper2.md","category":"ETC","title":"쿠버네티스 교과서","subtitle":"Chapter 2","content":"\n명령어 모음\n\n* kubectl exec: 파드 내부에서 명령어 실행\n* kubectl get pods: 파드 목록 조회\n* kubectl apply -f: YAML 파일로 리소스 생성\n* kubectl delete -f: YAML 파일로 리소스 삭제\n* kubectl port-forward: 로컬 포트로 포트 포워딩\n* kubectl run: 새로운 파드 생성\n* kubectl create deployment: 새로운 디플로이먼트 생성\n* kubectl logs: 파드 로그 조회\n\n=\u003e 플래시 카드 작성하는 것 생각해볼것\n","layout":"default","recommended":false,"data":{"title":"쿠버네티스 교과서","subtitle":"Chapter 2","date":"2024-03-14T00:00:00.000Z","layout":"default","categories":"ETC"}}]},{"category":"개발이야기","posts":[{"postName":"2024-05-17-socket hijack","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-17-socket hijack.md","category":"개발이야기","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","content":"\n## 개요 - hijack을 맞이하다\n\n나름대로 테스트코드도 다 돌려 본 채팅이 동작하는 것을 확인한 서버 프로그램을 가지고 있으니 클라이언트에서 부하\n테스트를 작성하는 것은 그렇게 어렵지 않을 것이라 생각했었습니다. 그리고 착각은 무엇인가 할 때마다 산산히 부서져\n나가고 있는 것을 체감하는 요즘입니다. 이번에 맞이한 녀석은 바로 `hijack`입니다.\n\nk6를 잘 모르는 상태에서 소켓 연결을 위해 메시지를 보내고, get request도 보내고 하다가 마침내는 ws의 connect를\n이용해서 요청을 보내는 데 성공했는데 이게 웬걸, 서버사이드에서 황당한 에러 메시지가 나왔습니다.\n\n![hijack log](/images/hijack/error%20-%20hijack.png)\n\n?? http response code는 200인데 error는 발생했고, 내 연결은 hijack(탈취)되었다고? 보자마자 제 머리 속에서\n떠오른 이미지는 이것이었습니다.\n\n![이게 무슨 소리요 의사양반](https://i.namu.wiki/i/uf88vRFdi3xVPlSMkSblePa7NN6QL1pmvUzCWe5rqlxLXvMtjHxqXTTapVkKUh4gSAvYdrI2DkfpWkFo8vpX_A.mp4)\n\n이게 대체 무슨 소리요 의사양반, 제가 여태까지 짜 둔 로직은 탈 생각은 하지도 않고 왜 클라이언트가 내 소켓을\n훔쳐가는 것이오. 이 도동놈을 내 대체 어찌해야 한다는 말이오. 우리 솔로몬급 판결사 copilot님께서는 이 도둑은\n의적으로 필수불가결하니 보내줘야하고, 오히려 제 서버가 이에 맞춰줘야 한다는 의견을 제시하였고 저는 이에 저항할\n도리 없이 일단 이 도둑에 맞춰 서버를 수정해야 하는 상황에 놓였습니다.\n\n그런데 누군지도 모르는 녀석에게 내 소켓을 탈취당한 것도 모자라 훔쳐가기 편하라고 집을 뜯어고치는 것은 너무\n억울해 이번에 한번 조사를 해보기로 했습니다.\n\n---\n\n## 웹소켓이 연결되는 과정\n\n하이잭에 대해 알기 위해서는 제가 대충 알고 있었던 웹소켓의 연결 과정부터 다시 짚어볼 필요가 있다 생각했습니다.\n웹소켓의 연결 과정은 소위 말하는 handshake를 통해 이루어집니다. 이 과정은 다음과 같습니다.\n\n1. 클라이언트가 서버에게 웹소켓 연결을 요청합니다.\n2. 서버는 클라이언트에게 응답을 보냅니다.\n3. 클라이언트는 서버에게 응답을 보냅니다.\n4. 연결이 성공하면 서버와 클라이언트는 데이터를 주고받을 수 있습니다.\n\n이런 교양 넘치는 사람들 간의 합의를 통해 연결이 이루어지는 것이 일반적인 연결 과정입니다. 여기까지가 제가 알고\n있는 내용이고, 서버사이드에서 유닛테스트 및 통합테스트를 통해 이 과정을 정상적으로 마칠 경우에 메시지 역시\n정상적으로 주고받을 수 있었습니다.\n\n---\n\n## 도동놈, 아니 도둑님 잡아라\n\n그런데 이번에는 클라이언트가 서버에게 연결을 요청하고, 서버가 응답을 보내고, 클라이언트가 응답을 보내는\n과정은 제가 서버 내에서 임의의 클라이언트를 상정하던 것과는 달랐습니다. 아무래도 그것은 제가 사용하는 k6의\nws.connect가 연결을 요청하는 과정에서 hijack이라는 go의 websocket 패키지의 메서드와 다른 방식으로 연결을\n하는 것일 가능성이 높아보였습니다.\n\n![나는 능이버섯이다](/images/hijack/능이버섯.png)\n\n뭐 여기까지 왔는데 어쩌겠습니까. 제 반려 프로그램을 포기할 수는 없으니 이 도둑님께 굴복하는 수밖에요. 조금 더\n찾아보니 websocket hijack 관련해서는 보안 관련 이슈들이 주를 이루고 있었으나, 다른 것은 go의 http 패지키의\nhijack interface였습니다. 즉 제가 쓰는 k6도 go를 기반으로 만들어졌고, 제 서버 역시도 go로 만들어졌기 때문에\n단순히 웹소켓 연결을 요청하는 것이 아니라 hijack을 통해 연결을 요청하는 것이었습니다.\n\n---\n\n## 내가 해야하는 조치\n\n현재 제 서버는 연결을 할 때 연결이 hijack에 의해서가 아니라 기존의 gin Context의 connection을 이용한 것입니다.\n이 때문에 hijack을 통해 연결을 요청하는 경우에는 연결이 되지 않는 문제가 발생하게 되었습니다. 이 문제를 해결하기 위해서\n제가 해야할 조치는 기존에 작성한 채팅쪽 서비스 코드와 소켓 연결 모듈을 새로운 인터페이스에 맞게 수정하는 것이네요.\n별 것 아니네요!\n\n는 그럴리가 없으니, 이슈를 새로 따서 현재 작성된 hijack이 이루어지지 않을 때의 연결을 위한 코드에서 최소한의\n수정을 통해 더 높은 단의 추상 interface를 제공하고 이를 통해 양쪽의 연결을 이루어지게끔 수정하는 것이 가능한\n지에 대한 검토 및 재설계의 과정을 거쳐야 할 것 같습니다. 개발은 너무 재밌어요.(농담 아님)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","date":"2024-05-17T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-05-12-Desk setting(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting(2).md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 지난 이야기\n\n\u003chttps://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/05/12/Desk-setting.html\u003e\n에서 보실 수 있습니다. 이미지는 아래와 같고 주로 큼직큼직한 물건들 모니터, 스피커, 스위치, 팔 받침, 모니터 받침에\n대해 설명했습니다.\n\n이번에는 좀 더 작은 주변기기들에 대해 이야기해보려 합니다\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n---\n\n## 인체공학 키보드 microsoft ergonomic\n\n저는 피씨방에서 키보드 소리가 씨끄럽다는 이유로... 항의를 들어본 적이 있을 정도로 굉장히 키보드를 세게 두드리는\n편입니다. 대체 왜 그런지 모르겠습니다만 엔터키를 칠 때는 오른쪽 손을 들었다가 내려찍는 식으로 치는 경우도 굉장히\n잦았죠. 이제는 많이 고쳤고, 소리 자체도 작게 나는 것을 쓰기 위해 멤브레인 키보드를 쓰기는 합니다만 이런 습관\n때문에 키보드를 오래 쓰는 직업이란 것이 겹치면서 손목에 부담이 많이 갔습니다.\n\n이 때문에 사용하기 시작한 것이 인체공학 키보드이고 핵심은 손목은 손가락보다 높은 곳으로, 키보드가 방사형으로\n구성되어 있어 어깨가 자연스럽게 펴지는 키보드가 되는 것입니다. 본 모델은 뭐 워낙에 유명한 하드웨어 명가 마소의\nergonomic 제품으로 텐키리스이면서 텐키리스가 아닙니다. 텐키용 무선 키보드가 따로 있거든요.\n\n저 같은 경우는 n버튼을 오른 손으로 누른다는 점도 겹쳐서 인체공학 키보드를 쓰는 것에 금방 적응할 수 있었고,\n지금은 일반 키보드를 쓰면 자세가 불편해서 도저히 못 쓸 정도입니다. 이것이 아니라도 어깨, 손목 등에 부담이 많이\n가는 사무직이라면 인체공학 키보드를 사용해보는 것은 강추합니다.\n\n---\n\n## 트랙볼\n\n구매한 지 이제 이틀 된 트랙볼입니다. 원래는 인체공학 버티컬 마우스를 사용했구요. 그것도 굉장히 편해서 제가\n롤을 접게 만든 원흉 중 하나였습니다만(일반 마우스를 쓸 수 없는 몸이 돼버림) 이 역시도 손목이나 어깨에 부담이\n가는 것 같아서 이번에 아예 트랙볼로 바꿨습니다.\n\n제가 선택한 기준은 엄지로 좌클릭을 하고 검~약지로 스크롤을 할 수 있으면서 환불이 가능한 국내 제품이었습니다.\n일단은 만족하고 사용중인데 아직 게임과 같은 작업을 할 때는 조금 어색하긴 하네요. 일단 어깨를 전혀 쓰지 않는\n것과 손목도 거의 쓰지 않아 몸에 부담이 덜 간다는 느낌은 들고 있습니다.\n\n---\n\n## 모니터 암 - 이라 쓰고 태블릿 거치대라 부른다\n\n분명 구매할 때는 모니터 암으로 샀습니다만 모니터랑 호환이 안 돼서 한동안 노트북 거치대로 쓰다가 이제는 태블릿\n및 휴대폰, 펜슬 등 자석이 달린 물건을 고정하는 물건으로 주로 사용중입니다. 그리고 의외로 태블릿을 거치해두면\n책 읽을 때 굉장히 편리하단 장점이 있습니다.\n\n나중에 호환이 되는 모니터를 구하거나 하게 되면 모니터 암으로 사용할 생각입니다만 지금은 꽤 만족 중이네요.\n\n---\n\n## 샤오미 무선 램프\n\n전에 요즘 [바꾼 물건 6선](https://kaestro.github.io/etc/2024/05/04/%EC%B5%9C%EA%B7%BC-%EB%82%B4-%EC%82%B6%EC%9D%84-%EB%B0%94%EA%BE%BC-%EC%A0%9C%ED%92%88%EB%93%A4.html)\n에서 언급한 적이 있는 물건인데, 최종적인 위치를 여기로 확정했습니다. pc 앞에 두고 모니터암과 함께 각도를 자유롭게\n돌리면서 직/간접적으로 백색광부터 따뜻한 빛까지 다양한 색상을 이용할 수 있습니다. 해당 위치가 태블릿 등을 거치하는\n곳이다보니 충전하기에도 용이하고 밤에 필요하면 뽑아서 밖으로 이동하기에도 편리합니다.\n\n---\n\n## 웹캠\n\n면접 등을 보는 용도로 구매한 웹캠입니다.\n\n---\n\n## 기타 무선 제품\n\n책상 좌측 하단에 있는 박스들에 주로 있는데, 게이밍 마우스(요즘엔 거의 사용하지 않는), 게이밍 무선 헤드셋,\n음감용 무선 헤드셋, 배터리 충전기, 링피트 컨트롤러(솔직히 다들 있으시죠?), 무선 엑스박스 컨트롤러, 스위치 팩,\n에어건 등이 있습니다.\n\n---\n\n## 의자\n\n얼마 전에 사망하셔서 집에 있던 식탁 의자 사용중입니다. 근데 원래 의자보다 더 편한 거 같네요?\n\n---\n\n## 마치며\n\n아무래도 불편한게 있으면 참지않고 바로바로 고치는 성격이다보니 무선과 인체공학 제품들로 둘러싸인 책상이\n완성됐네요. 다른 분들은 내 데스크는 이런 부분이 불편해서 사용중인 솔루션에 뭐가 있으신가요? 제 데스크에서\n개선할 만한 부분이 있다 싶으신 부분이 있으면 제 금전이 허락하는 한 참고해보도록 하겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":2}},{"postName":"2024-05-12-Desk setting","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting.md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 서론\n\n아무래도 저는 직업적으로나 취미 적인 측면에서 하루에 컴퓨터를 8시간 이상 사용하는 것은 부지기수이기 때문에,\n가능하면 아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅은 굉장히 공을 들여 만든 부분입니다. 문득 이것 역시도\n컴퓨터를 사용하는 게이머이자 개발자로서 공유하고 이야기를 나누면 재미있을 것 같다는 생각이 들어 글을 쓰게 됐습니다.\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n---\n\n## 현재 내 책상 세팅\n\n현재 제 책상의 전면 상태는 다음과 같습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n오타쿠스러운 취미가 그대로 반영돼 가장 먼저 눈길을 사로잡는 것은 장패드와 각종 실리콘 스탠드 등이겠지만, 그 뒤에\n감춰둔(?) 제 나름의 가능한 아프지 않게 컴퓨터를 사용하기 위한 노력이 있습니다. 이에 대해 한번 천천히 좌측에서\n우측으로 설명해보겠습니다.\n\n---\n\n## 듀얼 모니터\n\n집중력이 떨어지게 하는 역할을 하기도 합니다만, 개발 결과물을 확인하면서 진행하는 용도로 사용한다든가, 구글링\n레퍼런스를 찾아보는 용도로 사용한다는 것이 가장 큰 핑계인 듀얼 모니터입니다. 가장 유용할 때는 롤 경기를 보면서\n카카오톡을 확인하거나, 게임을 플레이하면서 디스코드를 띄워두는 등의 용도입니다.\n\n평소에 높은 집중력을 필요로 할 때는 화면을 하나 꺼두는 어플리케이션을 적극적으로 사용합니다만, 어쩔 수 없이\n두 화면의 활용도가 필요할 때는 듀얼 모니터가 굉장히 유용하게 사용됩니다. 다만 가끔 좌측 화면만 쳐다보고 우측\n화면은 카톡으로만 쓰는 경우를 보면 이럴거면 왜 듀얼 모니터를 쓰는지 의문이 들기도 합니다.\n\n---\n\n## 닌텐도 스위치\n\n작업을 하다가 모든 걸 때려치고 싶은 충동이 들 때 제 안의 흑염룡을 잠재워주는 닌텐도 스위치입니다. 정작 오디오\n인터페이스가 되어 있지 않아 게임을 할 때는 싸구려 모니터 스피커로만 게임을 한다는 것은 안 비밀입니다. 그래도\n젤다 시리즈, 파이어 엠블렘 시리즈, 마리오 시리즈, 컵헤드, 오버쿡드, 하데스, 유니콘 오버로드, 야추 등의 게임을\n플레이한 나름 효자 게임기입니다.\n\n최근에는 스트레스 풀고 싶을 때 태고의 달인을 켜고 신나게 팔을 흔들어서 제 진을 빼놓는 용도로 사용하고 있습니다.\n\n---\n\n## creative pebble v2\n\n가성비로 유명한 스피커입니다. 사실 책상에 놓을만한 사이즈의 물건이 이것 밖에 없었고, 생각보다 음향이 다른 저가형\n스피커와 다른 것을 못 느껴서 사기 당한건가 하는 생각도 처음엔 들었지만 그냥 썼었는데 마지막에 레퍼런스로 달아둔\n링크들을 통해 음향 설정을 하고 나니 많이 달라진 것을 확인할 수 있었습니다.\n\n가격, 크기, 음향과 같은 부분을 고려했을 때 굉장히 훌륭한 제품이라고 생각합니다.\n\n---\n\n## 데스크 팔 받침\n\n책상을 놓을 공간이 협소하다보니 작은 책상을 샀는데, 문제는 팔을 거치할 공간이 없어 팔꿈치가 공중에 떠 있고\n몸이 지나치게 모니터에 붙어있는 자세가 된다는 것이었습니다. 이 때문에 겨드랑이, 어깨 등의 통증이 심해서\n해결하기 위해 구매한 데스크 팔 받침이고 굉장히 많은 도움을 받고 있습니다. 책상이 작아서 조금만 더 늘렸으면\n좋겠다는 생각이 드시면 추천드립니다.\n\n---\n\n## 모니터 받침\n\n모니터 높이를 높게 쓰는 것이 경추 및 척추 위생에 도움이 된다해서 구매한 모니터 받침입니다. 높이 조절은 되지\n않아 아쉽지만 클래식한 목재 디자인에 이것저것 수납할 공간이 있는 것이 마음에 듭니다. 높이가 조금 모자란 것은\n제가 구매한 태블릿 pc의 박스로 조절해서 추가로 높여서 맞췄습니다.\n\n---\n\n## 추가자료\n\n1. \u003chttps://gall.dcinside.com/mgallery/board/view/?id=speakers\u0026no=181872\u003e\n2. \u003chttps://gall.dcinside.com/mgallery/board/view/?id=speakers\u0026no=189902\u003e\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":1}},{"postName":"2024-05-07-Docker mount","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-07-Docker mount.md","category":"개발이야기","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","content":"\n## 개요 - Docker mount란\n\n도커 컨테이너는 호스트와 별도로 파일 시스템을 가지고 있습니다. 이 파일 시스템은 컨테이너가 생성될 때 생성되며, 컨테이너가 종료되면 함께 삭제됩니다. 이 때문에 컨테이너가 종료되면 컨테이너 내부에 저장된 데이터는 모두 사라지게 됩니다. 이러한 문제를 해결하기 위해 도커는 컨테이너 내부의 파일 시스템을 호스트의 파일 시스템과 연결하는 방법을 제공합니다. 이를 도커 mount라고 합니다.\n\n도커 mount는 크게 두 가지 방법으로 구분됩니다. 하나는 볼륨(volume)을 사용하는 방법이고, 다른 하나는 바인드 마운트(bind mount)를 사용하는 방법입니다. 볼륨과 바인드 마운트는 각각 장단점이 있으며, 상황에 따라 적절한 방법을 선택해야 합니다.\n\n![docker mount](https://docs.docker.com/storage/images/types-of-mounts.webp?w=450\u0026h=300)\n\n---\n\n## 볼륨(volume)\n\n볼륨은 Docker가 관리하는 호스트 파일 시스템의 일부에 저장됩니다. Docker가 아닌 프로세스는 파일 시스템의 이 부분을 수정해서는 안되며,\n Docker에서 데이터를 유지하는 가장 좋은 방법이다.\n\n볼륨은 Docker에 의해 생성되고 관리됩니다. 명령을 사용하여 명시적으로 볼륨을 생성할 수 있습니다. 또는 Docker는 컨테이너나 서비스 생성\n 중에 볼륨을 생성할 수 있습니다.\n\n`docker volume create my-vol`\n\n특정 볼륨을 여러 컨테이너에 동시에 마운트하는 것도 가능합니다. 실행 중인 컨테이너가 볼륨을 사용하지 않더라도 Docker에서 계속 사용할 수\n 있으며, 자동으로 제거되지 않고 다음 명령을 사용하여 수동으로 제거해야 합니다.\n\n`docker volume prune my-vol`\n\n---\n\n## 바인드 마운트(bind mount)\n\n바인드 마운트는 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트하는 방식입니다. 바인드 마운트는 볼륨에 비해 기능이 제한되어 있지만 파일 또는 디렉터리는 호스트 시스템의 전체 경로로 참조되며 파일이나 디렉터리가 Docker 호스트에 이미 존재할 필요는 없습니다. 바인드 마운트는 빠르지만 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존하며 공식 문서에서는 볼륨을 사용하는 것을 권장합니다.\n\n---\n\n## 볼륨(volume) vs 바인드 마운트(bind mount)\n\n| 볼륨(volume) | 바인드 마운트(bind mount) |\n|---|---|\n| 호스트의 파일 시스템의 일부를 사용 | 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트 |\n| Docker가 관리 | Docker가 관리하지 않음 |\n| 볼륨을 여러 컨테이너에 동시에 마운트 가능 | 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존 |\n\n---\n\n## tmpfs 마운트\n\ntmpfs는 호스트의 메모리에 저장되는 가상 파일 시스템입니다. 컨테이너 수명 동안 컨테이너에서 비지속적 상태 또는 중요한 정보, 예를 들면 secrets, keys, tokens 등을 저장하는 데 사용됩니다. tmpfs는 컨테이너가 종료되면 삭제되므로 컨테이너가 종료되면 데이터가 사라지게 됩니다.\n\n---\n\n## 출처\n\n- [Docker Documentation](https://docs.docker.com/storage/)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","date":"2024-05-07T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-04-21-k6 vs Locust","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-04-21-k6 vs Locust.md","category":"개발이야기","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","content":"\n## 개요\n\nChatApplication의 RestAPI 서버에 대한 MVP 개발 완료 및 예정해뒀던 정비가 어느 정도 끝나가고 있어, 이제는 부하 테스트를 작성해야 할 때가 왔다는 생각에 어떻게 하면 좋을지에 대해 고민을 하게 됐습니다.\n\n크게는 두 가지 방법을 생각했습니다. 시작부터 직접 부하 테스트를 작성하는 방법과 부하 테스트 도구를 사용하는 방법이 그것입니다. 그리고 부하 테스트 도구를 사용하는 것이 시간이 지나치게 오래 걸리고 메리트가 없다 싶으면 직접 부하 테스트를 작성하고, 그렇지 않다면 부하 테스트 도구를 사용하는 것이 좋겠다는 생각에 도달했습니다.\n\n이를 검토하기 위해 부하 테스트 도구로 주로 사용되는 오픈 소스 솔루션에 무엇이 있는지 찾아보고 그 중에 후보로 `Locust`, `k6`, `JMeter`를 고민하게 됐습니다.\n\n---\n\n## 기준 세우기\n\n비교하기에 앞서 어떤 도구를 내가 원하는 지에 대한 기준을 세워야 했고, 그 기준은 다음과 같았습니다.\n\n```plaintext\n1. 자유도가 높으며, 다양한 테스트 케이스를 작성할 수 있는가?\n2. websocket을 지원하는가?\n3. 부하 테스트 결과를 쉽게 분석할 수 있는가?\n4. 활발한 커뮤니티를 기반으로 유지보수가 잘 되고 있는가?\n5. 적당한 학습 부하를 통한 자극이 되는가?\n```\n\n각각의 기준을 선정한 이유는 다음과 같습니다.\n\n1. ChatApplication의 RestAPI 서버는 현재 작은 규모의 트래픽만을 다루지만, 여기에 더해 다양한 기술들을 장기간에 걸쳐 새로 도입하는 것을 목표로 하기 때문입니다.\n2. 채팅을 주 기능으로 설정했기 때문에 이에 대해서는 확실한 부하 테스트를 해야 하기 때문입니다.\n3. 어떤 부분이 병목이 되는지, 어떤 부분이 더 개선이 필요한지를 빠르게 파악할 수 있기 때문입니다.\n4. 활발한 커뮤니티가 있을 경우 제가 부딪히게 될 문제들을 빠르게 해결할 수 있으며 동시에 오픈 소스에 참여할 수 있는 기회도 늘어나기 때문입니다.\n5. 마지막으로 이 프로젝트는 장기간 동안 새로운 것을 배우면서 적용해나가는 것을 목표로 하고 있기 때문에 적당한 학습 부하를 통한 자극이 되어야 합니다.\n\n---\n\n## 후보군 선정\n\n`Locust`, `k6`, `JMeter`는 현재 가장 널리 쓰이는 부하 테스트 도구들 중 하나였기 때문에 우선적으로 후보군으로 선정했지만, JMeter의 경우에는 위의 기준에 부합하지 못하는 부분이 많다고 판단했습니다. 이는 JMeter는 GUI 기반의 도구이기 때문에 테스트 케이스를 작성하고 실행하는 데에 시간이 많이 소요되며, 제가 원하는 수준의 자유도를 제공하거나 학습 부하를 제공하지 못한다고 생각했기 때문입니다.\n\n따라서 `Locust`와 `k6`를 후보군으로 선정하게 됐습니다.\n\n---\n\n## Locust vs k6\n\n`Locust`는 파이썬으로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. 파이썬을 사용하기 때문에 파이썬에 익숙한 제가 자유도 높게 테스트 코드를 작성하기에 적합하고, github repository가 23.6k의 star를 받고 contributor가 274명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. websocket을 자체적으로 지원하지 않는 것은 python의 websocket 패키지를 사용하면 되기 때문에 큰 문제가 되지 않았습니다.\n\n`k6`는 Go로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. Go로 작성돼있기 때문에 Locust와 비교해 더 대규모의 부하 테스트를 수행할 수 있으며, websocket을 내부 로직으로 지원하기 때문에 채팅 서버에 대한 부하 테스트를 진행하기에 적합합니다. github repository가 23.3k의 star를 받고 contributor가 1400여명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. javascript를 사용하기 때문에 마침 javascript를 공부할 계기가 필요했던 저에게 충분한 학습 부하를 제공할 것이라는 생각이 들었습니다.\n\n---\n\n## k6를 선택하다\n\nlocust 역시 굉장히 잘 운영되고 있는 매력적인 도구였지만, 제가 정해 둔 기준들에서 대부분 k6가 우세했고 무엇보다 이를 계기로 javascript를 공부할 수 있는 기회가 될 것이라는 생각에 k6를 사용해서 부하 테스트를 진행하기로 결정했습니다. 이를 통해 ChatApplication의 RestAPI 서버에 대한 부하 테스트를 진행하고, 이를 통해 어떤 부분이 개선이 필요한지 파악하고 개선해나가는 것이 목표입니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","date":"2024-04-21T00:00:00.000Z","categories":"개발이야기"}}]},{"category":"개발일지","posts":[{"postName":"2024-05-16-Chat Application review(11)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-16-Chat Application review(11).md","category":"개발일지","title":"ChatApplication Review(11)","subtitle":"작성중","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [client의 load test debugging](#client의-load-test-debugging)\n    - [signout이 진행이 안되고 있었음](#signout이-진행이-안되고-있었음)\n    - [enterchat 요청이 받아들여지지 않고 있었음](#enterchat-요청이-받아들여지지-않고-있었음)\n\n---\n\n## 배운 점\n\n- 주고받는 데이터 프로토콜 정확성의 중요성\n- 로그를 어느 정도까지 디테일하게 찍어주느냐의 중요성\n\n---\n\n## 진행 내용\n\n- client의 load test debugging\n\n---\n\n## 진행 과정\n\n### client의 load test debugging\n\n1. signout이 진행이 안되고 있었음\n2. enterchat 요청이 받아들여지지 않고 있었음\n\n#### signout이 진행이 안되고 있었음\n\nloadtest에서 header에 value의 key를 sessionkey로 보내고 있었는데 Session-Key가 올바른 키의 이름이었음.\n\n#### enterchat 요청이 받아들여지지 않고 있었음\n\n(진행중)\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":11,"classes":"wide","title":"ChatApplication Review(11)","subtitle":"작성중","date":"2024-05-16T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-05-06-Chat Application review(10)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-06-Chat Application review(10).md","category":"개발일지","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [grafana k6를 통한 테스트용 client 작성](#grafana-k6를-통한-테스트용-client-작성)\n  - [pre-commit을 통한 코드 품질 관리 도입](#pre-commit을-통한-코드-품질-관리-도입)\n  - [docker를 통한 시스템 구축 시도 및 실패](#docker를-통한-시스템-구축-시도-및-실패)\n\n---\n\n## 배운 점\n\n1. grafana k6의 사용법\n2. 섣부른 시스템 구축의 위험성\n\n---\n\n## 진행 내용\n\n- grafana k6를 통한 테스트용 client 작성\n- pre-commit을 통한 코드 품질 관리 도입\n- docker를 통한 시스템 구축 시도 및 실패\n\n---\n\n## 진행 과정\n\n### grafana k6를 통한 테스트용 client 작성\n\n![테스트 클라이언트](/images/chatapplication%20review/testclient.png)\n\n- javascript, grafana k6를 통해 테스트용 클라이언트 작성\n- httpRequests, loadTest, utils 패키지로 구성\n- 기본 모듈단 작성 완료했으며, 이후에는 테스트 케이스를 작성할 예정\n\n---\n\n### pre-commit을 통한 코드 품질 관리 도입\n\n- **문제**\n  - 완전히 코드가 저장되지 않은 상태로 커밋을 하거나, 코드의 품질이 낮은 상태로 커밋을 하는 경우가 발생\n- **해결**\n  - pre-commit을 통해 코드 품질을 관리하고, 코드가 저장되지 않은 상태로 커밋하는 것을 방지\n- **결과**\n\n![pre-commit](/images/chatapplication%20review/precommit.png)\n\n---\n\n### docker를 통한 시스템 구축 시도 및 실패\n\n- **문제**\n  - docker를 통해 부하 테스트 시스템을 구축하려 했으나, mounting volume이나 복잡한 명령어 사용 등에 어려움을 겪음\n- **해결**\n  - docker를 통한 부하 테스트 시스템 구축 포기 및 로컬 환경에서 진행하기로 결정\n- **결과**\n  - 부하테스트 작성 시작\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":10,"classes":"wide","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","date":"2024-05-06T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-23-re 제로부터 시작하는 블로그(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-23-re 제로부터 시작하는 블로그(3).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","content":"\n### 목차\n\n- [개발자의 블로그는 살아서 변화한다](#개발자의-블로그는-살아서-변화한다)\n- [사람들의 눈을 끌기 위한 노력](#사람들의-눈을-끌기-위한-노력)\n- [ui이 바뀌면 컨텐츠도 변화한다](#ui이-바뀌면-컨텐츠도-변화한다)\n- [심심할 틈이 없었던 3개월](#심심할-틈이-없었던-3개월)\n\n---\n\n## 개발자의 블로그는 살아서 변화한다\n\n개발자의 블로그란 것은 굳이 말하자면 디자이너와 작가가 개발자에게 직통 연결을 상시 가지고 있는 서비스와도 같다고 말할 수 있습니다. 글을 쓰다가 다음 포스트로 넘어가기 기능이 있으면 좋겠다는 생각이 들면 이를 바로 만들어 주고, 글이 몇 개 없을 때는 일렬로 늘어놓다가 글이 많아지면 카테고리로 분류하고 싶어지는 등의 변화의 요구가 즉각적으로 반영되기 때문입니다.\n\n다음은 제 블로그의 변천사 사진 몇 장입니다.\n\n|![image](/images/re%20제로부터%20시작하는%20블로그/before_grid_colorful.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_before_grid.png)|\n|---|---|\n|![image](/images/re%20제로부터%20시작하는%20블로그/front_without_recommend.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_recent.png)|\n\n처음에는 단순하게 흰 화면에 일렬로 글을 늘어놓았다가, 여백이 신경쓰여 그라데이션을 넣어보고, 숱한 항의(?) 끝에 이를 삭제하고, 가운데를 그림자 처리를 통해 종이가 놓인 것 같은 이미지에 카테고리 버튼을 넣은 뒤에, 끝내는 격자 형태로 글을 나열하고, 추천글 항목을 추가한 뒤에 최근 글을 보여주는 것으로 마무리되었습니다. 이처럼 자신에게 전권이 주어진 개발자의 블로그는 끊임없이 변화하고 발전하는 생명체와 같다고 생각합니다.\n\n---\n\n## 사람들의 눈을 끌기 위한 노력\n\n녹조라떼 급의 안구 테러 수준이었던 제 최초의 블로그 디자인이 제가 장난 친 것으로 보일 수도 있지만, 제 나름대로는 어떻게 하면 들어온 사람이 제가 작성한 컨텐츠에 집중할 수 있을까를 고민해서 나온 결과입니다. 해당 디자인을 한 것은 마케팅 관련한 책 중에서 '좋아 보이는 것들의 비밀'이라는 것을 읽고 나서 하게 된 결정이었습니다. 해당 책에서는 색상과 빛의 밝기, 각도와 같은 것을 활용해서 좋아 '보이는' 것을 통해 사람의 시선을 끌 것을 이야기하고 있었고 그 관점에서 봤을 때 저기에 표현돼있지 않은 제 블로그 더 이전의 형태는 너무 단조로웠기 때문입니다.\n\n'사람의 시선을 가운데로 유도하기 위해서는 어떻게 빛을 배치하면 될까?'라는 고민에서 시작해 제 블로그 전체 테마인 초록색 그라데이션에 억지로 맞추려다보니 나왔던 저 끔찍한 디자인은 주변 분의 꾸짖음과 함께 그림자를 이용해서 종이가 가운데에 올라온 것 같은 심플한 디자인으로 변경됐습니다.\n\n그리고 여기에 더해 글의 카테고리가 4개를 넘어가면서부터 한 줄로는 사람들이 읽고 싶은 글을 찾기 어려워지는 문제가 발생했기 때문에, 이를 해결하기 위해 격자 패턴 배열을 자주 사용하는 커뮤니티(pgr21, 홍차넷 등) 것들을 참조해서 추가하고, 여기에 더해 추천 글 항목과 최신글을 보여주는 기능을 더해서 홈 페이지를 지금의 모습으로 만들었습니다.\n\n---\n\n## ui이 바뀌면 컨텐츠도 변화한다\n\n이렇게 새로운 기능을 추가하면 재밌는 것은, 제가 쓰는 글 역시도 이에 맞춰서 변화한다는 것입니다. 예를 들어 제가 가장 크게 글쓰기에 변화가 생긴 시점은 화면에 맞추어 이동하는 목차 기능을 추가한 이후였습니다.\n\n|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/before_toc.PNG?raw=true)|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/after_toc.PNG?raw=true)|\n\n해당 기능은 장문의 글을 작성한 것을 제가 면접 전에 복기하는 과정에서 원하는 구간으로 넘어다닐 수 있는 기능이 있으면 글을 읽기에 편리할 것 같다는 생각에서 추가한 것이었습니다. 헤더로 소제목들을 작성해두면 이를 목차로 자동 생성해주는 해당 기능을 만든 이후와 이전에 쓴 글을 비교하면 이후의 글들은 훨씬 더 명확하게 구조화 되어 되는 것을 확인할 수 있었습니다. 이는 그런 기능에 적합한 글이 되게끔 제가 글을 쓸 때 의식하게 되기 때문이라고 생각하고 덕분에 블로그를 막 시작했을 때보다는 조금은 덜 부끄러운 글들을 쓸 수 있게 되지 않았나 생각합니다.\n\n---\n\n## 심심할 틈이 없었던 3개월\n\n절대 쉬운 일이었다고 말하기는 힘듭니다만, 굳이 말하자면 지난 세 달 동안 기술 블로그를 운영한 경험은 자영업자로 비유할 수 있을 것 같습니다. 무료로 웹 호스팅을 해주는 서비스 하나만 가지고 글을 쓰고, 이를 보기 쉽고 가능한 예쁘게(이게 제 최선 맞습니다) 디자인하고, 이를 남들이 보게 만들기 위해 모든 방법을 동원해야 하는 경험을 할 수 있었기 때문입니다.\n\n이 때문에 지난 3개월 동안 블로그를 운영하면서 단 한 순간도 심심할 일은 없었네요. 글을 쓰다보면 새로운 기능을 만들고 싶어지고, 새로운 기능을 만들면 이를 글로 쓰고 싶어지고, 그 글을 쓰면 이를 남들에게 알리고 싶어지는 등의 선순환이 꾸준히 이루어지다보니 어느 새 제 블로그도 곧 100개의 포스트를 채울 날이 얼마 남지 않았습니다.\n\n본인이 한번쯤 스스로 개발한 서비스를 운영하는 경험을 해보고 싶은데 방법을 잘 모르신다면, 깃허브 페이지와 jekyll을 이용한 기술 블로그 운영을 추천드립니다. 그것은 분명히 개발자로써의 인생에 웃으면서 추억할만한 제 신호등 같은 경험 하나쯤은 남겨줄 것이라 생각합니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","date":"2024-04-23T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":3}},{"postName":"2024-04-22-re 제로부터 시작하는 블로그(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-22-re 제로부터 시작하는 블로그(2).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","content":"\n### 목차\n\n- [다른 사람과 다른 길을 걷는 용기에 박수를](#다른-사람과-다른-길을-걷는-용기에-박수를)\n- [github pages, jekyll이란](#github-pages-jekyll이란)\n- [기술 블로거는 작가이자, 개발자이다](#기술-블로거는-작가이자-개발자이다)\n- [기술 블로거는 개발자이자, 마케터이다](#기술-블로거는-개발자이자-마케터이다)\n- [마치며](#마치며)\n\n---\n\n## 다른 사람과 다른 길을 걷는 용기에 박수를\n\n'개발자라면 역시 깃허브지!'라는 생각으로 깃허브로 블로그를 시작하기로 결심하신 용감하신 분들께 우선 박수드립니다. 스스로 블로그를 구축하는 것은 많이들 하지 않는 선택이니만큼 쉬운 길이라고는 할 수 없겠지만, 그만큼 할 수 있는 것도 많고 이를 통해 많은 것을 배울 수 있는 개발자로써 한 번쯤 해보면 좋은 경험이라고 생각합니다. 그럼 이제 웹 개발에 대한 지식이라곤 기초적인 api 서버를 구축하는 것 밖에 없었던 제가, github page와 jekyll을 통해 기술 블로그를 운영하면서 겪은 좌충우돌에 대해 잠깐 이야기해보겠습니다.\n\n---\n\n## github pages, jekyll이란\n\n이 둘을 활용하는 자세한 가이드는 [이 페이지](https://pages.github.com/)에서 확인하실 수 있습니다.\n\ngithub pages는 github에서 직접 호스팅을 제공하는 블로그 서비스로 단순히 깃허브 레포지토리에 블로그 정적 파일을 올리기만 하면 이와 관련한 웹페이지와 도메인을 무료로 제공해주는 서비스입니다. 해당 페이지의 빌드와 배포에 관련한 작업은 무려 github에서 직접 만들어둔 workflow인 pages-build-deployment를 통해 관리되며, 본인이 지정해 둔 브랜치를 기반으로 푸시가 일어날 때마다 해당 브랜치의 파일을 빌드하여 배포합니다. 웹 서비스를 경험해 보신 분이라면 이 정도만 해도 충분히 블로그를 운영하는 데에는 문제가 없을 것이며 '생각보다 되게 편리한데? 뭐가 그렇게 힘들었단거야?'라는 생각을 하실 수도 있겠네요.\n\njekyll은 github pages에서 추천하는 정적 사이트 생성기로, 마크다운 파일을 작성되어 있는 layout에 맞는 형태인 HTML로 변환해주는 역할을 합니다. 또한 그 밖에 웹사이트를 만들 때 신경써야 하는 timezone, sitemap, rss feed 등의 기능을 설정만으로도 쉽게 구현할 수 있도록 도와줍니다. 이를 통해 jekyll은 블로그를 운영하는 데 있어 개발보다는 글을 작성하는 데에 많은 시간을 쓸 수 있도록 도움을 줍니다. 또한, jekyll은 liquid라는 템플릿 언어를 사용하여 비교적 간단하게 javascript를 사용하지 않고도 동적인 웹페이지를 만들 수 있으며, 단순히 페이지에 몇 가지 항목을 등록하는 것만으로도 포스트와 관련한 카테고리나 태그, 추천 등의 추가적인 정보를 쉽게 관리할 수 있습니다.\n\n그리고 여기까지가 github pages와 jekyll이 제공하는 모든 것입니다. 사실 저는 이런 것들이 제공되고 있다는 사실도 알지 못하고 블로그가 동작한다는 사실만 인지할 정도로 웹 개발이 모자란 상태에서 운영을 시작했던 데다가, 이 외에도 블로그에 필요한 기능들이 굉장히 많고 유용하다는 것을 깨닫는 과정을 통해 네이버와 같이 여타의 플랫폼에서 제공하는 서비스들이 그만큼 대단하다는 것을 절감할 수 있었습니다.\n\n---\n\n## 기술 블로거는 작가이자, 개발자이다\n\n기술 블로거는 우선은 글을 쓰는 사람이 맞습니다. 하지만 그것은 필요조건일 뿐, 충분 조건은 아닙니다. 말 그대로 깃허브 페이지와 jekyll이 제공하는 것은 글을 작성하면 배포해주고, 이에 필요한 기본적인 포맷인 레이아웃이 끝입니다. 그러면 가장 먼저 시작해야하는 것은 우리에게 너무나 익숙한 웹 사이트의 index 페이지 작성 및 여기에 글이 나열될 수 있는 포스트 페이지를 만드는 것입니다. 즉, 깃허브 페이지로 블로그를 운영하려는 사람은 프론트엔드 개발자가 되어야 합니다.\n\n유명한 블로그 플랫폼인 네이버 블로그를 예시로 들자면 이제 누군가의 네이버 블로그에 들어갔을 때 가장 먼저 맨 위에 글들을 카테고리 별로 나눠주는 메뉴가 놓여있는 것이 대부분입니다. 잠깐, 그런데 내 블로그에 카테고리 별로 나눠주는 버튼은 어디 있죠? 지금부터 만드시면 됩니다. 작성한 글을 읽고 나서 다음 글로 넘어가거나 이전 글로 넘어가는 방법은요? 지금부터 만드시면 됩니다. 댓글은요? 지금부터 만드시면 됩니다.\n\n이처럼 기존에 서비스하던 블로그에서 이미 이러한 수많은 우리가 있는게 너무나도 자연스럽다 생각했던 기능들은 사실 당연한 것이 아니란 것을 깨닫게 되는 첫 순간에는 굉장히 당황스러웠습니다. 그걸 내가 어떻게 해? 그런데 개발자라는 직업의 사람이 모두들 그렇듯, 하다보면 다 된다는 것도 배울 수 있었습니다. 모든걸 제가 만들어야하는 것이 힘들고 괴로운 대신 그만큼 우리가 블로그에 모든 전권을 가지고 있기 때문에, 이런 못생긴 신호등 버튼을 만들어도 아무도 말릴 사람이 없다는 쾌락을 누릴 수 있었던 것은 소소한 재미입니다. 이제는 디자인을 변경했지만요.\n\n![신호등](/images/re%20제로부터%20시작하는%20블로그/신호등.png)\n\n---\n\n## 기술 블로거는 개발자이자, 마케터이다\n\n그렇게 고생해서 다른 블로그들에 있고 나한테 필요한 기능들을 개발해서 글을 쓰는 데까지 오는 데 성공하고 나니 나름대로 뿌듯함을 느낄 수 있습니다. 그런데 이번에는 다른 문제가 있다는 사실을 깨달을 수 있었습니다. 제가 그것을 깨달은 것은 제 블로그 글이나 블로그 자체가  구글이나 네이버 검색엔진을 통해 검색이 되지 않고 있기 때문에, 사실상 제가 작성하고 있는 것은 잘 연결된 인터넷 상에 자리한 것이 아니라 아는 사람만 드나들 수 있는 외딴 섬에 있는 것과 다름이 없다는 사실을 알 수 있었습니다.\n\n아직 구글 검색엔진을 기준으로 가장 먼저 이 부분을 해결하기 위해 제가 조사한 바에 따르면, 구글 검색엔진에 글이 노출이 되기 위해서는 두 가지 해결책을 취할 수 있습니다. 하나는 트래픽이 굉장히 많이 발생하도록 만들어서 구글이 중요한 사이트라고 인식해 검색 엔진에 스스로 등록하게 하는 것입니다. 당연히 이것은 불가능하기 때문에 저는 두 번째 방법을 사용했습니다. 그것은 구글에 직접 이 블로그의 주인임을 증명하고, 구글이 이 블로그를 검색 엔진에 등록하는데 필요한 모든 정보를 제공하는 것입니다. 이것을 [구글 서치 콘솔](https://search.google.com/search-console/about)이라고 합니다.\n\n저는 미련하게도 서치 콘솔에 등록한 이후에 '트래픽이 발생하기만 하면 알아서 잘 되겠지. 글을 쓰고 홍보하기만 하면 어떻게든 될 거야'하는 잘못된 생각을 가지고 일단 글만 쓰다가, 두 달이 넘도록 구글 검색 엔진에 노출이 되지 않아서 문제가 있다 생각해 다시 해결 방법을 찾아 나섰습니다. 그 결과, 구글 검색 엔진에 순수하게 트래픽을 통해 노출되는 것이 아니라 직접 [indexing을 요구](https://support.google.com/webmasters/answer/7440203?hl=ko)하거나 [sitemap을 제출](https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap?hl=ko\u0026visit_id=638493812450328388-2387940056\u0026rd=1)하는 등의 노력을 해야 작은 트래픽이라도 구글 검색 엔진에 노출이 된다는 것을 알 수 있었습니다.\n\n결과적으로 현재 저는 무려 블로그를 시작한 근 세달만에 블로그에 트래픽이 생기기 시작한 사실을 확인할 수 있었습니다.\n\n![디스커버](/images/re%20제로부터%20시작하는%20블로그/디스커버.png)\n![검색결과](/images/re%20제로부터%20시작하는%20블로그/검색%20결과.png)\n\n---\n\n## 마치며\n\n비록 제가 생각한 것보다 기술 블로그를 github pages를 통해 스스로 운영하는 과정은 많은 작업을 요구하는 일이었습니다. 하지만 그 덕분에 제가 알지 못했던 웹과 관련한 많은 기술들을 학습할 수 있었고, 처음으로 사이트에 트래픽이 생긴 날은 굉장히 감격스럽기도 했습니다. 그만큼 블로그를 운영하는 것은 개발자로써 나름대로 힘든 만큼 재미있고 굉장히 많이 자극이 되는 경험이었습니다.\n\n그럼 다음 편에서는 조금 더 구체적으로 블로그를 운영하면서 겪은 일들에 대해 이야기해보겠습니다. 긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","date":"2024-04-22T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":2}},{"postName":"2024-04-21-re 제로부터 시작하는 블로그(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-21-re 제로부터 시작하는 블로그(1).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","content":"\n### 목차\n\n- [나를 드러내기 위해서 라는 세속적인 계기](#나를-드러내기-위해서-라는-세속적인-계기)\n- [그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을](#그-때는-아직-몰랐습니다-남들이-다-하는-데에는-이유가-있다는-것을)\n- [부족하고 모자랐던 흑역사](#부족하고-모자랐던-흑역사)\n- [그래도 남이 봐주니 즐겁고 고마웠던 시간](#그래도-남이-봐주니-즐겁고-고마웠던-시간)\n\n---\n\n## 나를 드러내기 위해서 라는 세속적인 계기\n\n블로그를 다시 시작하게 된 계기는 굉장히 세속적이었습니다. 구직을 하는 초창기에 한 면접관께서 면접 중간에 제게 피드백으로 '이력서가 다른 사람들보다 많이 모자라기 때문에 이를 채우기 위한 노력을 할 필요가 있다, 일단 기술 블로그를 쓰는 것이 좋을 것 같다.'라는 조언을 해주셨기 때문입니다.\n\n저는 운이 좋은 편이라 이력서가 많이 미비한 상태에서도 꽤나 많은 면접을 볼 수 있기는 했지만, 그것이 이력서가 모자라도 괜찮다는 것과는 또 다른 이야기였습니다. 이력서가 모자라다는 것은 제가 어떤 사람인지, 어떤 경험을 가지고 있는지, 어떤 역량을 가지고 있는지를 제대로 보여주지 못한다는 것이기 때문입니다. 이 부분을 채우고 저를 채용 과정에서 더 잘 보여주면서 스스로에 대해 더 잘 알아볼 필요가 있다는 생각을 하게 되어 블로그를 다시 시작하게 되었습니다. 이전의 것을 경험이라고 할 수 있다면 말이죠.\n\n---\n\n## 그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을\n\n블로그를 시작하기 위해서는 일단 여러 플랫폼 중에서 무엇을 고를 지부터 선택해야 했습니다. 최근에 국내 1세대 블로그인 이글루스가 문을 닫는 것을 보고 가능하면 제가 작성한 글들에 대한 소유권을 유지하고 싶다는 생각이 들었고, 동시에 github pages를 이용한 블로그를 하면 깃허브에 글을 쓰는 것만으로도 contribution의 수를 늘릴 수 있기 때문에 굉장히 이득이라는 생각이 들었습니다. 그리고 남들이 주로 쓰는 플랫폼을 벗어나면 힙 해보이지 않을까 하는 망상도 조금 있었습니다.\n\n그러나 그 때는 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 걸 말이죠. github pages를 통한 블로그를 운영한다는 것은 결국 조그마한 웹 서비스를 스스로 운영하는 것과 같기 때문에 내가 거의 모든 통제를 가지고 있지만, 동시에 내가 하지 않은 그 어떤 것도 주어지지 않는다는 것을 말입니다. 그리고 인터넷 상에는 내가 눈치채지 못한 곳에서 생각보다 엄청나게 많은 것들이 바쁘게 동작하고 있다는 사실도 알 수 있었습니다.\n\n---\n\n## 부족하고 모자랐던 흑역사\n\n지금이야 '네가 작가냐, 글 쓸 시간에 코드 좀 짜라'는 말을 듣고 반성할 정도로 활발하게 글을 쓰는 편입니다만, 첫 글을 쓸 때에는 굉장히 막막했던 기억이 납니다. 우선은 무엇을 써야할지도 모르겠고, 무엇을 써야할지 알겠다고 해도 어떻게 써야할지도 모르겠었습니다. 그래서 그냥 블로그를 만들었다는 것을 기념하기 위해 블로그를 만들었다는 글을 쓰는 것으로 시작했지만, 끝나자마자 바로 그 다음 글은 어떻게 써야할 지에 대한 고민이 시작되었습니다.\n\n이 때 제가 도움을 크게 받은 것은 chatgpt였습니다. 아직도 얼추 어떤 질문을 넣었는지 기억이 납니다. '내가 요 근래 이런저런 것들을 공부했는데 이걸 기반으로 기술 블로그를 쓴다면 무슨 주제들을 다루면 좋을까? 그리고 그 주제별로 목차 제시해줘.' 마침 그 때가 의존성 역전에 대해 공부한 시기였고 기술적으로 매력있는 주제라는 생각이 들었기 때문에 그 주제를 기반으로 한 목차를 채우는 것으로 작문을 시작했습니다. 그리고 해당 글을 게재하고 많은 분들의 피드백을 받고 제가 크게 잘못했다는 것을 알 수 있었습니다.\n\n해당 글은 이제 블로그에서 내려두고 피드백을 기반으로 수정한 것이 이 [천원돌파 의존성 역전](https://kaestro.github.io/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2024/02/07/%EC%B2%9C%EC%9B%90%EB%8F%8C%ED%8C%8C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84.html)입니다. 피드백을 받고 많이 고친 것인데도 저 정도이니 원래는 어느 정도였는지 알 수 있으실 겁니다. 하지만 레포지토리 내에는 남겨둔 상태이니 혹시라도 궁금하신 분이면 쓰레기통에 버려진 기밀 문서를 뒤진다는 마음가짐을 가지고 찾아보시면 제 흑역사를 즐기실 수도 있을 겁니다.\n\n---\n\n## 그래도 남이 봐주니 즐겁고 고마웠던 시간\n\n그래도 블로그를 시작하고 남이 글을 읽고 반응을 보여주는 경험은 너무나도 즐겁고 소중하면서도 고마운 순간들이었습니다. 아직도 많이 모자라지만, 그 끔찍했던 글들을 홍차넷과 pgr21이란 커뮤니티에 퍼날랐을 때 이를 읽고 달아주신 댓글들 하나하나 덕분에 여태까지 이 블로그를 그만두지 않고 이어나갈 수 있었습니다. 읽기 불편하고 모자랐던 글들에 힘내라는 응원과 피드백, 잘 읽었다는 칭찬과 격려 모두다 저에게 큰 힘이 되는 소중한 말씀들이었습니다. 그럼 앞으로도 계속해서 글로 이 공간을 채워나가겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","date":"2024-04-21T00:00:00.000Z","categories":"개발일지","published":true,"recommended":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":1}}]},{"category":"디자인패턴","posts":[{"postName":"2024-02-28-Proxy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-28-Proxy Pattern.md","category":"디자인패턴","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 프록시 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**프록시 패턴**은 특정 객체로의 **접근을 제어하는 대리인**을 제공하는 패턴입니다. 이는 객체의 접근을 제어함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, 객체 생성 비용을 줄이기 위해 **객체를 생성하는 시점을 미루는** 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 **원격에서 제어**하는 **Gumball Machine**을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 **GumballMonitor**라는 **프록시**를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n자바에서는 프록시 패턴을 지원하기 위한 유용한 라이브러리를 다양하게 제공합니다.\n\n---\n\n## 요약\n\n1. **프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다.\n2. 프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다.\n3. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 **착각**합니다.\n4. 프록시 패턴은 **보안**이 중요한 객체에 대한 접근을 제어하는데 사용할 수 있습니다.\n5. **원격 객체**에 대한 접근을 제어하는데 사용할 수 있습니다.\n6. 객체 **생성 비용**을 줄이기 위해 객체를 **생성하는 시점을 미루는 목적**으로 사용할 수 있습니다.\n7. Gumball Machine - 실제 객체, GumballMonitor - 프록시\n\n---\n\n## 문제상황\n\n기존 Gumball Machine을 요청한 회사에서 **원격**으로 기계별 **상태를 파악**하고 싶다는 요청을 보냈습니다. 이를 구현하기 위해서 기존의 Gumball Machine에 대한 접근을 제어하는 GumballMonitor 클래스를 만들 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    int count;\n    String location;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n}\n\npublic class GumballMonitor {\n    GumballMachine machine;\n\n    public GumballMonitor(GumballMachine machine) {\n        this.machine = machine;\n    }\n\n    public void report() {\n        System.out.println(\"Gumball Machine: \" + machine.getLocation());\n        System.out.println(\"Gumball Inventory: \" + machine.getCount());\n    }\n}\n```\n\n그런데 이처럼 코드를 만들기 전에 요구 사항을 확실히 파악하는 것은 불가능에 가깝습니다. 이런 상황에서 모니터링을 기존의 코드를 수정하지 않고 추가하려면 어떻게 해야 할까요?\n\n---\n\n## 프록시 패턴을 사용한 해결책\n\n프록시 패턴을 사용하면 기존의 코드를 수정하지 않고도 모니터링을 추가할 수 있습니다. 프록시 패턴은 GumballMonitor 클래스는 그대로 두고, 원격에서 제어하는 Gumball Machine에 대한 **접근을 제어하는 프록시**를 만들어서 Gumball Machine을 제어할 수 있게 합니다.\n\n프록시는 진짜 객체를 **대신**하는 역할을 합니다. 이는 클라이언트가 진짜 객체에 직접 접근하는 것이 아니라, 프록시를 통해 접근하도록 합니다. 클라이언트는 프록시를 통해 진짜 객체에 접근하지만, 클라이언트는 이를 모르고 프록시를 진짜 객체로 착각합니다.\n\n클라이언트 객체는 원격 객체의 메소드 호출을 하는 것으로 착각하지만, 실제로는 프록시 객체의 메소드 호출을 하는 것입니다. 네트워크 통신과 같은 복잡한 작업은 프록시 객체가 처리해 줍니다.\n\n이런 프록시 보조 객체는 클라이언트 뿐 아니라 서버 쪽에서도 사용할 수 있습니다. 두 객체는 각자의 위치에서 받은 요청을 처리하고, 서로 통신을 하면서 진짜 서비스에서 클라이언트의 요청을 처리해줍니다.\n\n이를 java.rmi 패키지를 사용해서 구현하면 다음과 같습니다.\n\n```java\nimport java.rmi.*;\n\npublic interface GumballMachineRemote extends Remote {\n    public int getCount() throws RemoteException;\n    public String getLocation() throws RemoteException;\n    public State getState() throws RemoteException;\n}\n```\n\n```java\nimport java.io.*;\n\npublic interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    public static final long serialVersionUID = 2L;\n    transient GumballMachine gumballMachine;\n    // 기타 메소드\n}\n```\n\n```java\nimport java.rmi.*;\n\npublic class GumballMachine implements GumballMachineRemote {\n    int count;\n    String location;\n    State state;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n\n    public State getState() {\n        return state;\n    }\n}\n```\n이외에 rmi 레지스트리에 등록하는 등의 작업은 생략하겠습니다.\n\n---\n\n## 결론\n\n**프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다. 이는 객체의 **접근을 제어**함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, **객체 생성 비용**을 줄이기 위해 객체를 생성하는 시점을 미루는 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 원격에서 제어하는 Gumball Machine을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 GumballMonitor라는 프록시를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n다만 프록시 패턴은 원격에서 제어하는 것 외에도 다양한 객체의 **접근 방식을 제한**하는데 사용할 수 있습니다. 이 부분을 각자의 요구와 개발 환경에 맞게 사용하는 것이 중요하다 할 수 있을 것입니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","date":"2024-02-28T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-Composite Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-Composite Pattern.md","category":"디자인패턴","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 컴포지트 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**컴포지트 패턴**은 객체들이 복합적으로 구성된 **집합 객체**와 **단일 객체**가 있을 때, 이를 **동일하게 접근**할 수 있는 인터페이스로 구현한 뒤 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\nhead first design patterns에서는 기존의 팬케이크 식당과 디너 식당을 합병하는 상황에서 더 나아간 문제를 제시합니다. 여기에 디저트 식당을 추가로 합병한 뒤에, 이들의 메뉴를 각각 다른 시간대에 독립된 형태로 제공하는 것이 아니라 **복합적인 형태**로 제공하려면 어떻게 해야 할까요?\n\n예를 들어, 프랜차이즈의 오너가 시너지를 위해 디저트 식당을 합병한 경우를 가정해보겠습니다. 회사에서 목표로하는 것은 이 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, **기존 메뉴와 함께** 제공하는 것입니다. 디너 식당의 메뉴에 디저트 메뉴 코너를 추가하듯이 말입니다.\n\n**컴포지트 패턴**은 이런 문제에 대한 해결을 제시합니다. 기존에 반복자 패턴은 여러 다른 형태의 객체들을 단일의 반복자라는 인터페이스를 통해 순회할 수 있게 만들어 줬던 것과는 다르게, 컴포지트 패턴을 사용하려면 복합 객체와 단일 객체가 **동일한 인터페이스**를 가지고 있어야 합니다.\n\n새로운 인터페이스를 통해 컴포지트 패턴을 사용하면, 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있으면서 동시에 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 요약\n\n1. **컴포지트 패턴**은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다.\n2. 클라이언트가 **개별 객체**와 **복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있게 합니다.\n3. 컴포지트 패턴을 사용하면 **복합 객체**와 **단일 객체**가 동일한 인터페이스를 가지고 있어야 합니다.\n4. 컴포지트 패턴을 통해 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 문제상황\n\n성공적으로 팬케이스 하우스, 디너 하우스를 합병한 프랜차이즈의 오너는 이제 **수평적 확장**에 그치지 않고 **수직적인 확장**에 관심을 가지게 되었습니다. 그리고 그 수단은 바로 디저트 식당을 합병하는 것입니다.\n\n팬케이크 하우스와 디너 하우스의 합병은 서로가 운영하지 않는 시간대를 이용해 시너지를 내는 것이 목적이었습니다. 그러나 케이크 식당은 이와는 다르게, 기존의 메뉴와 함께 제공되어야 합니다. 이를 통해 동일 시간대에 더 많은 수익을 창출하는 것이 이번 합병의 목표입니다.\n\n위 상황을 코드로 나타내면 다음과 같습니다. 여기에 생략된 기존의 팬케이크, 디너 식당의 메뉴를 관리하는 클래스들을 반복자를 통해 작성한 코드는 [반복자 패턴 - 저녁밥도 팬케이크도 다 단비꺼야](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/02/23/Iterator-Pattern.html)를 참고해 주세요.\n\n```java\npublic class DessertMenu {\n    ArrayList\u003cMenuItem\u003e menuItems;\n\n    public DessertMenu() {\n        menuItems = new ArrayList\u003c\u003e();\n\n        addItem(\"케이크\", \"초콜릿 케이크\", true, 3.00);\n        addItem(\"케이크\", \"바닐라 케이크\", true, 3.00);\n        addItem(\"케이크\", \"딸기 케이크\", true, 3.00);\n    }\n\n    // 기타 디저트 메뉴를 구성하는 메서드들\n    ...\n}\n```\n\n문제는 위와 같은 메뉴를 관리하는 클래스를 기존의 팬케이크, 디너 식당의 메뉴에 추가하는 것이 복잡하단 것입니다.\n\n해결책 중 하나로는 디저트 메뉴의 항목을 각각 추가할 수도 있습니다. 하지만 만약에 디저트 식당에 새로운 메뉴가 추가하거나 삭제되면 이를 통합한 모든 메뉴들에 해당 작업을 실행해야 합니다. 또 만약 디저트 식당을 매각하게 돼서 메뉴를 삭제해야 한다면 이 또한 골치아픈 일이 될 것입니다.\n\n결국, 이처럼 각각이 다른 형태로 관리되는 메뉴들을 유연하게 통합하는데에는 한계가 있습니다.\n\n---\n\n## 컴포지트 패턴을 사용한 해결책\n\n우선 현재와 같이 각각의 메뉴를 관리하는 클래스들을 동일하게 **메뉴 항목**으로 취급할 수 있는 **인터페이스**를 만들어야 합니다. 이 인터페이스는 메뉴 항목이 가지는 **공통적인 특성**을 정의해야 합니다.\n\n이를 위해 MenuComponent라는 추상 클래스를 만들고, 이 클래스를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n코드로 표현하면 다음과 같습니다.\n\n```java\npublic abstract class MenuComponent {\n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n\n    // 기타 메서드들\n}\n```\n\nMenuComponent는 단일 메뉴와, 메뉴판이 가지는 공통적인 특성과 그렇지 않은 것이 동시에 정의돼있습니다. 이 때문에 클라이언트는 개별 메뉴와 복합 메뉴를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\n대신 개별 메뉴인 MenuItem의 경우에는 add, remove, getChild 메서드를 사용할 수 없게 만들어야 합니다. 이를 위해 UnsupportedOperationException을 던지는 것입니다.\n\n이제 이를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n```java\npublic class MenuItem extends MenuComponent {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean vegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n\n    public void print() {\n        System.out.print(\"  \" + getName());\n        if (isVegetarian()) {\n            System.out.print(\"(v)\");\n        }\n        System.out.println(\", \" + getPrice());\n        System.out.println(\"     -- \" + getDescription());\n    }\n}\n```\n\n```java\npublic class Menu extends MenuComponent {\n    ArrayList\u003cMenuComponent\u003e menuComponents = new ArrayList\u003c\u003e();\n    String name;\n    String description;\n\n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n\n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n\n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void print() {\n        System.out.print(\"\\n\" + getName());\n        System.out.println(\", \" + getDescription());\n        System.out.println(\"---------------------\");\n\n        Iterator\u003cMenuComponent\u003e iterator = menuComponents.iterator();\n        while (iterator.hasNext()) {\n            MenuComponent menuComponent = iterator.next();\n            menuComponent.print();\n        }\n    }\n}\n```\n\n이제 위의 **컴포지트 패턴**을 적용한 메뉴와 메뉴판을 웨이트리스에게 제공하면, 이를 복합적으로 **통합**해서 제공하는 시스템을 구축할 수 있게 됩니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TestMenu {\n    public static void main(String[] args) {\n        MenuComponent pancakeHouseMenu = new Menu(\"팬케이크 하우스 메뉴\", \"아침 메뉴\");\n        MenuComponent dinerMenu = new Menu(\"디너 메뉴\", \"점심 메뉴\");\n        MenuComponent dessertMenu = new Menu(\"디저트 메뉴\", \"디저트 메뉴\");\n\n        MenuComponent waitress = new Menu(\"전체 메뉴\", \"전체 메뉴\");\n\n        waitress.add(pancakeHouseMenu);\n        waitress.add(dinerMenu);\n\n        dinerMenu.add(desertMenu);\n        pancakeHouseMenu.add(desertMenu);\n\n        waitress.print();\n    }\n}\n```\n\n---\n\n## 결론\n\n**복합 객체**와 **단일 객체**를 동일하게 다루어서 **유연**하게 객체들을 **조합**하는 문제를 해결해야하는 경우가 있습니다. 이런 경우에는 양 객체에 **동일한 인터페이스**를 적용하는 **컴포지트 패턴**을 사용할 수 있습니다.\n\n컴포지트 패턴은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트가 **개별 객체**와 복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있습니다.\n\n이는 마치 프랜차이즈 오너가 사업을 **수평적 확장**에서 **수직적 확장**으로 바꾸는 것과 같습니다. 이를 통해 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, 기존 메뉴와 함께 제공하는 것입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-State Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-State Pattern.md","category":"디자인패턴","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 상태 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다. 이는 객체의 상태를 클래스로 표현해서 **추상화**하고, 상태 객체의 동작을 통해 조작하고자 하는 객체가 **자동으로 행동**을 **변경**할 수 있도록 합니다.\n\n상태 패턴을 사용하면 객체의 관점에서는 동일한 동작을 하지만, 내부적으로는 상태에 따라 다른 동작을 하도록 할 수 있습니다. 이는 마치 객체의 **클래스가 바뀌는 것**과 같은 효과를 가져옵니다.\n\nhead first design patterns는 **동전 투입기**를 예시로 들어 상태 패턴을 설명합니다. 동전 투입기는 **동전 없음**, **동전 있음**, **동전 투입됨**과 같은 여러 가지 **조건**에 따라 동작을 달리합니다. 이것들을 **내부 변수**의 값을 통해 **조건문**으로 처리하려 할 경우 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이런 상황에서 **상태 패턴**을 사용하면 각각의 **상태**를 클래스로 **캡슐화**해서 나중에 변경해야 하는 내용을 국지화할 수 있습니다. 이를 통해 상태에 따라 객체가 알아서 행동을 바꿀 수 있도록 할 수 있습니다. 이는 마치 매 순간 동전 투입기가 **새로운 물건**으로 변신하는 것과 같은 효과를 가져옵니다.\n\n상태 전환은 State 클래스로 제어할 수도 있고, Context 클래스로 제어할 수도 있습니다.\n\n---\n\n## 요약\n\n1. **상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다.\n2. 객체의 상태를 **클래스로 표현**하고, **내부 상태**에 따라 객체의 행동을 **알아서** 바꿀 수 있게 합니다.\n3. 상태 전환은 **State 클래스**로 제어할 수도 있고, **Context 클래스**로 제어할 수도 있습니다.\n4. Gumball Machine - Context, State - 동전 없음, 동전 있음, 동전 투입됨\n\n---\n\n## 문제상황\n\n동전을 투입하고 손잡이를 돌리면 알맹이가 나오는 껌볼 기계를 만들어 달라는 요청이 들어왔습니다. 이를 구현하기 위해서는 매 입력이 들어온 순간마다 해당 기계가 동전이 있는지, 손잡이를 돌렸는지, 알맹이가 있는지 정보를 가지고 있어야 합니다.\n\n이 정보들을 기존의 변수로 처리하려고 하면 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n\n    int state = SOLD_OUT;\n\n    public GumballMachine(int count) {\n        this.count = count;\n        if (count \u003e 0) {\n            state = NO_QUARTER;\n        }\n    }\n\n    public void insertQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"동전은 한 개만 넣어주세요.\");\n        } else if (state == NO_QUARTER) {\n            state = HAS_QUARTER;\n            System.out.println(\"동전을 넣으셨습니다.\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"매진되었습니다.\");\n        } else if (state == SOLD) {\n            System.out.println(\"잠깐만 기다려 주세요. 알맹이가 나가고 있습니다.\");\n        }\n    }\n\n    // ejectQuarter, turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이처럼 해당 객체가 동작할 때마다 사용할 메소드들은 모든 변수들에 대해 **분기문**을 처리해야하기 때문에 가독성이 떨어지고, **새로운 명령이나 변수**가 추가될 때마다 코드를 수정해야 하기 때문에 유지보수가 어렵습니다.\n\n만약 예를 들어 동전을 돌리는 순간에 10분의 1 확률로 두 개의 알맹이가 나오는 기능을 추가하고 싶다면 어떻게 해야할까요? 이를 위해서는 수많은 경우의 수를 고려해서 코드를 수정해야 합니다.\n\n---\n\n## 상태 패턴을 사용한 해결책\n\n문제를 반대로 생각해서 메소드가 실행될 때마다 모든 상태를 분기문을 통해 확인하는 것이 아니라, **객체의 상태**를 **변경**하고 해당 상태에 따라 객체의 **행동이 정해진다**면 어떨까요? 그것이 바로 **상태 패턴**입니다.\n\n상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현하도록 한 뒤, 이들을 **통합하는 인터페이스**를 제공하는 것을 통해 상태 패턴을 구현할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface State {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    GumballMachine gumballMachine;\n\n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    public void insertQuarter() {\n        System.out.println(\"동전을 넣으셨습니다.\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n\n    public void ejectQuarter() {\n        System.out.println(\"동전을 넣어주세요.\");\n    }\n\n    // turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n\n// HasQuarterState, SoldState, SoldOutState 클래스도 비슷한 방식으로 구현됩니다.\n```\n\n이렇게 구현한 상태 패턴을 통해 GumballMachine 클래스를 새로 구현하면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n\n    State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int count) {\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n\n        this.count = count;\n        if (count \u003e 0) {\n            state = noQuarterState;\n        }\n    }\n\n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void releaseBall() {\n        System.out.println(\"알맹이가 나가고 있습니다.\");\n        if (count != 0) {\n            count = count - 1;\n        }\n    }\n\n    // getCount, refill 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이제 각각의 상태에 대해 별도의 **클래스**로 **캡슐화**했기 때문에, Gumball은 현재 상태에 따로 인지할 필요 없이 인터페이스를 이용만 하면 됩니다. 이에 따른 **동작**은 각각의 **상태 클래스에서 정의**되어 있기 때문입니다.\n\n이는 추가적으로 상태를 추가하거나, 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 유지보수가 용이합니다.\n\n---\n\n## 결론\n\n**상태 패턴**은 객체의 **상태에 따라 객체의 행동을 변경**할 수 있게 하는 패턴입니다. 이는 객체의 **상태를 클래스로 표현**하고, 상태에 따라 **객체의 행동이 자동으로 결정**되도록 합니다. 이는 마치 객체의 클래스가 바뀌는 것과 같은 효과를 가져옵니다.\n\n상태 패턴을 통해 객체의 상태를 context가 아닌 **상태 클래스에서 관리**함으로써, context는 상태에 대해 알 필요 없이 **인터페이스를 통해 행동을 결정**할 수 있게 됩니다. 이는 유지보수가 용이하고, 새로운 상태를 추가하거나 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 **유연한 코드**를 작성할 수 있게 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-23-Iterator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-23-Iterator Pattern.md","category":"디자인패턴","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 반복자 패턴을 사용한 해결책\n5. 단일 역할 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**반복자 패턴**은 **컬렉션**의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소**에 **접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 접근을 하는 기능을 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\nhead first design patterns는 여러 가지 **음식점 통합**을 해야하는 상황을 이야기합니다. 음식점의 종류에는 팬케이크 하우스, 디너 하우스, 카페가 있고 이들은 각각의 메뉴를 ArrayList, Array, HashMap과 같이 **다른 형태로 관리**하고 있습니다. 이런 상황에서 한 명의 웨이트리스에게 메뉴들을 읽는 다른 방법들을 다 숙지시키고 일을 맡기는 것은 비효율적이고 위험합니다.\n\n이때 반복자 객체를 통한 접근을 사용해서 문제를 해결할 수 있습니다. 웨이트리스는 개별의 객체들을 순회하는 방법들에 대해 인지할 필요 없이 이를 **캡슐화**한 **반복자 객체**를 사용해서 각각의 객체들을 순회할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다**.\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n\n---\n\n## 요약\n\n1. **반복자 패턴**은 컬렉션의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소에 접근**할 수 있게 하는 패턴입니다.\n2. 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다.\n3. 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n4. **단일 역할 원칙**은 \"클래스는 하나의 변경 이유만을 가져야 한다.\"라는 원칙입니다.\n\n---\n\n## 문제상황\n\n마을의 디너 하우스에서 사업 확장의 일환으로 팬케이크 하우스와 **합병**을 하기로 결정했습니다. 이 합병은, 식사는 훌륭하지만 디저트가 아쉬웠던 약점 보완을 통해 시너지 작용을 해서 더 많은 손님을 유치할 수 있으리라 기대했습니다.\n\n그런데 여기에서 일 할 웨이트리스들 간에서 불만의 목소리가 나왔습니다. \"나는 **반대쪽 식당의 메뉴판**을 읽을 수가 없는데요?\"\n\n확인해보니, 팬케이크 하우스는 **ArrayList**, 디너 하우스는 **Array**로 메뉴를 관리하고 있었습니다. 이런 상황에서 두 식당을 통합하려면 손님은 자기가 주문하려는 메뉴를 알고 있는 웨이트리스가 누구인지를 알아내든지, 웨이트리스가 두 식당의 메뉴판을 다 숙지하고 있어야 하는 문제가 발생할 것으로 예상됩니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class MenuItem {\n    String name;\n    String description;\n    boolean isVegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean isVegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.isVegetarian = isVegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    ...\n}\n\npublic class PancakeHouseMenu {\n    ArrayList\u003cMenuItem\u003e menuItems;\n\n    public PancakeHouseMenu() {\n        menuItems = new ArrayList\u003cMenuItem\u003e();\n\n        addItem(\"K\u0026B 팬케이크 세트\", \"스크램블드 에그와 토스트가 곁들여진 팬케이크\", true, 2.99);\n        addItem(\"레귤러 팬케이크 세트\", \"달걀 후라이와 소시지가 곁들여진 팬케이크\", false, 2.99);\n        addItem(\"블루베리 팬케이크\", \"신선한 블루베리와 시럽으로 만든 팬케이크\", true, 3.49);\n        addItem(\"와플\", \"와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.\", true, 3.59);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        menuItems.add(menuItem);\n    }\n\n    public ArrayList\u003cMenuItem\u003e getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n\n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n\n        addItem(\"채식주의자용 BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", true, 2.99);\n        addItem(\"BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", false, 2.99);\n        addItem(\"오늘의 스프\", \"감자 샐러드를 곁들인 오늘의 스프\", false, 3.29);\n        addItem(\"핫도그\", \"사워크라우트, 갖은 양념, 양파, 치즈가 곁들여진 핫도그\", false, 3.05);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        if (numberOfItems \u003e= MAX_ITEMS) {\n            System.err.println(\"죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n\n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n\n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n\n    public void printMenu() {\n        ArrayList\u003cMenuItem\u003e breakfastItems = pancakeHouseMenu.getMenuItems();\n        MenuItem[] lunchItems = dinerMenu.getMenuItems();\n\n        System.out.println(\"아침 메뉴\");\n        for (int i = 0; i \u003c breakfastItems.size(); i++) {\n            MenuItem menuItem = breakfastItems.get(i);\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n\n        System.out.println(\"점심 메뉴\");\n        for (int i = 0; i \u003c lunchItems.length; i++) {\n            MenuItem menuItem = lunchItems[i];\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n위와 같은 상황을 개선하지 않으면 앞으로 더 많은 음식점을 통합하려는 목표를 가진 주인 입장에서는 심각한 걸림돌이 될 수 있습니다. 새로운 종업원을 교육하는 것도 힘들고, 주문의 절차도 복잡해지기 때문입니다.\n\n여태까지 디자인 패턴을 적용하면서 이런 문제를 해결해왔듯이, **반복**이 되면서 **변하는 부분**을 찾아내고, 이를 **캡슐화**해서 **재사용**할 수 있게 만들어야 합니다.\n\n\n---\n\n## 반복자 패턴을 사용한 해결책\n\n**반복자 패턴**을 사용하면 위와 같은 문제를 해결할 수 있습니다. 반복자 패턴은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션**의 **모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n비유를 통해 설명하자면 웨이트리스에게 메뉴들을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 **쪽지**를 주는 것과 같습니다. 이 쪽지는 각각의 식당에 대한 메뉴판을 순회하는 방법을 캡슐화한 반복자 객체입니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\npublic interface Menu {\n    Iterator createIterator();\n}\n\npublic class PancakeMenuIterator implements Iterator {\n    ArrayList\u003cMenuItem\u003e items;\n    int position = 0;\n\n    public PancakeMenuIterator(ArrayList\u003cMenuItem\u003e items) {\n        this.items = items;\n    }\n\n    public Object next() {\n        MenuItem menuItem = items.get(position);\n        position = position + 1;\n        return menuItem;\n    }\n\n    public boolean hasNext() {\n        return position \u003c items.size();\n    }\n}\n\npublic class PancakeHouseMenu implements Menu {\n    ...\n\n    public Iterator createIterator() {\n        return new PancakeHouseMenuIterator(menuItems);\n    }\n}\n\npublic class Waitress {\n    ...\n\n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n\n        System.out.println(\"아침 메뉴\");\n        printMenu(pancakeIterator);\n        System.out.println(\"점심 메뉴\");\n        printMenu(dinerIterator);\n    }\n\n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = (MenuItem) iterator.next();\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n이제 더 많은 식당들을 추가하더라도 각각의 웨이트리스들에게 새로운 메뉴판을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 쪽지를 읽는 방법을 숙지시키는 것만으로도 교육과정을 줄일 수 있습니다.\n\n---\n\n## 단일 역할 원칙\n\n**단일 역할 원칙**(Single Responsibility Principle)은 **\"클래스는 하나의 변경 이유만을 가져야 한다.\"**라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 **바뀌는 부분**의 **역할**이 **하나**이도록 하자는 원칙입니다.\n\n반복자 패턴을 사용하면 이 원칙을 지킬 수 있습니다. 웨이트리스는 메뉴판을 읽는 방법을 숙지시키는 역할만을 가지고 있고, 반복자 객체는 메뉴판을 순회하는 역할만을 가지고 있습니다. 이렇게 각각의 객체들은 하나의 역할만을 가지고 있기 때문에 단일 역할 원칙을 지킬 수 있습니다.\n\n---\n\n## 결론\n\n**반복자 패턴**은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션의 모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 반복 작업을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n이는 마치 여러 가지 **다른 형태의 메뉴판**을 가지고 있는 **음식점의 메뉴**를 통합할 때, 근무할 웨이트리스에게 각각의 메뉴를 숙지하게 하는 것이 아니라 이를 **통합한 쪽지**를 주는 것과 같습니다. 이를 통해 웨이트리스는 각각의 메뉴를 숙지할 필요 없이 쪽지를 통해 메뉴를 **순회**할 수 있게 됩니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 **컬렉션에서 분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다.**\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","date":"2024-02-23T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-21-Template Method Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-21-Template Method Pattern.md","category":"디자인패턴","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 템플릿 메소드 패턴을 사용한 해결책\n5. 후크 메소드\n6. 할리우드 원칙\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 일부 단계를 서브클래스로 미루는 패턴입니다. 이는 **알고리즘의 구조**를 변경하지 않고 알고리즘의 **특정 단계**를 서브클래스에서 **재정의**할 수 있게 합니다.\n\n이 과정을 통해 템플릿 메소드 패턴은 알고리즘의 **템플릿(틀)**을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **카페인 음료 만들기**를 가져옵니다. 카페인 음료에는 커피와 홍차가 있을 수 있고, 둘은 많은 부분에서 같은 과정을 거치지만 '찻잎'과 '커피 콩'을 넣는 부분이나, '설탕과 우유'와 '레몬'을 추가하는 과정이 다릅니다.\n\n템플릿 메소드 패턴을 통해서 메소드에서 **공유**하는 부분은 상위 클래스에서 구현해 두고, **차이**가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 **후크 메소드**란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n**할리우드 원칙**은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, **의존성이 부패**하(복잡하기 꼬이)지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n\n---\n\n## 요약\n\n1. **템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 **일부 단계**를 서브클래스로 미루는 패턴입니다.\n2. **템플릿**을 통해 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다.\n3. **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n4. 물 끓이기 - 고정 알고리즘, 찻잎/커피 콩 넣기 - 서브클래스에서 재정의할 수 있는 부분\n5. **후크 메소드**는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n6. **할리우드 원칙**은 **의존성이 부패**하지 않도록 하는 원칙입니다.\n\n---\n\n## 문제상황\n\n기존에 커피만 판매하던 카페에서 최신 유행에 맞추어 홍차를 판매하기로 결정했습니다. 처음에는 둘의 제조법이 다르기 때문에 별개의 방식으로 관리하고 있었지만, 일을 진행하는 과정에서 과정에서 중복되는 부분이 많은데 이를 따로 관리하는 것이 비효율적이라는 생각을 하게 됐습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    abstract void prepareRecipe(); \n    abstract void boilWater(); \n    abstract void pourInCup();\n}\n\npublic class Coffee extends CaffeineBeverage {\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void brewCoffeeGrinds() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addSugarAndMilk() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage{\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        steepTeaBag();\n        pourInCup();\n        addLemon();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void steepTeaBag() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addLemon() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n---\n\n## 템플릿 메소드 패턴을 사용한 해결책\n\n현재 카페에서 커피와 홍차를 준비하는 과정에서 물 끓이기와 컵에 따르기가 중복되는 것을 볼 수 있습니다. 또 찻잎을 우리는 것과, 레몬을 추가하는 것은 커피를 우리는 것과 우유를 첨가하는 것과 비슷한 행위입니다.\n\n이런 중복성을 해소하기 위해 템플릿 메소드 패턴을 사용할 수 있습니다. 바로 prepareRecipe() 메소드를 추상화하는 것을 통해 말입니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n\n    abstract void brew();\n    abstract void addCondiments();\n\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n기존의 prepareRecipe는 abstract로 선언돼 모든 서브클래스에서 별개로 구현해야했지만, 현재 prepareRecipe는 final로 선언돼 있어 서브클래스에서 오버라이드할 수 없습니다. 이를 통해 prepareRecipe는 고정된 알고리즘을 가지고 있습니다. 하지만 여기에 brew()와 addCondiments()는 추상 메소드로 선언돼 있어 서브클래스에서 구현해서 각자의 알고리즘을 만들 수 있습니다.\n\n이렇게 **템플릿**이라는 **골격** 내에서 **동일한 부분**을 **상위 클래스**에서 구현하고, 일부 **차이**가 나는 부분을 **서브 클래스**에서 구현하는 것을 우리는 **템플릿 메소드**라고 합니다.\n\n---\n\n## 후크 메소드\n\n위에서처럼 모든 서브 클래스마다 다르게 동작을 해야하는 경우도 있지만, 때로는 **아무 동작도 하지 않아야** 되는 경우도 있습니다. 이럴 때 사용하는 것이 바로 **후크 메소드**입니다.\n\n후크 메소드는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n예를 들어, 커피나 홍차를 끓이는 것과 달리 우유, 설탕, 레몬을 추가하는 것은 선택사항입니다. 이럴 때 후크 메소드를 사용할 수 있습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        ...\n        if (customerWantsCondiments()) {\n            addCondiments();\n        }\n    }\n\n    ...\n    // 후크 메소드\n    boolean customerWantsCondiments() {\n        return true;\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    ...\n    // 후크 메소드 오버라이드\n    @Override\n    boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith(\"y\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n기존에 상위 클래스에서 hooker 메소드인 customerWantsCondiments는 아무것도 하지 않습니다. 그리고 서브 클래스인 커피에서는 유저의 입력에 따라서 첨가물인 설탕과 우유를 추가할지 말지를 결정합니다.\n\n---\n\n## 할리우드 원칙\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정하는 것을 말합니다.\n\n템플릿 메소드 패턴은 이 원칙을 따르는 대표적인 패턴입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않습니다.\n\n예를 들어, 스타버즈에서 음료수를 제조하기 시작하면 커피나 홍차를 만들기 위해 물을 끓이고, 컵에 따르는 것은 상위 클래스에서 결정하고, 그 외의 것인 커피를 우려내거나 찻잎을 우려낼 때에만 서브 클래스를 불러냅니다.\n\n이런 것이 할리우드 원칙입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않는 것입니다. 이는 일종의 의존성 역전이라고도 할 수 있습니다.\n\n---\n\n## 결론\n\n템플릿 메소드 패턴은 알고리즘의 템플릿(틀)을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\n템플릿 메소드 패턴을 통해 메소드에서 공유하는 부분은 상위 클래스에서 구현해 두고, 차이가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 후크 메소드란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","date":"2024-02-21T00:00:00.000Z","categories":"디자인패턴"}}]},{"category":"Algorithm","posts":[{"postName":"2024-05-12-5월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-12-5월 2주차 알고리즘 문제.md","category":"Algorithm","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","content":"\n### 목차\n\n- [$O(n)$으로 배열 내 요소 간 최대 차이 구하기](#on으로-배열-내-요소-간-최대-차이-구하기)\n- [필요 없는 중간과정 생략하기](#필요-없는-중간과정-생략하기)\n- [3개의 distinct한 subarray를 구하는 방법](#3개의-distinct한-subarray를-구하는-방법)\n\n---\n\n## $O(n)$으로 배열 내 요소 간 최대 차이 구하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea)\n\n- 문제 요약\n  - int array가 주어졌을 때, i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(n^2)$\n    - i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.\n    - 따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - A[j] \u003e A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.\n    - 그렇지 않을 경우에는 i를 j로 갱신한다.\n\n```python\ndef maxDifference(self, nums: List[int]) -\u003e int:\n    max_diff = -1\n    min_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] \u003e min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n    return max_diff\n```\n\n---\n\n## 필요 없는 중간과정 생략하기\n\n- [문제 링크](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2)\n\n- 문제 요약\n  - n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.\n  - 개선 풀이\n    - 어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.\n    - 따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.\n    - 이 때문에 처음과 끝만 보면 된다.\n\n```python\ndef mostVisited(self, n: int, rounds: List[int]) -\u003e List[int]:\n    start, end = rounds[0], rounds[-1]\n    if start \u003c= end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(1, end + 1)) + list(range(start, n + 1))\n```\n\n---\n\n## 3개의 distinct한 subarray를 구하는 방법\n\n- [문제 링크](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6)\n\n- 문제 요약\n  - int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.\n  - subarray는 연속된 요소들의 집합이다.\n- 풀이 요약\n  - Time Complexity: $O(n^2)$\n  - 3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n\n```go\nfunc minCost(nums []int) int {\n    n := len(nums)\n\n    minCost := math.MaxInt32\n    for i := 1; i \u003c n - 1; i++ {\n        for j := i + 1; j \u003c n; j++ {\n            cost := nums[0] + nums[i] + nums[j]\n            minCost = min(minCost, cost)\n        }\n    }\n    return minCost\n}\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","date":"2024-05-12T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-10-Graph","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Graph.md","category":"Algorithm","title":"Graph","subtitle":"탐색을 위한 자료구조","content":"\n### 목차\n\n- [1. 그래프란?](#1-그래프란)\n- [2. 그래프의 활용](#2-그래프의-활용)\n- [3. 그래프 표현 방법](#3-그래프-표현-방법)\n  - [3.1 인접 행렬(Adjacency Matrix)](#31-인접-행렬adjacency-matrix)\n  - [3.2 인접 리스트(Adjacency List)](#32-인접-리스트adjacency-list)\n- [Reference](#reference)\n\n---\n\n## 1. 그래프란?\n\n그래프는 정점과 간선으로 이루어진 자료구조이다. 그래프는 다음과 같은 특징을 가진다.\n\n- 정점(Vertex): 데이터를 저장하는 공간\n- 간선(Edge): 정점과 정점을 연결하는 선\n- 방향성: 간선에 방향이 있는 경우 방향 그래프, 없는 경우 무방향 그래프\n- 가중치: 간선에 가중치가 있는 경우 가중치 그래프, 없는 경우 비가중치 그래프\n\n## 2. 그래프의 활용\n\n그래프는 주로 탐색을 위해 사용된다. 여기에서 탐색이란 그래프의 정점(vertex)을 방문하기 위해\n간선(edge)을 따라 이동하는 것을 의미한다. 탐색을 통해 그래프의 구조를 파악하거나 특정 정점을\n 찾는 등의 작업을 수행할 수 있다. 대표적인 예시로는 미로 찾기, 최단 경로 찾기, 네트워크 경로\n 찾기 등이 있다.\n\n그래프 탐색 알고리즘에는 다음과 같은 것들이 있다.\n\n- 깊이 우선 탐색(DFS, Depth First Search)\n- 너비 우선 탐색(BFS, Breadth First Search)\n- 다익스트라 알고리즘(Dijkstra Algorithm)\n- 벨만-포드 알고리즘(Bellman-Ford Algorithm)\n- ...\n\n## 3. 그래프 표현 방법\n\n대표적으로 그래프는 대표적으로 다음의 두 가지 방법으로 표현할 수 있다\n\n- 인접 행렬(Adjacency Matrix)\n- 인접 리스트(Adjacency List)\n\n### 3.1 인접 행렬(Adjacency Matrix)\n\n인접 행렬은 2차원 배열로 그래프를 표현하는 방법이다. 인접 행렬은 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V x V` 크기의 2차원 배열이 필요하다.\n- 정점 `u`와 정점 `v`가 연결되어 있으면 `matrix[u][v] = 1`, 연결되어 있지 않으면 `matrix[u][v] = 0`이다.\n- 가중치 그래프의 경우 `matrix[u][v] = w`로 표현한다.\n\n```python\nmatrix = [[1, 0, 0, 1, 0],\n          [0, 1, 1, 0, 0],\n          [0, 1, 1, 1, 1],\n          [1, 0, 1, 1, 0],\n          [0, 0, 1, 0, 1]]\n```\n\n인접 행렬은 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(1)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 유용하다.\n  - 가중치 그래프의 경우 간선의 가중치를 쉽게 확인할 수 있다.\n  - 무방향 그래프의 경우 대각선을 기준으로 대칭성을 가진다.\n  - 행렬의 곱셈을 이용해 그래프의 연결 여부를 확인할 수 있다.\n  - ...\n- 단점\n  - 정점의 개수가 많을 경우 메모리 낭비가 심하다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 낭비가 심하다.\n  - ...\n\n인접 행렬은 정점의 개수가 적고 간선의 개수가 많은 밀집 그래프(Dense Graph)의 경우에 적합하다.\n\n### 3.2 인접 리스트(Adjacency List)\n\n인접 리스트는 리스트를 이용해 그래프를 표현하는 방법이다. 인접 리스트는 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V`개의 리스트가 필요하다.\n- 각 리스트는 해당 정점과 연결된 정점들을 저장한다.\n- 가중치 그래프의 경우 각 리스트의 원소는 정점과 가중치를 저장한다.\n\n```python\nadj_list = [[(3, 1)],\n            [(1, 1), (2, 1)],\n            [(1, 1), (2, 1), (3, 1), (4, 1)],\n            [(0, 1), (2, 1), (3, 1)],\n            [(2, 1), (4, 1)]]\n```\n\n인접 리스트는 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 메모리 사용량이 적다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(E)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 사용량이 적다.\n  - ...\n- 단점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 비효율적이다.\n  - 가중치 그래프의 경우 간선의 가중치를 확인하기 어렵다.\n  - ...\n\n인접 리스트는 정점의 개수가 많고 간선의 개수가 적은 희소 그래프(Sparse Graph)의 경우에 적합하다.\n\n---\n\n## Reference\n\n- [Introduction to Algorithms, 3rd Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Graph","subtitle":"탐색을 위한 자료구조","date":"2024-05-10T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-07-Shortest Path(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-07-Shortest Path(1).md","category":"Algorithm","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","content":"\n### 목차\n\n- [Introduction](#introduction)\n- [Optimal substructure](#optimal-substructure)\n- [negative-weight edges](#negative-weight-edges)\n- [Cycles](#cycles)\n- [relaxation](#relaxation)\n- [References](#references)\n\n---\n\n## Introduction\n\nShortest path problem은 그래프에서 두 정점 사이의 최단 경로를 찾는 문제이다. 이 문제는 다양한 분야에서 응용되며, 다양한 알고리즘이\n 제안되어 있다. Shortest path problem은 다음과 같은 세 가지 유형으로 나뉜다.\n\n1. Single-source shortest path problem\n    - 주어진 그래프에서 특정 정점에서 다른 모든 정점까지의 최단 경로를 찾는 문제이다.\n2. Single-destination shortest path problem\n    - 주어진 그래프에서 모든 정점에서 특정 정점까지의 최단 경로를 찾는 문제이다.\n3. All-pairs shortest path problem\n    - 주어진 그래프에서 모든 정점 사이의 최단 경로를 찾는 문제이다.\n\n이 글에서는 single-source shortest path problem에 대해 다룬다. single-source shortest path problem은 다음과 같은 두 가지 유형으로 나뉜다.\n\n1. Unweighted graph: 그래프의 간선에 가중치가 없는 경우\n2. Weighted graph: 그래프의 간선에 가중치가 있는 경우\n\n이 글에서는 weighted graph에 대해 다룬다. weighted graph에서 single-source shortest path problem을 해결하는 대표적인 알고리즘은\n 다음과 같다.\n\n1. Dijkstra's algorithm\n2. Bellman-Ford algorithm\n\n---\n\n## Optimal substructure\n\nShortest path problem은 optimal substructure를 가진다. Optimal substructure란 문제의 최적해가 부분 문제의 최적해로부터 구해질 수\n 있는 성질을 말한다.\n Shortest path problem에서 optimal substructure는 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. If $p$ contains an intermediate vertex $x$, then $p$ can be divided into two subpaths $s \\rightarrow x$ and $x \\rightarrow v$. The subpath $s \\rightarrow x$ is a shortest path from $s$ to $x$, and the subpath $x \\rightarrow v$ is a shortest path from $x$ to $v$.\n\n즉, 최단 경로 $p$가 중간 정점 $x$를 포함하고 있다면, $p$는 두 개의 부분 경로 $s \\rightarrow x$와 $x \\rightarrow v$로 나눌 수 있다.\n 부분 경로 $s \\rightarrow x$는 $s$에서 $x$로 가는 최단 경로이며, 부분 경로 $x \\rightarrow v$는 $x$에서 $v$로 가는 최단 경로이다.\n\n---\n\n## negative-weight edges\n\n그래프의 간선이 음수 가중치를 가지는 경우, cycle이 존재할 수 있다. 이 경우, shortest path problem을 해결하는 알고리즘은 cycle을\n 탐지하여 음의 무한대로 수렴할 수 있다.\n\nDijkstra's algorithm의 경우 모든 간선의 가중치가 양수인 경우에만 사용할 수 있다. Bellman-Ford algorithm은 음수 가중치를 가지는\n 간선이 존재하고 cycle이 없는 경우에 사용할 수 있다.\n\n---\n\n## Cycles\n\nShortest path problem에서 cycle이 존재하는 경우, 해당 cycle이 음수 가중치를 가지는 경우와 양수 가중치를 가지는 경우로 나뉜다.\n 음수 가중치를 가지는 cycle이 존재하는 경우, shortest path problem을 해결하는 알고리즘은 cycle을 탐지하여 음의 무한대로 수렴할 수\n 있어 해를 구할 수 없다. 반면 양수 가중치를 가지는 cycle이 존재하는 경우, 해당 cycle을 포함하는 경로는 무한히 큰 가중치를 가지므로\n 최단 경로가 될 수 없다. 즉 우리는 shortest path problem에서 cycle을 포함하는 경로를 고려하지 않는다.\n\n---\n\n## relaxation\n\nShortest path problem을 해결하는 알고리즘은 relaxation이라는 연산을 사용한다. relaxation은 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. The relaxation operation updates the shortest path estimate $v.d$ and the predecessor $v.\\pi$ of vertex $v$ if a shorter path from $s$ to $v$ is found.\n\n즉, 매 정점 $v$에 대해 $s$에서 $v$로 가는 최단 경로 $v.d$와 이전 정점 $v.\\pi$를 업데이트하는 연산이다.\n\n---\n\n## References\n\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n  by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, p.643 ~ p.650\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":1}},{"postName":"2024-05-10-Shortest Path(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(2).md","category":"Algorithm","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`벨만-포드 알고리즘`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n 포함된 그래프에서도 사용할 수 있다. 음수 가중치를 가진 간선이 포함된 그래프에서도 사용할\n 수 있다는 장점이 있으며, 음수 사이클이 존재하는 경우 false/error를 반환하는 방식으로\n 음수 사이클을 탐지할 수 있다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n벨만-포드 알고리즘은 다음과 같은 방식으로 동작한다.\n\n```plaintext\nBELLMAN-FORD(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  for i = 1 to |V[G]| - 1  // 그래프의 정점 수 - 1만큼 반복합니다.\n3      for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n4          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n5  for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n6      if d[v] \u003e d[u] + w(u, v)  // u를 통해 v로 가는 경로가 v의 현재 거리 값보다 작다면\n7          return false  // 음의 사이클이 존재하므로 false를 반환합니다.\n8  return true  // 모든 간선에 대해 음의 사이클이 없다면 true를 반환합니다.\n```\n\n`BELLMAN-FORD(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `d`: 정점 `s`로부터 정점 `v`까지의 최단 거리를 저장하는 배열\n- V[G]: 그래프 `G`의 정점 집합\n- E[G]: 그래프 `G`의 간선 집합\n\n---\n\n## Algorithm by python\n\n```python\ndef bellman_ford(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 간선들에 대해 반복적으로 거리를 갱신(relax)합니다\n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbour in graph[node]:\n                if distance[neighbour] \u003e distance[node] + graph[node][neighbour]:\n                    distance[neighbour], predecessor[neighbour] = distance[node] + graph[node][neighbour], node\n\n    # 음수 사이클을 확인합니다\n    for node in graph:\n        for neighbour in graph[node]:\n            assert distance[neighbour] \u003c= distance[node] + graph[node][neighbour]\n\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n벨만-포드 알고리즘의 시간 복잡도는 $O(VE)$이다. 이는 모든 간선에 대해 최단 거리를 갱신하는\n 과정을 $|V| - 1$번 반복하기 때문이다.\n\n---\n\n## Reference\n\n- [Bellman-Ford algorithm - Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":2}},{"postName":"2024-05-10-Shortest Path(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(3).md","category":"Algorithm","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`Dijkstra algorithm`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n포함된 그래프에서는 사용할 수 없다. 대신 음수 가중치를 가진 간선이 없는 그래프에서는 `Bellman-ford algorithm`보다\n더 빠르게 동작한다.\n\n이를 위해 `Dijkstra algorithm`은 `priority queue`를 사용하여 최단 거리를 계산하며, 이미 계산이 완료된 정점\n들은 다시 계산하지 않는다. 이 때문에 `Dijkstra algorithm`은 `그리디 알고리즘`으로 분류된다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n`Dijkstra algorithm`은 다음과 같은 방식으로 동작한다.\n\n```plaintest\nDIJKSTRA(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  S = {}  // 최단 경로가 발견된 정점들의 집합 S를 초기화합니다.\n3  Q = V[G]  // 모든 정점들을 포함하는 우선순위 큐 Q를 생성합니다.\n4  while Q != {}  // Q가 빌 때까지 반복합니다.\n5      u = EXTRACT-MIN(Q)  // Q에서 거리 값이 가장 작은 정점 u를 추출합니다.\n6      S = S append {u}  // u를 S에 추가합니다.\n7      for each vertex v in Adj[u]  // u의 모든 인접 정점 v에 대해\n8          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n```\n\n`DIJKSTRA(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `S`: 이미 최단 거리를 계산한 정점의 집합\n- `Q`: 아직 최단 거리를 계산하지 않은 정점의 집합\n- `V[G]`: 그래프 `G`의 정점 집합\n- `Adj[u]`: 정점 `u`에 인접한 정점들의 집합\n\n---\n\n## Algorithm by python\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 우선순위 큐를 초기화합니다\n    queue = [(0, start)]\n\n    while queue:\n        # 우선순위 큐에서 가장 가까운 노드를 추출합니다\n        current_distance, current_node = heapq.heappop(queue)\n        # 이미 처리된 노드인 경우 건너뜁니다\n        if current_distance \u003e distance[current_node]:\n            continue\n        # 인접 노드에 대해 최단 거리를 갱신합니다\n        for neighbor, weight in graph[current_node].items():\n            new_distance = current_distance + weight\n            if new_distance \u003c distance[neighbor]:\n                distance[neighbor] = new_distance\n                predecessor[neighbor] = current_node\n                heapq.heappush(queue, (new_distance, neighbor))\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n`Dijkstra algorithm`의 시간 복잡도는 `O((V + E) log V)`이다. 이는 `priority queue`를 사용하여\n최단 거리를 계산하기 때문에 정점을 추출하는 과정이 `O(log V)`이기 때문이다. Bellman-ford algorithm과\n달리 모든 간선이 아니라 `최소 거리를 가진 정점만`을 추출하여 계산하기 때문에 더 빠르게 동작한다.\n\n---\n\n## Reference\n\n- [Dijkstra algorithm - wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n- [Dijkstra algorithm - geeksforgeeks](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\n- [Introduction to algorithms, 3rd edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":3}}]},{"category":"서평","posts":[{"postName":"2024-03-29-공부란 무엇인가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-29-공부란 무엇인가.md","category":"서평","title":"떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여","subtitle":"공부란 무엇인가 서평","content":"\n### 목차\n\n- [책 정보](#책-정보)\n- [떡볶이는 좋지만, 더덕 구이는 싫은걸](#떡볶이는-좋지만-더덕-구이는-싫은걸)\n- [공부는 지적인 근육 트레이닝이다](#공부는-지적인-근육-트레이닝이다)\n- [지(知)성장을 위한 시작점](#지知성장을-위한-시작점)\n- [티모 애호가에서 벗어나 장인이 되려면](#티모-애호가에서-벗어나-장인이-되려면)\n- [꿀렁이는 근육에서 벗어나, 추락하는 열차를 지탱하려면](#꿀렁이는-근육에서-벗어나-추락하는-열차를-지탱하려면)\n- [열심히 공부한 당신, 쉬어라](#열심히-공부한-당신-쉬어라)\n\n---\n\n## 책 정보\n\n- 제목: 공부란 무엇인가\n- 저자: 김영민\n- 출판사: 어크로스\n\n---\n\n## 떡볶이는 좋지만, 더덕 구이는 싫은걸\n\n한국은 어려서부터 편식하지 않을 것을 미덕으로 삼는 문화을 갖추고 있습니다. [1인당 전세계 채소 섭취량이 무려 2위](https://m.health.chosun.com/svc/news_view.html?contid=2023071802471)라는 이야기도 있을 정도이니, 부모님들의 노고가 빛을 발하고 있는 모양입니다.\n\n그럼에도 불구하고 채소를 먹기 싫어하는 사람은 여전히 많습니다. 제가 아는 모 여학생은 이제 나이 스물이 다 돼가지만 고기 반찬이 없으면 밥을 먹지 않고, 제육볶음을 먹을 때 채소 비율이 반을 넘어가면 손을 대지 않습니다.\n\n그런데 그 여학생이 고기 한 점 없어도 없어서 못 먹는 음식이 있습니다. 그것이 바로 떡볶이입니다. 그런데 문제는 요즘 수많은 미디어에서 선전하듯 떡볶이는 정제 탄수화물과 단순당에 나트륨 덩어리인 식품이라 몸에 좋지 못하단 것입니다. 그에 반해 더덕 구이 같은 채소는 모두들 입을 모아 먹어야하는 좋은 음식입니다.\n\n물론 사람의 대부분이 채소가 아니라 고기를 더 좋아하는 것이 사실입니다. 그럼에도 채소를 더욱 싫어하게 되는 이유는 어린 시절 강제로 채소를 먹는 경험을 통해 '싫어하는 것', 혹은 '억지로 해야하는 것'이라는 인식이 자리잡았기 때문일지도 모릅니다.\n\n저자는 한국의 공부 문화가 그렇게 자리잡아가고 있는 세태에 대해 걱정하는 마음에 이 책을 썼습니다. 한국의 공부가 입시와 취업으로 환원되지 않을 경우에는 무의미한 것으로 받아들여지고 있기 때문에 공부 자체가 하기 싫은 것으로 인식되고 있고, 공부가 가져다 줄 수 있는 잘 양념된 삶을 이루지 못하고 있는 것이 걱정되기 때문입니다.\n\n국내 최고의 공부 중독자이자 제가 가장 좋아하는 에세이 작가인 김영민 교수님은 이를 위해 공부란 무엇이고, 어떤 것을 공부해야하며, 어떻게, 왜 공부해야하는지와 같은 질문을 제기합니다. 그리고 이에 대해 독자와 대화를 통해 토론하고 본인이 생각하는 답에 대한 제시를 한 뒤 독자 스스로의 답을 제시하기를 바랍니다.\n\n---\n\n## 공부는 지적인 근육 트레이닝이다\n\n세상에 모든 것들은 독특합니다만, 그 중에서도 인간만한 동물은 드물다고 생각합니다. 그리고 헬스장에 가면 그 특이함의 끝이 무엇인가에 대해 엿볼 수 있다고 생각합니다. 온 몸이 상기된 상태로 신음을 내면서 \"한 번만 더...!\"를 외치는 사람들. 그들은 온 몸을 땀으로 적셔가며 숨을 헐떡이고, 자신의 근육을 찢어내는 고통을 스스로 추구하는 구도자들입니다. 그런데 신기한 일은 그들이 그런 고통을 즐긴다는 사실입니다.\n\n그들이 이런 괴로움을 추구하는 것은 아픔 그 자체를 즐거워하기 때문은 아닙니다. 다만 그 괴로움을 경험했을 때, 그리고 그것을 이겨냈을 때 어제의 나보다 나아진 나를 체험할 것을 기대하기 때문에 이를 감내하고 도전하는 것입니다. 지난 달의 내가 3대 200을 들 수 있었는데 이번 달에 230을 해냈다면, 그것은 금전으로 환원되지 않는 무엇보다 소중한 경험이기 때문입니다. 이런 자기 갱신의 체험을 경험한 사람들은 과정에 수반되는 괴로움 역시도 즐기게 되고, 이를 통해 자신의 삶을 더욱 풍요롭게 만들어나갑니다.\n\n공부 역시 마찬가지입니다. 지식을 탐구하고 어제의 무지했던 과거의 나로부터 벗어나는 자기 갱신의 과정을 체험하는 것이 공부입니다. 도서관이라는 지식의 헬스장에 들어가 책이라는 지식의 바벨을 꾸준히 들어가며 머리털이 빠져나가는 고통과 괴로움을 견디는 것이 공부입니다. 그렇다고 진짜 머리털이 너무 많이 빠진다면 그건 좀 곤란합니다. 혹시 본인이 그런 상황에 처해계시다면 도서관보다는 병원을 찾아보시는 것이 좋습니다.\n\n---\n\n## 지(知)성장을 위한 시작점\n\n제가 도서관에서 책을 읽는 것을 헬스장에서 근육을 단련하는 것에 비유하긴 했습니다만, 헬스장에서 운동을 하는 모두가 소위 몸짱이 되는 것은 아닌 것처럼 모든 공부가 지(知)성장을 이끌어 똑똑한 사람이 되도록 만들어주지는 못합니다. 근성장을 위해서는 자신이 단련하려는 하는 근육을 선택하고, 현재 자신이 가진 근력을 측정한 뒤 한계를 뛰어넘기 위해 이에 부딪히는 것이 필요합니다. 공부 역시도 마찬가지입니다.\n\n그렇다면 공부에서 우선 근육에 해당하는 것들에는 무엇이 있을까요? 우선은 특정 개념들을 명료하게 정의하고 사용하는 것부터 시작할 수 있을 것 같습니다. 개념에 대해 정의를 내리는 것은 이해의 첫 걸음이라 할 수 있기 때문입니다. 유명한 [김춘수 시인의 꽃](https://namu.wiki/w/%EA%BD%83(%EA%B9%80%EC%B6%98%EC%88%98))이라는 시에서 '내가 그의 이름을 불러주었을 때, 그는 나에게로 와서 꽃이 되었다.'라고 한 것처럼, 우리는 이름을 불러줄 수 있기 전까지는 사물을 다른 것과 구분지어 인식하지 못합니다.\n\n이 때 해당 개념들을 모호하게 정의하지 않도록 노력해야 할 것입니다. 모호한 정의는 이를 무기 삼으려는 권력자라면 이상적일 수도 있습니다. 나에게로 와서 꽃이 된 객체는 어떤 이름을 부여받았을까요? 제 네이밍 센스는 절망적이기 때문에 예를 들어 '유니' 같은 이름을 지었다 할 때 꽃이 와서 항의할 수도 있습니다. '이름을 불러준다고 했지만, 이런 촌스러운 이름일 거라곤 생각하지 못했어!'라고 말이죠. 그러면 저는 이렇게 말할 수도 있습니다. '내가 이름을 불러준다고 했지 그게 멋진 이름일 거라고 한 적은 없는데?' 그러니 꽃은 명확하게 저에게 요구해야합니다, '고등학생 100명에게 물어봤을 때 70명 이상이 세련됐다라고 말하는 이름을 지어줘'와 같이 말이죠.\n\n하지만 공부에서 개념 정의는 권력 다툼이 아니라 사물에 대한 올바른 인식이 목표이기 때문에 이런 다툼이 발생하지 않도록 노력 해야 합니다. 이를 위해 가급적 명료하고 정확하게 정의해서 자신에게 사물을 올바르게 인식할 수 있는 능력이 함양되도록 노력해야 합니다. 그렇지 않으면 책에서 나온 예시처럼 대머리에 대해 '대머리는 반짝반짝'이라고 말하는 사람이 될 것입니다.\n\n이런 개념들을 세워 지(知)성장이 이루어지고 지식의 척추기립근이 바로 서면서 자기 갱신의 체험을 하게 되면 비로소 눈이 뜨이고 이전보다 좀 더 섬세한 인식을 할 수 있게 될 것입니다.\n\n---\n\n## 티모 애호가에서 벗어나 장인이 되려면\n\n척추 기립근이 바로 서고 눈이 띄었다면 이제 우리는 비로소 눈을 완전히 뜰 능력을 갖춘 생후 2주차의 아기와 동일한 지점에 도착했다고 할 수 있을 것입니다. 하지만 눈을 떴다고 해서 보이는 것에 대한 인식을 할 수 있느냐하면 그건 또 다른 문제입니다. 아기는 수많은 훈련을 해도 한참동안 아빠를 아빠라 부르지 못하고 엄마라고 부릅니다. 이렇게 아기가 아빠와 엄마를 구분짓기 위해 오랜기간 훈련을 해야하는 것처럼 우리가 올바른 인식을 하기 위해서도 수많은 훈련이 필요합니다.\n\n그러나 단순히 훈련을 오래 한다고 해서 능력이 함양되지는 않습니다. 롤에서 우리는 소위 브실골에 있는 한 캐릭터에 수백 수천 게임을 투자한 사람들을 종종 만날 수 있지만, 그들을 우리가 장인이라고 부르지는 않습니다. 그들은 단순히 그 캐릭터를 좋아하고 많이 한 애호가일 뿐입니다. 그렇다면 노력이 어떻게 하면 애호가가 되는데 머무르지 않고 장인이 되도록 할 수 있을까요?\n\n그러기 위해서는 우리는 올바른 방향성을 갖춘 노력을 해야합니다. 그리고 이런 방향성을 잡아주는 역할을 하는 것이 바로 **질문**입니다. 저자분의 표현을 빌리자면, '방광에 아무리 액체가 가득해도 갈증 해소에 도움이 되지 않는 것처럼, 자료가 아무리 가득해도 엉뚱한 위치에 놓여 있다면 지적 호기심 해소에 도움이 되지 않습니다.' 따라서 단순히 게임을 많이 해서 경험을 쌓는 것이 아니라, 그 경험이 발전을 위해 올바른 위치에 쌓이도록 노력해야합니다. 그리고 우리는 질문을 하고 이에 대답을 하는 과정을 통해 이를 이룰 수 있습니다.\n\n질문에도 좋은 질문과 좋지 못한 질문이 있습니다. 좋은 질문에는 여러 기준이 있겠지만 가장 먼저 챙길 가치 중 하나는 완성된 문장으로 질문을 표현하는 것입니다. '아, 정글이 탑 좀...'이라고 눈치 보는 것이 아니라 '정글이 탑에서 대포 웨이브를 쌓는걸 보고 윗동선을 밟아서 다이브를 하면 게임을 유리하게 이끌 수 있지 않았을까요?'와 같이 완성된 문장으로 질문을 표현하는 것입니다. 질문을 할 때 무책임하게 대충 단어를 몇 개 던지고 상대가 알아서 이해해주기를 기대해서는 안됩니다.\n\n그 다음으로는 질문을 할 때 자신의 관점에 지나치게 열중한 나머지 상대방과 소통하지 않고 관점을 무시하지 않도록 노력해야 합니다. 아까 3용 싸움에서 우리가 어떻게 하면 한타를 이길 수 있었을 지에 대해 이야기하고 있는데 갑자기, '아 그러게 내가 아까 탑 오라했을때 왔으면 킬먹고 고속도로 냈을텐데'와 같은 태도를 취해서는 안 될 것입니다. 그런 대화를 통해 이야기가 평행선을 달리지 않도록 하려면 상대의 논의 내부로 들어갈 필요가 있습니다.\n\n그러나 저자의 표현을 빌리면 '상대의 논의 내부로 들어가는 것이 바람직하다 해서, 너무 세세한 문제에 집착하라는 말은 아닙니다.' 너무 깊게 들어가서 대부분 관심을 갖지 않을 질문하는 것은 생산적이지 않고 지적질에 불과한 경우가 대부분이기 때문입니다. '아까 용싸움 할 때 왜 감성센도 쓰셨어요?'와 같은 질문을 해서는 안 될 것입니다.\n\n---\n\n## 꿀렁이는 근육에서 벗어나, 추락하는 열차를 지탱하려면\n\n마침내 지성장을 이루는 데 성공했고, 애호가가 아니라 장인이 되기 위한 방향성을 잡았다면 다음은 이 성장을 다른 사람들과 공유할 필요가 있습니다. 여기서 공유한다는 것은 근육을 꿀렁거리면서 '내 가슴 근육 멋있지?'라며 자랑하는 것을 말하는 것이 아닙니다. 그보다는 [스파이더맨이 열차가 다리에서 떨어지지 않도록 가슴 근육을 최대한 쥐어짠 것처럼](https://www.youtube.com/watch?v=yRhRZB-nqOU), 자신의 지적인 근육이 감당하기 힘들 정도로 어려운 주제에 대한 견해를 제시하고 다른 사람들과 토론하는 것을 말합니다. 이때 이런 어려운 주제에 해당하는 것이 바로 논쟁의 여지가 있는 주제입니다.\n\n논쟁의 여지가 있는 주제를 다룬다는 것은 어렵습니다. 이는 논쟁의 여지가 없는 쉬운 주제를 다루는 것과 달리 기존과 다른 주장을 제시하고 그것을 넘어서야 하기 때문입니다. 본 저자는 예시로 리어왕에서 사생아 에드먼드가 사생아를 멸시하는 상식을 뒤집어놓는 주장을 제시합니다. \"사생아가 비천하다고? 사생아는 자연스럽게 불타는 성욕을 만족시키다가 생겨난 존재이니, 지겹고 따분한 침대에서 의무 삼아 잉태된 정실 자식들보다 낫지!\" 이렇듯 논쟁의 여지가 있는 주제에서 기존과 다른 자신의 견해를 제시하고, 비판을 통한 검증을 받아가며 자신의 견해가 틀렸다는 것을 깨닫는 경험을 통해 이전보다 올바르고 섬세한 인식을 갖추게 될 것입니다. 운이 좋다면 자신의 주장이 올바르다는 것을 깨닫는 경험을 할 수도 있을 것입니다.\n\n이 때 듣고자 관심이 있는 사람에게 전달력 있게 비문이 적은 문장과 똑바른 발음을 통해 해상도가 높은 표현을 사용해서, 상대방이 이해하기 쉽게 주장을 전달해야합니다. 일요일 오전 10시에 선거 유세 차량에서 나오는, 갈라지고 잘 들리지도 않지만 씨끄러워서 짜증을 유발하는 것 만큼은 탁월한 마이크 소리를 통해 아직 잠에서 깨지도 않은 주민들에게 '저에게 투표하시면 아무튼 좋은 일이 생길 겁니다!'와 같은 말을 하는 것으로는 누구의 마음도 움직이지 못할 것입니다. 이런 청중이 듣건 말건 개의치 않고 자기 이야기를 기어이 하고야 마는 것은 서로의 발전을 꾀하는 것보다 자신이 말하는 데서 얻는 쾌감을 추구하는 것일 뿐입니다.\n\n---\n\n## 열심히 공부한 당신, 쉬어라\n\n비일상의 추구의 최종 목표는 일상에서 벗어나 자신을 되돌아보고 자신의 삶의 소중함이나 개선하고 반성할 점을 깨달은 뒤, 다시 일상으로 돌아가서 그것을 실천하는 것입니다. 이는 우리가 여행을 떠날 때 최종 목적지를 집으로 삼는 것과 마찬가지이고, 모든 여행에서 가장 중요한 일은 집으로 무사히 돌아오는 것과 같습니다. 공부 역시도 자신을 갱신하는 여정이기 때문에 일상의 평범함으로 돌아와 휴식을 취하는 것이 가장 중요합니다.\n\n그렇지만 활시위가 이완되기 위해서는 당겨지는 것이 우선해야하듯이, 공부를 열심히 하지 않으면 쉬는 능력 역시도 길러질 수 없습니다. 그러니 진정한 휴식을 취하려면 공부를 통한 자기 갱신의 여정이 앞서야 합니다. 평소에 운동을 하던 사람이 집에 누워 있다면 이를 통해 근육이 회복되고 더 강해질 것이지만, 운동을 하지 않는 저 같은 사람이 집에 누워 있다면 살만 찌우게 될 것입니다.\n\n만약 공부를 해서 휴식을 할 수 있는 체력을 기르는 데 성공했다면 이제는 어떻게 쉬어야 할 지에 대해서 이야기 할 차례입니다. 산책을 취하거나 잠을 자는 것처럼 비어있는 시간을 보내는 것도 좋고, 평소보다 쉬운 글을 읽거나 쓰는 일종의 퇴행도 좋습니다. 저자는 모든 휴식의 궁극으로 빈둥거리며 여행하기를 추천합니다.\n\n떡볶이와 같은 자극적이지만 영양가 없는 공부만 하는 것에서 벗어나 더덕구이와 같이 영양가 있고 하는 것을 보면 뭔가 있어 보이는 사람을 섬세하게 만드는 공부를 하고, 이를 통해 진정한 휴식에 도달하는 사람이 한국 사회에 더 많아지기를 바랍니다.\n\n---\n","layout":"산문","recommended":true,"data":{"layout":"산문","classes":"wide","title":"떡볶이는 좋지만 더덕구이는 싫은 사람들을 위하여","subtitle":"공부란 무엇인가 서평","date":"2024-03-29T00:00:00.000Z","categories":"서평","recommended":true}},{"postName":"2024-03-17-스틱!","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-17-스틱!.md","category":"서평","title":"스틱!","subtitle":"1초 만에 착 달라붙는 메시지, 그 안에 숨겨진 6가지 법칙","content":"\n## 출판사 및 저자\n\n* 저자: 칩 히스, 댄 히스\n* 역자: 안진환, 박슬리\n* 출판사: 웅진지식하우스\n\n---\n\n## 책 소개\n\n**'앉아', '기다려'**. 이처럼 간단한 요청을 강아지에게 부탁하고 받아들여지는 일만 해도 굉장히 많은 노력이 듭니다. 하지만 사회에서 맺는 대부분의 관계는 그런 노력을 할 수 있는 여유가 없기 때문에 우리는 한 순간에 내 **메시지**가 상대에게 **전달**되고 **받아들여지기를 소망**합니다.\n\n저자들은 이렇게 남들에게 자신이 전하고자 하는 **메시지**를 **뇌리에 달라붙게 만드는 것**은 천재만이 할 수 있는 것이 아니라, 다음의 **6가지 법칙**을 따르면 기를 수 있는 능력이라고 저자들은 주장합니다. 그리고 이 6가지 법칙들을 지킨 **성공 사례**들을 통해 유효성을 입증하고, 효과적이지 못한 메시지를 **1초 만에 착 달라붙는 메시지로 바꾸는 과정**을 통해서 이 6가지 법칙을 **활용하는 방법**을 설명합니다.\n\n저자들이 주장하는 6가지 법칙, **SUCCES(s)**은 다음과 같습니다.\n\n```md\n1. 단순함(Simplicity)\n2. 의외성(Unexpectedness)\n3. 구체성(Concreteness)\n4. 신뢰성(Credibility)\n5. 감성(Emotions)\n6. 스토리(Stories)\n```\n\n나머지 단어와 달리 **단순함**의 경우는 오해하기 쉬워 설명을 덧붙이면, 저자가 말하는 단순함이란 메시지를 전달하는 방법이 단순해야 한다는 것이 아닙니다. 그보다 메시지를 전달할 때 **핵심**만을 담아야 한다는 것입니다.\n\n최근 면접을 자주 보게 되면서, 내가 이 회사에 매력있는 사람이라는 **메시지**를 전달할 수 있는 방법이 무엇인지에 대해 많은 고민을 하게 되었습니다. 그것 뿐 아니라 제 블로그 글도 다른 사람들에게 **매력적**으로 읽혀서 **기억**에 남고 싶고, 같은 프로젝트를 진행하는 팀원들에게 내 의견을 **효과적**으로 전달하고 싶다고 갈망하게 됐습니다.\n\n저는 이 책을 읽으면서 **효과적인 소통**을 위해 **노력해야하는 방향**을 찾을 수 있었습니다. 당장에 내일 있을 면접 때 제가 어떤 사람으로 보이고 싶은지 돌이켜보고, 이를 위해서 **자기소개**를 준비하는 것을 통해 **적용**해 볼 수도 있었으니까요. 좋은 결과로 이어져서 자랑하는 글을 쓸 수 있으면 그것은 또 하나의 즐거움이겠네요.\n\n꼭 면접을 보는 상황이 아니라도 사람과의 **소통**에 있어서 자신의 의견을 **효과적으로 전달**하는 데 성공한 다양하고 구체적인 사례들을 통해 이 **6가지 법칙(SUCCESs)**을 이야기 하고 있어서, 많은 것을 배울 수 있는 좋은 책이었습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"스틱!","subtitle":"1초 만에 착 달라붙는 메시지, 그 안에 숨겨진 6가지 법칙","date":"2024-03-17T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-14-구글 엔지니어는 이렇게 일한다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-14-구글 엔지니어는 이렇게 일한다.md","category":"서평","title":"구글 엔지니어는 이렇게 일한다","subtitle":"프로그래머에서 소프트웨어 엔지니어로","content":"\n## 출판사 및 저자\n\n* 저자: 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트\n* 역자: 개앞맵시\n* 출판사: O'Reilly, 한빛미디어\n\n---\n\n## 책 소개\n\n최근에 읽은 이 책에 대한 서평 중에서 그런 이야기가 있었습니다. 누군가가 개발자가 읽어야하는 가장 중요한 책 단 세 권을 꼽으라 한다면 기존에는 Code Complete, Refactoring 이후에 마땅한 것이 없었다. 그런데 그 세 번째에 들어갈만한 책이 나왔다. 이 책을 다 읽은 현 시점에서 저 역시도 **이 책은 개발자라면 반드시 읽어야 하는 책의 목록에 들어가야 한다는 생각을 하게 됐습니다.** 동시에 앞의 두 권 역시도 읽어봐야 할거라는 생각이 드네요.\n\n이 책을 요약한 핵심은 책의 첫 장, 첫 문장에서 이미  정리돼있습니다. **프로그래밍과 소프트웨어 엔지니어링의 가장 큰 차이는 시간, (규모) 확장, 실전에서의 트레이드오프 이렇게 세 가지라고 생각합니다.** 그리고 이 책은 장장 700여쪽에 달하는 분량으로 이 이야기들을 다룹니다.\n\n유명한 말 중에 '악마는 디테일에 있다'는 말이 있습니다. 그만큼 전달하려는 메시지는 전달하는 사람과 그 내용의 디테일을 배제하고 이야기할 수 없으리라 생각합니다. 애석하게도 저에게는 이 책이 갖추고 있는 디테일들을 훌륭하게 전달할 수 있는 방법에 대해서 알지 못합니다. 이 책은 충분히 **구글이 겪어온 수십년의 세월동안 얻은 배움의 정수**를 요약해서 후배들이 나아가기를 바라는 소망을 담아 만들어낸 **무공비급**이라 생각합니다.\n\n이에 비하면 매우 보잘것 없는 경험이지만, 최근 두 명의 팀원 분을 모집해 채팅 어플리케이션을 작성하는 경험을 하고 있습니다. 그리고 그 기간은 약 4주째에 들어가고 있는 시점입니다. 이 과정을 통해 내가 작성하고 있는 프로그램이 계속해서 **초기와 같은 발전을 유지하고 소통**이 되면서 이후에도 **계속해서 발전**할 수 있도록 하는 것이 얼마나 어려운 일인지를 느끼고 있습니다.\n\n요즘에는 이런 것을 소프트웨어 업계쪽에서도 관심을 많이 가지고 있는 분위기입니다. 이를 가지고 소위 **CI/CD**라고 부르고 있고 많은 개발 팀에서 git과 같은 버전 관리 시스템이나, jenkins와 같은 툴을 사용하고 있습니다. 저 같은 경우는 git을 사용한지 꽤나 오랜 기간이 됐습니다만, 이것을 왜 사용하고 어떻게 해야하는 지에 대한 이해는 애석하게도 부족하고 고민해 본 적도 없었다는 생각을 하게 됩니다.\n\n아직은 많이 모자랍니다만 이 책을 읽고 프로그래머에서 **소프트웨어 엔지니어**가 되기 위한 고민을 할 수 있는 사람으로 한 발짝 나아갈 수 있었습니다. 좋은 소프트웨어 엔지니어가 되기 위해서 앞으로 **더 많은 사람들이 이용**하고, **수년에서 수십년간 유지보수가 되어야 할 코드**를 작성하려면 무슨 고민을 해야 하는가 그것은 제가 살아나가면서 계속해야 할 숙제일 것입니다.\n\n혹시나 본인이 프로그래머로써 나아가야할 방향을 찾지 못해 방황하고 있거나, 자신의 프로그램이 갈수록 생산성이 떨어진다는 생각을 하고 계시는 분이라면 이 책을 추천드립니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"구글 엔지니어는 이렇게 일한다","subtitle":"프로그래머에서 소프트웨어 엔지니어로","date":"2024-03-14T00:00:00.000Z","categories":"서평"}},{"postName":"2024-03-13-가상 면접 사례로 배우는 대규모 시스템 설계 기초","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-13-가상 면접 사례로 배우는 대규모 시스템 설계 기초.md","category":"서평","title":"가상 면접 사례로 배우는 대규모 시스템 설계 기초","subtitle":"","content":"\n## 출판사 및 저자\n\n* 저자: 알렉스 쉬\n* 출판사: 인사이트\n\n---\n\n## 책 소개\n\n가상 면접 사례로 배우는 대규모 시스템 설계 기초는 차근차근 **단계**를 밟아나가면서 **시스템을 설계**한다면 어떤 것을 **고려**해야하는 지 경험있는 개발자 분께서 앞에서 천천히 시연해주는 듯한 그런 좋은 책이었습니다.\n\n가능하면 읽으시는 분들께서 제목과 부제목을 통해 글의 내용이 본인에게 유용할지 판단하실 수 있도록 하는 것이 제가 이 블로그의 지향점입니다. 그런데 이 책은 도저히 맞는 부제목을 생각할 수가 없었습니다. 그 정도로 책은 **제목**에서 전달하겠다 말한 이야기를 충실하고 **이해하기 쉽게 설명**합니다. 이 책이 대상 독자로 면접자를 가정하고 있긴 하지만, **주제**로 **대규모 시스템 설계 기초**를 다루고 있는 만큼 구직자가 아닌 분께도 충분히 도움이 될만한 내용을 담고 있다 생각합니다.\n\n이 책은 **가상 면접 사례로 배우는 대규모 시스템 설계 기초**입니다. 이 책을 읽으면 **대규모 시스템을 작성해야하는 상황**을 맞이했을 때 발생 가능한 **문제**에는 어떤 것이 있고, 이를 **해결**하기 위해서 사용할 수 있는 **방법**, 그리고 **과정**들에 대해서 배울 수 있습니다.\n\n이 책은 크게 **세 개의 대단원** 구성으로 나누어져 있습니다.\n\n* 시스템을 설계할 때 고려해야 할 **기본 원칙**과 **지식** 이를 다루는 **과정**\n* 부품으로 사용될 **작은 시스템**들을 설계하는 방법\n* 이들을 조합해서 **대규모 시스템**을 설계하는 방법\n\n우선 **규모 확장성(QPS: Queries Per Second)**을 고려해서 설계하는데 필요한 기술들을 소개합니다. 이와 관련된 기술들에는  **CDN, 수평적 확장, 메시지 큐** 등이 있습니다. 이런 기술들 중 어떤 것을 사용할 지 판단하는 근거를 생각하는 것 역시 중요합니다. 이를 위한 **개략적인 추정**을 하기 위해서 **메모리 접근 시간**과 같은 디테일에 대한 지식을 처음으로 가르쳐줍니다. 그리고 위 지식들을 종합해서 **시스템을 설계하는 과정**을 다음의 **문제 이해** 및 **설계 범위 확정**, **개략적인 설계**, **상세 설계**의 단계를 통해 예시를 들어가면서 설명합니다.\n\n그리고 이 설계하는 과정을 적용해서 **처리율 제한 장치**, **안정 해시**, **유일 ID 생성기**와 같은 대규모 시스템에서 활용하게 될 **작은 시스템**들을 설계하는 것을 보여줍니다. 이 때는 알고리즘 수준까지 내려가서 기반 기술에 대한 자세한 설명을 포함합니다.\n\n그리고 이들을 다 같이 엮어서 **뉴스 피드 시스템**, **채팅 시스템**, **검색어 자동완성 시스템**, **유튜브**와 같은 구체적인 대규모 시스템을 설계할 때 할 법한 설계적인 고민들을 보여줍니다.\n\n물론 실제 제품에서 해야할 고민에 비해서는 훨씬 간략한 내용들이지만, 이를 통해 시니어 개발자 분들께서 대규모 시스템을 설계할 때 고려하는 것들에 대한 편린을 엿볼 수 있었던 기회였습니다. 동시에 내가 이용하고 있는 수 많은 서비스들이 이런 고민들을 통해서 수 많은 사람들에게 안정적으로 서비스가 되고 발전한다는 것이 굉장히 어렵고 멋진 일이며 나 역시도 이런 일을 하는 사람이 되고 싶다는 조금의 욕심도 들었습니다.\n\n**여러 프로그램이 상호작용하는 시스템을 설계해야하는 상황**에 놓여서 고민을 하고 있는 개발자분이시라면, 이 책을 통해 자신의 모호한 **질문들을 구체화하고 해결**해나가는 방향을 잡는 데 도움을 주는 든든한 선배분과 함께하는 듯한 경험을 하실 수 있으리라 생각합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"가상 면접 사례로 배우는 대규모 시스템 설계 기초","date":"2024-03-13T00:00:00.000Z","categories":"서평","subtitle":""}},{"postName":"2024-03-10-데이터 중심 애플리케이션 설계","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/BookReviews/2024-03-10-데이터 중심 애플리케이션 설계.md","category":"서평","title":"데이터 중심 애플리케이션 설계","subtitle":"현대 소프트웨어 데이터 관리 카탈로그","content":"\n## 출판사 및 저자\n\n* 저자: 마틴 클레프만\n* 출판사: 위키 북스\n\n---\n\n## 책 소개\n\n이 책은 현대에 **데이터**를 다룰 때 **발생하는 많은 문제점**들과 이를 **해결하기 위한 많은 방법**들을 원리에서부터 실제 적용한 제품들까지에 이르는 폭 넓은 내용을 이야기합니다. 여러 가지 내가 해결하고자하는 문제 상황에서 사용하는 데이터의 성질에 따라 발생할 수 있는 문제들에는 무엇이 있고, 이를 해결하기 위해서는 어떤 기술을 사용하는 것이 좋을지에 대한 인사이트를 얻을 수 있었습니다.\n\n최근 백엔드 개발자로써 다룰 수 있는 기술 여러 가지 중에서 데이터를 다루는 기술이 핵심적이라는 생각을 하고 있습니다. 이는 날이 갈수록 데이터가 생성되는 속도는 빨라지고 있고, 또한 다양해지고 있기 때문입니다. 그리고 이런 데이터들 별로 공학적이나 경제적으로 효율적인 해결 방법을 내놓는 것은 백엔드 개발자의 책무라고 생각합니다.\n\n근래에 진행하고 있는 채팅 어플리케이션 프로젝트 같은 경우에도 사용자의 메시지, 사용자의 프로필, 사용자의 친구 목록, 사용자의 채팅방 목록, 채팅방의 메시지 등과 같은 다양한 데이터들을 다루게 됐습니다. 이 책을 읽어보면서 제가 다루고 있는 데이터들에 적용할 수 있는 다양한 기술들에 무엇이 있는지와 그 장단점을 고민해 볼 수 있는 시간을 가질 수 있어 좋았습니다. 이를 통해 현재 프로그램이 단순히 동작하는 프로그램을 넘어서, 오랜 기간 다양한 요구에 부합할 수 있도록 설계하는 고민을 하는 데 도움을 받았습니다.\n\n다만 '프로그래머의 뇌'에서 사용한 표현을 빌리자면, 이 책은 굉장히 많은 부하를 요구하는 책입니다. 데이터베이스의 원리부터 시작해서, nosql, 분산시스템, 스트림 등 정말 다양한 주제를 다루고 있습니다. 굉장히 흥미롭고 현재 제가 읽어야하는 책이긴 했지만 동시에 조금 버겁기도 했던 것 같네요. 당장은 한 번 '아 이런 게 있구나' 정도를 가볍게 알아두고 관련된 기술을 사용하게 될 때 겁없이 다가갈 수 있는 원동력을 얻었다는 정도로 만족해야할 것 같습니다. 못해도 올해 말에서 내년 초 정도에는 한 번 더 읽으면 더 많은 것을 깨달을 수 있지 않을까 싶네요.\n\n현재 혹은 나중에라도 여러 종류의 데이터들을 효율적으로 다뤄야하는 문제를 겪게 되실 것 같다면, 이 책을 읽어보시는 것을 통해 도움을 받으실 수 있을 것이라 생각합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"데이터 중심 애플리케이션 설계","subtitle":"현대 소프트웨어 데이터 관리 카탈로그","date":"2024-03-10T00:00:00.000Z","categories":"서평"}}]},{"category":"WeeklyPosts","posts":[{"postName":"2024-05-12-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-05-12-Post reviews.md","category":"WeeklyPosts","title":"5월 2주차 포스트","subtitle":"rate limit, retry 전략, 자기연민","content":"\n### 목차\n\n- [Rate Limit이란](#rate-limit이란)\n- [Retry 전략: Exponential Backoff, jitter](#retry-전략-exponential-backoff-jitter)\n- [Self-compassion is the motivator you’re missing](#self-compassion-is-the-motivator-youre-missing)\n\n---\n\n## Rate Limit이란\n\n[포스트 링크](https://etloveguitar.tistory.com/126)\n\nrate limit은 서비스가 트래픽을 제어하기 위해 사용하는 방법 중 하나로, 서비스에 대한 요청을 제한하는 것이다.\n 예를 들어 서비스의 트래픽이 10초당 100개로 제한되어 있다면, 10초에 100개 이상의 요청을 보내면 서비스는 요청을\n 거부할 것이다.\n\nrate limit이 필요한 이유는 서비스의 안정성과 성능을 보장하고, 과도한 트래픽으로부터 서비스를 보호하는 등의\n 서비스의 안정성을 보장하기 위함이다. rate limit은 서비스의 트래픽을 제어하기 위해 throttling 방법이라 할 수\n 있으며 방법에는 다음과 같은 것들이 있다.\n\n 1. Hard throttling: 트래픽이 제한을 초과하면 요청을 거부한다.\n 2. Soft throttling: 트래픽이 제한을 특정 비율 이상 초과하면 요청을 거부한다.\n 3. Dynamic throttling: 트래픽이 제한을 초과해도 서버 상태에 따라 요청을 처리할 수 있다.\n\n---\n\n## Retry 전략: Exponential Backoff, jitter\n\n[포스트 링크](https://jungseob86.tistory.com/12)\n\nretry 전략은 서비스의 안정성을 보장하기 위해 사용하는 방법 중 하나로, 서비스에 대한 요청이 실패했을 때\n 다시 시도하는 방법이다. 예를 들어 통신 상태 장애로 인해 요청 혹은 응답이 실패했을 때, 일정 시간 후에\n 클라이언트/서버가 다시 같은 요청/응답을 시도하는 것이다.\n\nretry 전략에는 여러 가지가 있는데 그 중에서 exponential backoff과 jitter가 있다. exponential backoff은\n 재시도 간격을 지수적으로 증가시키는 방법이다. 예를 들어 1초, 2초, 4초, 8초, ... 와 같이 시간 간격을\n 늘려가며 재시도하는 것이다. 이 방법은 서버의 부하를 줄이고, 서비스의 안정성을 보장하기 위해 사용된다.\n\njitter는 재시도 간격을 랜덤하게 설정하는 방법이다. exponential backoff은 재시도 간격이 일정하게 증가하는\n 반면, jitter는 재시도 간격을 랜덤하게 설정하여 서버의 부하를 분산시키고, 서비스의 안정성을 보장하기 위해\n 사용된다.\n\n---\n\n## Self-compassion is the motivator you’re missing\n\n[포스트 링크](https://medium.com/behavior-design/studies-show-self-compassion-is-the-motivator-youre-missing-affbceaf5ee3)\n\n자기에 대해 비판적인 태도를 가지고 징계하거나, 자신을 비난하거나, 자신을 비굴하게 만드는 것은 자신의 성장과\n발전을 방해할 수 있으며, 오히려 자기에 대한 자비로운 태도를 가지는 것은 자신의 성장과 발전을 도울 수 있다는\n내용의 포스트이다.\n\n만약 본인이 아니라 친구가 실패하고 힘든 경험을 했을 때에 그 친구에게 꾸짖는 말을 하지 않을 것이라면, 그것은\n자신에게도 적용되어야 한다. 자기에게 자비롭게 대하고, 비판을 하기 전에 한번 숨을 돌리고 만약 친구에게라면\n어떻게 대할 지 한 번 생각해보는 것으로 자신에게도 자비롭게 대할 수 있다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"5월 2주차 포스트","subtitle":"rate limit, retry 전략, 자기연민","date":"2024-05-12T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-05-05-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-05-05-Post reviews.md","category":"WeeklyPosts","title":"5월 1주차 포스트","subtitle":"히어로와 잡부, 자동화의 중용","content":"\n### 목차\n\n- [히어로를 채용하고 잡부를 만드는 스타트업](#히어로를-채용하고-잡부를-만드는-스타트업)\n- [루브 골드버그 장치와 같은 지나친 자동화를 경계하자](#루브-골드버그-장치와-같은-지나친-자동화를-경계하자)\n- [Golang: Improving Your Go Project with Pre-Commit Hooks](#golang-improving-your-go-project-with-pre-commit-hooks)\n\n---\n\n## 히어로를 채용하고 잡부를 만드는 스타트업\n\n[포스트 링크](https://eopla.net/magazines/15449)\n\n사람을 기반으로하는 스타트업에서 능력 있는 인재를 뽑은 다음에 팀으로 만드는 것에 실패하는 경우들에 대해 이야기한다. 문제를 해결할 수\n 있는 능력이 있는 사람은 누구나 히어로이고 그 사람을 뽑는 것은 일반적으로 다른 히어로가 나가는 것과 맞물리게 된다. 그러나 이 히어로가\n 나간 자리를 다시 채우는 경우는 없고, 그러면 이전의 사람이 했던 일들 중에서 다른 사람이 할 수 있는 일들이 떠넘겨지게 된다. 즉 히어로가\n 잡부가 되는 것이다.\n\n이를 방지하기 위해서 해당 포스트에서 제시하는 것은, 히어로가 퇴사 카드를 꺼내들기 전에 먼저 팀을 만들고 그가 불만이 있을 법한 사항들을\n 개선해주자는 것이다. 퇴사 카드를 꺼내든 이후에 연봉 협상과 같은 협상책을 제시하는 것은 이미 늦은 것이다. 이를 위해 할 수 있을 법한 일\n들로는 다음과 같은 것을 제시한다.\n\n1. 정기적인 개인면담\n2. 개인이 처한 상황에 대해 회사가 해줄 수 있는 창구마련\n3. 선심성 발행이 아닌 진심을 담은 회사 히어로서의 성과급 제도 발행 및 적용\n4. 외부 리뷰서비스나 커뮤니티의 지속적인 상황파악을 통한 개선점 도출 및 지속적인 피드백\n5. 히어로를 관리하는 관리자의 역량을 점검\n\n그리고 최종적으로 남은 사람들에 대해서도 배려해달라는 이야기로, 요 근래 스타트업에 지원하면서 가져야 할 마음가짐에 대해 생각해보는 글이\n 됐다.\n\n---\n\n## 루브 골드버그 장치와 같은 지나친 자동화를 경계하자\n\n[포스트 링크](https://itnext.io/rube-goldberg-cloud-architect-a5bbb357b54d)\n\n루브 골드버그 장치라는 보이기는 거창하나 하는 일은 아주 단순한 재미만을 추구하는 연쇄 반응 기계 만화의 비유를 통해 소프트웨어 산업에서\n 자동화를 할 때 주의해야 할 점들에 대해 이야기한다. 루브 골드버그 장치는 매우 복잡한 구조를 가지고 있지만, 그 구조를 이해하면 그것이\n 하는 일은 매우 단순하고 사람이 직접 하는 것보다 더 복잡하고 비효율적일 수 있다. 이처럼 소프트웨어 산업에서도 자동화를 할 때 자동화를\n 이룰 때 하는 이유와 그것이 하는 일이 실제로 가져다 주는 이득이 무엇인지를 잘 생각해야한다는 내용을 담고 있다.\n\n최근 오픈소스 프로젝트를 참가해보면서 소규모 프로젝트들에서조차 pre-commit과 같은 자동화 도구에 지나치게 많은 hook을 사용하고 있다고\n 느껴지는 지점들이 있었다. 처음에는 이것들이 굉장히 멋있고 개발에 도움이 된다고 생각했지만, 해당 장치들을 세팅할 시간에 실제로 코드를\n 작성하는 것이 낫겠다는 생각도 들었고 동시에 이들에 맞추어 코드를 수정하는 시간들이 코드의 품질에 도움이 되는 것인지에 대해 의문이\n 생기는 시점이었다. 이러한 부분들에 대한 경계 및 정도를 잘 판단하는 것이 중요하다는 것을 다시 한 번 느끼게 되었다.\n\n---\n\n## Golang: Improving Your Go Project with Pre-Commit Hooks\n\n[포스트 링크](https://goangle.medium.com/golang-improving-your-go-project-with-pre-commit-hooks-a265fad0e02f)\n\n그럼에도 불구하고 실제로 이들을 사용해보는 경험은 어느 정도 규모가 이미 자리잡은 시스템이 필요한 프로젝트에서는 도입이 필요하다고 생각\n한다. 내 채팅 어플리케이션용 api 서버 역시 개발이 약 3개월차가 되면서 작성한 line의 수가 12000줄을 넘어가고 지운 것이 6000줄이 될 정도\n로 양이 많아지고 있다. 이러한 상황에서 코드의 품질을 유지해야 개발 속도를 높일 수 있을 것이라 생각해서 pre-commit을 도입하게 됐다.\n\n다만 이를 동시에 containerization하는 IaC 역시도 도입하려는 생각을 원래는 하고 있었는데, 그럴 시간에 그냥 개발을 하는 것이 더 나을\n 것이라는 생각이 들었다. 어차피 내가 다른 개발 환경에서 작업할 일도 없고, 다른 사람과 협업할 일도 없을 가능성이 높은 상황인 프로젝트\n이니까.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"5월 1주차 포스트","subtitle":"히어로와 잡부, 자동화의 중용","date":"2024-05-05T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-28-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-28-Post reviews.md","category":"WeeklyPosts","title":"4월 4주차 포스트","subtitle":"제목, 관리, 놀이, 스마트폰 사용량","content":"\n### 목차\n\n- [How to Write a Compelling Headline That Isn’t Clickbait](#how-to-write-a-compelling-headline-that-isnt-clickbait)\n- [당신은 충분히 관리하고 있지 않습니다](#당신은-충분히-관리하고-있지-않습니다)\n- [There's something about a run in the rain](#theres-something-about-a-run-in-the-rain)\n- [My Daily Smartphone Usage Reduced By 90% Using This Simple System](#my-daily-smartphone-usage-reduced-by-90-using-this-simple-system)\n\n---\n\n## How to Write a Compelling Headline That Isn’t Clickbait\n\n[포스트 링크](https://blog.medium.com/how-to-write-a-compelling-headline-that-isnt-clickbait-7cb816cec438)\n\n최근 글을 쓰면서 좋은 제목을 작성하는 것에 많은 고민을 하게 된다. 글의 내용을 잘 표현하면서도 사람의 눈길을 끌 수 있는 제목을 만드는 것은 프로그램에서 메소드 이름을 작성하는 것과 비슷하지만, 그것보다는 훨씬 더 어려운 일이다. 내 최근 글의 제목들에는 많이 발전하고 있지만 아직 과하게 어그로성이 짙거나, 글의 내용을 함축하지 못하기도 하고, 지나치게 설명이 모자랄 때도 있다.\n\n여기서 이야기하는 헤드라인의 지침은 다음과 같다.\n\n```markdown\n1. 독자가 일하게 만들지 말라 - 독자가 글에 관심을 가져야하는지 판단하는데 필요한 모든 정보를 제공하라.\n2. 청중에게 적합한 언어를 사용하라 - 일반 독자 대상이라면 전문 용어는 사용하지 말라.\n3. 흥미로운 것에 집중하라 - 모든 내용을 다룰 필요는 없다. 이야기의 가장 흥미로운 부분에 초점을 맞춰라.\n4. 중요성을 어필하라 - 이 글이 독자에게 왜 중요한지를 강조하라.\n```\n\n그리고 이를 활용하는 헤드라인 작성 방법 5단계를 다음과 같이 정리한다.\n\n```markdown\n1. 사실대로 말하라 - 헤드라인은 글의 내용을 정확하게 반영해야 한다.\n2. 흥미롭게 만들라 - 흥미로운 측면에 집중해서 독자가 읽고 싶을법하게 만들어라.\n3. 간결하게 작성하라 - 가능한 간결하면서 설득력이 있어야 한다.\n4. 단호하게 표현하라 - 주장을 하려는 글의 경우 단호해야 한다.\n5. 다른 사람에게 읽어달라 부탁하라 - 다른 사람에게 읽어보라고 부탁하면서 피드백을 받아라.\n```\n\n헤드라인을 요즈음 작성하는 데 도움이 많이 되는 내용이었다.\n\n---\n\n## 당신은 충분히 관리하고 있지 않습니다\n\n[포스트 링크](https://medium.com/onebigthought/youre-not-managing-enough-56dfc99519fd)\n\n암벽 등반에서 아래에서 등산가의 안전을 유지하기 위한 빌레이가 하는 일의 비유를 통해, 업무에서 관리자가 해야하는 일에 대해 이야기한다. 관리자는 상대에 대한 마이크로 관리를 하는 것은 지양해야하지만, 상대에게 성장할 수 있는 공간하는 것을 제공하고 격려하면서 기다리는 수동적인 위치에만 있어서는 안된다. 저자는 이를 위해 세가지 방법론을 제시한다.\n\n```markdown\n1. 명확성을 제공하라 - 명확한 목표, 동기, 기대치를 방법은 규정하지 않되 전부 제공하라.\n2. 액세스, 컨텍스트를 제공하라 - 상대가 필요한 정보에 접근할 수 있도록 하고, 그 정보가 어떤 맥락에서 필요한지를 제공하라.\n3. 계획을 세우라 - 상대가 성공적으로 일을 할 수 있도록 단계와 이정표를 세우라\n```\n\n그리고 위의 것들을 꾸준히 해야한다 이야기한다. 일종의 오픈소스 프로젝트를 한 것인 chat application의 경우 나도 이런 부분들이 모자랐기 때문에 실패했고 이를 개선하고 싶고 해당 방법론을 채용하려한다.\n\n---\n\n## There's something about a run in the rain\n\n[포스트 링크](https://medium.com/runners-life/theres-something-about-a-run-in-the-rain-7afbf4a79810)\n\n**우리는 늙었다고 노는 것을 멈추지 않는다. 다만 놀지 않기 때문에 늙어갈 뿐이다.**라는 조지 버나드 쇼의 유명한 문구로부터 시작하는 이 글은, 비가 올 때 달리기를 한 경험에 대해서 이야기한다. 달리기를 놀이가 아니라 수단으로 생각한다면 비가 오지 않을 때에만 달리기 할 것이지만, 놀이로 생각하기 때문에 본인은 비가 올 때에도 달리기를 할 수 있었다 이야기한다. 그리고 이를 통해 놀이의 중요성에 대해 이야기한다.\n\n나도 요즈음 글쓰기와 달리기를 놀이로써 즐기고 있기 때문에 많은 부분이 공감이 됐고, 내가 하는 일이 쓸모없는 일이 아니라는 위안을 얻을 수 있었다.\n\n---\n\n## My Daily Smartphone Usage Reduced By 90% Using This Simple System\n\n[포스트 링크](https://medium.com/publishous/the-dss-system-that-helped-me-cut-my-daily-smartphone-usage-by-90-aa2d88889e30)\n\n스마트폰 사용량을 줄이기 위한 방법으로 업무용과 개인용으로 나누어 사용하는 방법을 소개한다. 저자는 이를 나눈 뒤에 개인용 스마트폰의 경우 사용 시간 제한을 두면서 스마트폰 사용량을 줄였다고 이야기한다.\n\n나 역시도 비슷한 경험을 lenovo y700 태블릿을 구매하면서 느꼈다. 업무용으로 연락하는 것은 핸드폰에, 취미 생활과 공부라는 용도로 태블릿을 사용하도록 분리하면서 이전과 달리 이들을 사용하느라 쓸모없는 시간을 보내는 양이 많이 줄어들었다.\n\n핸드폰 같은 경우 아직 이를 더 줄이는 노력을 할 필요가 있다고 느끼고 이 때문에 폰을 분리하는 것도 고려해보려한다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 4주차 포스트","subtitle":"제목, 관리, 놀이, 스마트폰 사용량","date":"2024-04-28T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-21-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-21-Post reviews.md","category":"WeeklyPosts","title":"4월 3주차 포스트","subtitle":"","content":"\n### 목차\n\n- [good first issue 라벨을 이용하여 오픈소스 기여하기](#good-first-issue-라벨을-이용하여-오픈소스-기여하기)\n- [빨리빨리? 불안증? 뇌과학자가 소개하는 한국인이 분노하는 이유?](#빨리빨리-불안증-뇌과학자가-소개하는-한국인이-분노하는-이유)\n- [외톨이? 고독사? 한국이 세상에서 가장 외로운 나라가 된 이유?](#외톨이-고독사-한국이-세상에서-가장-외로운-나라가-된-이유)\n- [구글 검색에 블로그 노출시키기](#구글-검색에-블로그-노출시키기)\n- [고루틴의 동작 원리에 관하여](#고루틴의-동작-원리에-관하여)\n\n---\n\n## good first issue 라벨을 이용하여 오픈소스 기여하기\n\n[포스트 링크](https://well-balanced.medium.com/%EA%BC%BC%EC%88%98%EB%A1%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0-b34ee4cc2bc2)\n\ngood first issue 라벨을 이용하면 오픈 소스에 기여하는 것이 쉬워진다는 이야기이다. good first issue는 기존의 개발자들이 해결하기 쉬우면서도 진입점으로 사용하기 좋은 이슈들을 해결하지 않고 새로 오픈 소스에 기여하려는 사람들을 위해 남겨두는 라벨이다. 이러한 이슈들을 만든다는 것 자체가 일을 체계적으로 하고 깃허브 생태계에 대한 이해도가 높다는 의미여서 해당 라벨을 기준으로 검색을 하니 확실히 관리가 잘 되고 있는 레포지토리이면서 새로운 사람을 필요로하는 것들을 찾을 수 있었다.\n\n이를 통해 현재 tagsy-discord, vizro와 같은 오픈 소스 프로젝트에 참여를 하는 중이다.\n\n---\n\n## 빨리빨리? 불안증? 뇌과학자가 소개하는 한국인이 분노하는 이유?\n\n[포스트 링크](https://www.youtube.com/watch?v=AJSscwZP1Xs)\n\n최근 한국을 세계에서 가장 우울한 나라라는 이야기가 화제가 되고 있다. 이를 한국은 시스템이 잘 되어 있기 때문에 예측이 가능한 영역이 많아 문제가 되고 있다는 관점이었다. 왜냐하면 예측이 어긋날 때 사람은 고통을 느끼기 때문이다. 이런 예시로 한국은 지하철을 탈 때 환승을 위한 열차 칸과 출구 조차도 신경쓴다는 이야기를 한다. 이와 반대 되게 예측하는 능력이 없으면 불안은 오지 않는다고 하며 그 예시로 아기가 어머니가 집을 나가는 것을 경험하고 예측하게 되는 순간부터 불안을 느끼게 되는 것을 이야기한다.\n\n한국은 이런 예측 가능성 때문에 통제에 대한 욕구가 굉장히 강한 경향을 가지고 있다. 대표적인 것이 사주팔자나 MBTI 같은 것을 통해 사람을 예측하려고 하는 유행이 있다. 여기에 더해 한국은 사회적으로 시기별로 삶에 대해 약속이 어느 정도 되어 있다. 공부를 열심히해서 어느 정도 대학을 가면 어느 정도의 회사를 가고 와 같은 그런 약속이다. 그리고 그런 계획이 깨졌을 때 굉장히 조급해지고, 불안하면서, 분노하게 되는 것이다.\n\n이런 한국의 불안에 대한 근본적인 해답으로 장동선 박사님은 다양성을 존중하는 자세에 대해 이야기한다. 사람들이 다들 비슷한 약속에 맞춰서 사는 그런 트랙이 있는 것이 아니라 다른 형태의 삶을 산다는 것을 인정할 수 있게 되면 이런 불안감을 줄일 수 있을 것이란 이야기이다. 한국은 그런 점에서 다양성과 자유가 굉장히 부족한 나라라고 이야기한다.\n\n결국 행복하게 잘 살기 위해서는 스스로 선택하는 자율성이 필요하고, 누군가 만들어놓은 틀 안에서 살아가지 않는 노력을 해야 한다는 것이다. 이런 이야기를 통해 나 역시도 이전에는 굉장히 우울했던 경우가 있었고 그런 사회적인 배경에서 비슷한 경험을 했었다는 생각을 하게 됐다.\n\n---\n\n## 외톨이? 고독사? 한국이 세상에서 가장 외로운 나라가 된 이유?\n\n[포스트 링크](https://www.youtube.com/watch?v=U5U_jK-xJjM)\n\n한국은 가장 불안한 나라에 이어서 가장 외로운 나라로 평가받고 있다. 대표적으로 한국은 집에서 혼자 있는 것을 가장 좋아하고, 가족과 같이 있어도 외롭다고 느낀다. 이는 집에서도 자기 모습이 아닌 상태로 살아가야 하는 경우가 많기 때문이다.\n\n그렇다면 한국인은 왜 집에서도 온전히 자신의 모습을 보이지 못할까? 그것은 다른 사람의 눈치를 많이 봐야 하기 때문이다. 남이 나를 어떻게 생각할까? 그런데 내가 하고 싶은 말은 무엇인가? 그것은 Destructive social shaming 즉 파괴적으로 사회적인 수치심을 주는 일이 굉장히 많이 일어나기 때문이라고 한다. 대표적인 예시로 연예인들이 연애 등에서 문제가 생기면 그것이 굉장히 큰 사회적인 이슈로 불거지면서 압박을 받게 되는 것을 든다. 이렇기 때문에 한국 사람들은 마음 속으로 꾹꾹 눌러두는 일이 많을 것이라 한다.\n\n이렇게 만성 스트레스를 받으면 사람은 해마가 작아져서 기억력이 나빠지고 학습 능력이 떨어지고, 편도체로 인해 우울 기능이 떨어지며, 전두엽에 악영향을 줘 판단력이 저하된다고 말한다.\n\n||자본주의|유교문화|\n|---|---|---|\n|**단점**|물질주의|눈치\u0026서열|\n|**장점**|개인표현|가족\u0026화합|\n\n이라는 가치들이 있을 때 이들 중에서 안 좋은 것만이 결합된 문화를 가지고 있다는 것이다. 한국 사회가 이런 외로움이 적어지기 위해 1편과 이어져서 놀라움과 예상하지 못한 새로운 인연들이 생기는 것이 중요하다고 이야기를 마치면서 외로움이 무엇인가에 대해 다시 생각해보는 계기가 됐다.\n\n---\n\n## 구글 검색에 블로그 노출시키기\n\n[포스트 링크](https://jsy1110.github.io/2022/google-search-console/)\n\n여태까지 약 4개월이 조금 안되는 기간동안 블로그를 운영하는 중인데, 내 닉네임으로 검색을 하는데 구글 검색창에 나오지 않는다는 사실에 무엇이 문제인지 고민이 많았다. 이전에 google search console에 인증을 해 놨으니 블로그가 검색에 노출되어야 한다고 생각했었고, 단순히 트래픽이 발생하지 않기 때문이라 생각했는데 그것은 아니라는 생각이 들었기 때문이다.\n\n이번에 url을 인덱싱함과 동시에 sitemap을 추가하고, robots.txt 파일 또한 추가해서 검색 엔진이 블로그를 크롤링할 수 있도록 설정을 마쳐둔 상태이다. 아직은 사이트맵 처리만 완료된 상태이고, 크롤링은 되지 않아 내가 수동으로 요청을 해 둔 인덱스만 생성이 돼있다. 이를 더 일찍 했으면 좋았을텐데 아쉬웠고, 개인 블로그를 운영하는 경우에 내가 구현하지 않은 것은 대부분의 경우에 돌아가지 않는다는 사실을 다시금 깨닫는다. 그래도 블로그를 운영하면서 인터넷에 대한 지식이 많이 쌓이고 있는 것을 느낄 수 있었던 귀한 경험이었다.\n\n---\n\n## 고루틴의 동작 원리에 관하여\n\n[포스트 링크](https://ykarma1996.tistory.com/188)\n\n얼마 전 당황해서 고루틴은 프로세스냐 스레드냐는 질문에 프로세스라는 대답을 한 적이 있다. 이는 고루틴은 경량 스레드이지만 스레드는 아니고 병렬보다는 동시성을 활용하기 위해 커널을 통하지 않고 내부적으로 관리하는 컨텍스트 스위칭을 하니까 프로세스라는 잘못된 결론에 도달했었기 때문이다.\n\n추가적으로 조사하면서 goroutine은 runtime scheduler에 의해 green thread로 관리되는 스레드이며, 결론적으로는 스레드라고 부를 수 있다. 다만 시스템콜을 직접적으로 사용하는 goroutine은 스레드라기보다는 프로세스 내에서 관리되는 경량 스레드이므로 양쪽에 속하지 않는다고 말할 수 있을 것 같다. 이런 포스트가 아니라 책을 통한 공부도 한번 쯤 깊게 해 볼 필요가 있을 것 같다.\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 3주차 포스트","subtitle":"","date":"2024-04-21T00:00:00.000Z","categories":"WeeklyPosts"}},{"postName":"2024-04-15-Post reviews","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/글 후기/Weekly Posts/2024-quarter-2nd/2024-04-15-Post reviews.md","category":"WeeklyPosts","title":"4월 2주차 포스트","subtitle":"첫번째 팬케이크는 버려라, 기술 직군 경력 우선순위, 2023년 top programming languages","content":"\n### 목차\n\n- [첫번째 팬케이크는 버려라](#첫번째-팬케이크는-버려라)\n- [기술 직군에서 경력을 쌓을 때 우선순위 가이드](#기술-직군에서-경력을-쌓을-때-우선순위-가이드)\n- [2023년 top programming languages](#2023년-top-programming-languages)\n\n---\n\n## 첫번째 팬케이크는 버려라\n\n[포스트 링크](https://medium.com/weirdo-poetry/the-first-pancake-principle-a67e374bceea)\n\n창의적이거나 매력적인 아이디어에 흥미를 느꼈다가 막상 시작하면 본인이 생각하지 못했던 난관들 때문에 압도되는 일이 자주 생깁니다. 저 같은 경우는 이번에 진행한 [채팅 프로젝트](https://github.com/kaestro/chatapplication) 같은 경우가 그랬습니다. 동시 수용 인원 15000명과 1분당 7천개의 메시지 수신을 중계하는 서버를 구축한다는 아이디어는 얼핏 봤을때 너무 매력적이었습니다. 그리고 여기에 사용하면 될 것이라 생각한 기술 스택도 마찬가지였습니다. 그리고 저는 그 아이디어를 구현하기 위해 무작정 시작했고, 압도되는 난관들을 마주했습니다.\n\n저자는 본인이 보이 스카우트 때 팬 케이크를 구우면서 배운 원칙을 통해 이 일은 자연스러운 일이며 오히려 \"신에 대한 희생\"이라고 표현합니다. 이는 무엇을 실제로 시작하기 전에는 무슨 일이 일어날 지 알 수 없기 때문에 조정하는 과정에서는 실패가 발생하는 게 당연하다는 이야기입니다. 마치 팬케이크를 굽기 위한 팬이 처음에 적절하게 달궈졌는지 확인하기 위해 첫번째 팬케이크를 버리는 것처럼 말이죠. 그리고 이 때문에 저자는 첫번째 팬케이크는 버리는 마음가짐을 통해 기대의 부담을 벗어나야 상상력을 제대로 발휘할 수 있다고 말합니다.\n\n저자는 이를 이용해서 본인이 하이쿠로만 말하는 로봇에 관한 연재 만화를 그린 일화를 추가로 제시합니다. 처음에는 모자랐지만 그 아이디어가 완벽해질 때까지 기다렸다면 아무것도 만들어지지 못했을 것이라는 말과 함께요. 이처럼 무언가를 시작할 때 완벽을 추구한다는 잘못된 목표를 가지지 않도록 해야겠습니다.\n\n---\n\n## 기술 직군에서 경력을 쌓을 때 우선순위 가이드\n\n[포스트 링크](https://dnastacio.medium.com/hierarchy-of-career-priorities-c18768d32598)\n\n저자는 Maslow의 욕구 계층 구조를 참고하여 기술 직군에서 경력을 쌓을 때 우선순위를 제안하고, 이를 기반으로 한 자신이 배운 것들을 공유합니다. 이를 참고하면 기술 직군에서 경력을 쌓을 때 어떤 것에 집중해야 하는지에 대한 가이드가 될 수 있을 것이라는 생각을 하게 됐습니다.\n\n![우선순위 계층](https://miro.medium.com/v2/resize:fit:1100/format:webp/1*8tp3caPQO7klijrsv2JDlw.png)\n\n```plaintext\n1. 고용 가능성\n2. 보상과 안정성\n3. 성장과 발전\n4. 일과 삶의 균형 및 웰빙\n5. 목적과 의미\n```\n\n위의 예시들을 통해 4가지 교훈을 제시합니다.\n\n```plaintext\n1. 기술 스택이 고용 가능성을 정의한다.\n2. 노후화 기간인 3년: COBOL\n3. 최첨단을 주의하라.\n4. 고도로 전문화된 도메인 프로젝트를 주의하라.\n```\n\n우선 제품 기술 스택이 직원에게 고용 가능성 관점에서 가장 중요한 요소라는 이야기로 시작합니다. 이는 현재 작업을 이어나갈 사람을 구하는 것과 동시에 이후에 이를 이어받을 사람을 시장에서 구하는 것이 용이해진다는 의미이기 때문입니다. 이 때문에 노후화되고 인기가 없는 기술 스택을 사용하는 상사는 사람을 그만두게 할 수 있다고 이야기합니다.\n\n그리고 이런 기술의 트렌드는 전반적으로 3년을 주기로 변화하고 있으며, 그 예시로 COBOL을 듭니다. 그리고 다음의 github 사용자 활동 분석을 제시해서 이를 뒷받침합니다. 이 트렌드를 보며 javascript, typescript와 같은 기존에 크게 주목하지 않았던 언어에 대해 생각해보고 다른 글들도 찾아보게 됐습니다.\n\n![언어 선호도 변화 추이](https://camo.githubusercontent.com/8718666e98e034746add66bab1ba74bcb6d8670266b2fcc1b9dfef3cff621db7/68747470733a2f2f6d69726f2e6d656469756d2e636f6d2f76322f726573697a653a6669743a313130302f666f726d61743a776562702f312a4b59634534697a49396d5042484c4e71735f787552412e706e67)\n\n그렇지만 그렇다고 하여 최첨단의 것을 추구하는 것이 가지는 위험성에 대해서도 경고하며, 특정 기술 스택에 지나치게 의존되어 있지 않도록 주의하라고 이야기합니다. 이는 특정 기술 스택에 의존하게 되면 그 기술 스택이 노후화되거나 인기가 없어질 때 큰 타격을 받을 수 있기 때문입니다.\n\n---\n\n## 2023년 top programming languages\n\n[포스트 링크](https://linuxiac.com/github-top-programming-languages-of-2023/)\n\n| Ranking | Programming Language | Percentage |\n|---------|----------------------|------------|\n| 1       | Python               | 17.715%   |\n| 2       | Java                 | 11.086%   |\n| 3       | Go                   | 10.817%   |\n| 4       | JavaScript           | 10.065%   |\n| 5       | C++                  | 9.712%    |\n| 6       | TypeScript           | 7.610%    |\n| 7       | PHP                  | 4.835%    |\n| 8       | Ruby                 | 4.690%    |\n| 9       | C                    | 4.309%    |\n| 10      | C#                   | 3.531%    |\n\n생각하는 것과 언어 사용의 지표가 많이 다르고, 여러 방면으로 찾아 볼 필요가 있겠다는 생각을 하게 됐습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 2주차 포스트","subtitle":"첫번째 팬케이크는 버려라, 기술 직군 경력 우선순위, 2023년 top programming languages","date":"2024-04-15T00:00:00.000Z","categories":"WeeklyPosts"}}]},{"category":"신변잡기","posts":[{"postName":"2024-05-16-새로움을 경험하며 나를 돌아보다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-16-새로움을 경험하며 나를 돌아보다.md","category":"신변잡기","title":"비어있는 공백기가 아니라 충만했던 탐색기(2)","subtitle":"소중한 것을 손에서 놓아보다","content":"\n### 목차\n\n- [더욱 더 새로운 사람을 만나고, 안 하던 것을 하는 환경으로 저를 밀어넣었습니다](#더욱-더-새로운-사람을-만나고-안-하던-것을-하는-환경으로-저를-밀어넣었습니다)\n- [직업을 탐색하는 기간을 가졌습니다](#직업을-탐색하는-기간을-가졌습니다)\n- [내가 손에서 놓은 것의 가치를 알게 되었습니다](#내가-손에서-놓은-것의-가치를-알게-되었습니다)\n- [마치며](#마치며)\n\n---\n\n## 더욱 더 새로운 사람을 만나고, 안 하던 것을 하는 환경으로 저를 밀어넣었습니다\n\n저는 원래 새로운 사람을 많이 만나지 않는 편이고 먼저 연락도 잘 하지 않는 사람이었습니다. 일년 동안 일을 제외하고는\n누군가 소개해주는 것이 아니라면 새로운 사람을 만나지 않는 것이 대부분이었죠. 게임을 취미라고 했지만,\n하던 게임의 하던 캐릭터를 반복하는 안전한 환경에서만 즐기는 편이었습니다. 그리고 가장 먼저 바꾼 것이 이런\n환경이었습니다.\n\n저는 카카오톡 오픈 채팅의 다양한 채팅방에 들어가며 새로운 사람들을 만나기 시작했습니다. 단순히 채팅방에서만\n대화하는 것을 떠나 함께 만나서 식사를 하고, 커피를 마시며 대화를 나누는 시간을 가졌습니다. 또 장르를 막론하고\n젤다의 전설, 우마무스메 프리티 더비, 몬스터 헌터와 같은 전혀 다른 게임을 즐기며 게임에 대한 넓은 시야를\n얻을 수 있었습니다.\n\n이런 기존과 다른 다양한 것을 하는 것이 강제된 환경에서 저는 새로운 사람들을 만나고, 경험을 하며 이전에는 생각지도\n못했던 자신이 만들어지는 것을 확인할 수 있었습니다.\n\n---\n\n## 직업을 탐색하는 기간을 가졌습니다\n\n그런 다음에는 과연 개발자가 제게 맞는 직업인지, 혹은 다른 직업을 찾아보는 것이 좋을지에 대해 확인하기 위해\n다양한 직업을 경험해보기로 했습니다. 일용직으로 물류센터에서 근무하거나, 학원에서 선생으로 근무하고, 돈을 받고\n글을 쓰는 일을 해보기도 했습니다. 해당 직업들의 경험들은 모두 제게 새로운 경험이었음과 동시에 맞는 부분이 있어\n평생을 이 직업으로 살아가는 것도 나쁘지는 않겠다는 생각이 들었습니다.\n\n하지만, 이런 경험들을 통해 제가 가장 만족스러워하는 일은 개발자로서의 일이었음을 알게 되었습니다. 개발자가 되어\n버그를 찾고 머리를 쥐어 뜯으며 해결하거나, 어제와 달라진 오늘의 새로운 기술을 습득하고, 이를 통해 다른 사람들과\n함께 상품을 만드는 것을 할 때 가장 자기 갱신의 체험을 많이 할 수 있었고 그 과정이 즐거웠기 때문입니다.\n\n그렇게 기존과 다른 곳에서 오랜 기간 방황을 한 끝에 저는 기존의 환경이 제가 가장 원하는 것임을 깨달았고, 현재는\n개발자로서 복귀하기 위해 노력하는 중입니다.\n\n---\n\n## 내가 손에서 놓은 것의 가치를 알게 되었습니다\n\n자신이 가진 것의 가치를 알기 위해서는 그것을 손에서 놓아봐야 한다고 합니다. 지난 약 2개월의 기간은 제게 있어서\n그것을 실천하고, 그 빈자리를 여러 가지 다른 것들로 채워보는 시간이었습니다. 그리고 이런 경험들을 통해 제 빈자리를\n메워줄 수 있는 가장 잘 맞는 것이 제가 원래 가지고 있던 것이었다는 것을 깨달을 수 있었습니다.\n\n그렇다고 단순히 제가 멀리 돌아오기만 한 것은 아닙니다. 대신 저는 다양한 경험들과 사람들을 만나면서 새로운 도전을\n하고 실패하는 과정을 두려워하지 않는 성정을 가지게 되었습니다. 그리고 이전처럼 문제가 해결되기를 기다리는 것이 아니라\n먼저 나서서 해결하려는 자세를 가지게 되었습니다.\n\n---\n\n## 마치며\n\n이처럼 기존의 환경을 떠나 새로운 것을 경험하고, 자신을 되돌아보며 재구축하는 경험은 저에게 항상 긍정적인 변화를\n가져다주었습니다. 그렇기 때문에 2년 전에 퇴사를 하고 탐색기를 가지기 위해 새로운 환경으로 떠난 것은 제게 있어서\n인생을 한번 다시 채우기 위해 우선 비우고 정리하는 시간이었다고 생각합니다. 그리고 이제는 정리해둔 공간을 다시\n채워나가기 위해 노력해야겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"비어있는 공백기가 아니라 충만했던 탐색기(2)","subtitle":"소중한 것을 손에서 놓아보다","date":"2024-05-16T00:00:00.000Z","categories":"신변잡기","series":"비어있는 공백기가 아니라 충만했던 탐색기","seriesIndex":2}},{"postName":"2024-05-16-작고 소중한 28회","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-16-작고 소중한 28회.md","category":"신변잡기","title":"작고 소중한 28회의 클릭","subtitle":"최초의 구글 서치 콘솔 업적","content":"\n### 목차\n\n- [작은 업적을 달성하는 성취감](#작은-업적을-달성하는-성취감)\n- [읽어주신 분들에게 감사의 말씀을 드리고 싶습니다](#읽어주신-분들에게-감사의-말씀을-드리고-싶습니다)\n- [다음에는 30, 40회를 목표로](#다음에는-30-40회를-목표로)\n\n---\n\n## 작은 업적을 달성하는 성취감\n\n5월 15일 뜻밖에 구글 서치 콘솔에서 '축하드립니다'로 시작하는 메일이 와 있었습니다. 무슨 일인지 궁금해서 열어보니,\n제가 운영하는 블로그에서 구글의 검색 엔진을 통해 유입된 클릭 수가 지난 28일간 20회를 넘은 업적을 달성했다는\n내용이었습니다.\n\n![20회 달성 업적](/images/구글서치%20첫%2028일/20회%20업적.png)\n\n유튜브에서 조회수가 20회를 넘었다면 그것이 대단한 것은 못되는 것처럼, 제가 모든 조회수를 현재는 추적할 방법이\n없습니다만 블로그의 클릭 수가 20회를 넘었다는 것은 그리 큰 일이 아닌 것 같습니다. 그럼에도 불구하고 이런 조그만\n업적을 달성했다는 것이 뿌듯하게 느껴졌습니다.\n\n---\n\n## 읽어주신 분들에게 감사의 말씀을 드리고 싶습니다\n\n구글 서치 콘솔에 등록한 지는 얼마 되지 않았습니다만, 그 이전에도 제 모자란 블로그를 방문해 주시거나, 이를 퍼나른\n커뮤니티의 글들을 읽어주시고 댓글을 달아주신 분들에게 꼭 감사의 말씀을 전하고 싶습니다. 그 분들의 따뜻한 격려의\n말씀들이 없었다면 이 작은 성취조차 달성하지 못했으리라 생각합니다. 그러니 이 조그만 업적 달성은 저만의 것이 아니라\n읽어주신 분들과 함께한 것이라 생각하고, 이에 보답하기 위해 더 나은 글을 쓰고자 노력해야겠다는 생각을 하게 됩니다.\n\n---\n\n## 다음에는 30, 40회를 목표로\n\n![28회 클릭 횟수](/images/구글서치%20첫%2028일/28회.png)\n\n이번에는 30회에 아쉽게 조금 미치지 못했지만, 다음에는 30회 그리고 더 나아가 40회 이상의 클릭 수를 달성할 수\n있도록 정진하고 싶습니다. 나름 자신 있는 3편의 글을 써 둔 것이 있고 올릴 순간을 보고 있으니 이 글들이 더 많은\n분들에게 도움이 되고, 그에 대한 보답으로 클릭 수가 더 많이 증가할 수 있으면 좋겠네요.\n\n그럼 이번에도 읽어주셔서 감사하고, 앞으로도 더 나은 글을 쓰기 위해 노력하겠습니다. 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"작고 소중한 28회의 클릭","subtitle":"최초의 구글 서치 콘솔 업적","date":"2024-05-16T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-05-15-새로움을 경험하며 나를 돌아보다","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-15-새로움을 경험하며 나를 돌아보다.md","category":"신변잡기","title":"비어있는 공백기가 아니라 충만했던 탐색기(1)","subtitle":"새로움을 경험하며 나를 돌아보다","content":"\n### 목차\n\n- [지난 2년의 공백기 동안 뭘하고 보내셨나요?](#지난-2년의-공백기-동안-뭘하고-보내셨나요)\n- [나에게 탐색기가 필요했던 이유](#나에게-탐색기가-필요했던-이유)\n- [굳이 새로운 환경을 찾은 이유](#굳이-새로운-환경을-찾은-이유)\n- [마치며](#마치며)\n\n---\n\n## 지난 2년의 공백기 동안 뭘하고 보내셨나요?\n\n구직을 위해 면접을 보면 제게 늘 물어보는 질문 중 하나가 있습니다. 그것은 '이전 직장을 퇴사한 이후에 공백기가\n꽤 긴데, 미기입 하신 건가요? 혹시 이 기간 동안에는 무엇을 하셨나요?'입니다. 이에 대해 저는 '그\n기간은 제게 있어서 자신을 되돌아보기 위해 기존에 하지 못했던 것들을 시도하고 새로운 사람들을 만나는 시간으로,\n경력적으로는 빈 기간이었을 수 있지만 제 인생에서는 충만했던 탐색기였습니다'라고 대답할 수 있지 않을까 싶습니다.\n\n---\n\n## 나에게 탐색기가 필요했던 이유\n\n전에 [저는 외로워서 퇴사했고, 이젠 아닙니다](https://kaestro.github.io/%EC%8B%A0%EB%B3%80%EC%9E%A1%EA%B8%B0/2024/04/23/%EC%A0%80%EB%8A%94-%EC%99%B8%EB%A1%9C%EC%9B%A0%EA%B3%A0,-%EC%9D%B4%EC%A0%A0-%EC%95%84%EB%8B%99%EB%8B%88%EB%8B%A4.html)라는 글에서 밝혔던 것처럼, 저는 인간으로 살아가는 데 스스로를 힘들게 만드는\n요소들이 많았습니다. 다른 사람을 믿지 못해 제 고민을 이야기하지 않았고, 문제의 해결은 큰\n노력없이 시간이 해결해주기만을 기다렸습니다. 그리고 이런 방식은 저를 고립시키고, 더욱 더 외로워지게 만들었습니다.\n제게 변화가 필요했다는 것은 확실했고, 제가 이를 해결하기 위해 선택한 방법은 현재 속한 환경에서 벗어나는 것이었습니다.\n\n---\n\n## 굳이 새로운 환경을 찾은 이유\n\n기존의 환경 내에서도 변화를 이루는 것이 가능했을지도 모르지만, 저 같은 경우는 환경을 바꿀 때 생기는 변화들을 통해\n현재의 사람이 되어오는 자기 갱신의 경험들을 체험해온 것이 이런 도전을 선택하게 된 원인입니다. 구체적인 예시로 고등학교는\n공주에 있는 한일 고등학교라는 조그만 기숙학교를, 군 생활은 카투사(KATUSA)로 복무하면서 겪은 경험들이 기존의 환경과는\n완전히 달랐고 그곳에서 생활하면서 새로운 자신을 발견하는 경험들을 할 수 있었기 때문입니다.\n\n한일 고등학교는, 지금은 바뀌었을 것으로 생각되지만, 전원이 기숙사에서 생활하며 학원이 아니라 스스로 학습을 해야만\n하는 환경이란 점이 기존과 달랐습니다. 이는 중학교 때까지 무언가를 배우기 위해서는 항상 학원부터 찾았던 저에게는 큰 변화를\n가져왔습니다. 한일고를 다니면서 저는 매일 아침에 그 날의 할 일을 계획하고 실천하며 피드백하는 것을 습관으로 만드는 과정을\n거쳤고, 이를 통해 저는 스스로 문제를 해결할 줄 아는 사람이 되었습니다. 그리고 이를 통해 나름 괜찮은 대학에 진학할\n수 있었습니다.\n\nKATUSA는 Korean Augmentation To the United States Army의 약자로, 한국 군대의 병력을 미군에게 보조하는 역할을\n하는 군인들을 일컫는 말입니다. 해당 프로그램을 통해 저는 미국인들과 함께 생활하면서 다양한 문화를 경험하고\n새로운 사람들과 친구가 되는 경험을 통해 다름을 인정하고 존중하는 사람이 될 수 있었습니다. 낚시와 사냥을 좋아하는\n상사와 휴일에 화천 산천어 축제를 가거나, 서울 구경을 하면서 나에게 익숙한 것이 다른 사람에게는 독특하고 신기하며\n당연하지 않다는 사실을 배울 수 있었습니다. 이러한 경험들을 통해 저는 다름을 인정하고 존중할 수 있는 능력을 길렀기\n때문에 새로운 사람과 환경에서 변화하는 것에 대해 긍정적인 태도를 가지게 되었습니다.\n\n---\n\n## 마치며\n\n이처럼 기존에 속한 환경을 바꾸는 것을 통해 새로운 것을 체험하고, 자신을 되돌아보면서 재구축하는 경험은 저에게\n항상 긍정적인 변화를 가져다주었습니다. 그렇기 때문에 2년 전에 퇴사를 하고 탐색기를 가지기 위해 새로운 환경으로\n떠난 것은 제게 있어서 굉장히 인생을 충만하게 채워주었고, 이를 통해 새로운 나를 발견하고 성장할 수 있었다 생각합니다.\n\n다음 글에서는 이러한 탐색기를 통해 어떤 변화를 이루었는지, 그리고 이를 통해 얻은 것들이 무엇인지에 대해 이야기해보겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"비어있는 공백기가 아니라 충만했던 탐색기(1)","subtitle":"새로움을 경험하며 나를 돌아보다","date":"2024-05-15T00:00:00.000Z","categories":"신변잡기","series":"비어있는 공백기가 아니라 충만했던 탐색기","seriesIndex":1}},{"postName":"2024-05-07-from odds and ends to room","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/2024-05-07-from odds and ends to room.md","category":"신변잡기","title":"정리를 통해 잠만 자는 공간에서 나로써 존재할 수 있는 공간으로","subtitle":"잡동사니에서 방으로","content":"\n### 목차\n\n- [정리를 통해 인생 최초로 내 공간을 얻다](#정리를-통해-인생-최초로-내-공간을-얻다)\n- [아시아 사람은 집에는 관심이 많으면서 정작 꾸미는데는 관심이 없다](#아시아-사람은-집에는-관심이-많으면서-정작-꾸미는데는-관심이-없다)\n- [마무리](#마무리)\n\n---\n\n## 정리를 통해 인생 최초로 내 공간을 얻다\n\n부끄러운 이야기입니다만, 며칠 전에서야 제 인생 처음으로 옷장과 방을 스스로 정리했습니다. 방을 청소하거나 정리해본 적이 여태까지 없다는\n 것은 아니라 이것들을 어떻게하면 내 생활 패턴에 어울리는 형태로 자리를 잡게 만들어 내 개성을 드러내는 공간으로 사용한 것은 이번이\n 처음이었습니다. 그런 과정을 통해 나는 여태까지 내 부모님이 만들어주신 방을 쓰거나 학교에서 제공하는 공동의 공간으로써 자연발생적인\n 방을 가졌던적은 있지만, 이번처럼 '내 공간'이라 할 수 있는 곳은 처음 사용해본 것 같다는 생각이 들었습니다.\n\n옷걸이 전반을 내가 원하는 순서대로 재배치하고 옷걸이에 올라가지 않는 옷은 분류하는 과정을 통하다보니 프로그래머로써의 관점에서 '디자인이\n 아니라 기능만이 중요한 운동복 같은 옷이라면 큐처럼 선입선출로 관리할 방법이 없을까?'와 같은 질문에 도달하기도 했습니다. 지구의 중력을\n 거스르는 일은 워낙에 대단한 일이기에 이에 도달하지는 못했지만, 옷 정리 트레이를 구매하고 이에 포개서 옷을 정렬해두니 제 개성이 드러나는\n 공간이 되는 것을 볼 수 있었습니다.\n\n제 공간에서 드러나는 개성은 유지 관리 용이한 시스템을 구축하는 것을 좋아한다는 점입니다. 그러기 위해 가장 많이 사용하는 물건은\n 접근성이 높은 공간에 사용 빈도가 낮은 물건은 접근성이 낮은 공간에 두고, 비슷한 성향의 물건들은 같은 곳에 관리합니다. 그리고 이 방이\n 단순히 제 노력만으로 유지되는 것이 아니라 적은 노력과 자연스러움으로도 유지될 수 있도록 박스, 트레이, 선반과 같은 도구로 시스템을\n 갖춰두었습니다.\n\n---\n\n## 아시아 사람은 집에는 관심이 많으면서 정작 꾸미는데는 관심이 없다\n\n얼마 전 외국인들이 가지는 의문 중에 아시아인들은 왜 집을 꾸미는 데에는 관심이 없느냐는 이야기를 본 적이 있습니다. 아시아인들이 집에\n 대해 보이는 관심은 지대한 데 반해, 정작 이를 꾸미는 노력은 서양 사람들이 바라볼 때 이해하기 힘들 정도로 부족하다는 것입니다. 해당 영상\n에서는 이에 대해 집은 '가격, 부지, 평수'와 같이 남들과 정량적으로 비교를 통해 계급을 나타내는 수단으로 사용할 수 있는 반면, 집을 꾸미는\n 것은 '개인의 취향과 개성을 드러내는 수단'이기 때문이라 이야기합니다.\n\n이에 대해 무조건적인 동의를 할 수는 없습니다만, 저와 제 가족의 사례로 놓고 봤을 때는 이 이야기가 어느 정도 맞다고 생각합니다. 저희\n 가족은 집에서 방을 단순히 잠을 자고 일어나 밖을 나가기 위해 정비하기 위한 일종의 전투기의 격납고 같은 공간으로써만 활용해 왔습니다.\n 제 가족에게 중요한 것은 해당 집이 역세권 몇분 거리인지, 서울에서 얼마나 떨어져있는지, 주변에 편의시설이 얼마나 있는지와 같은 외적인\n 요소 뿐이었습니다. 집을 꾸미는 것은 남들이 다들 하는 것을 따라하는 것이면 족했습니다. 그리고 이제는 그런 집에서 벗어나고 싶다고\n 생각하고 이를 위해 노력하려 합니다.\n\n---\n\n## 마무리\n\n정리와 내 물건들로 방을 꾸미는 것은 제 개성을 드러내는 것이며 동시에 방을 격납고가 아니라 내가 나로써 있을 공간으로 만들어주는 행위\n라는 사실을 이번 일을 계기로 깨달을 수 있었습니다. 정리를 하고 빈 공간이 생기니 이를 채우기 위한 아이디어가 떠오르고, 그것을 실행하니\n 또 다른 아이디어가 떠오르는 과정을 통해 제 방은 점점 더 나를 닮아가고 있습니다.\n\n그러다보니 현재 제 방에는 얼마 전까지는 없었던 스피커, 가습기, 옷장 정리 트레이, 피규어 같은 물건들이 들어오게 되었습니다. 그리고\n 이전에는 방을 단순히 잠을 자면 족하던 공간으로 생각했지만 이제는 제 방이 제가 나로써 가장 자연스럽게 존재할 수 있는 공간이 되었다고\n 생각합니다. 이제 곧 얼마 전 구매한 베개가 오면 그것들은 또 제 방을 더 나로써 가깝게 만들어줄 것이 즐겁게 기대되네요. 앞으로도 제 방을\n 더 나에게 가깝고 나로써 존재할 수 있는 공간으로 만들어가는 과정을 즐기며 이를 통해 나를 더 알아가고 싶습니다. 그러기 위해선 먼저\n 정리부터 시작해야 하겠지만요.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"정리를 통해 잠만 자는 공간에서 나로써 존재할 수 있는 공간으로","subtitle":"잡동사니에서 방으로","date":"2024-05-07T00:00:00.000Z","categories":"신변잡기"}},{"postName":"2024-05-03-수단이 아닌 목적으로써의 면접을 위하여(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/신변잡기/수단이 아닌 목적으로써의 면접을 위하여/2024-05-03-수단이 아닌 목적으로써의 면접을 위하여(3).md","category":"신변잡기","title":"합격보다 소통을 목표로 하는 면접을 위하여(3)","subtitle":"나에게 관심을 가져주는 기업과의 면접","content":"\n### 목차\n\n- [대화의 기본은 상대방에게 관심을 가져주는 것이다](#대화의-기본은-상대방에게-관심을-가져주는-것이다)\n- [나에게 관심을 가져주는 기업과의 면접 vs 나에게 관심을 가져주지 않는 기업과의 면접](#나에게-관심을-가져주는-기업과의-면접-vs-나에게-관심을-가져주지-않는-기업과의-면접)\n- [스스로를 드러내는 기업과의 면접 vs 스스로를 드러내지 않는 기업과의 면접](#스스로를-드러내는-기업과의-면접-vs-스스로를-드러내지-않는-기업과의-면접)\n- [마무리](#마무리)\n\n---\n\n## 대화의 기본은 상대방에게 관심을 가져주는 것이다\n\n상대방에게 관심을 가지는 것이 대화의 기본이라고 저는 생각합니다. 면접을 기준으로 이야기하면 상대편이 공개하는 정보만을 피상적으로\n 파악하고 대화에 나서는 것이 아니라, 그 정보를 기반으로 드러내지 않은 것들에 대한 질문을 던지는 것이 관심을 가지는 방법이라고 생각\n합니다.\n\n이런 질문을 맞이했을 때 때로는 다른 사람의 시선으로 본 사실로부터 알아낼 수 있는, 본인도 생각하지 못했던 사실을 알게 되는 경우도\n 많았습니다. 이런 대화를 경험했을 때는 몰랐던 자신의 모습을 발견하고 그것을 통해 자신을 더 잘 이해할 수 있게 되는 체험을 하게\n 되기도 합니다. 반면에 관심을 이 없는 대화를 진행했을 때 그 경험은 서로 준비한 대답을 주고받는 것에 그치게 되기 때문에 상대방이\n 꾸며낸 모습만을 보게 됩니다.\n\n그렇기 때문에 상대에게 관심을 가지고 대화를 나누어야 진정으로 서로를 이해할 수 있고 서로에게 도움이 되는 대화를 할 수 있습니다. 즉,\n 대화를 통해 서로간에 소통이 이루어지기 위한 가장 기본적인 요소는 상대에게 관심을 가지는 것이라고 저는 생각합니다.\n\n---\n\n## 나에게 관심을 가져주는 기업과의 면접 vs 나에게 관심을 가져주지 않는 기업과의 면접\n\n이력서란 것을 결국 수십, 수백개씩 보기 때문에 그 안에 담긴 정보들이 비슷비슷해 채용 담당자라면 이를 파헤치고 옥석을 가리기 위해 노력하는\n 것이 굉장히 괴로운 일이란 것은 저도 백번 이해합니다. 제가 동일한 입장이더라도 이력서를 보는 것은 굉장히 힘들고, 특히 저처럼 이력서 안에\n 자신을 잘 정제해서 담아내는 능력이 부족해서 상대에게 제대로 전달하지 못하는 경우에는 더욱 힘들 것이라 생각합니다. 그렇기 때문에 면접을\n 보는 과정에서 저에게 관심을 가져주고 조사를 통해 질문을 준비해 온 기업과 그렇지 않은 기업의 차이는 굉장히 크게 받아들여졌습니다.\n\n심할 정도로 저에게 관심을 가져주지 않는 면접의 경우 면접관이 현장에서 이력서를 받아보고 질문을 던지는 것에 그치는 경우도 있었습니다. 그럴\n 경우에 받은 질문에는 본인의 성격은 어떠냐, 동생은 있냐는 질문이 있었습니다. 그런 질문을 통해 사람의 성격을 파악할 수 있을지는 모르겠\n습니다만, 이렇게 만나보기 전에 관심이 있는 것도 아니어서 저를 알아보고 오지도 않았는데 면접을 보자는 제안을 받아 진행한 경우에는 대부분\n 경험이 좋지 않았습니다.\n\n반면에 저에게 관심을 가져주는 면접의 경우에는 이력서에 적힌 내용과 블로그, 깃허브 등을 통해 저를 파악하고 그것을 기반으로 제가 드러내지\n 않은 내용들에 대해서 질문을 던지는 경우가 많았습니다. 예시를 들자면 '외로워서 이전에 퇴사하셨다고 이야기하셨는데, 지금 이전의 회사로\n 돌아가신다면 동일한 일이 반복될 것이라 생각하세요? 이번에는 어떤 점이 다를 것이라 생각하세요?'와 같은 질문을 받기도 했습니다. 이런\n 저에 대한 진정한 관심을 보여주는 질문을 하면 저 역시도 해당 기업에 신뢰를 가질 수 있고, 기업 역시도 제가 준비한 꾸며낸 모습이 아닌\n 감춰둔 내면을 볼 수 있기에 서로에게 이득이 되는 대화가 될 수 있다고 생각합니다.\n\n---\n\n## 스스로를 드러내는 기업과의 면접 vs 스스로를 드러내지 않는 기업과의 면접\n\n회사 내의 업무만을 처리하는 것으로도 감당하기 힘들 정도의 격무에 다들 시달리고 있기 때문에 따로 준비하기 힘들다는 것은 알지만,\n 그렇더라도 본인을 드러내는 기업과 드러내지 않는 기업은 지원자에게 큰 차이로 다가옵니다. 우리가 마치 소개팅과 같이 중요한 상대방과의\n 만남을 앞두고 있을 때 본인의 멋진 점을 어필하기 위해 드러내는 방법을 고민하고 꾸미는 것처럼, 기업 역시도 본인이 원하는 인재를 영입하기\n 위해서는 자신이 매력있는 기업이라는 것을 보여주어야 한다고 생각합니다.\n\n이 때 매력을 단순히 금전적인 것이나 복지 등으로 한정해서 생각해서는 안된다 생각합니다. 복지와 금전적인 보상은 정량적으로 서열을 매길 수\n 있기 때문에 이를 통해서는 본인보다 높은 보상을 제시할 수 있는 기업을 찾기도 쉽고, 이것만을 경쟁력으로 삼는다면 인재는 더 높은 서열의\n 기업들에 지원하게 될 것이기 때문입니다. 이 때문에 기업 역시도 본인이 금전적인 것 뿐 아니라 기업 문화나 서로를 존중하는 분위기와 같은\n 정성적인 것들을 기르고 드러내기 위해 노력해야 한다고 생각합니다.\n\n주의할 점은 이런 정성적인 문화와 같은 것은 단순히 보도자료를 한 두번 채용 페이지에 적어놓는 것으로 충분히 어필하는 것이 불가능하다는 점\n입니다. 마치 우리가 사람의 성격을 판단할 때 그 사람의 말이 아니라 행동을 보고 판단하는 것처럼 기업 역시도 본인이 어필하고 싶은 것을\n 행동으로 보여주어야 한다고 생각합니다. 그리고 이를 꾸준히 밖으로 표현하는 방법에 대해 고민하고 실천해야 한다고 생각합니다.\n\n---\n\n## 마무리\n\n취업을 위한 면접에 대해서 부정적인 생각을 가지고 있는 사람이 많고 그럴만한 경험을 실제로 많이 하는 것이 사실입니다. 하지만 서로에게 충\n분한 관심을 가지고 단순히 취업을 위한 과정이 아니라 새로운 사람을 만나 본인에 대한 이야기를 나누는 시간이라 생각하면, 면접이라는 과정은\n 스스로에 대해 더 잘 이해하도록 많은 회사들에서 자발적으로 시간을 써가며 도움을 주는 것으로도 볼 수 있다고 저는 느껴졌습니다.\n 사실 인생에서 유명인이 아닌 이상 우리 얘기를 받아적기까지 하면서 들어주는 호사를 언제 느껴볼 수 있겠어요?\n\n그러니 면접을 통과점으로만 생각하기보다 서로에게 관심을 가지고 대화를 나누는 시간으로 생각하면, 그 과정에서 많은 것을 얻을 수\n 있다 생각합니다. 독자 분들께 앞으로 있을 많은 면접들이 관심으로 가득한 진정한 소통을 통해 서로에게 도움이 되는 시간들이 되기를 바랍니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"합격보다 소통을 목표로 하는 면접을 위하여(3)","subtitle":"나에게 관심을 가져주는 기업과의 면접","date":"2024-05-03T00:00:00.000Z","categories":"신변잡기","published":true,"series":"합격보다 소통을 목표로 하는 면접을 위하여","seriesIndex":3}}]},{"category":"게임이야기","posts":[{"postName":"2024-05-18-게임에서 볼 수 있는 두려움의 활용","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-05-18-게임에서 볼 수 있는 두려움의 활용.md","category":"게임이야기","title":"게임은 어떻게 두려움을 통해 유저를 영웅으로 만드는가","subtitle":"손실 회피 경향을 통해 살펴본 게임 속 두려움","content":"\n### 목차\n\n- [게임에서 볼 수 있는 두려움의 종류들](#게임에서-볼-수-있는-두려움의-종류들)\n- [두려움이란 무엇이고 어디서 오는가](#두려움이란-무엇이고-어디서-오는가)\n- [게임은 두려움으로 어떻게 유저를 영웅으로 만드는가](#게임은-두려움으로-어떻게-유저를-영웅으로-만드는가)\n- [마치며](#마치며)\n\n---\n\n## 게임에서 볼 수 있는 두려움의 종류들\n\n[![nameless name](https://img.youtube.com/vi/WrWga0k-fzE/hqdefault.jpg)](https://www.youtube.com/watch?v=WrWga0k-fzE)\n\n오늘 걸즈 밴드 크러시라는 애니메이션을 보다가 나온 두려움을 안고 하고 싶은 것을 하는 용기에 대해 이야기하는\n것을 보고 큰 감명을 받고, 저는 그런 두려움을 어디에서 극복하는지에 대해 생각해보았습니다. 그리고 그것이 게임에서\n활용되는 경우가 굉장히 많고 제가 이를 극복하는 과정을 통해 영웅이 되는 것을 느끼는 즐거움을 경험한다는 사실을\n깨달을 수 있었습니다.\n\n게임에서는 다양한 형태의 두려움을 볼 수 있습니다. 부쉬 속 정글러어어, 모르면 맞아야지, 감나빗!, 상상 속의\n니비루, 차오르는 스트레스 수치와 깎여나가는 체력. 이처럼 게임에서는 다양한 형태의 두려움을 경험할 수 있고 우리는\n이를 극복하며 게임을 즐기게 됩니다.\n\n---\n\n## 두려움이란 무엇이고 어디서 오는가\n\n그런데 두려움이란 무엇이고 어디서 오는 것일까요? 저는 두려움이란 생물이 가진 손실 회피 본능을 구체화 시켜 놓아\n생존율을 높이기 위해 발생한 감정이라고 생각합니다. 즉 손해를 보는 것이 생존과 직결되는 상황에서 이를 회피하기\n위해 두려움이라는 감정이 발생한다는 것이 제 주장입니다.\n\n제 생각이 맞다면 두려움이 발생하기 때문에 우리는 손실이 발생할 수 있는 상황에서 안전한 선택을 하도록 유도되며,\n이를 통해 두려움을 받아들이는 객체들이 생존을 더 잘 할 수 있게 되면서 진화를 거듭한 겁쟁이들의 후손이 우리일 것입니다.\n게임이랑 다르게 우리는 현실에서 위험한 상황을 맞이했을 때 이를 맞부딪혔다가 실패할 경우 죽음까지는 아니더라도\n복구하기 어려운 손실을 입게 될 수도 있으니까요.\n\n---\n\n## 게임은 두려움으로 어떻게 유저를 영웅으로 만드는가\n\n왜 게임에서는 우리가 현실에서 피하기 위해 노력하는 두려움을 활용할까요? 저는 게임이 현실에서는 불가능한 체험을\n제공하는 것을 목표로 하기 때문이라고 생각합니다. 현실에서 우리는 진상 손님을 만났을 때 손님은 왕이라며 요구에\n응해야 하거나, 길에서 담배를 피우는 중고등학생 무리를 만났을 때 무리를 피해야 하는 등의 상황에서 두려움에 굴복하고\n피해나가야 합니다. 하지만 우리는 가슴 한 구석에서는 그런 두려움을 극복하고 마주해서 이겨내는 영웅이 되는 것을\n꿈꾸곤 합니다.\n\n그리고 게임은 여러 종류의 적당히 극복 가능한 두려움을 곳곳에 배치하여 우리에게 도망치지 않고 맞서 싸우도록 유도합니다.\n유저는 이 두려움으로부터 도망치는 현실에서의 자신이 아니라, 모두가 한 명의 영웅이 되어 시련을 극복하고 특별한\n한 사람이 되는 경험을 통해 게임을 즐깁니다.\n\n---\n\n## 마치며\n\n오늘은 게임에서 두려움이 어떻게 유저를 영웅으로 만드는지에 대해 이야기해보았습니다. 두려움은 우리가 손실을\n회피하기 위해 발생하는 감정이라고 생각하며, 게임에서 두려움은 현실에서와 달리 극복 가능한 상황으로 제공되어\n유저가 영웅이 되는 장치로 활용됩니다.\n\n다음에는 게임에서 활용되는 두려움의 구체적인 성공 사례 및 실패 사례들을 통해 두려움을 활용하는 방법에 대해\n이야기해보겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"게임은 어떻게 두려움을 통해 유저를 영웅으로 만드는가","subtitle":"손실 회피 경향을 통해 살펴본 게임 속 두려움","date":"2024-05-18T00:00:00.000Z","categories":"게임이야기","series":"게임이 두려움을 통해 유저를 영웅으로 만드는 방법","seriesIndex":1}},{"postName":"2024-05-04-우마무스메 개론-3","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-05-04-우마무스메 개론-3.md","category":"게임이야기","title":"전술을 수립하고 룸매치를 통해 최종 점검하자","subtitle":"우마무스메 개론(3)","content":"\n### 목차\n\n- [역대급 팀이 있어도 클린스만은 아시안컵을 우승하지 못했다](#역대급-팀이-있어도-클린스만은-아시안컵을-우승하지-못했다)\n- [자신의 에이스 우마무스메의 승리 플랜은 무엇인가](#자신의-에이스-우마무스메의-승리-플랜은-무엇인가)\n- [초반에 경합을 발생시킬 것인가, 아니면 후반에 승부를 가릴 것인가](#초반에-경합을-발생시킬-것인가-아니면-후반에-승부를-가릴-것인가)\n- [룸매치와 실전을 통해 환경을 최종 점검하자](#룸매치와-실전을-통해-환경을-최종-점검하자)\n- [마치며](#마치며)\n\n---\n\n## 역대급 팀이 있어도 클린스만은 아시안컵을 우승하지 못했다\n\n최근 한국 사람들을 경악케 한 사건이 하나 있었습니다. 소위 황금세대라고도 불리는 역대급 선수들로 구성된 한국 아시안컵 축구 대표팀이\n 결승에서 석패를 한 것도 아니라, 4강 진출에 그쳤을 뿐 아니라 내적인 경기력도 참담했다는 점입니다. 그리고 그 주 요인으로 꼽힌 것은 바로\n 감독인 클린스만의 전술 부재였습니다. 그리고 우마무스메 프리티 더비 역시 마찬가지로 올바른 전략 전술을 수립하지 않는다면 어떤 역대급\n 우마무스메를 육성하는 데 성공하더라도 이를 활용하지 못하고 무용지물로 만들 수도 있습니다.\n\n이 때문에 이 게임의 기본적인 전략을 이해하고 자신의 전략을 수립하는 것이 중요합니다. 이번에는 이를 위한 방법을 이야기해보려 합니다.\n\n---\n\n## 자신의 에이스 우마무스메의 승리 플랜은 무엇인가\n\n이 게임에서 가장 먼저 이해해야하는 것은 자신이 에이스 주자로 사용할 우마무스메가 어떤 승리 플랜을 이해하는 것입니다. 2차 카프리콘 배의\n 추입마였던 두 다른 승리 플랜을 가지고 있는 우마무스메인 나리타 타이신과 응원단장 킹 헤일로와 같은 사례를 놓고 보면 이는 극명하게\n 드러납니다.\n\n나리타 타이신의 가장 큰 장점은 순위조건이 부재하고 위력은 조금 약하지만 최속의 타이밍에 발동하는 육박하는 그림자라는 현재 유일무이한\n 금딱 가속기를 내장하고 있으며, 이를 뒷받침하기 위해 다른 추입마들에 비해 비교적 빠른 중반 타이밍에 발동하는 속도 증가 고유기인\n Nemesis를 보유하고 있다는 점입니다. 즉 나리타 타이신은 여타 골드쉽으로 대표되는 롱스퍼트형 추입마들과 동일한 승리 공식을 가지고\n 있습니다. 추입마이지만 앞 각질을 중반 타이밍에 빠르게 치고 나와 그들과 비슷한 위치에서 뛰쳐나간다는 점입니다.\n\n반면 킹 헤일로는 원본마가 그러했듯 굉장히 낭만 넘치는 승리 플랜을 가지고 있습니다. 타카마츠노미야 기념에서 마생 최초이자 마지막 g1 우승\n을 이룬 킹 헤일로는 해당 경주에서 종반부에 이길 수 있다고 상상하기 힘들 정도로 뒤에 위치하고 있었지만, 말도 안되는 속도로 가장 바깥에서\n 치고 들어오며 나머지 경쟁자들을 휩쓸어버리는 경주를 했습니다. 이 경기를 모티프로 한 응원단장 킹 헤일로는 후반부까지 뒤에서 힘을 모은 뒤\n 마지막 순간에 폭발적인 속도로 앞으로 나아가는 승리 플랜을 가지고 있습니다.\n\n이 두가지 다른 우마무스메가 각각 승리하기 위해서는 어떤 승리 플랜을 사용하는 것이 좋을까요? 저는 나리타 타이신은 초중반에 경합이\n 발생하는 편성 상에서, 킹 헤일로는 가능한 적은 경합만 이루어진 상태로 후반부에 승부를 가리는 편성을 사용하는 것이 좋다고 생각합니다.\n 그렇다면 각각의 승리 플랜에 맞는 편성은 어떤 구성을 의미하는 것일까요?\n\n---\n\n## 초반에 경합을 발생시킬 것인가, 아니면 후반에 승부를 가릴 것인가\n\n우마무스메라는 게임은 경합이 이루어지는 구간이 일반적으로 초반, 중반, 후반 한번씩으로 나누어져있는 게임입니다. 이 때 초반부터 경합이\n 나기 위해서는 자신과 같은 혹은 바로 앞의 각질의 숫자가 얼마나 있느냐에 따라 결정됩니다. 이 때문에 추입마인 나리타 타이신이 초, 중반부에\n 경합이 이루어지려면 선/추입의 숫자가 많은 편성을 사용하는 것이 좋습니다. 만약 선/추입의 숫자가 적은 도주/선행이 총 여섯 이상인 편성에서\n 경주를 하게 된다면 나리타 타이신의 최대 강점 중 하나인 '7위에서 추격이 활성화 됐을때 발동하는 nemesis'를 사용할 수 없게 될 가능성이\n 높아지기 때문입니다.\n\n반면 킹 헤일로는 중반에 순위조건을 가지고 치고 나가는 스킬도 부재할 뿐더러, 오히려 보유한 고유기는 '진행 거리 비율 50% 이하일 때 순위\n 비율 70%(6~9위)를 유지' 했을 때 발동합니다. 즉 킹 헤일로는 레이스의 전반부에 절대로 앞으로 나서서는 안됩니다. 만약 선/추입이 총 다섯\n 이상인 편성에서 경주를 하게 된다면 초, 중반 경합의 과정에서 킹 헤일로는 본인의 고유기를 사용할 수 없게 될 가능성이 높아집니다. 이 때문에 킹 헤일로는 본인을 제외하고는 도주/선행 위주로 구성된 편성을 사용하는 것이 좋습니다.\n\n|  | 나리타 타이신 | 킹 헤일로 |\n|:---:|:---:|:---:|\n| 승리 플랜 | 초중반에 경합 | 후반에 승부 |\n| 유리 구성 | 도주/선행 5 이하 | 도주/선행 6 이상 |\n| 추천 편성 | 선/추입 둘 이상 | 킹 제외 도주/선행 |\n\n---\n\n## 룸매치와 실전을 통해 환경을 최종 점검하자\n\n이제 자신의 우마무스메가 어떤 승리 플랜을 가지고 있는지, 그에 맞는 편성은 무엇인지 알게 되었습니다. 특히 룸매치의 경우 실전에서 결승에서\n 만날 수 있는 수준의 트레이너와 보통 경쟁하게 되기 마련입니다. 그 사람들이 현재 주로 사용하는 편성은 어떻게 되는지 확인하고, 주로\n 나오는 편성에 대응해서 내 에이스 우마무스메가 승리하기에 유리한 조합을 찾아내는 것이 중요합니다. 예를 들어 룸매치에서 선/추입이 3 이상인\n 경주가 거의 나오지 않는다면 오히려 본인이 킹 헤일로를 사용하더라도 선/추입마를 하나 더 포함하는 편성을 사용하는 것이 좋을 수도 있습니다.\n\n또한 룸매치는 평균 이상의 트레이너와 경쟁한다는 것을 감안해서, 실전에서 확인을 통해 예측한 환경과 현실이 얼마나 일치하는지를 확인할\n 필요도 있습니다. 이 과정을 통해 자신의 편성이 실전에서 얼마나 효과적인지를 확인하고, 필요하다면 편성을 수정하는 것도 중요합니다. 이를\n 위해 저는 함께 게임하는 분들과 실전 환경의 통계를 수집하고 분석해서 편성을 최적화하기도 했습니다. 특히 본인의 통계는 편향성이 있을 수\n 밖에 없기 때문에, 서클원과 같이 다른 사람들의 통계를 함께 수집하고 분석할 수 있다면 이는 승리에 큰 도움이 됩니다.\n\n---\n\n## 마치며\n\n최대한 많은 내용을 담으려고 노력하기는 했지만, 우마무스메 프리티 더비가 워낙에 파고들 것이 많은 복잡한 게임이기 때문에 다루지 못한\n 이야기들도 많아 아쉬움만 남습니다. 다만 어디까지나 개론의 성격으로 기초적인 이론을 모르고 계신 분들께 조금이라도 도움이 됐으면 하는\n 생각에 모자란 펜을 들고 이 글을 쓰게 되었습니다.\n\n우마무스메는 분명 운빨 망겜이 맞습니다. 하지만 그 운을 최대한 자신에게 유리하게 끌어들이는 데 성공하셨다면 모두가 어엿한 트레이너라고\n 생각합니다. 긴 글 읽어주셔서 감사하고 앞으로도 우마무스메 프리티 더비를 즐기는 모든 분들이 행복한 경주를 즐길 수 있기를 바랍니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"전술을 수립하고 룸매치를 통해 최종 점검하자","subtitle":"우마무스메 개론(3)","date":"2024-05-04T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":3}},{"postName":"2024-04-27-우마무스메 개론-2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-27-우마무스메 개론-2.md","category":"게임이야기","title":"인자작 없는 육성은 도박이다","subtitle":"우마무스메 개론(2)","content":"\n### 목차\n\n- [간단한 계산으로 이해하는 타협의 이유](#간단한-계산으로-이해하는-타협의-이유)\n- [유효 육성 횟수를 올리는 방법: 6일이냐, 2일 혹은 2육성이냐](#유효-육성-횟수를-올리는-방법-6일이냐-2일-혹은-2육성이냐)\n- [스킬을 포함하면 최소 20일이 걸리는 육성시간](#스킬을-포함하면-최소-20일이-걸리는-육성시간)\n- [평균적으로 생각하는 인자작으로 충분한 우마무스메를 육성하는 것은 도박이다](#평균적으로-생각하는-인자작으로-충분한-우마무스메를-육성하는-것은-도박이다)\n\n---\n\n## 간단한 계산으로 이해하는 타협의 이유\n\n우마무스메라는 게임은 수많은 확률의 교집합으로 이루어져있고, 이 때문에 타협을 할 기준을 정해두지 않으면 이는 단순히 운을 믿고 도박을 하는 것과 다를 바가 없다고 저는 생각합니다. 이를 위해 그랜드라이브 막바지 시점(2024-04-27)에서 충족 가능한 에이스마의 예시를 통해 왜 그런지 한번 이야기해보려 합니다.\n\n만약 본인이 이번 챔피언스 미팅인 [카프리콘배(2024-05-04 ~ 2024-05-10)](https://namu.wiki/w/%EC%9A%B0%EB%A7%88%EB%AC%B4%EC%8A%A4%EB%A9%94%20%ED%94%84%EB%A6%AC%ED%8B%B0%20%EB%8D%94%EB%B9%84/%EC%9D%B4%EB%B2%A4%ED%8A%B8/%EC%B1%94%ED%94%BC%EC%96%B8%EC%8A%A4%20%EB%AF%B8%ED%8C%85/2%ED%9A%8C%EC%B0%A8#s-2.9)에 출주시킬 우마무스메 중 하나로 킹 헤일로를 선택했다고 가정해보겠습니다. 보통 이야기하는 좋은 우마무스메의 기준이 되는 몇 가지를 예시로 이것이 얼마나 이루어지기 힘든지 한 번 살펴보겠습니다.\n\n```markown\n1. 잔디/단거리 적성이 S이다\n2. 스피드 1500 이상/파워 1100 이상이다\n3. 강공책, 전광석화를 보유하고 있다\n4. 좌회전, 겨울, 맑음, 양호한 경기장과 같은 패시브 스킬을 보유하고 있다.\n5. 직선 주파, 추입 직/코, 단거리 직/코, 꼬리올리기와 속/가속기를 보유하고 있다.\n```\n\n추가로 각각에 따른 가정을 해보겠습니다.\n\n```markown\n1. 잔디/단거리 적성이 S가 될 확률은 육성마다 각각 25%이다.\n2. 스피드 1500 이상 \u0026 파워 1100 \u0026 지능 1000 이상이 될 확률은 육성마다 약 20%이다.\n3. 금딱 스킬을 획득할 확률은 각각 60%이다.\n```\n\n그렇다면 위의 가정을 기준으로 잔디/단거리 둘 중 하나라도 적성이 S이면서, 스피드 1500에 파워 1100인 우마무스메가 필수 금딱 스킬을 모두 보유할 확률은 다음과 같습니다.\n\n$$(0.25 + 0.25 - 0.25^2) \\times 0.2 \\times 0.6^2$$\n$$=0.0315=3.15\\%$$\n\n즉, 모든게 다 완벽하게 갖춰진 상태에서 여러분들이 보통 기본적이라고 생각하는 우마무스메를 육성하는 데에는 못해도 30번 정도의 육성이 필요할 것이란 뜻입니다. 보통 잘 갖춰진 육성을 하는 데에 렌탈을 포함해야하는 것을 감안하면 이는 타협하지 않을 때 단순히 '기초적인' 우마무스메를 육성하는데 인자작을 제외한 본 육성에만 렌탈을 모두 소모하는 것을 가정했을 때 후보로 고려해볼 수 있을 정도는 되는 우마무스메를 육성하는데에 평균 6일의 시간이 필요하단 뜻입니다.\n\n여기에 더해 각종 패시브 스킬과 직/코, 속/가속기를 갖추는 것은 더욱더 어려울 것입니다. 이러한 이유로 타협을 할 기준을 정해두지 않으면 이는 단순히 운을 믿고 도박을 하는 것과 다를 바가 없다고 저는 생각합니다. 이것이 제가 보통 이야기하는 완벽한 우마무스메를 육성하는 것을 목표로 하지 않고 제 나름의 타협을 하는 이유입니다.\n\n---\n\n## 유효 육성 횟수를 올리는 방법: 6일이냐, 2일 혹은 2육성이냐\n\n그런데 여기서 우리가 확률을 높일 수 있는 몇가지 방법이 있습니다. 그 중 하나는 바로 좋은 인자를 사용하는 것이고, 나머지의 예로는 넓은 기준을 사용하는 것입니다. 보통 챔피언스 미팅에서 주전 멤버로 사용하는 우마무스메의 경우 유효 적성을 둘 중 하나를 S로 사용하는 것을 필수로 하는 편이기 때문에 이를 기준으로 한 번 이야기해보면 다음과 같습니다.\n\n만약 단거리 혹은 잔디 적성 S가 나올 확률을 10%씩 올릴 때마다 방금 기준의 우마무스메를 육성 성공할 확률은 3.69%, 4.23%로 상승하며, 이는 둘을 동시에 10%씩 올릴 때마다 4.15%, 5.02%로 상승합니다. 이 게임에서 [적인자 계승 확률 변동폭](https://www.fmkorea.com/5022035640)을 감안할 때, 이는 적인자가 2성인 인자를 3성으로 하나 바꿀 때마다 유효 육성 횟수가 약 3배 증가하기 때문에 필요 육성 횟수가 약 1/3 감소하는 효과가 발생합니다. 참고로 1성 인자와 3성 인자의 차이는 약 15배 정도입니다.\n\n이는 다시 말해 후보로 사용해 볼 수 있는 우마무스메를 육성하는 데에 적인자 1, 2성 하나를 교체할 때마다 6일 걸리던 시간을 2일이나 심지어는 하루 2회 육성으로 단축할 수 있다는 소리가 되고, 다시 말해 그만큼 완성도가 높은 육성을 할 가능성이 올라간다는 뜻입니다. 이 때문에 본인이 거리 혹은 마장 적성 둘 중 하나를 S로 사용하는 것을 필수로 삼는다면, 자신이 사용하는 적인자의 상태부터 점검하는 것이 급선무라 할 수 있습니다. 그리고 다른 백인자나 청인자를 포기하더라도 적인자의 성급을 높이는 타협을 하는 것이 필수적이라 할 수 있습니다.\n\n다음은 제가 실제로 사용했던 적인자 중 하나인 청1 적3 직부모인자의 예시입니다.\n\n![청1 적3 직부모인자](/images/우마무스메%20개론/예시%20청1%20적3%20인자.jpg)\n\n---\n\n## 스킬을 포함하면 최소 20일이 걸리는 육성시간\n\n그런 의미에서 스킬은 적인자보다는 확률이 널널하다고 말할 수 있습니다. 적성은 오로지 계승에 의존해야하는데 반해 스킬은 계승이나 악곡과 같은 시나리오 이벤트, 스킬 힌트, 레이스 보상, 랜덤 카드 이벤트 등 다양한 방법으로 얻을 수 있기 때문입니다. 그렇지만 이 역시도 필수적으로 획득해야하는 흰딱 스킬이라는 것이 가끔은 존재합니다. 대표적으로 추입마인 킹 헤일로의 경우 '직선주파' 혹은 '뒤처지기 방지'와 같은 스킬을 획득하는 것을 필수로 여기는 경우가 많습니다.\n\n그나마 각질 스킬이고 널리 쓰이는 카드인 Mr.CB의 스킬 힌트로도 획득 가능한 직선주파 스킬을 획득하는 확률을 높게 쳐서 40%라고 가정하더라도, 인자작이 되어있지 않을 때 파인 모션, 토카이 테이오, 오구리 캡 이외의 카드로 힌트를 통해 획득하는 것이 불가능하다 봐야하는 뒤처지기 방지의 경우 획득 확률을 10% 정도로 가정했을 때 둘 중 하나의 유효 흰딱 가속기를 획득할 확률은 다음과 같습니다.\n\n$$0.4 + 0.1 - 0.4 \\times 0.1 = 0.46 = 46\\%$$\n\n이는 아까의 기준과 합쳐 생각했을 때 보통 생각하는 '출발선에 서는 우마무스메'의 기준인 '잔디/단거리 적성이 S이고, 스피드 1500 이상\u0026 파워 1100 이상이며,  강공책, 전광석화를 보유하고 있는'데다가 '직선주파 혹은 뒤처지기 방지'와 같은 추가적인 가속도를 가지고 있는 우마무스메를 육성할 가능성은 평균적으로 1.45% 정도밖에 되지 않는다는 사실을 의미합니다. 이는 100번의 육성을 했을 때 1번 정도의 확률로만 나올 수 있는 것을 의미하며 곧 렌탈을 통해 육성을 하려할 경우 육성마 하나에 약 20일의 시간이 필요하단 사실을 의미합니다.\n\n---\n\n## 평균적으로 생각하는 인자작으로 충분한 우마무스메를 육성하는 것은 도박이다\n\n위의 계산들을 통해 사람들이 평균적으로 생각하는 인자작의 수준으로 챔피언스 미팅에서 충분히 쓸만하다고 평가하는 우마무스메의 출발선 정도의 우마무스메를 키우는 것이 거의 불가능하다는 사실을 아실 수 있을 것이라 생각합니다. 챔피언스 미팅의 주기는 보통 한달인 30일 정도이기 때문에, 주자 하나를 테스트하는 것이 가능한 정도까지 육성하는데에만 그것도 적성을 거리와 마장 둘 중 하나만 타협해서 붙여도 약 20일이 걸린다면 셋이나 되는 주자를 육성하는 것은 불가능에 가까우며 사실상 도박에 가깝다 할 수 있습니다.\n\n그런데 20일을 주자로 사용할 우마무스메가 아니라 인자로 사용할 우마무스메를 육성하는 데에 사용한다면 확률을 획기적으로 끌어올릴 수 있게 되고, 이는 렌탈을 이용해서 고점마를 육성하는 것이 아니라 인자작을 하는 데 사용하는 것이 훨씬 효율적이란 사실을 의미합니다. 이러한 이유로 저는 사람들이 평균적으로 '충분하다'라고 평가하는 인자작의 수준은 충분에서 거리가 멀며 본인이 생각하는 것보다 훨씬 도박에 가깝다 생각합니다. 그러므로 본인이 진지하게 챔피언스 미팅에 출전하고자 하는 트레이너이고 인자작을 남들만큼 했다고 생각한다면, 그것이 충분한 것에서 많이 모자라며 훨씬 공을 들일 필요가 있습니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인자작 없는 육성은 도박이다","subtitle":"우마무스메 개론(2)","date":"2024-04-27T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":2}},{"postName":"2024-04-20-우마무스메 개론-1","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-20-우마무스메 개론-1.md","category":"게임이야기","title":"200만원으로 우마무스메 12/15관을 달성한 비결","subtitle":"우마무스메 개론(1)","content":"\n### 목차\n\n- [우마무스메는 운빨 망겜이 아니다](#우마무스메는-운빨-망겜이-아니다)\n- [자기소개](#자기소개)\n- [완벽한 도자기를 깎는 것이 최적의 방법은 아니다](#완벽한-도자기를-깎는-것이-최적의-방법은-아니다)\n- [최적해는 인자작 복리를 이용하는 것이다](#최적해는-인자작-복리를-이용하는-것이다)\n  - [증조부 인자작 한 것 예시](#증조부-인자작-한-것-예시)\n\n---\n\n## 우마무스메는 운빨 망겜이 아니다\n\n우마무스메는 수많은 확률의 누적으로 이루어진 게임입니다. 게임을 하기 위해 갖춰야하는 장비와 캐릭터에 해당하는 우마무스메와 서포터 카드를 뽑는 것은 가챠를 통해서 얻고, 육성을 하는 과정의 모든 턴에 발생하는 이벤트는 확률에 의해 결정되는데, 스킬을 획득하는 것도 확률, 발동하는 것도 확률, 적성이 올라가는 것도 확률, 자기보다 강하거나 약한 상대를 만나는 것도 확률, 어느 레인에 걸리는지도 확률, 늦은 출발을 하느냐도 확률입니다.\n\n이 때문에 사람들은 소위 우마무스메를 현대적으로 해석한 서브 컬쳐 파칭코 혹은 디아블로라고도 합니다. 유저가 게임의 결과에 대해 가질 수 있는 통제권이 마치 슬롯머신에서 레버를 당기는 횟수를 제외하고 없는 것과 마찬가지로 육성 횟수와 참여 횟수와 같은 시행횟수를 늘리는 것 뿐이라는 것이 그 이유입니다. 그러나 저는 이것이 잘못된 해석이라고 생각합니다.\n\n우마무스메는 분명 확률의 누적으로 이루어진 게임입니다만, 유저가 노력을 통해서 유리한 결과가 일어나도록 확률을 조작할 수 있는 여러 가지 방법이 존재하고, 이를 과학적으로 접근해서 육성에 방향성을 주는 것을 통해 유저는 게임을 유리한 방향으로 통제할 수 있습니다. 이는 마치 포커와 같은 게임이 분명 확률의 누적으로 이루어져 있고 그 운을 뛰어넘는 것은 불가능하지만, 승률이 높은 사람이 존재하는 것과 마찬가지입니다.\n\n이 글에서는 우마무스메를 과학적으로 접근해서 승리를 단순히 운에 맡기지 않고, 원리에 대한 이해와 이를 이용한 전략 수립 및 실천을 통해 고수 트레이너가 되는 방법을 이야기해보려 합니다.\n\n---\n\n## 자기소개\n\n제가 가장 좋아하는 우마무스메는 킹 헤일로, 그 이유는 쏟아지는 중압감과 실패 속에서도 좌절하지 않고 끝까지 도전해서 마침내 우승을 쟁취하는 킹에게 감동받았기 때문입니다. 그 다음은 파인 모션입니다. 우마무스메 프리티 더비라는 게임은 킹이 아니라 하더라도 수 많은 우마무스메들이 힘겨운 순간들을 견디고, 끝까지 도전해서 목표를 쟁취하는 노력하는 모습이 너무나도 감동적이기 때문에 하나하나가 너무 매력 넘치고 비록 플레이하면서 괴로울 때도 많았지만 제 인생에서 가장 좋아하는 게임 중 하나입니다.\n\n저는 우마무스메 프리티더비를 키타산 블랙 서포터카드 픽업 당시 시작해 1차 타우러스 챔피언스 미팅부터 참가해 2차 레오배까지 총 16회의 챔피언스 미팅 중 15회에 참가해 12회의 플래티넘을 달성한 트레이너입니다. 제가 플래티넘을 달성한 챔피언스 미팅은 1차는 제미니, 캔서, 버고, 리브라, 스콜피오, 사지타리우스, 피스케스, 아쿠아리우스, 카프리콘이며 2차는 타우러스, 제미니, 레오배입니다.\n\n![플래티넘 칭호 일부](/images/우마무스메%20개론/플래티넘%20칭호%20일부.png)\n\n우승시에 사용한 우마무스메는 1착 기준으로 응원단장 킹 헤일로, 발렌타인 미호노 부르봉, 스마트 팔콘, 나리타 타이신, 세이운 스카이, 수영복 마루젠스키, 골드 쉽이 있습니다. 특히 아오하루배는 전관을 도주로 플래티넘을 달성하기도 했습니다. 관련된 영상이 궁금하신 분은 [다음 유튜브 영상들](https://www.youtube.com/@prosy1719/videos)을 참고해주세요.\n\n---\n\n## 완벽한 도자기를 깎는 것이 최적의 방법은 아니다\n\n우마무스메를 플레이 할 때 '완벽한 도자기를 깎는 것'과 같이 하시는 분들이 꽤나 많습니다. 인터넷에서 돌아다니는 공략들을 통해서 어느 스탯과 스킬을 보유하고 있어야 하는 지에 대한 가이드를 찾고, 그 기준에 부합할 때까지 우마무스메를 육성하는 것입니다. 특히 이 공략들은 소위 미래시라 불리는 일본 서버를 플레이한 경험자들이 자신의 체험을 통해 제시한 것이기 때문에 이를 무비판적으로 수용하고 그것이 안 나오면 '나는 이렇게 노력하는데 운이 없어서 이길 수 없다'라고 생각하거나, 그것이 나왔는데도 질 경우 '나는 잘 했는데 운빨 망겜이라 계속 진다'라고 생각하기도 합니다.\n\n얼핏 합리적으로 보이는 이 육성 방법에는 문제점이 몇 가지 있습니다.\n\n1. 우마무스메에 완벽함은 시스템적으로 존재할 수 없다.\n2. 완벽함의 기준에 대한 검증이 부족하다.\n3. 완벽함을 달성하는 것은 너무 확률이 낮기 때문에 시간이 많이 필요하다.\n4. 한국 서버와 일본 서버의 환경이 다르기 때문에 강한 우마무스메의 형태와 편성이 다른 경우가 많다.\n\n우마무스메 프리티더비는 완벽한 플레이가 불가능한 게임입니다. 그렇기 때문에 저는 이 게임에서 가장 중요한 것 중 하나는 스스로의 타협 지점에 대해 설정해 두는 것이라 생각합니다. 포커를 플레이할 때 본인의 칩이 떨어져가서 쫓기듯이 올인 배팅을 하는 것이 아니라, 자신이 생각해 둔 한계 지점을 기반으로 게임을 빌드업해 나가듯이 본인이 멈춰야 하는 지점에 대해 생각해야합니다.\n\n타인이 정한 기준의 완벽함을 달성하더라도 그것은 해당 기준을 완벽하게 만족한다는 것이지, 최강의 우마무스메를 육성하는데 성공했다는 것과는 다릅니다. 과거의 데이터만을 기반으로 이를 목표를 수립하고 현재에 대한 피드백을 하지 않는 것은 굉장히 문제가 있는 접근 방법입니다. 한국 서버는 일본 서버와 달리 시기적으로 일찍 유저들이 학습한 개념적인 부분을 활용하는 경우가 굉장히 잦습니다. 대표적인 것이 1차 캔서배 스마트 팔콘입니다. 일본에서 1차 캔서배 때 스마트 팔콘은 소위 '뚜껑'이라고 불리는 용도로 제한적으로 사용됐지만, 한국에서는 1차 캔서배부터 스마트 팔콘을 에이스로 활용한 전략이 활발하게 사용되었습니다.\n\n이런 이유들 때문에 단순히 남이 정해준 기준을 만족하는 완벽함을 추구하는 것은 최적의 방법이 아니며, 오히려 스스로 타협 지점을 설정하고 이를 기반으로 피드백을 통해 육성 방향을 조정하는 능력을 키우는 데 방해가 되기 때문에 이를 지양해야 한다고 저는 생각합니다. 제가 남들처럼 남이 짜 준 청사진을 기반으로 완벽한 도자기를 깎는 방식으로 게임을 플레이했다면, 200만원으로 15관 중 12관을 달성하는 것은 불가능했을 것입니다.\n\n---\n\n## 최적해는 인자작 복리를 이용하는 것이다\n\n제가 생각하는 우마무스메를 플레이하는 최적의 방법은 인자작을 통한 복리를 이용하는 것입니다. 인자작이란 출주마가 아니라 짧게는 출주마의 부모, 더 나아가서는 조, 증조, 증증조, 증증증조 부모를 육성하는 것을 말합니다. 이 말을 보자마자 '이거 사람 아니야, 말 악귀야. 그걸 어떻게 해?'라고 생각하는 분들이 있을 겁니다. 그렇게 시간이 오래 걸리는 일을 어떻게 해? 하지만 이 게임의 원리를 이해하시면 이것이 오히려 시간을 절약하는 방법이라는 것을 알 수 있습니다.\n\n우마무스메의 인자 시스템의 복리적인 측면에 대해 간략하게 설명하면, 동일한 것이 부모/조부에 중복해서 걸려있는 횟수가 높을수록 인자로 남을 확률이 높아지는 로직으로 이루어져 있습니다. 이 때문에 단순히 여러 스킬이 붙은 단 하나의 우마무스메 인자를 만들어내는 것을 목표로 하는 것이 아니라, 여러 우마무스메를 번갈아가면서 육성하면서 오래 쓸 수 있는 핵심 인자가 중첩되도록 하는 것이 중요합니다.\n\n### 증조부 인자작 한 것 예시\n\n![증조부 네이처](/images/우마무스메%20개론/증조부%20인자%20예시.png)\n\n이를 통해 훌륭한 증증조부가 발생하면 이를 통해 좋은 증조부가, 조부가, 부모가, 출주마가 발생합니다. 그리고 이들 중에서 활용할 수 있는 우마무스메의 갯수가 늘어납니다. 즉, 인자작의 복리를 적용한 인자작을 하게 되면 단순히 즉전감으로 활용하기 위한 조부모, 부모, 출주마 셋만을 목표로 하는 육성에 비해 유효 육성의 횟수가 압도적으로 높아지게 됩니다. 즉, 시간을 훨씬 더 효율적으로 사용할 수 있게 되기 때문에 같은 시간 동안 더 많은 우마무스메를 육성하는 것과 동일한 효과를 얻을 수 있으며 이는 복리의 특성상 시간이 지날수록 더 큰 효과를 가져다 줍니다.\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"200만원으로 우마무스메 12/15관을 달성한 비결","subtitle":"우마무스메 개론(1)","date":"2024-04-20T00:00:00.000Z","categories":"게임이야기","published":false,"series":"우마무스메 개론","seriesIndex":1}},{"postName":"2024-04-10-유니콘 오버로드 리뷰 - 2","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/취미/게임 이야기/2024-04-10-유니콘 오버로드 리뷰 - 2.md","category":"게임이야기","title":"전투로 극복한 rpg의 한계","subtitle":"유니콘 오버로드 리뷰(2)","content":"\n### 목차\n\n- [게임 정보](#게임-정보)\n- [rpg에서 성장의 매력, 그리고 한계](#rpg에서-성장의-매력-그리고-한계)\n- [그러면 캐릭터를 많이 쓰면 되잖아?](#그러면-캐릭터를-많이-쓰면-되잖아)\n- [그렇지만 조작할 것은 적게](#그렇지만-조작할-것은-적게)\n- [그러면서 억까도 적게](#그러면서-억까도-적게)\n- [마무리](#마무리)\n\n---\n\n## 게임 정보\n\n- **게임명**: 유니콘 오버로드\n- **제작사**: 바닐라웨어\n- **유통사**: ATLUS\n- **장르**: SRPG, JRPG, 오픈월드\n\n---\n\n## rpg에서 성장의 매력, 그리고 한계\n\nrpg의 매력 중 큰 비중을 차지하는 요소 중 하나는 성장입니다. 우리는 캐릭터를 플레이 하면서 각종 스탯이 오르거나, 장비를 획득하고, 동료를 얻으면서 성장하는 것을 경험합니다. 대부분 경우 성장을 통해 힘이나 지능과 같은 전투에서 필요한 스탯이 올라서 구체적인 강함이 늘어나지만, 그것이 아니라도 동료 캐릭터와의 인연도나 새로운 물건을 만들 수 있게 되는 등 다양한 방식으로도 성장을 경험할 수 있습니다. 그리고 이전보다 더 나아진 캐릭터를 보면서 뿌듯함을 느끼는 것은 rpg의 매력 중 하나입니다.\n\n하지만 그것은 동시에 rpg란 게임이 가지는 한계이기도 합니다. 게임은 끝이 있기 마련이고, 더 이상 목표를 제시해주기 힘든 시점에 도달하면 그동안 성장을 위해 해왔던 컨텐츠들이 더 이상 재미를 제공하지 못하는 순간이 오게 됩니다.\n\n![토끼공듀](https://i.namu.wiki/i/RuVq_fIkWuGcG9lq9h_ugJYQO9EyYLRYVZlNH2FRqkOFDaQ9CeqeHjQr0h5dCE1djxbJCsA8bsfXX4tZ3L_qgg.webp)\n\n전설의 무기가 있으면 무슨 소용일까요? 우리가 캐릭터를 키메라로 만들지 않는 한 우리 캐릭터가 들 수 있는 검은 최대 두개 뿐입니다.(입으로 칼을 무는 조로는 예욉니다.) 캐릭터가 쓸 수 있는 모자는 하나 뿐입니다. 우리의 동료가 될 수 있는 친구의 수는 한계가 있습니다. 곧 끝날 것을 아는 데 새로 얻은 장비나 캐릭터를 추가로 성장시킬 수 있다는 이야기는 매력적이라기보다 보상이 모자란 공수표처럼 느껴지기까지 합니다. 이처럼 어느 시점에 도달하면 rpg에서 성장은 더이상 매력으로 다가오지 않고 우리에게 숙제이자 부담으로 다가오는 순간이 찾아옵니다.\n\n---\n\n## 그러면 캐릭터를 많이 쓰면 되잖아?\n\n![유닛 구성](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%EC%9C%A0%EB%8B%9B%20%EB%A6%AC%EC%8A%A4%ED%8A%B8.jpg?raw=true)\n\n위의 이미지는 제가 유니콘 오버로드의 엔딩을 본 시점에서 제가 사용하던 병종 구성입니다. 유니콘 오버로드는 최대 10개 분대, 각 분대당 최대 5명의 유닛을 사용할 수 있습니다. 그렇기 때문에 최대 50명의 유닛을 사용할 수 있습니다. 자신이 보유한 캐릭터들 중에서 50명을 선택해서 10개의 분대를 꾸리는 조합의 경우의 수는 무려 4537555나 됩니다. 그리고 이 정도면 어지간하면 본인의 마음에 드는 조합이 하나는 있을 것입니다.\n\n네? 이걸 어떻게 키우냐구요? 그래서 준비했습니다. 유니콘 오버로드는 다양한 필드 반복 컨텐츠를 통해 빠른 레벨업이 가능한 소위 '쩔'이 가능한 시스템과 경험치 책이 존재하며, 후반부에 얻을 수 있는 캐릭터일수록 높은 레벨로 시작하는 등의 편의성을 제공합니다. 거기다가 47종이나 되는 병종이 존재해서 새로운 적에 맞춘 새로운 아군의 조합을 만들어내는 재미도 있습니다. 이 게임의 대부분의 캐릭터는 어느 시점에 들어오더라도 당장 사용할 곳이 있으며, 그러는 데에는 많은 노력이 필요하지 않습니다.\n\n여기에 더해 이 게임은 매력적인 아이템이 굉장히 많습니다. 유니콘 오버로드는 단순히 스탯을 올려주는 장비를 구성하는 데에서 그치지 않고, 유틸성이 높은 스킬들을 제공하는 다양한 장비들을 통해 같은 병종이라도 전혀 다른 운용 방식으로 활용할 수 있는 재미를 제공합니다. 체력이 낮을 수록 강해지는 캐릭터에게 단 한번 즉사를 면하고 체력 1이 남는 스킬이 주어진다면 어떨까요? 자힐은 없지만, 힐을 받으면 광역 힐을 주는 캐릭터에게 힐을 할 수 있는 능력을 부여하는 아이템을 준다면요? 명중률이 떨어지는 대신 확정적으로 치명타가 발생하는 스킬과 명중 보정이 확정인 스킬을 번갈아 사용해서 딜러에게 치명타시에 강력한 딜러에게 버프를 준다면요? 이 역시 유니콘 오버로드가 가지고 있는 많은 캐릭터를 사용하는 전투 방식이 아니었다면, '그래서 이걸 누구 주는데?'라는 질문에 대답하지 못했을 것입니다.\n\n---\n\n## 그렇지만 조작할 것은 적게\n\n그치만 그 많은걸 복잡하게 어떻게 조작할건데? 그러기 머리 아파서 난 srpg가 싫어. 그래서 준비했습니다. 아무것도 조작하지 마세요. 유니콘 오버로드는 매 턴 어느 스킬을 누구에게 사용해야할지 고민하고 그 결과에 대해 예상해야 했던 기존의 srpg와는 전혀 다른 전투 방식을 채택합니다. 그것은 바로 자동전투입니다.\n\n![필드 구성](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%ED%95%84%EB%93%9C%20%EA%B5%AC%EC%84%B1.jpg?raw=true)\n\n유니콘 오버로드의 전투는 srpg라기보다는 rts의 것을 많이 닮아 있습니다. 플레이어는 전투에서 공용으로 사용하는 재화인 '브레이브 포인트'를 소모해서 분대를 소환하거나 스킬을 사용할 수 있습니다. 이를 이용해 소환한 유닛을 스타크래프트에서 어택땅하듯이 이동해서 서로 유닛이 겹치게 되면 서로의 전투 결과가 시뮬레이트 되며 승패가 결정됩니다. 이 때 승리한 유닛은 추가 행동의 권리가 주어지고 브레이브 포인트를 일정 수치 획득하게 되며, 패배한 유닛은 행동 불가 상태가 되고 그 상태에서 연전을 하게 될 경우 불리한 전투를 진행하게 됩니다.\n\n이런 두가지 반대되는 복잡함과 간단함을 동시에 추구하고 밸런스를 맞추는 데 성공했기 때문에 유니콘 오버로드의 전투는 적당히 도전적이면서도 쉽게 접근할 수 있기 때문에 매력적입니다. 유니콘 오버로드의 전투는 이 조화를 통해 많은 캐릭터를 사용하더라도 그것이 복잡하게 느껴지지 않고, 오히려 캐릭터를 더 많이 사용하고 싶게 만들어줍니다.\n\n---\n\n## 그러면서 억까도 적게\n\n![감나빗](https://img3.ruliweb.com/data/review/2016/10m/xcm/xcm_06.jpg)\n\n감나빗으로 대표되는 srpg의 소위 억까는 유저들이 해당 장르를 기피하는 이유 중 하나입니다. 이는 본인이 잘못한 것이 없이 올바른 전략을 취했음에도 불구하고 랜덤한 요소로 인해 예측과 다른 결과가 나오는 불쾌한 경험을 제공하기 때문입니다. 하지만 유니콘 오버로드에서는 이런 불쾌한 예측 불가능한 요소를 최대한 줄이고 모든 변수를 유저에게 유리한 방향으로 조작하려고 노력했습니다. 유저는 모든 전투가 일어나기 전에 그 결과를 정확하게 알 수 있고, 원하지 않는 결과가 나올 경우에는 여기에 개입하여 원하는 결과를 얻기 위한 다양한 수단을 사용할 수 있습니다.\n\n![전투 예시](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/%EC%A0%84%ED%88%AC%EB%A1%9C%20%EA%B7%B9%EB%B3%B5%ED%95%9C%20rpg%EC%9D%98%20%ED%95%9C%EA%B3%84/%EC%A0%84%ED%88%AC%20%EC%98%88%EC%8B%9C.jpg?raw=true)\n\n유저는 전투 결과를 수행하지 않고 전투 결과를 확인한 상태에서 전투 결과에 영향을 미치는 소모품을 사용하거나 배치를 변경할 수 있고, 발동하는 스킬의 종류와 순서 및 대상을 변경할 수 있는데다가 급기야는 여러 상성에 대응할 수 있는 분대를 묶어서 전투에 투입해서 자신이 원하는 병종간의 전투만 이루어지도록 할 수도 있습니다. 이 때문에 사실상 억까가 존재하지 않고, 설사 불리한 상황을 마주하더라도 유저 스스로 잃을 것 없이 얻을 것만 있는 묘수를 찾아낼 수 있는 시스템은 굉장히 매력적입니다.\n\n---\n\n## 마무리\n\nrpg의 성장과 srpg의 묘수는 게임의 핵심적인 매력이지만 동시에 그 게임의 한계를 결정짓는 요소이기도 했습니다. 바닐라웨어는 유니콘 오버로드에서 이 한계를 극복하기 위해 택틱스 오우거식 전투를 도입해 매력적인 srpg의 새로운 방향을 제시하는데 성공했다고 생각합니다. 거기다가 게임 전반적으로 유저가 불쾌할만한 요소들을 가능한 줄이고, 유저에게 유리하면서도 적당히 도전적으로 느껴지게 하기 위한 고민을 전반적으로 많이 느낄 수 있었던 수작이라고 생각합니다. 그렇기에 유니콘 오버로드는 srpg의 팬이라면 꼭 해봐야하면서 동시에 srpg를 평소에 즐기지 않던 분도 굉장히 쉽고 재밌게 할 수 있는 게임이니 꼭 한번 해보시길 추천드립니다. 긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"전투로 극복한 rpg의 한계","subtitle":"유니콘 오버로드 리뷰(2)","date":"2024-04-19T00:00:00.000Z","categories":"게임이야기","published":true,"recommended":true,"series":"유니콘 오버로드 리뷰","seriesIndex":2}}]}]},"__N_SSG":true},"page":"/","query":{},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>