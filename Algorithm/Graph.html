<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Graph</h1><h1 class="project-subtitle">탐색을 위한 자료구조</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#1-그래프란" title="null">1. 그래프란?</a></li>
<li><a target="_self" href="#2-그래프의-활용" title="null">2. 그래프의 활용</a></li>
<li><a target="_self" href="#3-그래프-표현-방법" title="null">3. 그래프 표현 방법</a><ul>
<li><a target="_self" href="#31-인접-행렬adjacency-matrix" title="null">3.1 인접 행렬(Adjacency Matrix)</a></li>
<li><a target="_self" href="#32-인접-리스트adjacency-list" title="null">3.2 인접 리스트(Adjacency List)</a></li>
</ul>
</li>
<li><a target="_self" href="#reference" title="null">Reference</a></li>
</ul>
<hr>

      <h2 id="1.-그래프란?">
        <a name="1.-그래프란?" class="anchor" href="#1.-그래프란?">
          <span class="header-link"></span>
        </a>
        1. 그래프란?
      </h2><p>그래프는 정점과 간선으로 이루어진 자료구조이다. 그래프는 다음과 같은 특징을 가진다.</p>
<ul>
<li>정점(Vertex): 데이터를 저장하는 공간</li>
<li>간선(Edge): 정점과 정점을 연결하는 선</li>
<li>방향성: 간선에 방향이 있는 경우 방향 그래프, 없는 경우 무방향 그래프</li>
<li>가중치: 간선에 가중치가 있는 경우 가중치 그래프, 없는 경우 비가중치 그래프</li>
</ul>

      <h2 id="2.-그래프의-활용">
        <a name="2.-그래프의-활용" class="anchor" href="#2.-그래프의-활용">
          <span class="header-link"></span>
        </a>
        2. 그래프의 활용
      </h2><p>그래프는 주로 탐색을 위해 사용된다. 여기에서 탐색이란 그래프의 정점(vertex)을 방문하기 위해
간선(edge)을 따라 이동하는 것을 의미한다. 탐색을 통해 그래프의 구조를 파악하거나 특정 정점을
 찾는 등의 작업을 수행할 수 있다. 대표적인 예시로는 미로 찾기, 최단 경로 찾기, 네트워크 경로
 찾기 등이 있다.</p>
<p>그래프 탐색 알고리즘에는 다음과 같은 것들이 있다.</p>
<ul>
<li>깊이 우선 탐색(DFS, Depth First Search)</li>
<li>너비 우선 탐색(BFS, Breadth First Search)</li>
<li>다익스트라 알고리즘(Dijkstra Algorithm)</li>
<li>벨만-포드 알고리즘(Bellman-Ford Algorithm)</li>
<li>...</li>
</ul>

      <h2 id="3.-그래프-표현-방법">
        <a name="3.-그래프-표현-방법" class="anchor" href="#3.-그래프-표현-방법">
          <span class="header-link"></span>
        </a>
        3. 그래프 표현 방법
      </h2><p>대표적으로 그래프는 대표적으로 다음의 두 가지 방법으로 표현할 수 있다</p>
<ul>
<li>인접 행렬(Adjacency Matrix)</li>
<li>인접 리스트(Adjacency List)</li>
</ul>

      <h3 id="3.1-인접-행렬(adjacency-matrix)">
        <a name="3.1-인접-행렬(adjacency-matrix)" class="anchor" href="#3.1-인접-행렬(adjacency-matrix)">
          <span class="header-link"></span>
        </a>
        3.1 인접 행렬(Adjacency Matrix)
      </h3><p>인접 행렬은 2차원 배열로 그래프를 표현하는 방법이다. 인접 행렬은 다음과 같은 특징을 가진다.</p>
<ul>
<li>정점의 개수가 <code>V</code>일 때, <code>V x V</code> 크기의 2차원 배열이 필요하다.</li>
<li>정점 <code>u</code>와 정점 <code>v</code>가 연결되어 있으면 <code>matrix[u][v] = 1</code>, 연결되어 있지 않으면 <code>matrix[u][v] = 0</code>이다.</li>
<li>가중치 그래프의 경우 <code>matrix[u][v] = w</code>로 표현한다.</li>
</ul>
<pre><code class="language-python">matrix = [[1, 0, 0, 1, 0],
          [0, 1, 1, 0, 0],
          [0, 1, 1, 1, 1],
          [1, 0, 1, 1, 0],
          [0, 0, 1, 0, 1]]
</code></pre>
<p>인접 행렬은 다음과 같은 장단점을 가진다.</p>
<ul>
<li>장점<ul>
<li>두 정점이 연결되어 있는지 확인하는데 <code>O(1)</code>의 시간 복잡도가 소요된다.</li>
<li>두 정점 사이의 간선을 찾는데 유용하다.</li>
<li>가중치 그래프의 경우 간선의 가중치를 쉽게 확인할 수 있다.</li>
<li>무방향 그래프의 경우 대각선을 기준으로 대칭성을 가진다.</li>
<li>행렬의 곱셈을 이용해 그래프의 연결 여부를 확인할 수 있다.</li>
<li>...</li>
</ul>
</li>
<li>단점<ul>
<li>정점의 개수가 많을 경우 메모리 낭비가 심하다.</li>
<li>특정 정점과 연결된 간선을 찾는데 <code>O(V)</code>의 시간 복잡도가 소요된다.</li>
<li>희소 그래프(Sparse Graph)의 경우 메모리 낭비가 심하다.</li>
<li>...</li>
</ul>
</li>
</ul>
<p>인접 행렬은 정점의 개수가 적고 간선의 개수가 많은 밀집 그래프(Dense Graph)의 경우에 적합하다.</p>

      <h3 id="3.2-인접-리스트(adjacency-list)">
        <a name="3.2-인접-리스트(adjacency-list)" class="anchor" href="#3.2-인접-리스트(adjacency-list)">
          <span class="header-link"></span>
        </a>
        3.2 인접 리스트(Adjacency List)
      </h3><p>인접 리스트는 리스트를 이용해 그래프를 표현하는 방법이다. 인접 리스트는 다음과 같은 특징을 가진다.</p>
<ul>
<li>정점의 개수가 <code>V</code>일 때, <code>V</code>개의 리스트가 필요하다.</li>
<li>각 리스트는 해당 정점과 연결된 정점들을 저장한다.</li>
<li>가중치 그래프의 경우 각 리스트의 원소는 정점과 가중치를 저장한다.</li>
</ul>
<pre><code class="language-python">adj_list = [[(3, 1)],
            [(1, 1), (2, 1)],
            [(1, 1), (2, 1), (3, 1), (4, 1)],
            [(0, 1), (2, 1), (3, 1)],
            [(2, 1), (4, 1)]]
</code></pre>
<p>인접 리스트는 다음과 같은 장단점을 가진다.</p>
<ul>
<li>장점<ul>
<li>메모리 사용량이 적다.</li>
<li>특정 정점과 연결된 간선을 찾는데 <code>O(E)</code>의 시간 복잡도가 소요된다.</li>
<li>희소 그래프(Sparse Graph)의 경우 메모리 사용량이 적다.</li>
<li>...</li>
</ul>
</li>
<li>단점<ul>
<li>두 정점이 연결되어 있는지 확인하는데 <code>O(V)</code>의 시간 복잡도가 소요된다.</li>
<li>두 정점 사이의 간선을 찾는데 비효율적이다.</li>
<li>가중치 그래프의 경우 간선의 가중치를 확인하기 어렵다.</li>
<li>...</li>
</ul>
</li>
</ul>
<p>인접 리스트는 정점의 개수가 많고 간선의 개수가 적은 희소 그래프(Sparse Graph)의 경우에 적합하다.</p>
<hr>

      <h2 id="reference">
        <a name="reference" class="anchor" href="#reference">
          <span class="header-link"></span>
        </a>
        Reference
      </h2><ul>
<li><a target="_self" href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms" title="null">Introduction to Algorithms, 3rd Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein</a></li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/Introduction to Shortest Path algorithm">이전 포스트: <!-- -->Introduction to Shortest Path algorithm</a></div><div style="text-align:right"><a href="/Algorithm/Bellman-ford algorithm">다음 포스트: <!-- -->Bellman-ford algorithm</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-05-10-Graph","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Graph.md","category":"Algorithm","title":"Graph","subtitle":"탐색을 위한 자료구조","content":"\n### 목차\n\n- [1. 그래프란?](#1-그래프란)\n- [2. 그래프의 활용](#2-그래프의-활용)\n- [3. 그래프 표현 방법](#3-그래프-표현-방법)\n  - [3.1 인접 행렬(Adjacency Matrix)](#31-인접-행렬adjacency-matrix)\n  - [3.2 인접 리스트(Adjacency List)](#32-인접-리스트adjacency-list)\n- [Reference](#reference)\n\n---\n\n## 1. 그래프란?\n\n그래프는 정점과 간선으로 이루어진 자료구조이다. 그래프는 다음과 같은 특징을 가진다.\n\n- 정점(Vertex): 데이터를 저장하는 공간\n- 간선(Edge): 정점과 정점을 연결하는 선\n- 방향성: 간선에 방향이 있는 경우 방향 그래프, 없는 경우 무방향 그래프\n- 가중치: 간선에 가중치가 있는 경우 가중치 그래프, 없는 경우 비가중치 그래프\n\n## 2. 그래프의 활용\n\n그래프는 주로 탐색을 위해 사용된다. 여기에서 탐색이란 그래프의 정점(vertex)을 방문하기 위해\n간선(edge)을 따라 이동하는 것을 의미한다. 탐색을 통해 그래프의 구조를 파악하거나 특정 정점을\n 찾는 등의 작업을 수행할 수 있다. 대표적인 예시로는 미로 찾기, 최단 경로 찾기, 네트워크 경로\n 찾기 등이 있다.\n\n그래프 탐색 알고리즘에는 다음과 같은 것들이 있다.\n\n- 깊이 우선 탐색(DFS, Depth First Search)\n- 너비 우선 탐색(BFS, Breadth First Search)\n- 다익스트라 알고리즘(Dijkstra Algorithm)\n- 벨만-포드 알고리즘(Bellman-Ford Algorithm)\n- ...\n\n## 3. 그래프 표현 방법\n\n대표적으로 그래프는 대표적으로 다음의 두 가지 방법으로 표현할 수 있다\n\n- 인접 행렬(Adjacency Matrix)\n- 인접 리스트(Adjacency List)\n\n### 3.1 인접 행렬(Adjacency Matrix)\n\n인접 행렬은 2차원 배열로 그래프를 표현하는 방법이다. 인접 행렬은 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V x V` 크기의 2차원 배열이 필요하다.\n- 정점 `u`와 정점 `v`가 연결되어 있으면 `matrix[u][v] = 1`, 연결되어 있지 않으면 `matrix[u][v] = 0`이다.\n- 가중치 그래프의 경우 `matrix[u][v] = w`로 표현한다.\n\n```python\nmatrix = [[1, 0, 0, 1, 0],\n          [0, 1, 1, 0, 0],\n          [0, 1, 1, 1, 1],\n          [1, 0, 1, 1, 0],\n          [0, 0, 1, 0, 1]]\n```\n\n인접 행렬은 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(1)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 유용하다.\n  - 가중치 그래프의 경우 간선의 가중치를 쉽게 확인할 수 있다.\n  - 무방향 그래프의 경우 대각선을 기준으로 대칭성을 가진다.\n  - 행렬의 곱셈을 이용해 그래프의 연결 여부를 확인할 수 있다.\n  - ...\n- 단점\n  - 정점의 개수가 많을 경우 메모리 낭비가 심하다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 낭비가 심하다.\n  - ...\n\n인접 행렬은 정점의 개수가 적고 간선의 개수가 많은 밀집 그래프(Dense Graph)의 경우에 적합하다.\n\n### 3.2 인접 리스트(Adjacency List)\n\n인접 리스트는 리스트를 이용해 그래프를 표현하는 방법이다. 인접 리스트는 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V`개의 리스트가 필요하다.\n- 각 리스트는 해당 정점과 연결된 정점들을 저장한다.\n- 가중치 그래프의 경우 각 리스트의 원소는 정점과 가중치를 저장한다.\n\n```python\nadj_list = [[(3, 1)],\n            [(1, 1), (2, 1)],\n            [(1, 1), (2, 1), (3, 1), (4, 1)],\n            [(0, 1), (2, 1), (3, 1)],\n            [(2, 1), (4, 1)]]\n```\n\n인접 리스트는 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 메모리 사용량이 적다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(E)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 사용량이 적다.\n  - ...\n- 단점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 비효율적이다.\n  - 가중치 그래프의 경우 간선의 가중치를 확인하기 어렵다.\n  - ...\n\n인접 리스트는 정점의 개수가 많고 간선의 개수가 적은 희소 그래프(Sparse Graph)의 경우에 적합하다.\n\n---\n\n## Reference\n\n- [Introduction to Algorithms, 3rd Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Graph","subtitle":"탐색을 위한 자료구조","date":"2024-05-10T00:00:00.000Z","categories":"Algorithm"}},"title":"Graph","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"Introduction to Shortest Path algorithm","category":"Algorithm"},"next":{"title":"Bellman-ford algorithm","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"Graph"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>