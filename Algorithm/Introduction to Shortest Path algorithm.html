<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Introduction to Shortest Path algorithm</h1><h1 class="project-subtitle">single-source shortest path algorithm(1)</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#introduction" title="null">Introduction</a></li>
<li><a target="_self" href="#optimal-substructure" title="null">Optimal substructure</a></li>
<li><a target="_self" href="#negative-weight-edges" title="null">negative-weight edges</a></li>
<li><a target="_self" href="#cycles" title="null">Cycles</a></li>
<li><a target="_self" href="#relaxation" title="null">relaxation</a></li>
<li><a target="_self" href="#references" title="null">References</a></li>
</ul>
<hr>

      <h2 id="introduction">
        <a name="introduction" class="anchor" href="#introduction">
          <span class="header-link"></span>
        </a>
        Introduction
      </h2><p>Shortest path problem은 그래프에서 두 정점 사이의 최단 경로를 찾는 문제이다. 이 문제는 다양한 분야에서 응용되며, 다양한 알고리즘이
 제안되어 있다. Shortest path problem은 다음과 같은 세 가지 유형으로 나뉜다.</p>
<ol>
<li>Single-source shortest path problem<ul>
<li>주어진 그래프에서 특정 정점에서 다른 모든 정점까지의 최단 경로를 찾는 문제이다.</li>
</ul>
</li>
<li>Single-destination shortest path problem<ul>
<li>주어진 그래프에서 모든 정점에서 특정 정점까지의 최단 경로를 찾는 문제이다.</li>
</ul>
</li>
<li>All-pairs shortest path problem<ul>
<li>주어진 그래프에서 모든 정점 사이의 최단 경로를 찾는 문제이다.</li>
</ul>
</li>
</ol>
<p>이 글에서는 single-source shortest path problem에 대해 다룬다. single-source shortest path problem은 다음과 같은 두 가지 유형으로 나뉜다.</p>
<ol>
<li>Unweighted graph: 그래프의 간선에 가중치가 없는 경우</li>
<li>Weighted graph: 그래프의 간선에 가중치가 있는 경우</li>
</ol>
<p>이 글에서는 weighted graph에 대해 다룬다. weighted graph에서 single-source shortest path problem을 해결하는 대표적인 알고리즘은
 다음과 같다.</p>
<ol>
<li>Dijkstra&#39;s algorithm</li>
<li>Bellman-Ford algorithm</li>
</ol>
<hr>

      <h2 id="optimal-substructure">
        <a name="optimal-substructure" class="anchor" href="#optimal-substructure">
          <span class="header-link"></span>
        </a>
        Optimal substructure
      </h2><p>Shortest path problem은 optimal substructure를 가진다. Optimal substructure란 문제의 최적해가 부분 문제의 최적해로부터 구해질 수
 있는 성질을 말한다.
 Shortest path problem에서 optimal substructure는 다음과 같이 정의된다.</p>
<blockquote>
<p>Let $G = (V, E)$ be a directed graph with a weight function $w: E \rightarrow \mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \in V$, let $p$ be a shortest path from $s$ to $v$. If $p$ contains an intermediate vertex $x$, then $p$ can be divided into two subpaths $s \rightarrow x$ and $x \rightarrow v$. The subpath $s \rightarrow x$ is a shortest path from $s$ to $x$, and the subpath $x \rightarrow v$ is a shortest path from $x$ to $v$.</p>
</blockquote>
<p>즉, 최단 경로 $p$가 중간 정점 $x$를 포함하고 있다면, $p$는 두 개의 부분 경로 $s \rightarrow x$와 $x \rightarrow v$로 나눌 수 있다.
 부분 경로 $s \rightarrow x$는 $s$에서 $x$로 가는 최단 경로이며, 부분 경로 $x \rightarrow v$는 $x$에서 $v$로 가는 최단 경로이다.</p>
<hr>

      <h2 id="negative-weight-edges">
        <a name="negative-weight-edges" class="anchor" href="#negative-weight-edges">
          <span class="header-link"></span>
        </a>
        negative-weight edges
      </h2><p>그래프의 간선이 음수 가중치를 가지는 경우, cycle이 존재할 수 있다. 이 경우, shortest path problem을 해결하는 알고리즘은 cycle을
 탐지하여 음의 무한대로 수렴할 수 있다.</p>
<p>Dijkstra&#39;s algorithm의 경우 모든 간선의 가중치가 양수인 경우에만 사용할 수 있다. Bellman-Ford algorithm은 음수 가중치를 가지는
 간선이 존재하고 cycle이 없는 경우에 사용할 수 있다.</p>
<hr>

      <h2 id="cycles">
        <a name="cycles" class="anchor" href="#cycles">
          <span class="header-link"></span>
        </a>
        Cycles
      </h2><p>Shortest path problem에서 cycle이 존재하는 경우, 해당 cycle이 음수 가중치를 가지는 경우와 양수 가중치를 가지는 경우로 나뉜다.
 음수 가중치를 가지는 cycle이 존재하는 경우, shortest path problem을 해결하는 알고리즘은 cycle을 탐지하여 음의 무한대로 수렴할 수
 있어 해를 구할 수 없다. 반면 양수 가중치를 가지는 cycle이 존재하는 경우, 해당 cycle을 포함하는 경로는 무한히 큰 가중치를 가지므로
 최단 경로가 될 수 없다. 즉 우리는 shortest path problem에서 cycle을 포함하는 경로를 고려하지 않는다.</p>
<hr>

      <h2 id="relaxation">
        <a name="relaxation" class="anchor" href="#relaxation">
          <span class="header-link"></span>
        </a>
        relaxation
      </h2><p>Shortest path problem을 해결하는 알고리즘은 relaxation이라는 연산을 사용한다. relaxation은 다음과 같이 정의된다.</p>
<blockquote>
<p>Let $G = (V, E)$ be a directed graph with a weight function $w: E \rightarrow \mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \in V$, let $p$ be a shortest path from $s$ to $v$. The relaxation operation updates the shortest path estimate $v.d$ and the predecessor $v.\pi$ of vertex $v$ if a shorter path from $s$ to $v$ is found.</p>
</blockquote>
<p>즉, 매 정점 $v$에 대해 $s$에서 $v$로 가는 최단 경로 $v.d$와 이전 정점 $v.\pi$를 업데이트하는 연산이다.</p>
<hr>

      <h2 id="references">
        <a name="references" class="anchor" href="#references">
          <span class="header-link"></span>
        </a>
        References
      </h2><ul>
<li><a target="_self" href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition" title="null">Introduction to Algorithms, 3rd Edition</a>
by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, p.643 ~ p.650</li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/BFS and DFS">이전 포스트: <!-- -->BFS and DFS</a></div><div style="text-align:right"><a href="/Algorithm/Graph">다음 포스트: <!-- -->Graph</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-05-07-Shortest Path(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-07-Shortest Path(1).md","category":"Algorithm","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","content":"\n### 목차\n\n- [Introduction](#introduction)\n- [Optimal substructure](#optimal-substructure)\n- [negative-weight edges](#negative-weight-edges)\n- [Cycles](#cycles)\n- [relaxation](#relaxation)\n- [References](#references)\n\n---\n\n## Introduction\n\nShortest path problem은 그래프에서 두 정점 사이의 최단 경로를 찾는 문제이다. 이 문제는 다양한 분야에서 응용되며, 다양한 알고리즘이\n 제안되어 있다. Shortest path problem은 다음과 같은 세 가지 유형으로 나뉜다.\n\n1. Single-source shortest path problem\n    - 주어진 그래프에서 특정 정점에서 다른 모든 정점까지의 최단 경로를 찾는 문제이다.\n2. Single-destination shortest path problem\n    - 주어진 그래프에서 모든 정점에서 특정 정점까지의 최단 경로를 찾는 문제이다.\n3. All-pairs shortest path problem\n    - 주어진 그래프에서 모든 정점 사이의 최단 경로를 찾는 문제이다.\n\n이 글에서는 single-source shortest path problem에 대해 다룬다. single-source shortest path problem은 다음과 같은 두 가지 유형으로 나뉜다.\n\n1. Unweighted graph: 그래프의 간선에 가중치가 없는 경우\n2. Weighted graph: 그래프의 간선에 가중치가 있는 경우\n\n이 글에서는 weighted graph에 대해 다룬다. weighted graph에서 single-source shortest path problem을 해결하는 대표적인 알고리즘은\n 다음과 같다.\n\n1. Dijkstra's algorithm\n2. Bellman-Ford algorithm\n\n---\n\n## Optimal substructure\n\nShortest path problem은 optimal substructure를 가진다. Optimal substructure란 문제의 최적해가 부분 문제의 최적해로부터 구해질 수\n 있는 성질을 말한다.\n Shortest path problem에서 optimal substructure는 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. If $p$ contains an intermediate vertex $x$, then $p$ can be divided into two subpaths $s \\rightarrow x$ and $x \\rightarrow v$. The subpath $s \\rightarrow x$ is a shortest path from $s$ to $x$, and the subpath $x \\rightarrow v$ is a shortest path from $x$ to $v$.\n\n즉, 최단 경로 $p$가 중간 정점 $x$를 포함하고 있다면, $p$는 두 개의 부분 경로 $s \\rightarrow x$와 $x \\rightarrow v$로 나눌 수 있다.\n 부분 경로 $s \\rightarrow x$는 $s$에서 $x$로 가는 최단 경로이며, 부분 경로 $x \\rightarrow v$는 $x$에서 $v$로 가는 최단 경로이다.\n\n---\n\n## negative-weight edges\n\n그래프의 간선이 음수 가중치를 가지는 경우, cycle이 존재할 수 있다. 이 경우, shortest path problem을 해결하는 알고리즘은 cycle을\n 탐지하여 음의 무한대로 수렴할 수 있다.\n\nDijkstra's algorithm의 경우 모든 간선의 가중치가 양수인 경우에만 사용할 수 있다. Bellman-Ford algorithm은 음수 가중치를 가지는\n 간선이 존재하고 cycle이 없는 경우에 사용할 수 있다.\n\n---\n\n## Cycles\n\nShortest path problem에서 cycle이 존재하는 경우, 해당 cycle이 음수 가중치를 가지는 경우와 양수 가중치를 가지는 경우로 나뉜다.\n 음수 가중치를 가지는 cycle이 존재하는 경우, shortest path problem을 해결하는 알고리즘은 cycle을 탐지하여 음의 무한대로 수렴할 수\n 있어 해를 구할 수 없다. 반면 양수 가중치를 가지는 cycle이 존재하는 경우, 해당 cycle을 포함하는 경로는 무한히 큰 가중치를 가지므로\n 최단 경로가 될 수 없다. 즉 우리는 shortest path problem에서 cycle을 포함하는 경로를 고려하지 않는다.\n\n---\n\n## relaxation\n\nShortest path problem을 해결하는 알고리즘은 relaxation이라는 연산을 사용한다. relaxation은 다음과 같이 정의된다.\n\n\u003e Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. The relaxation operation updates the shortest path estimate $v.d$ and the predecessor $v.\\pi$ of vertex $v$ if a shorter path from $s$ to $v$ is found.\n\n즉, 매 정점 $v$에 대해 $s$에서 $v$로 가는 최단 경로 $v.d$와 이전 정점 $v.\\pi$를 업데이트하는 연산이다.\n\n---\n\n## References\n\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n  by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, p.643 ~ p.650\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":1}},"title":"Introduction to Shortest Path algorithm","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"BFS and DFS","category":"Algorithm"},"next":{"title":"Graph","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"Introduction to Shortest Path algorithm"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>