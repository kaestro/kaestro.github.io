<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">4월 2주차 알고리즘 문제</h1><h1 class="project-subtitle">sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#금주의-문제-sliding-window를-통해-더-적게-비교하기" title="null">[금주의 문제] sliding window를 통해 더 적게 비교하기</a></li>
<li><a target="_self" href="#trailing-zeros-제거하는-다양한-방법" title="null">trailing zeros 제거하는 다양한 방법</a></li>
<li><a target="_self" href="#저장을-통해-연산-횟수-줄이기" title="null">저장을 통해 연산 횟수 줄이기</a></li>
</ul>
<hr>

      <h2 id="[금주의-문제]-sliding-window를-통해-더-적게-비교하기">
        <a name="[금주의-문제]-sliding-window를-통해-더-적게-비교하기" class="anchor" href="#[금주의-문제]-sliding-window를-통해-더-적게-비교하기">
          <span class="header-link"></span>
        </a>
        [금주의 문제] sliding window를 통해 더 적게 비교하기
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/description/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2200%20-%20LeetCode.py" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>list integer에서 key값과 좌우로 k만큼 떨어진 index로 구성된 list를 구하는 문제이다.(findKthDistanceIndices)</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>기존 풀이<ul>
<li>Time Complexity: $O(k*n)$</li>
<li>set을 이용해서 key가 발견되면 좌우 index range를 update하고, 최후에 sorted된 list를 반환하는 방식으로 구현했다.</li>
</ul>
</li>
<li>개선 풀이<ul>
<li>Time Complexity: $O(n)$</li>
<li>sliding window를 통해 update해야할 필요가 있는 index를 범위를 줄인다</li>
<li>한 번만의 loop만으로 문제를 해결할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>

      <h2 id="trailing-zeros-제거하는-다양한-방법">
        <a name="trailing-zeros-제거하는-다양한-방법" class="anchor" href="#trailing-zeros-제거하는-다양한-방법">
          <span class="header-link"></span>
        </a>
        trailing zeros 제거하는 다양한 방법
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/remove-trailing-zeros-from-a-string/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/1057a28ce89c643e18d6b9f72a6aa5f3de68044b" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>문자열로 저장한 수에서 맨 뒤의 0들을 모두 제거하는 문제이다.</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>내 풀이<ul>
<li>내 풀이는 input string을 list로 변환한 뒤 pop을 사용해 0을 제거하는 방식으로 구현했다.</li>
<li>이는 python에서 list pop은 stack과 같이 동작하기 때문에 효율적이기 때문이다.</li>
</ul>
</li>
<li>다른 풀이<ul>
<li>rstrip을 사용한다</li>
<li>수를 integer로 변환하고 뒤집었다가 다시 뒤집는다</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>

      <h2 id="저장을-통해-연산-횟수-줄이기">
        <a name="저장을-통해-연산-횟수-줄이기" class="anchor" href="#저장을-통해-연산-횟수-줄이기">
          <span class="header-link"></span>
        </a>
        저장을 통해 연산 횟수 줄이기
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2970%20-%20LeetCode.py" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>integer array에서 subarrary를 삭제한 뒤에 전 구간에서 increasing하는 array가 되는 경우, 삭제한 subarray를 incremovable subarray라 한다. 이때 incremovable subarray의 개수를 구하는 문제이다.</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>Brute Force 풀이<ul>
<li>Time Complexity: $O(n^3)$</li>
<li>모든 subarray에 대해 잘라지지 않은 subarray가 increasing한지 확인하는 방법</li>
</ul>
</li>
<li>개선 풀이<ul>
<li>Time Complexity: $O(n^2)$</li>
<li>모든 subarray들의 increasing 여부를 저장한다. 그런 다음 자르고 나서 좌 우가 increasing하고, 연결부가 increasing한 경우를 찾는다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">for i in range(len(nums)):
    for j in range(i, len(nums)):
        if isIncreasingSubarray.get((0, i - 1), True) and isIncreasingSubarray.get((j + 1, len(nums) - 1), True):
            if nums[j+1] &gt; nums[i-1] if i &gt; 0 and j &lt; len(nums) - 1 else True:
                result += 1
</code></pre>
<hr>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/4월 1주차 알고리즘 문제">이전 포스트: <!-- -->4월 1주차 알고리즘 문제</a></div><div style="text-align:right"><a href="/Algorithm/4월 3주차 알고리즘 문제">다음 포스트: <!-- -->4월 3주차 알고리즘 문제</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-04-09-4월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-09-4월 2주차 알고리즘 문제.md","category":"Algorithm","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","content":"\n### 목차\n\n- [\\[금주의 문제\\] sliding window를 통해 더 적게 비교하기](#금주의-문제-sliding-window를-통해-더-적게-비교하기)\n- [trailing zeros 제거하는 다양한 방법](#trailing-zeros-제거하는-다양한-방법)\n- [저장을 통해 연산 횟수 줄이기](#저장을-통해-연산-횟수-줄이기)\n\n---\n\n## [금주의 문제] sliding window를 통해 더 적게 비교하기\n\n- [문제 링크](https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2200%20-%20LeetCode.py)\n\n- 문제 요약\n  - list integer에서 key값과 좌우로 k만큼 떨어진 index로 구성된 list를 구하는 문제이다.(findKthDistanceIndices)\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(k*n)$\n    - set을 이용해서 key가 발견되면 좌우 index range를 update하고, 최후에 sorted된 list를 반환하는 방식으로 구현했다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - sliding window를 통해 update해야할 필요가 있는 index를 범위를 줄인다\n    - 한 번만의 loop만으로 문제를 해결할 수 있다.\n\n---\n\n## trailing zeros 제거하는 다양한 방법\n\n- [문제 링크](https://leetcode.com/problems/remove-trailing-zeros-from-a-string/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/1057a28ce89c643e18d6b9f72a6aa5f3de68044b)\n\n- 문제 요약\n  - 문자열로 저장한 수에서 맨 뒤의 0들을 모두 제거하는 문제이다.\n- 풀이 요약\n  - 내 풀이\n    - 내 풀이는 input string을 list로 변환한 뒤 pop을 사용해 0을 제거하는 방식으로 구현했다.\n    - 이는 python에서 list pop은 stack과 같이 동작하기 때문에 효율적이기 때문이다.\n  - 다른 풀이\n    - rstrip을 사용한다\n    - 수를 integer로 변환하고 뒤집었다가 다시 뒤집는다\n\n---\n\n## 저장을 통해 연산 횟수 줄이기\n\n- [문제 링크](https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2970%20-%20LeetCode.py)\n\n- 문제 요약\n  - integer array에서 subarrary를 삭제한 뒤에 전 구간에서 increasing하는 array가 되는 경우, 삭제한 subarray를 incremovable subarray라 한다. 이때 incremovable subarray의 개수를 구하는 문제이다.\n- 풀이 요약\n  - Brute Force 풀이\n    - Time Complexity: $O(n^3)$\n    - 모든 subarray에 대해 잘라지지 않은 subarray가 increasing한지 확인하는 방법\n  - 개선 풀이\n    - Time Complexity: $O(n^2)$\n    - 모든 subarray들의 increasing 여부를 저장한다. 그런 다음 자르고 나서 좌 우가 increasing하고, 연결부가 increasing한 경우를 찾는다.\n\n```python\nfor i in range(len(nums)):\n    for j in range(i, len(nums)):\n        if isIncreasingSubarray.get((0, i - 1), True) and isIncreasingSubarray.get((j + 1, len(nums) - 1), True):\n            if nums[j+1] \u003e nums[i-1] if i \u003e 0 and j \u003c len(nums) - 1 else True:\n                result += 1\n```\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","date":"2024-04-09T00:00:00.000Z","categories":"Algorithm"}},"title":"4월 2주차 알고리즘 문제","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"4월 1주차 알고리즘 문제","category":"Algorithm"},"next":{"title":"4월 3주차 알고리즘 문제","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"4월 2주차 알고리즘 문제"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>