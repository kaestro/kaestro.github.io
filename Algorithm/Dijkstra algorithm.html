<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Dijkstra algorithm</h1><h1 class="project-subtitle">single-source shortest path algorithm(3)</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#1-introduction" title="null">1. Introduction</a></li>
<li><a target="_self" href="#2-algorithm-by-pseudocode" title="null">2. Algorithm by pseudocode</a></li>
<li><a target="_self" href="#algorithm-by-python" title="null">Algorithm by python</a></li>
<li><a target="_self" href="#time-complexity" title="null">Time complexity</a></li>
<li><a target="_self" href="#reference" title="null">Reference</a></li>
</ul>
<hr>

      <h2 id="1.-introduction">
        <a name="1.-introduction" class="anchor" href="#1.-introduction">
          <span class="header-link"></span>
        </a>
        1. Introduction
      </h2><p><code>Dijkstra algorithm</code>은 <code>단일 출발점 최단 경로 알고리즘</code> 중 하나로, <code>음수 가중치</code>를 가진 간선이
포함된 그래프에서는 사용할 수 없다. 대신 음수 가중치를 가진 간선이 없는 그래프에서는 <code>Bellman-ford algorithm</code>보다
더 빠르게 동작한다.</p>
<p>이를 위해 <code>Dijkstra algorithm</code>은 <code>priority queue</code>를 사용하여 최단 거리를 계산하며, 이미 계산이 완료된 정점
들은 다시 계산하지 않는다. 이 때문에 <code>Dijkstra algorithm</code>은 <code>그리디 알고리즘</code>으로 분류된다.</p>
<hr>

      <h2 id="2.-algorithm-by-pseudocode">
        <a name="2.-algorithm-by-pseudocode" class="anchor" href="#2.-algorithm-by-pseudocode">
          <span class="header-link"></span>
        </a>
        2. Algorithm by pseudocode
      </h2><p><code>Dijkstra algorithm</code>은 다음과 같은 방식으로 동작한다.</p>
<pre><code class="language-plaintest">DIJKSTRA(G, w, s)
1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.
2  S = {}  // 최단 경로가 발견된 정점들의 집합 S를 초기화합니다.
3  Q = V[G]  // 모든 정점들을 포함하는 우선순위 큐 Q를 생성합니다.
4  while Q != {}  // Q가 빌 때까지 반복합니다.
5      u = EXTRACT-MIN(Q)  // Q에서 거리 값이 가장 작은 정점 u를 추출합니다.
6      S = S append {u}  // u를 S에 추가합니다.
7      for each vertex v in Adj[u]  // u의 모든 인접 정점 v에 대해
8          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.
</code></pre>
<p><code>DIJKSTRA(G, w, s)</code>: 그래프 <code>G</code>와 가중치 함수 <code>w</code>, 시작 정점 <code>s</code>를 입력으로 받아 최단 경로를 계산한다.</p>
<p>이 때 사용하는 자료구조는 다음과 같다.</p>
<ul>
<li><code>S</code>: 이미 최단 거리를 계산한 정점의 집합</li>
<li><code>Q</code>: 아직 최단 거리를 계산하지 않은 정점의 집합</li>
<li><code>V[G]</code>: 그래프 <code>G</code>의 정점 집합</li>
<li><code>Adj[u]</code>: 정점 <code>u</code>에 인접한 정점들의 집합</li>
</ul>
<hr>

      <h2 id="algorithm-by-python">
        <a name="algorithm-by-python" class="anchor" href="#algorithm-by-python">
          <span class="header-link"></span>
        </a>
        Algorithm by python
      </h2><pre><code class="language-python">import heapq

def dijkstra(graph, start):
    distance, predecessor = dict(), dict()
    # 각 노드의 거리와 선행 노드를 초기화합니다
    for node in graph:
        distance[node], predecessor[node] = float(&#39;inf&#39;), None
    distance[start] = 0

    # 우선순위 큐를 초기화합니다
    queue = [(0, start)]

    while queue:
        # 우선순위 큐에서 가장 가까운 노드를 추출합니다
        current_distance, current_node = heapq.heappop(queue)
        # 이미 처리된 노드인 경우 건너뜁니다
        if current_distance &gt; distance[current_node]:
            continue
        # 인접 노드에 대해 최단 거리를 갱신합니다
        for neighbor, weight in graph[current_node].items():
            new_distance = current_distance + weight
            if new_distance &lt; distance[neighbor]:
                distance[neighbor] = new_distance
                predecessor[neighbor] = current_node
                heapq.heappush(queue, (new_distance, neighbor))
    return distance, predecessor
</code></pre>
<hr>

      <h2 id="time-complexity">
        <a name="time-complexity" class="anchor" href="#time-complexity">
          <span class="header-link"></span>
        </a>
        Time complexity
      </h2><p><code>Dijkstra algorithm</code>의 시간 복잡도는 <code>O((V + E) log V)</code>이다. 이는 <code>priority queue</code>를 사용하여
최단 거리를 계산하기 때문에 정점을 추출하는 과정이 <code>O(log V)</code>이기 때문이다. Bellman-ford algorithm과
달리 모든 간선이 아니라 <code>최소 거리를 가진 정점만</code>을 추출하여 계산하기 때문에 더 빠르게 동작한다.</p>
<hr>

      <h2 id="reference">
        <a name="reference" class="anchor" href="#reference">
          <span class="header-link"></span>
        </a>
        Reference
      </h2><ul>
<li><a target="_self" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" title="null">Dijkstra algorithm - wikipedia</a></li>
<li><a target="_self" href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/" title="null">Dijkstra algorithm - geeksforgeeks</a></li>
<li><a target="_self" href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition" title="null">Introduction to algorithms, 3rd edition</a></li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/Bellman-ford algorithm">이전 포스트: <!-- -->Bellman-ford algorithm</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-05-10-Shortest Path(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(3).md","category":"Algorithm","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`Dijkstra algorithm`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n포함된 그래프에서는 사용할 수 없다. 대신 음수 가중치를 가진 간선이 없는 그래프에서는 `Bellman-ford algorithm`보다\n더 빠르게 동작한다.\n\n이를 위해 `Dijkstra algorithm`은 `priority queue`를 사용하여 최단 거리를 계산하며, 이미 계산이 완료된 정점\n들은 다시 계산하지 않는다. 이 때문에 `Dijkstra algorithm`은 `그리디 알고리즘`으로 분류된다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n`Dijkstra algorithm`은 다음과 같은 방식으로 동작한다.\n\n```plaintest\nDIJKSTRA(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  S = {}  // 최단 경로가 발견된 정점들의 집합 S를 초기화합니다.\n3  Q = V[G]  // 모든 정점들을 포함하는 우선순위 큐 Q를 생성합니다.\n4  while Q != {}  // Q가 빌 때까지 반복합니다.\n5      u = EXTRACT-MIN(Q)  // Q에서 거리 값이 가장 작은 정점 u를 추출합니다.\n6      S = S append {u}  // u를 S에 추가합니다.\n7      for each vertex v in Adj[u]  // u의 모든 인접 정점 v에 대해\n8          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n```\n\n`DIJKSTRA(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `S`: 이미 최단 거리를 계산한 정점의 집합\n- `Q`: 아직 최단 거리를 계산하지 않은 정점의 집합\n- `V[G]`: 그래프 `G`의 정점 집합\n- `Adj[u]`: 정점 `u`에 인접한 정점들의 집합\n\n---\n\n## Algorithm by python\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 우선순위 큐를 초기화합니다\n    queue = [(0, start)]\n\n    while queue:\n        # 우선순위 큐에서 가장 가까운 노드를 추출합니다\n        current_distance, current_node = heapq.heappop(queue)\n        # 이미 처리된 노드인 경우 건너뜁니다\n        if current_distance \u003e distance[current_node]:\n            continue\n        # 인접 노드에 대해 최단 거리를 갱신합니다\n        for neighbor, weight in graph[current_node].items():\n            new_distance = current_distance + weight\n            if new_distance \u003c distance[neighbor]:\n                distance[neighbor] = new_distance\n                predecessor[neighbor] = current_node\n                heapq.heappush(queue, (new_distance, neighbor))\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n`Dijkstra algorithm`의 시간 복잡도는 `O((V + E) log V)`이다. 이는 `priority queue`를 사용하여\n최단 거리를 계산하기 때문에 정점을 추출하는 과정이 `O(log V)`이기 때문이다. Bellman-ford algorithm과\n달리 모든 간선이 아니라 `최소 거리를 가진 정점만`을 추출하여 계산하기 때문에 더 빠르게 동작한다.\n\n---\n\n## Reference\n\n- [Dijkstra algorithm - wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n- [Dijkstra algorithm - geeksforgeeks](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\n- [Introduction to algorithms, 3rd edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":3}},"title":"Dijkstra algorithm","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"Bellman-ford algorithm","category":"Algorithm"},"next":null}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"Dijkstra algorithm"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>