<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">BFS and DFS</h1><h1 class="project-subtitle">그래프를 탐색하는 두 가지 단순한 방법</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="bfs와-dfs는-그래프를-탐색하는-방법-중-두-가지입니다">
        <a name="bfs와-dfs는-그래프를-탐색하는-방법-중-두-가지입니다" class="anchor" href="#bfs와-dfs는-그래프를-탐색하는-방법-중-두-가지입니다">
          <span class="header-link"></span>
        </a>
        BFS와 DFS는 그래프를 탐색하는 방법 중 두 가지입니다
      </h2><p>BFS(Breadth First Search)와 DFS(Depth First Search)는 그래프를 탐색하는 방법 중 하나입니다. 여기서 그래프를 탐색한다는 것은 그래프의 정점(vertex)에 접근해서 해당 정점이 가지고 있는 정보를 이용해 자신이 원하는 연산을 수행하는 것을 의미합니다. 미로 찾기 문제를 풀 때, 미로를 그래프로 표현하고 출발점에서 도착점까지의 경로를 찾는 문제를 풀 때 각각의 정점을 방문하면서 탈출구에 도달할 때까지 탐색하는 것이 그래프 탐색의 한 예입니다.</p>

      <h3 id="bfs(breadth-first-search)">
        <a name="bfs(breadth-first-search)" class="anchor" href="#bfs(breadth-first-search)">
          <span class="header-link"></span>
        </a>
        BFS(Breadth First Search)
      </h3><p>BFS는 그래프를 탐색할 때 너비를 우선으로 탐색하는 방법입니다. 즉, 시작 정점에서 가까운 정점부터 탐색을 진행하며 큐(Queue)를 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산의 경우에는 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 시간 복잡도는 $O(V+E)$입니다. 이를 통해 풀 수 있는 문제의 예시로는 모든 정점 간의 거리가 같을 때 최단 경로를 찾는 문제가 있습니다.</p>

      <h4 id="shortest-path">
        <a name="shortest-path" class="anchor" href="#shortest-path">
          <span class="header-link"></span>
        </a>
        shortest path
      </h4>
      <h3 id="dfs(depth-first-search)">
        <a name="dfs(depth-first-search)" class="anchor" href="#dfs(depth-first-search)">
          <span class="header-link"></span>
        </a>
        DFS(Depth First Search)
      </h3><p>DFS는 그래프를 탐색할 때 깊이를 우선으로 탐색하는 방법입니다. 시작 정점에서 깊이를 우선으로 탐색을 진행하며 스택(Stack)을 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산은 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 BFS와 마찬가지로 시간 복잡도는 $O(V+E)$입니다.</p>
<p>DFS는 각각의 간선을 다음의 네 가지로 구분하는 데 사용할 수 있습니다.</p>
<pre><code class="language-plaintext">1. 트리 간선(tree edge): DFS 트리에서 나온 간선(edge)
2. 순방향 간선(forward edge): DFS 트리에서 나온 간선이 아니지만, 자식 노드로 가는 간선(edge)
3. 역방향 간선(back edge): DFS 트리에서 나온 간선이 아니지만, 조상 노드로 가는 간선(edge)
4. 교차 간선(cross edge): DFS 트리에서 나온 간선이 아니지만, 서로 다른 서브트리 간의 간선(edge)
</code></pre>
<p>여기서 dfs트리란 DFS를 수행하면서 만들어지는 각 정점을 방문하는 순서대로 정렬된 트리를 의미합니다. DFS 트리에서 나온 간선(edge)이라는 것은 DFS를 수행하면서 만들어지는 트리에서 나온 것을 의미하며 나머지 간선(edge)들은 DFS 트리에서 나오지 않는 것들입니다.</p>

      <h4 id="topological-sort">
        <a name="topological-sort" class="anchor" href="#topological-sort">
          <span class="header-link"></span>
        </a>
        topological sort
      </h4><p>구성 요소 간에 우선순위가 존재하는 경우 이를 정렬하는 것을 위상정렬(topological sort)이라고 합니다. 위상정렬은 DFS를 이용하여 구현할 수 있으며 다음과 같은 순서를 따릅니다.</p>
<pre><code class="language-plaintext">1. DFS를 이용하여 그래프를 탐색한다. 탐색하는 과정에서 각각의 정점을 방문하는데 걸린 시간을 기록한다.
2. 모든 정점을 방문한 후, 각 정점을 방문한 시간을 기준으로 내림차순으로 정렬한 linked list를 반환한다.
</code></pre>
<pre><code class="language-plaintext">1. DFS를 이용하여 그래프를 탐색한다.
2. 탐색하고 빠져나오는 순간에 해당 정점을 linked list의 맨 앞에 추가한다.
3. 이를 모든 정점을 방문할 때까지 반복한다.
4. linked list를 반환한다.
</code></pre>
<pre><code class="language-python">def topological_sort(graph):
    visited = [False] * len(graph)
    topological_order = []
    stack = []

    for v in range(len(graph)):
        if not visited[v]:
            stack.append(v)
            while stack:
                node = stack[-1]
                if not visited[node]:
                    visited[node] = True
                    for neighbor in graph[node]:
                        if not visited[neighbor]:
                            stack.append(neighbor)
                else:
                    stack.pop()
                    topological_order.append(node)

    return topological_order[::-1]
</code></pre>

      <h4 id="acyclic-graph">
        <a name="acyclic-graph" class="anchor" href="#acyclic-graph">
          <span class="header-link"></span>
        </a>
        acyclic graph
      </h4><p>acyclic graph는 사이클이 없는 그래프를 의미합니다. 이 때 acyclic graph는 위상정렬을 통해 정렬할 수 있습니다.</p>

      <h4 id="strongly-connected-components">
        <a name="strongly-connected-components" class="anchor" href="#strongly-connected-components">
          <span class="header-link"></span>
        </a>
        strongly connected components
      </h4><p>strongly connected component는 모든 구성 vertex(정점)들이 서로 도달 가능한 그래프의 부분 그래프를 의미합니다. 이를 수학적으로 표현하면 다음과 같습니다.</p>
<p>vertices C is strongly connected component when</p>
<p>$$G = (V, E)$$
$$C \subseteq V$$
$$\forall u, \forall v \in C, u \rightarrow v \text{ and } v \rightarrow u$$</p>
<p>이를 DFS를 이용해 구하는 방법은 다음과 같습니다.</p>
<ol>
<li>그래프 $G$에 대해 DFS를 수행해서 모든 정점에 대해 끝나는 시간을 기록한다.</li>
<li>그래프 $G$의 간선을 뒤집어서 그래프 $G^T$를 만든다.</li>
<li>$G^T$에 대해 DFS를 수행해서 끝나는 시간이 큰 정점부터 탐색한다.</li>
<li>탐색하는 과정에서 방문하는 정점들이 하나의 strongly connected component를 형성한다.</li>
</ol>
<pre><code class="language-python">def strongly_connected_components(graph):
    visited = [False] * len(graph)
    stack = []
    for v in range(len(graph)):
        if not visited[v]:
            dfs(graph, v, visited, stack)

    graph_reverse = [[] for _ in range(len(graph))]
    for v in range(len(graph)):
        for neighbor in graph[v]:
            graph_reverse[neighbor].append(v)

    visited = [False] * len(graph)
    components = []
    while stack:
        node = stack.pop()
        if not visited[node]:
            component = []
            dfs_reverse(graph_reverse, node, visited, component)
            components.append(component)

    return components
</code></pre>
<hr>

      <h2 id="출처">
        <a name="출처" class="anchor" href="#출처">
          <span class="header-link"></span>
        </a>
        출처
      </h2><ul>
<li>Introduction to Algorithms, 3rd Edition. Thomas H. Cormen, Charles E. pg.610 ~ 644</li>
<li><a target="_self" href="https://www.geeksforgeeks.org/introduction-to-directed-acyclic-graph/" title="null">GeeksforGeeks</a></li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/Dynamic Programming">이전 포스트: <!-- -->Dynamic Programming</a></div><div style="text-align:right"><a href="/Algorithm/Introduction to Shortest Path algorithm">다음 포스트: <!-- -->Introduction to Shortest Path algorithm</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-04-25-BFS and DFS","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-25-BFS and DFS.md","category":"Algorithm","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","content":"\n## BFS와 DFS는 그래프를 탐색하는 방법 중 두 가지입니다\n\nBFS(Breadth First Search)와 DFS(Depth First Search)는 그래프를 탐색하는 방법 중 하나입니다. 여기서 그래프를 탐색한다는 것은 그래프의 정점(vertex)에 접근해서 해당 정점이 가지고 있는 정보를 이용해 자신이 원하는 연산을 수행하는 것을 의미합니다. 미로 찾기 문제를 풀 때, 미로를 그래프로 표현하고 출발점에서 도착점까지의 경로를 찾는 문제를 풀 때 각각의 정점을 방문하면서 탈출구에 도달할 때까지 탐색하는 것이 그래프 탐색의 한 예입니다.\n\n### BFS(Breadth First Search)\n\nBFS는 그래프를 탐색할 때 너비를 우선으로 탐색하는 방법입니다. 즉, 시작 정점에서 가까운 정점부터 탐색을 진행하며 큐(Queue)를 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산의 경우에는 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 시간 복잡도는 $O(V+E)$입니다. 이를 통해 풀 수 있는 문제의 예시로는 모든 정점 간의 거리가 같을 때 최단 경로를 찾는 문제가 있습니다.\n\n#### shortest path\n\n### DFS(Depth First Search)\n\nDFS는 그래프를 탐색할 때 깊이를 우선으로 탐색하는 방법입니다. 시작 정점에서 깊이를 우선으로 탐색을 진행하며 스택(Stack)을 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산은 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 BFS와 마찬가지로 시간 복잡도는 $O(V+E)$입니다.\n\nDFS는 각각의 간선을 다음의 네 가지로 구분하는 데 사용할 수 있습니다.\n\n```plaintext\n1. 트리 간선(tree edge): DFS 트리에서 나온 간선(edge)\n2. 순방향 간선(forward edge): DFS 트리에서 나온 간선이 아니지만, 자식 노드로 가는 간선(edge)\n3. 역방향 간선(back edge): DFS 트리에서 나온 간선이 아니지만, 조상 노드로 가는 간선(edge)\n4. 교차 간선(cross edge): DFS 트리에서 나온 간선이 아니지만, 서로 다른 서브트리 간의 간선(edge)\n```\n\n여기서 dfs트리란 DFS를 수행하면서 만들어지는 각 정점을 방문하는 순서대로 정렬된 트리를 의미합니다. DFS 트리에서 나온 간선(edge)이라는 것은 DFS를 수행하면서 만들어지는 트리에서 나온 것을 의미하며 나머지 간선(edge)들은 DFS 트리에서 나오지 않는 것들입니다.\n\n#### topological sort\n\n구성 요소 간에 우선순위가 존재하는 경우 이를 정렬하는 것을 위상정렬(topological sort)이라고 합니다. 위상정렬은 DFS를 이용하여 구현할 수 있으며 다음과 같은 순서를 따릅니다.\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다. 탐색하는 과정에서 각각의 정점을 방문하는데 걸린 시간을 기록한다.\n2. 모든 정점을 방문한 후, 각 정점을 방문한 시간을 기준으로 내림차순으로 정렬한 linked list를 반환한다.\n```\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다.\n2. 탐색하고 빠져나오는 순간에 해당 정점을 linked list의 맨 앞에 추가한다.\n3. 이를 모든 정점을 방문할 때까지 반복한다.\n4. linked list를 반환한다.\n```\n\n```python\ndef topological_sort(graph):\n    visited = [False] * len(graph)\n    topological_order = []\n    stack = []\n\n    for v in range(len(graph)):\n        if not visited[v]:\n            stack.append(v)\n            while stack:\n                node = stack[-1]\n                if not visited[node]:\n                    visited[node] = True\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            stack.append(neighbor)\n                else:\n                    stack.pop()\n                    topological_order.append(node)\n\n    return topological_order[::-1]\n```\n\n#### acyclic graph\n\nacyclic graph는 사이클이 없는 그래프를 의미합니다. 이 때 acyclic graph는 위상정렬을 통해 정렬할 수 있습니다.\n\n#### strongly connected components\n\nstrongly connected component는 모든 구성 vertex(정점)들이 서로 도달 가능한 그래프의 부분 그래프를 의미합니다. 이를 수학적으로 표현하면 다음과 같습니다.\n\nvertices C is strongly connected component when\n\n$$G = (V, E)$$\n$$C \\subseteq V$$\n$$\\forall u, \\forall v \\in C, u \\rightarrow v \\text{ and } v \\rightarrow u$$\n\n이를 DFS를 이용해 구하는 방법은 다음과 같습니다.\n\n1. 그래프 $G$에 대해 DFS를 수행해서 모든 정점에 대해 끝나는 시간을 기록한다.\n2. 그래프 $G$의 간선을 뒤집어서 그래프 $G^T$를 만든다.\n3. $G^T$에 대해 DFS를 수행해서 끝나는 시간이 큰 정점부터 탐색한다.\n4. 탐색하는 과정에서 방문하는 정점들이 하나의 strongly connected component를 형성한다.\n\n```python\ndef strongly_connected_components(graph):\n    visited = [False] * len(graph)\n    stack = []\n    for v in range(len(graph)):\n        if not visited[v]:\n            dfs(graph, v, visited, stack)\n\n    graph_reverse = [[] for _ in range(len(graph))]\n    for v in range(len(graph)):\n        for neighbor in graph[v]:\n            graph_reverse[neighbor].append(v)\n\n    visited = [False] * len(graph)\n    components = []\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs_reverse(graph_reverse, node, visited, component)\n            components.append(component)\n\n    return components\n```\n\n---\n\n## 출처\n\n- Introduction to Algorithms, 3rd Edition. Thomas H. Cormen, Charles E. pg.610 ~ 644\n- [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-directed-acyclic-graph/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","date":"2024-04-25T00:00:00.000Z","categories":"Algorithm"}},"title":"BFS and DFS","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"Dynamic Programming","category":"Algorithm"},"next":{"title":"Introduction to Shortest Path algorithm","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"BFS and DFS"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>