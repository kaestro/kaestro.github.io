<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Dynamic Programming</h1><h1 class="project-subtitle">최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="dynamic-programming은-optimization-problem-해결-방법이다">
        <a name="dynamic-programming은-optimization-problem-해결-방법이다" class="anchor" href="#dynamic-programming은-optimization-problem-해결-방법이다">
          <span class="header-link"></span>
        </a>
        Dynamic Programming은 Optimization Problem 해결 방법이다
      </h2><p>여러 가지 문제 중에 Dynamic Programming을 사용해서 푸는 문제들은 Optimization Problem을 푸는 경우로 한정됩니다. 그렇다면 Optimization Problem은 무엇을 의미하는 것일까요?</p>
<p>이는 여러개의 <a target="_self" href="https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/" title="null">선택 가능한 후보 중에서 최적의 해 또는 최적의 해에 근접한 값을 찾는 문제</a>를 말합니다. 이는 종종 <a target="_self" href="https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html" title="null">특정 기능의 최대값 또는 최소값을 찾는 것</a>이 포함됩니다. 예를 들면 이동에 소요되는 최소 시간, 작업 수행에 필요한 최소 비용, 장치에서 생성할 수 있는 최대 전력 등이 있습니다.</p>
<hr>

      <h2 id="dynamic-programming을-사용하는-문제의-특징">
        <a name="dynamic-programming을-사용하는-문제의-특징" class="anchor" href="#dynamic-programming을-사용하는-문제의-특징">
          <span class="header-link"></span>
        </a>
        Dynamic Programming을 사용하는 문제의 특징
      </h2><p>최적값을 문제를 푸는 문제들 중에서도 Dynamic Programming을 통해 해결할 수 있는 문제들은 다음의 두 가지 특징을 가지고 있습니다.</p>
<ol>
<li><strong>Optimal Substructure</strong> : 문제의 최적해가 부분 문제의 최적해로 구성되어 있습니다.</li>
<li><strong>Overlapping Subproblems</strong> : 부분 문제들이 중복되어 계산되는 경우가 있습니다.</li>
</ol>

      <h3 id="optimal-substructure">
        <a name="optimal-substructure" class="anchor" href="#optimal-substructure">
          <span class="header-link"></span>
        </a>
        Optimal Substructure
      </h3><p>문제의 최적해가 부분 문제의 최적해로 구성돼 있다는 다음과 같은 의미를 나타냅니다. 우선, 주어진 문제의 최적해를 선택할 수 있다고 가정해 보겠습니다. 이 최적해를 구하는 구조의 특징을 통해 최적해의 값을 정의내릴 때, 부분 문제의 최적해를 사용할 수 있습니다.</p>
<p>예를 들어, Rod-Cutting 문제 즉 막대기를 가장 비싼 가격의 단위 막대기들로 자르는 최적의 해를 구하는 문제를 생각해보겠습니다. 이 문제에서 막대기는 단위 길이별로 가격이 정해져 있습니다.</p>
<p>$$Price_1 = 1, Price_2 = 5, Price_3 = 8$$과 같이 말입니다.</p>
<p>이 때 길이가 4인 막대기를 자르는 최적의 해를 구한다고 가정했을 때, 길이가 5인 막대기를 자르는 최적의 해를 구하는 방법은 다음과 같습니다.</p>
<p>$$Price_5 = \max_{k=1}^{3}(Price_k + Price_{5-k})$$</p>
<p>이처럼 특정 순간의 최적해를 구할 때, 그 최적해를 구성하는 부분 문제의 최적해를 사용해서 표현할 수 있습니다.</p>

      <h3 id="overlapping-subproblems">
        <a name="overlapping-subproblems" class="anchor" href="#overlapping-subproblems">
          <span class="header-link"></span>
        </a>
        Overlapping Subproblems
      </h3><p>이 때 부분 문제들을 구하는 과정 역시 중복되어 계산되는 경우가 있습니다. 방금의 Rod-Cutting 문제를 예시로 들면 Price(5)의 최적해를 구하기 위해서는 Price(4), Price(3), Price(2)의 값을 계산해야합니다. 그리고 이는 다시 {Price(3), Price(2), Price(1)}, {Price(2), Price(1), Price(0)}의 값을 계산해야합니다. 이 때 Price(3)은 Price(2)를 계산할 때도 필요하고 Price(1)을 계산할 때도 필요합니다.</p>
<hr>

      <h2 id="dynamic-programming의-구현-방법">
        <a name="dynamic-programming의-구현-방법" class="anchor" href="#dynamic-programming의-구현-방법">
          <span class="header-link"></span>
        </a>
        Dynamic Programming의 구현 방법
      </h2><p>Dynamic Programming을 구현하는 방법은 요약하자면 다음과 같습니다.</p>
<pre><code class="language-markdown">1. 최적해를 구하는 경우를 나타내는 함수를 부분 문제의 최적해를 이용해 표현합니다.
2. 부분 문제가 더 나눌 수 없는 경우를 찾아내고, 이를 기저 조건으로 설정합니다.
3. 부분 문제를 구하는 과정에서 중복되는 계산을 피하기 위해, 부분 문제의 최적해를 저장하는 배열을 사용합니다.
</code></pre>

      <h3 id="top-down-approach">
        <a name="top-down-approach" class="anchor" href="#top-down-approach">
          <span class="header-link"></span>
        </a>
        Top-Down Approach
      </h3><p>Top-Down Approach는 재귀적인(recursive) 방법을 사용하여 문제를 푸는 방법입니다. 예를 들어 rod-cutting 문제를 해결하려 할 때 Price(5)의 값을 구하기 위해 Price(4), Price(3), Price(2)의 값을 구하는 방법입니다. 이는 보통 재귀적인 방법을 사용하여 구현되며 이를 memoization이라고 합니다.</p>

      <h3 id="bottom-up-approach">
        <a name="bottom-up-approach" class="anchor" href="#bottom-up-approach">
          <span class="header-link"></span>
        </a>
        Bottom-Up Approach
      </h3><p>Bottom-Up Approach는 반복적인(iterative) 방법을 사용하여 문제를 푸는 방법입니다. 이는 보통 반복문을 사용하여 작은 값부터 큰 값까지 순차적으로 계산하는 방법입니다. 이를 tabulation이라고 합니다.</p>
<p>문제의 성향에 따라 Top-down approach가 더 적은 연산을 필요로 할 수도 있지만, Bottom-up approach가 더 직관적이고 iterative한 계산 방식을 사용하기 때문에 디버깅에 용이한 등의 장점을 가지고 있습니다.</p>
<hr>

      <h2 id="참고-자료">
        <a name="참고-자료" class="anchor" href="#참고-자료">
          <span class="header-link"></span>
        </a>
        참고 자료
      </h2><ul>
<li>Introduction To algorithms pg.380 ~ 434</li>
<li><a target="_self" href="https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/" title="null">Convex Optimization for All</a></li>
<li><a target="_self" href="https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html" title="null">Optimization Problems</a></li>
<li><a target="_self" href="https://www.geeksforgeeks.org/tabulation-vs-memoization/" title="null">tabulation vs memoization</a></li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/5월 2주차 알고리즘 문제">이전 포스트: <!-- -->5월 2주차 알고리즘 문제</a></div><div style="text-align:right"><a href="/Algorithm/BFS and DFS">다음 포스트: <!-- -->BFS and DFS</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-04-24-Dynamic Programming","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-24-Dynamic Programming.md","category":"Algorithm","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","content":"\n## Dynamic Programming은 Optimization Problem 해결 방법이다\n\n여러 가지 문제 중에 Dynamic Programming을 사용해서 푸는 문제들은 Optimization Problem을 푸는 경우로 한정됩니다. 그렇다면 Optimization Problem은 무엇을 의미하는 것일까요?\n\n이는 여러개의 [선택 가능한 후보 중에서 최적의 해 또는 최적의 해에 근접한 값을 찾는 문제](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)를 말합니다. 이는 종종 [특정 기능의 최대값 또는 최소값을 찾는 것](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)이 포함됩니다. 예를 들면 이동에 소요되는 최소 시간, 작업 수행에 필요한 최소 비용, 장치에서 생성할 수 있는 최대 전력 등이 있습니다.\n\n---\n\n## Dynamic Programming을 사용하는 문제의 특징\n\n최적값을 문제를 푸는 문제들 중에서도 Dynamic Programming을 통해 해결할 수 있는 문제들은 다음의 두 가지 특징을 가지고 있습니다.\n\n1. **Optimal Substructure** : 문제의 최적해가 부분 문제의 최적해로 구성되어 있습니다.\n2. **Overlapping Subproblems** : 부분 문제들이 중복되어 계산되는 경우가 있습니다.\n\n### Optimal Substructure\n\n문제의 최적해가 부분 문제의 최적해로 구성돼 있다는 다음과 같은 의미를 나타냅니다. 우선, 주어진 문제의 최적해를 선택할 수 있다고 가정해 보겠습니다. 이 최적해를 구하는 구조의 특징을 통해 최적해의 값을 정의내릴 때, 부분 문제의 최적해를 사용할 수 있습니다.\n\n예를 들어, Rod-Cutting 문제 즉 막대기를 가장 비싼 가격의 단위 막대기들로 자르는 최적의 해를 구하는 문제를 생각해보겠습니다. 이 문제에서 막대기는 단위 길이별로 가격이 정해져 있습니다.\n\n$$Price_1 = 1, Price_2 = 5, Price_3 = 8$$과 같이 말입니다.\n\n이 때 길이가 4인 막대기를 자르는 최적의 해를 구한다고 가정했을 때, 길이가 5인 막대기를 자르는 최적의 해를 구하는 방법은 다음과 같습니다.\n\n$$Price_5 = \\max_{k=1}^{3}(Price_k + Price_{5-k})$$\n\n이처럼 특정 순간의 최적해를 구할 때, 그 최적해를 구성하는 부분 문제의 최적해를 사용해서 표현할 수 있습니다.\n\n### Overlapping Subproblems\n\n이 때 부분 문제들을 구하는 과정 역시 중복되어 계산되는 경우가 있습니다. 방금의 Rod-Cutting 문제를 예시로 들면 Price(5)의 최적해를 구하기 위해서는 Price(4), Price(3), Price(2)의 값을 계산해야합니다. 그리고 이는 다시 {Price(3), Price(2), Price(1)}, {Price(2), Price(1), Price(0)}의 값을 계산해야합니다. 이 때 Price(3)은 Price(2)를 계산할 때도 필요하고 Price(1)을 계산할 때도 필요합니다.\n\n---\n\n## Dynamic Programming의 구현 방법\n\nDynamic Programming을 구현하는 방법은 요약하자면 다음과 같습니다.\n\n```markdown\n1. 최적해를 구하는 경우를 나타내는 함수를 부분 문제의 최적해를 이용해 표현합니다.\n2. 부분 문제가 더 나눌 수 없는 경우를 찾아내고, 이를 기저 조건으로 설정합니다.\n3. 부분 문제를 구하는 과정에서 중복되는 계산을 피하기 위해, 부분 문제의 최적해를 저장하는 배열을 사용합니다.\n```\n\n### Top-Down Approach\n\nTop-Down Approach는 재귀적인(recursive) 방법을 사용하여 문제를 푸는 방법입니다. 예를 들어 rod-cutting 문제를 해결하려 할 때 Price(5)의 값을 구하기 위해 Price(4), Price(3), Price(2)의 값을 구하는 방법입니다. 이는 보통 재귀적인 방법을 사용하여 구현되며 이를 memoization이라고 합니다.\n\n### Bottom-Up Approach\n\nBottom-Up Approach는 반복적인(iterative) 방법을 사용하여 문제를 푸는 방법입니다. 이는 보통 반복문을 사용하여 작은 값부터 큰 값까지 순차적으로 계산하는 방법입니다. 이를 tabulation이라고 합니다.\n\n문제의 성향에 따라 Top-down approach가 더 적은 연산을 필요로 할 수도 있지만, Bottom-up approach가 더 직관적이고 iterative한 계산 방식을 사용하기 때문에 디버깅에 용이한 등의 장점을 가지고 있습니다.\n\n---\n\n## 참고 자료\n\n- Introduction To algorithms pg.380 ~ 434\n- [Convex Optimization for All](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)\n- [Optimization Problems](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)\n- [tabulation vs memoization](https://www.geeksforgeeks.org/tabulation-vs-memoization/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","date":"2024-04-24T00:00:00.000Z","categories":"Algorithm"}},"title":"Dynamic Programming","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"5월 2주차 알고리즘 문제","category":"Algorithm"},"next":{"title":"BFS and DFS","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"Dynamic Programming"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>