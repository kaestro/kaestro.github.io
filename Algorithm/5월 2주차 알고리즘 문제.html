<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">5월 2주차 알고리즘 문제</h1><h1 class="project-subtitle">과연 중간 과정은 꼭 필요할까?</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#on으로-배열-내-요소-간-최대-차이-구하기" title="null">$O(n)$으로 배열 내 요소 간 최대 차이 구하기</a></li>
<li><a target="_self" href="#필요-없는-중간과정-생략하기" title="null">필요 없는 중간과정 생략하기</a></li>
<li><a target="_self" href="#3개의-distinct한-subarray를-구하는-방법" title="null">3개의 distinct한 subarray를 구하는 방법</a></li>
</ul>
<hr>

      <h2 id="$o(n)$으로-배열-내-요소-간-최대-차이-구하기">
        <a name="$o(n)$으로-배열-내-요소-간-최대-차이-구하기" class="anchor" href="#$o(n)$으로-배열-내-요소-간-최대-차이-구하기">
          <span class="header-link"></span>
        </a>
        $O(n)$으로 배열 내 요소 간 최대 차이 구하기
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>int array가 주어졌을 때, i &lt; j이고 A[i] &lt; A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>기존 풀이<ul>
<li>Time Complexity: $O(n^2)$</li>
<li>i &lt; j이고 A[i] &lt; A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.</li>
<li>따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.</li>
</ul>
</li>
<li>개선 풀이<ul>
<li>Time Complexity: $O(n)$</li>
<li>A[j] &gt; A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.</li>
<li>그렇지 않을 경우에는 i를 j로 갱신한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">def maxDifference(self, nums: List[int]) -&gt; int:
    max_diff = -1
    min_val = nums[0]
    for i in range(1, len(nums)):
        if nums[i] &gt; min_val:
            max_diff = max(max_diff, nums[i] - min_val)
        else:
            min_val = nums[i]
    return max_diff
</code></pre>
<hr>

      <h2 id="필요-없는-중간과정-생략하기">
        <a name="필요-없는-중간과정-생략하기" class="anchor" href="#필요-없는-중간과정-생략하기">
          <span class="header-link"></span>
        </a>
        필요 없는 중간과정 생략하기
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>기존 풀이<ul>
<li>n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.</li>
</ul>
</li>
<li>개선 풀이<ul>
<li>어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.</li>
<li>따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.</li>
<li>이 때문에 처음과 끝만 보면 된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">def mostVisited(self, n: int, rounds: List[int]) -&gt; List[int]:
    start, end = rounds[0], rounds[-1]
    if start &lt;= end:
        return list(range(start, end + 1))
    else:
        return list(range(1, end + 1)) + list(range(start, n + 1))
</code></pre>
<hr>

      <h2 id="3개의-distinct한-subarray를-구하는-방법">
        <a name="3개의-distinct한-subarray를-구하는-방법" class="anchor" href="#3개의-distinct한-subarray를-구하는-방법">
          <span class="header-link"></span>
        </a>
        3개의 distinct한 subarray를 구하는 방법
      </h2><ul>
<li><p><a target="_self" href="https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/" title="null">문제 링크</a></p>
</li>
<li><p><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6" title="null">내 풀이</a></p>
</li>
<li><p>문제 요약</p>
<ul>
<li>int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.</li>
<li>subarray는 연속된 요소들의 집합이다.</li>
</ul>
</li>
<li><p>풀이 요약</p>
<ul>
<li>Time Complexity: $O(n^2)$</li>
<li>3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.</li>
</ul>
</li>
</ul>
<pre><code class="language-go">func minCost(nums []int) int {
    n := len(nums)

    minCost := math.MaxInt32
    for i := 1; i &lt; n - 1; i++ {
        for j := i + 1; j &lt; n; j++ {
            cost := nums[0] + nums[i] + nums[j]
            minCost = min(minCost, cost)
        }
    }
    return minCost
}
</code></pre>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/Algorithm/5월 1주차 알고리즘 문제">이전 포스트: <!-- -->5월 1주차 알고리즘 문제</a></div><div style="text-align:right"><a href="/Algorithm/Dynamic Programming">다음 포스트: <!-- -->Dynamic Programming</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-05-12-5월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-12-5월 2주차 알고리즘 문제.md","category":"Algorithm","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","content":"\n### 목차\n\n- [$O(n)$으로 배열 내 요소 간 최대 차이 구하기](#on으로-배열-내-요소-간-최대-차이-구하기)\n- [필요 없는 중간과정 생략하기](#필요-없는-중간과정-생략하기)\n- [3개의 distinct한 subarray를 구하는 방법](#3개의-distinct한-subarray를-구하는-방법)\n\n---\n\n## $O(n)$으로 배열 내 요소 간 최대 차이 구하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea)\n\n- 문제 요약\n  - int array가 주어졌을 때, i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(n^2)$\n    - i \u003c j이고 A[i] \u003c A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.\n    - 따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - A[j] \u003e A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.\n    - 그렇지 않을 경우에는 i를 j로 갱신한다.\n\n```python\ndef maxDifference(self, nums: List[int]) -\u003e int:\n    max_diff = -1\n    min_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] \u003e min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n    return max_diff\n```\n\n---\n\n## 필요 없는 중간과정 생략하기\n\n- [문제 링크](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2)\n\n- 문제 요약\n  - n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.\n  - 개선 풀이\n    - 어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.\n    - 따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.\n    - 이 때문에 처음과 끝만 보면 된다.\n\n```python\ndef mostVisited(self, n: int, rounds: List[int]) -\u003e List[int]:\n    start, end = rounds[0], rounds[-1]\n    if start \u003c= end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(1, end + 1)) + list(range(start, n + 1))\n```\n\n---\n\n## 3개의 distinct한 subarray를 구하는 방법\n\n- [문제 링크](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6)\n\n- 문제 요약\n  - int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.\n  - subarray는 연속된 요소들의 집합이다.\n- 풀이 요약\n  - Time Complexity: $O(n^2)$\n  - 3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n\n```go\nfunc minCost(nums []int) int {\n    n := len(nums)\n\n    minCost := math.MaxInt32\n    for i := 1; i \u003c n - 1; i++ {\n        for j := i + 1; j \u003c n; j++ {\n            cost := nums[0] + nums[i] + nums[j]\n            minCost = min(minCost, cost)\n        }\n    }\n    return minCost\n}\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","date":"2024-05-12T00:00:00.000Z","categories":"Algorithm"}},"title":"5월 2주차 알고리즘 문제","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"5월 1주차 알고리즘 문제","category":"Algorithm"},"next":{"title":"Dynamic Programming","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"5월 2주차 알고리즘 문제"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>