<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">4월 1주차 알고리즘 문제</h1><h1 class="project-subtitle">가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h3 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h3><ul>
<li><a target="_self" href="#이번-주의-문제-can-make-palindrome-from-substring" title="null">[이번 주의 문제] Can Make Palindrome from Substring</a></li>
<li><a target="_self" href="#가능한-적게-저장하라" title="null">가능한 적게 저장하라</a></li>
<li><a target="_self" href="#integer-보다-string이-더-빠른-경우-input에-적절한-보정을-사용하는-방법" title="null">integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법</a></li>
<li><a target="_self" href="#pattern-찾기--변환하기" title="null">pattern 찾기 =&gt; 변환하기</a></li>
<li><a target="_self" href="#가능한-적게-저장하라---2" title="null">가능한 적게 저장하라 - 2</a></li>
</ul>
<hr>

      <h2 id="[이번-주의-문제]-can-make-palindrome-from-substring">
        <a name="[이번-주의-문제]-can-make-palindrome-from-substring" class="anchor" href="#[이번-주의-문제]-can-make-palindrome-from-substring">
          <span class="header-link"></span>
        </a>
        [이번 주의 문제] Can Make Palindrome from Substring
      </h2><p><a target="_self" href="https://leetcode.com/problems/can-make-palindrome-from-substring/description/" title="null">문제 링크</a></p>
<p>문제 요약: inputs[left:right+1]를 rearrange하고 k번 이하의 문자를 변경해서 palindrome을 만들 수 있는지 확인하는 문제이다.</p>
<p>dp, prefix sum을 통한 (i, j) 구간의 저장 공간 줄이기, xor 연산의 사용, binary로 변환하는 방법 등을 통해 풀이를 개선할 수 있다. <a target="_self" href="https://leetcode.com/problems/can-make-palindrome-from-substring/solutions/371999/python-100-runtime-and-memory/" title="null">참고자료</a></p>
<p>내 풀이 개선 과정</p>
<ol>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/4e0178afb27014628516dc2a47c0c557b9969d19" title="null">prototype without rearrange</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/3e5f988d9bf8e79222c52e4d2f4bb22d6034436c" title="null">saving everything is too much</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/78b0945d61b74012b3f331c2829354404e73424e" title="null">using prefix sum to reduce space</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/f8bd0f94ea3eee84ddf7df8df5130967efc02ea5" title="null">Use List instead of Dictionary When index range is small and limited. If only odd/even matters don&#39;t add and %= 2, use xor</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/d3a4fbeb4c0c86ada9266748c5b848a7b8b0782f" title="null">If only odd/even number matters, you may change integer into binary</a></li>
</ol>
<hr>

      <h2 id="가능한-적게-저장하라">
        <a name="가능한-적게-저장하라" class="anchor" href="#가능한-적게-저장하라">
          <span class="header-link"></span>
        </a>
        가능한 적게 저장하라
      </h2><ul>
<li><a target="_self" href="https://leetcode.com/problems/toeplitz-matrix/description/" title="null">문제 링크</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/6208041d46052adfabceeb6c1b34685d68896482" title="null">내 풀이</a></li>
</ul>
<p>문제 요약: 대각선의 값들이 모두 동일한 value를 가지는 지 확인하는 문제이다.</p>
<p>최초의 풀이는 대각선의 값들을 dictionary 안에 저장하고, 이들을 같은지 확인하는 방식으로 구현했다. key로는 (row, col)을 쓰고, mat[(row, col)] == mat[(row-1, col-1)]인지 확인했다.</p>
<pre><code class="language-python">matrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0]))}
</code></pre>
<p>그런데 이는 최초의 첫 row/col만 확인하면 되는 문제이기 때문에, dictionary에 해당 값들만 저장하고 이를 비교하도록 구현을 변경했다.</p>
<pre><code class="language-python">matrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if i == 0 or j == 0}
</code></pre>
<p>이 밖에 key로 row - col을 사용하는 것도 한가지 방법이며, 이 방법을 사용할 경우 dictionary가 아니라 조금의 튜닝을 통해 일반적인 list로도 구현이 가능하다.</p>
<hr>

      <h2 id="integer-보다-string이-더-빠른-경우.-input에-적절한-보정을-사용하는-방법">
        <a name="integer-보다-string이-더-빠른-경우.-input에-적절한-보정을-사용하는-방법" class="anchor" href="#integer-보다-string이-더-빠른-경우.-input에-적절한-보정을-사용하는-방법">
          <span class="header-link"></span>
        </a>
        integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법
      </h2><ul>
<li><a target="_self" href="https://leetcode.com/problems/split-with-minimum-sum/description/" title="null">문제 링크</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/825c371389d1f69d10666d23fc8f38bbf650c2b3" title="null">내 풀이</a></li>
</ul>
<p>문제 요약: 각 수의 자릿수를 가지고 split number를 만든 뒤에 이 중 합이 가장 작은 split sum을 구하는 문제이다.</p>
<p>내 기존 풀이는 integer를 나누고, 나머지를 digits list에 저장하는 방식이었다. 그런데 이러는 것보다 string으로 변환한 뒤 처리하는 것이 더 유리할 수 있다. 이는 각각을 나누는 연산을 진행하는 것보다 string으로 변환하는 것이 빠르기 때문으로 추측된다.</p>
<pre><code class="language-python">def save_digits_as_int(num: int):
    digits = []
    while num &gt; 0:
        digits.append(num % 10)
        num //= 10
    return digits
</code></pre>
<pre><code class="language-python">def save_digits_as_char(num: int):
    return list(str(num))
</code></pre>
<p>해당 문제는 맨 앞에 0이 나오는 경우를 허용하는 문제이기 때문에 input integer의 자리수가 홀수일 경우 0을 추가해주는 보정을 하면 해결이 쉬워진다.</p>
<hr>

      <h2 id="pattern-찾기-=&gt;-변환하기">
        <a name="pattern-찾기-=&gt;-변환하기" class="anchor" href="#pattern-찾기-=&gt;-변환하기">
          <span class="header-link"></span>
        </a>
        pattern 찾기 =&gt; 변환하기
      </h2><ul>
<li><a target="_self" href="https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description/" title="null">문제 링크</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/c0515d3bf3ab61a79de9f97679ffe965902ea9bb" title="null">내 풀이</a></li>
</ul>
<p>문제 요약: 주어진 integer에 대해 pattern이 [1, 0, -1] 세 가지로 주어지고, 이것들이 부분 순열에서의 증가, 동일, 감소 패턴을 나타내는 문제이다. 그리고 이 pattern이 몇 번 나오는지 확인하는 문제이다.</p>
<p>기존의 내 문제 풀이는 모든 index에 대해 pattern이 존재하는지 확인하는 방식으로 구현했다.</p>
<pre><code class="language-python">for i in range(len(nums) - len(patterns)):
    for j in range(len(patterns)):
        if patterns[j] == 1 and nums[i + j + 1] &lt;= nums[i + j]:
            break
        elif patterns[j] == 0 and nums[i + j + 1] != nums[i + j]:
            break
        elif patterns[j] == -1 and nums[i + j + 1] &gt;= nums[i + j]:
            break
    else:
        result += 1
</code></pre>
<p>이 문제는 pattern을 만드는 문제로 바꾸어 생각해서 해결할 수 있다.</p>
<pre><code class="language-python">def apply_pattern(nums: List[int], pattern: List[int]) -&gt; List[int]:
    ans = []
    for i in range(1, len(nums)):
        if (nums[i] == nums[i - 1]):
            ans.append(0)
        elif (nums[i] &gt; nums[i - 1]):
            ans.append(1)
        else:
            ans.append(-1)
    return ans
</code></pre>
<p>둘의 시간복잡도는 동일하지만 두 번째 방법이 더 직관적이고 이해하기도 쉬우면서, 더 적은 비교 연산을 수행하기 때문에 성능이 좋게 나타나는 것을 확인할 수 있었다.</p>
<hr>

      <h2 id="가능한-적게-저장하라---2">
        <a name="가능한-적게-저장하라---2" class="anchor" href="#가능한-적게-저장하라---2">
          <span class="header-link"></span>
        </a>
        가능한 적게 저장하라 - 2
      </h2><ul>
<li><a target="_self" href="https://leetcode.com/problems/design-an-ordered-stream/description/" title="null">문제 링크</a></li>
<li><a target="_self" href="https://github.com/kaestro/algorithms_v3/commit/f38f736837c54887b8a31bbb59a0806a8b7f2c7b" title="null">내 풀이</a></li>
</ul>
<p>문제 요약: stream이 들어올 때, id 지점 기준으로 내보낼 수 있는 연속된 chunk가 형성되면 이를 내보내는 문제이다.</p>
<p>기존의 내 풀이는 stream에서 return할 값들을 새로운 list에 저장하고, 이를 return하는 방식으로 구현했다.</p>
<pre><code class="language-python">result = []
for i in range(self.idx, len(self.stream)):
    if self.stream[i] is None:
        break
    result.append(self.stream[i])
    self.idx += 1
return result
</code></pre>
<p>그러나 이는 정직한 부분 리스트를 반환하는 함수이기 때문에 새로운 list를 생성할 필요가 없다.</p>
<pre><code class="language-python">begin = self.idx
while self.stream[self.idx]:
    self.idx += 1

return self.stream[begin:self.idx]
</code></pre>
<hr>
</div><div style="display:flex;flex-direction:column;gap:1em"><div style="text-align:right"><a href="/Algorithm/4월 2주차 알고리즘 문제">다음 포스트: <!-- -->4월 2주차 알고리즘 문제</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-04-03-4월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-03-4월 1주차 알고리즘 문제.md","category":"Algorithm","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","content":"\n### 목차\n\n- [\\[이번 주의 문제\\] Can Make Palindrome from Substring](#이번-주의-문제-can-make-palindrome-from-substring)\n- [가능한 적게 저장하라](#가능한-적게-저장하라)\n- [integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법](#integer-보다-string이-더-빠른-경우-input에-적절한-보정을-사용하는-방법)\n- [pattern 찾기 =\\\u003e 변환하기](#pattern-찾기--변환하기)\n- [가능한 적게 저장하라 - 2](#가능한-적게-저장하라---2)\n\n---\n\n## [이번 주의 문제] Can Make Palindrome from Substring\n\n[문제 링크](https://leetcode.com/problems/can-make-palindrome-from-substring/description/)\n\n문제 요약: inputs[left:right+1]를 rearrange하고 k번 이하의 문자를 변경해서 palindrome을 만들 수 있는지 확인하는 문제이다.\n\ndp, prefix sum을 통한 (i, j) 구간의 저장 공간 줄이기, xor 연산의 사용, binary로 변환하는 방법 등을 통해 풀이를 개선할 수 있다. [참고자료](https://leetcode.com/problems/can-make-palindrome-from-substring/solutions/371999/python-100-runtime-and-memory/)\n\n내 풀이 개선 과정\n\n1. [prototype without rearrange](https://github.com/kaestro/algorithms_v3/commit/4e0178afb27014628516dc2a47c0c557b9969d19)\n2. [saving everything is too much](https://github.com/kaestro/algorithms_v3/commit/3e5f988d9bf8e79222c52e4d2f4bb22d6034436c)\n3. [using prefix sum to reduce space](https://github.com/kaestro/algorithms_v3/commit/78b0945d61b74012b3f331c2829354404e73424e)\n4. [Use List instead of Dictionary When index range is small and limited. If only odd/even matters don't add and %= 2, use xor](https://github.com/kaestro/algorithms_v3/commit/f8bd0f94ea3eee84ddf7df8df5130967efc02ea5)\n5. [If only odd/even number matters, you may change integer into binary](https://github.com/kaestro/algorithms_v3/commit/d3a4fbeb4c0c86ada9266748c5b848a7b8b0782f)\n\n---\n\n## 가능한 적게 저장하라\n\n- [문제 링크](https://leetcode.com/problems/toeplitz-matrix/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/6208041d46052adfabceeb6c1b34685d68896482)\n\n문제 요약: 대각선의 값들이 모두 동일한 value를 가지는 지 확인하는 문제이다.\n\n최초의 풀이는 대각선의 값들을 dictionary 안에 저장하고, 이들을 같은지 확인하는 방식으로 구현했다. key로는 (row, col)을 쓰고, mat[(row, col)] == mat[(row-1, col-1)]인지 확인했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0]))}\n```\n\n그런데 이는 최초의 첫 row/col만 확인하면 되는 문제이기 때문에, dictionary에 해당 값들만 저장하고 이를 비교하도록 구현을 변경했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if i == 0 or j == 0}\n```\n\n이 밖에 key로 row - col을 사용하는 것도 한가지 방법이며, 이 방법을 사용할 경우 dictionary가 아니라 조금의 튜닝을 통해 일반적인 list로도 구현이 가능하다.\n\n---\n\n## integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법\n\n- [문제 링크](https://leetcode.com/problems/split-with-minimum-sum/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/825c371389d1f69d10666d23fc8f38bbf650c2b3)\n\n문제 요약: 각 수의 자릿수를 가지고 split number를 만든 뒤에 이 중 합이 가장 작은 split sum을 구하는 문제이다.\n\n내 기존 풀이는 integer를 나누고, 나머지를 digits list에 저장하는 방식이었다. 그런데 이러는 것보다 string으로 변환한 뒤 처리하는 것이 더 유리할 수 있다. 이는 각각을 나누는 연산을 진행하는 것보다 string으로 변환하는 것이 빠르기 때문으로 추측된다.\n\n```python\ndef save_digits_as_int(num: int):\n    digits = []\n    while num \u003e 0:\n        digits.append(num % 10)\n        num //= 10\n    return digits\n```\n\n```python\ndef save_digits_as_char(num: int):\n    return list(str(num))\n```\n\n해당 문제는 맨 앞에 0이 나오는 경우를 허용하는 문제이기 때문에 input integer의 자리수가 홀수일 경우 0을 추가해주는 보정을 하면 해결이 쉬워진다.\n\n---\n\n## pattern 찾기 =\u003e 변환하기\n\n- [문제 링크](https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/c0515d3bf3ab61a79de9f97679ffe965902ea9bb)\n\n문제 요약: 주어진 integer에 대해 pattern이 [1, 0, -1] 세 가지로 주어지고, 이것들이 부분 순열에서의 증가, 동일, 감소 패턴을 나타내는 문제이다. 그리고 이 pattern이 몇 번 나오는지 확인하는 문제이다.\n\n기존의 내 문제 풀이는 모든 index에 대해 pattern이 존재하는지 확인하는 방식으로 구현했다.\n\n```python\nfor i in range(len(nums) - len(patterns)):\n    for j in range(len(patterns)):\n        if patterns[j] == 1 and nums[i + j + 1] \u003c= nums[i + j]:\n            break\n        elif patterns[j] == 0 and nums[i + j + 1] != nums[i + j]:\n            break\n        elif patterns[j] == -1 and nums[i + j + 1] \u003e= nums[i + j]:\n            break\n    else:\n        result += 1\n```\n\n이 문제는 pattern을 만드는 문제로 바꾸어 생각해서 해결할 수 있다.\n\n```python\ndef apply_pattern(nums: List[int], pattern: List[int]) -\u003e List[int]:\n    ans = []\n    for i in range(1, len(nums)):\n        if (nums[i] == nums[i - 1]):\n            ans.append(0)\n        elif (nums[i] \u003e nums[i - 1]):\n            ans.append(1)\n        else:\n            ans.append(-1)\n    return ans\n```\n\n둘의 시간복잡도는 동일하지만 두 번째 방법이 더 직관적이고 이해하기도 쉬우면서, 더 적은 비교 연산을 수행하기 때문에 성능이 좋게 나타나는 것을 확인할 수 있었다.\n\n---\n\n## 가능한 적게 저장하라 - 2\n\n- [문제 링크](https://leetcode.com/problems/design-an-ordered-stream/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/f38f736837c54887b8a31bbb59a0806a8b7f2c7b)\n\n문제 요약: stream이 들어올 때, id 지점 기준으로 내보낼 수 있는 연속된 chunk가 형성되면 이를 내보내는 문제이다.\n\n기존의 내 풀이는 stream에서 return할 값들을 새로운 list에 저장하고, 이를 return하는 방식으로 구현했다.\n\n```python\nresult = []\nfor i in range(self.idx, len(self.stream)):\n    if self.stream[i] is None:\n        break\n    result.append(self.stream[i])\n    self.idx += 1\nreturn result\n```\n\n그러나 이는 정직한 부분 리스트를 반환하는 함수이기 때문에 새로운 list를 생성할 필요가 없다.\n\n```python\nbegin = self.idx\nwhile self.stream[self.idx]:\n    self.idx += 1\n\nreturn self.stream[begin:self.idx]\n```\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","date":"2024-04-03T00:00:00.000Z","categories":"Algorithm"}},"title":"4월 1주차 알고리즘 문제","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":null,"next":{"title":"4월 2주차 알고리즘 문제","category":"Algorithm"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"Algorithm","title":"4월 1주차 알고리즘 문제"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>