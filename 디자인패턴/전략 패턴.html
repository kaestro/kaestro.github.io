<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">전략 패턴</h1><h1 class="project-subtitle">고무 오리는 날 수 없다, 엄마에게 혼났죠</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>개요</li>
<li>요약</li>
<li>문제상황</li>
<li>interface를 통한 해결의 문제점</li>
<li>전략 패턴을 통한 해결</li>
<li>결론</li>
</ol>
<hr>

      <h2 id="개요">
        <a name="개요" class="anchor" href="#개요">
          <span class="header-link"></span>
        </a>
        개요
      </h2><p>본 글은 <strong>head first design patterns</strong> 책을 읽고 정리한 글입니다.</p>
<p><strong>전략 패턴</strong>은 <strong>알고리즘</strong>을 독립적인 객체로 <strong>캡슐화</strong>해서, 클라이언트와 <strong>분리</strong>하는 디자인 패턴입니다. 이를 통해 클라이언트는 알고리즘을 변경하지 않고도 다양한 알고리즘을 사용할 수 있습니다.</p>
<p>head first design patterns는 이에 대한 예시로 오리의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 오리의 <strong>꽥꽥</strong> 소리를 낸다는 행동은 오리의 종류에 따라 다르게 구현될 수 있습니다. 또한 여기에 <strong>날다</strong>와 같은 기능을 추가하는 것이 요구될 수도 있습니다. 이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 <strong>전략 패턴</strong>입니다.</p>
<hr>

      <h2 id="요약">
        <a name="요약" class="anchor" href="#요약">
          <span class="header-link"></span>
        </a>
        요약
      </h2><ul>
<li>전략 패턴은 알고리즘을 독립적인 객체로 캡슐화해서, 클라이언트와 분리하는 디자인 패턴입니다.</li>
<li>클라이언트 - 오리, 알고리즘 - 날다, 꽥꽥</li>
<li>상속이나 구현보다는 <strong>구성</strong>을 활용한다.</li>
</ul>
<hr>

      <h2 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h2><p>기존에 수영하고, 소리만 낼 수 있는 오리가 구현돼고 있던 다음과 같은 프로그램이 있었습니다. 모든 오리들은 밖에 표현되는 방식만 다르게 구현돼 있습니다.</p>
<pre><code class="language-java">public abstract class Duck {
    public void swim() {
        System.out.println(&quot;수영&quot;);
    }

    public void quack() {
        System.out.println(&quot;꽥꽥&quot;);
    }

    public abstract void display();
}

public class MallardDuck extends Duck {
    public void display() {
        System.out.println(&quot;MallardDuck&quot;);
    }
}

public class RedheadDuck extends Duck {
    public void display() {
        System.out.println(&quot;RedheadDuck&quot;);
    }
}

...
</code></pre>
<p>그런데 어느날, 오리에 날다 행동을 추가하라는 기획이 내려왔습니다. 그래서 당신은 다음과 같이 날다의 행동을 추가했습니다.</p>
<pre><code class="language-java">public abstract class Duck {
    ...

    public void fly() {
        System.out.println(&quot;날다&quot;);
    }
}
</code></pre>
<p>그리고 대재앙을 맞이하게 됩니다. 이 오리 클래스를 상속하던 클래스 중에는 날아서는 안되는 rubberduck이 존재했던 것입니다. 이 노란빛 귀염둥이는 화면을 가득 수놓으며 우리를 괴롭히는 상황을 만들어냅니다.</p>
<p>이런 식으로, 상속을 통해 구현된 클래스들에 새로운 행동을 추가하거나, 기존 행동을 변경하는 것은 많은 예상불가능한 결과를 낳을 수 있기 때문에 어렵습니다.</p>
<hr>

      <h2 id="interface를-통한-해결의-문제점">
        <a name="interface를-통한-해결의-문제점" class="anchor" href="#interface를-통한-해결의-문제점">
          <span class="header-link"></span>
        </a>
        Interface를 통한 해결의 문제점
      </h2><p>이 문제를 해결하기 위해 duck을 interface로 만들어서, 각각의 오리들이 이를 구현하도록 할 수 있습니다. 그런데, rubberduck과 같이 가끔 발생하는 예외가 있을 뿐 대부분의 경우에는 동일한 행동을 반복해서 사용하면 될 상황에서 interface를 사용하는 것은 매우 비효율적입니다.</p>
<pre><code class="language-java">public interface Duck {
    public void swim();
    public void quack();
    public void display();
    public void fly();
}
</code></pre>
<p>위와 같은 Duck을 구현하는 수많은 클래스들에 대해 우리는 모두 4가지 메소드를 구현해야합니다. 그 뿐 아니라 이번에 fly를 추가해야했던 것과 같은 상황이 발생하면, Duck을 <strong>구현</strong>한 모든 클래스들에 해당 메소드들을 다 작성해주어야하는 번거로움이 생깁니다.</p>
<hr>

      <h2 id="전략-패턴을-통한-해결">
        <a name="전략-패턴을-통한-해결" class="anchor" href="#전략-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        전략 패턴을 통한 해결
      </h2><p>이를 해결하기 위해 나온 것이 전략 패턴입니다. 전략 패턴은 <strong>알고리즘</strong>(날다, 꽥꽥 소리내다 등)을 독립적인 객체로 <strong>캡슐화</strong>한 뒤, 클라이언트와 <strong>분리</strong>하는 디자인 패턴입니다. 전략패턴을 사용할 경우 클래스를 만들 때 <strong>변화가 필요한</strong> 메소드는 상속하거나 구현하지 않습니다. 대신 각각의 행동을 독립적인 객체로 만든 뒤 이를 필요한 클래스에 <strong>구성으로 추가</strong>합니다.</p>
<pre><code class="language-java">public interface FlyBehavior {
    public void fly();
}

public interface QuackBehavior {
    public void quack();
}

...

public class Duck {
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    public void performFly() {
        flyBehavior.fly();
    }

    public void performQuack() {
        quackBehavior.quack();
    }

    public void setFlyBehavior(FlyBehavior fb) {
        flyBehavior = fb;
    }

    public void setQuackBehavior(QuackBehavior qb) {
        quackBehavior = qb;
    }
}
</code></pre>
<p>위와 같은 방식을 통해 우리는 각각의 행동을 독립적인 객체로 만들어서 필요한 클래스에 구성해 추가할 수 있습니다. 이를 통해 우리는 새로운 행동을 추가하거나, 기존 행동을 변경하는 것이 매우 쉬워집니다. 또한, 각각의 행동을 동적으로 변경하거나 확장할 수 있습니다.</p>
<p>다시 말해, 우리는 전략 패턴을 통해 다음과 같은 장점을 얻을 수 있습니다.</p>
<ol>
<li>한번 구현한 행동을 다른 클래스에도 쉽게 <strong>재사용</strong>할 수 있습니다.</li>
<li>행동을 <strong>변경</strong>하거나 <strong>확장</strong>하기가 매우 쉬워집니다.</li>
<li>행동을 <strong>동적</strong>으로 변경하는 것도 가능합니다.</li>
</ol>
<hr>

      <h2 id="결론">
        <a name="결론" class="anchor" href="#결론">
          <span class="header-link"></span>
        </a>
        결론
      </h2><p>프로그램의 구체적인 <strong>동작</strong>을 <strong>캡슐화</strong>하고 이를 클래스에서 <strong>구성</strong>하는 형태를 우리는 전략 패턴이라고 부릅니다. 이를 통해 우리는 한 번 작성한 코드를 <strong>재사용</strong>하는 장점을 유지하면서도, 새로운 행동을 <strong>추가</strong>하거나 기존 행동을 <strong>동적으로 변경</strong>하는 것이 용이한 프로그램을 작성할 수 있습니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/디자인패턴/천원돌파 의존성 역전">이전 포스트: <!-- -->천원돌파 의존성 역전</a></div><div style="text-align:right"><a href="/디자인패턴/데코레이터 패턴">다음 포스트: <!-- -->데코레이터 패턴</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-13-Strategy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-13-Strategy Pattern.md","category":"디자인패턴","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. interface를 통한 해결의 문제점\n5. 전략 패턴을 통한 해결\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**전략 패턴**은 **알고리즘**을 독립적인 객체로 **캡슐화**해서, 클라이언트와 **분리**하는 디자인 패턴입니다. 이를 통해 클라이언트는 알고리즘을 변경하지 않고도 다양한 알고리즘을 사용할 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 오리의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 오리의 **꽥꽥** 소리를 낸다는 행동은 오리의 종류에 따라 다르게 구현될 수 있습니다. 또한 여기에 **날다**와 같은 기능을 추가하는 것이 요구될 수도 있습니다. 이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 **전략 패턴**입니다.\n\n---\n\n## 요약\n\n* 전략 패턴은 알고리즘을 독립적인 객체로 캡슐화해서, 클라이언트와 분리하는 디자인 패턴입니다.\n* 클라이언트 - 오리, 알고리즘 - 날다, 꽥꽥\n* 상속이나 구현보다는 **구성**을 활용한다.\n\n---\n\n## 문제상황\n\n기존에 수영하고, 소리만 낼 수 있는 오리가 구현돼고 있던 다음과 같은 프로그램이 있었습니다. 모든 오리들은 밖에 표현되는 방식만 다르게 구현돼 있습니다.\n\n```java\npublic abstract class Duck {\n    public void swim() {\n        System.out.println(\"수영\");\n    }\n\n    public void quack() {\n        System.out.println(\"꽥꽥\");\n    }\n\n    public abstract void display();\n}\n\npublic class MallardDuck extends Duck {\n    public void display() {\n        System.out.println(\"MallardDuck\");\n    }\n}\n\npublic class RedheadDuck extends Duck {\n    public void display() {\n        System.out.println(\"RedheadDuck\");\n    }\n}\n\n...\n\n```\n\n그런데 어느날, 오리에 날다 행동을 추가하라는 기획이 내려왔습니다. 그래서 당신은 다음과 같이 날다의 행동을 추가했습니다.\n\n```java\npublic abstract class Duck {\n    ...\n\n    public void fly() {\n        System.out.println(\"날다\");\n    }\n}\n```\n\n그리고 대재앙을 맞이하게 됩니다. 이 오리 클래스를 상속하던 클래스 중에는 날아서는 안되는 rubberduck이 존재했던 것입니다. 이 노란빛 귀염둥이는 화면을 가득 수놓으며 우리를 괴롭히는 상황을 만들어냅니다.\n\n이런 식으로, 상속을 통해 구현된 클래스들에 새로운 행동을 추가하거나, 기존 행동을 변경하는 것은 많은 예상불가능한 결과를 낳을 수 있기 때문에 어렵습니다.\n\n---\n\n## Interface를 통한 해결의 문제점\n\n이 문제를 해결하기 위해 duck을 interface로 만들어서, 각각의 오리들이 이를 구현하도록 할 수 있습니다. 그런데, rubberduck과 같이 가끔 발생하는 예외가 있을 뿐 대부분의 경우에는 동일한 행동을 반복해서 사용하면 될 상황에서 interface를 사용하는 것은 매우 비효율적입니다.\n\n```java\npublic interface Duck {\n    public void swim();\n    public void quack();\n    public void display();\n    public void fly();\n}\n```\n\n위와 같은 Duck을 구현하는 수많은 클래스들에 대해 우리는 모두 4가지 메소드를 구현해야합니다. 그 뿐 아니라 이번에 fly를 추가해야했던 것과 같은 상황이 발생하면, Duck을 **구현**한 모든 클래스들에 해당 메소드들을 다 작성해주어야하는 번거로움이 생깁니다.\n\n---\n\n## 전략 패턴을 통한 해결\n\n이를 해결하기 위해 나온 것이 전략 패턴입니다. 전략 패턴은 **알고리즘**(날다, 꽥꽥 소리내다 등)을 독립적인 객체로 **캡슐화**한 뒤, 클라이언트와 **분리**하는 디자인 패턴입니다. 전략패턴을 사용할 경우 클래스를 만들 때 **변화가 필요한** 메소드는 상속하거나 구현하지 않습니다. 대신 각각의 행동을 독립적인 객체로 만든 뒤 이를 필요한 클래스에 **구성으로 추가**합니다.\n\n```java\npublic interface FlyBehavior {\n    public void fly();\n}\n\npublic interface QuackBehavior {\n    public void quack();\n}\n\n...\n\npublic class Duck {\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void setFlyBehavior(FlyBehavior fb) {\n        flyBehavior = fb;\n    }\n\n    public void setQuackBehavior(QuackBehavior qb) {\n        quackBehavior = qb;\n    }\n}\n```\n\n위와 같은 방식을 통해 우리는 각각의 행동을 독립적인 객체로 만들어서 필요한 클래스에 구성해 추가할 수 있습니다. 이를 통해 우리는 새로운 행동을 추가하거나, 기존 행동을 변경하는 것이 매우 쉬워집니다. 또한, 각각의 행동을 동적으로 변경하거나 확장할 수 있습니다.\n\n다시 말해, 우리는 전략 패턴을 통해 다음과 같은 장점을 얻을 수 있습니다.\n\n1. 한번 구현한 행동을 다른 클래스에도 쉽게 **재사용**할 수 있습니다.\n2. 행동을 **변경**하거나 **확장**하기가 매우 쉬워집니다.\n3. 행동을 **동적**으로 변경하는 것도 가능합니다.\n\n---\n\n## 결론\n\n프로그램의 구체적인 **동작**을 **캡슐화**하고 이를 클래스에서 **구성**하는 형태를 우리는 전략 패턴이라고 부릅니다. 이를 통해 우리는 한 번 작성한 코드를 **재사용**하는 장점을 유지하면서도, 새로운 행동을 **추가**하거나 기존 행동을 **동적으로 변경**하는 것이 용이한 프로그램을 작성할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","date":"2024-02-13T00:00:00.000Z","categories":"디자인패턴"}},"title":"전략 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"천원돌파 의존성 역전","category":"디자인패턴"},"next":{"title":"데코레이터 패턴","category":"디자인패턴"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"디자인패턴","title":"전략 패턴"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>