<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">파사드 패턴</h1><h1 class="project-subtitle">이겨야 한다 &#x27;딸깍&#x27;</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>개요</li>
<li>요약</li>
<li>문제상황</li>
<li>파사드 패턴을 통한 해결</li>
<li>최소 지식 원칙</li>
<li>결론</li>
</ol>
<hr>

      <h2 id="개요">
        <a name="개요" class="anchor" href="#개요">
          <span class="header-link"></span>
        </a>
        개요
      </h2><p>본 글은 <strong>head first design patterns</strong> 책을 읽고 정리한 글입니다.</p>
<p><strong>파사드 패턴</strong>은 <strong>복잡한 서브시스템을 간단하게 제공</strong>하는 패턴입니다. 이는 간단한 인터페이스를 통해 까다로운 구현을 숨기고 사용자가 쉽게 사용할 수 있게 합니다. 이는 <strong>복잡성을 감소</strong>시키고 <strong>유지보수성</strong>을 높일 수 있습니다.</p>
<p>head first design patterns는 이에 대한 예시로 <strong>홈시어터</strong>를 가져옵니다. 홈시어터는 DVD 플레이어, 음향 시스템, 프로젝터 등으로 이루어져 있습니다.</p>
<p>만약 홈시어터에서 영화 한 편을 보기 위해 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 한다면 사용자는 매번 영화를 보기 위해 많은 시간을 소비해야 합니다. 그러다보면 그냥 영화를 안 보고 말게 될 수도 있습니다.</p>
<p>이때 파사드 패턴을 사용하면 사용자는 <strong>간단한 인터페이스</strong>를 통해 영화를 볼 수 있습니다. 소위 버튼 하나만 <strong>딸깍</strong> 누르면 영화가 시작되는 것과 같습니다.</p>
<p><strong>최소 지식 원칙</strong>은 <strong>객체 사이의 상호작용</strong>을 <strong>최소화</strong>한다는 원칙입니다. 이는 시스템을 디자인 할 때 <strong>상호작용 클래스의 수</strong>와 <strong>상호작용 방식</strong>에 주의를 기울여야 한다는 뜻입니다.</p>
<hr>

      <h2 id="요약">
        <a name="요약" class="anchor" href="#요약">
          <span class="header-link"></span>
        </a>
        요약
      </h2><ol>
<li><strong>파사드 패턴</strong>은 복잡한 서브시스템을 <strong>단순한 인터페이스</strong>로 제공합니다.</li>
<li><strong>복잡성을 감소</strong>시키고 <strong>유지보수성</strong>을 높일 수 있습니다.</li>
<li>딸깍 - 파사드, DVD 플레이어/음향 시스템/프로젝터 - 서브시스템</li>
<li>파사드는 클라이언트와 구성 요소로 이루어진 <strong>서브시스템을 분리</strong>합니다.</li>
<li>파사드는 여러 클래스를 <strong>하나로 감싸서 사용</strong>할 수 있습니다.</li>
<li><strong>최소 지식 원칙</strong>은 객체 사이의 <strong>상호작용을 최소화</strong>한다는 원칙입니다.</li>
</ol>
<hr>

      <h2 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h2><p>한 영화광이 자신의 꿈이었던 자기만의 <strong>홈 시어터</strong>를 마침내 구축했습니다. 그런데 막상 꿈이 현실이 되고 보니, 그렇게 행복할 줄만 알았던 영화 생활은 녹록치 않았습니다.</p>
<p>영화를 볼 때마다 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 하고, 심지어 동작하지 않은 것이 있으면 그것을 해결해야 했습니다. 이러다보니 영화를 보는 것이 귀찮아지고, 결국 홈 시어터를 사용하지 않게 되었습니다.</p>
<p>이런 상황을 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public class DvdPlayer {
    // DvdPlayer의 동작을 위한 메소드들
}

public class Amplifier {
    // Amplifier의 동작을 위한 메소드들
}

public class Projector {
    // Projector의 동작을 위한 메소드들
}

...

public static void main(String[] args) {

    Client client = new Client();

    DvdPlayer dvdPlayer = new DvdPlayer();
    Amplifier amplifier = new Amplifier();
    Projector projector = new Projector();
    // ...
    dvdPlayer.on();
    amplifier.on();
    projector.on();
    // ...
}
</code></pre>
<p>평생의 숙원이었던 홈 시어터를 포기할 수는 없기 때문에 해결하기 위한 방법을 강구하던 중 이에 대한 해결방법에 대한 제안을 듣게 되었습니다.</p>
<hr>

      <h2 id="파사드-패턴을-통한-해결">
        <a name="파사드-패턴을-통한-해결" class="anchor" href="#파사드-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        파사드 패턴을 통한 해결
      </h2><p><strong>파사드 패턴</strong>을 사용하면 사용자는 <strong>간단한 인터페이스</strong>를 통해 영화를 볼 수 있습니다. 버튼 하나만 <strong>딸깍</strong> 누르면 영화를 투영할 스크린은 내려오고, 창문을 가리는 커튼이 닫히고, DVD 플레이어가 켜지고, 음향 시스템이 켜지고, 프로젝터가 켜지는 것과 같습니다.</p>
<p>이를 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public class HomeTheaterFacade {
    DvdPlayer dvdPlayer;
    Amplifier amplifier;
    Projector projector;
    // ...

    public HomeTheaterFacade(DvdPlayer dvdPlayer, Amplifier amplifier, Projector projector, ...) {
        this.dvdPlayer = dvdPlayer;
        this.amplifier = amplifier;
        this.projector = projector;
        // ...
    }

    public void watchMovie() {
        dvdPlayer.on();
        amplifier.on();
        projector.on();
        // ...
    }
}
</code></pre>
<p>파사드 패턴을 사용하면 사용자는 <strong>간단한 인터페이스</strong>를 통해 영화를 볼 수 있습니다. 이를 통해 클라이언트와 구성요소로 이루어진 <strong>서브시스템을 분리</strong>하고, <strong>여러 클래스를 하나로</strong> 감싸서 사용할 수 있습니다.</p>
<hr>

      <h2 id="최소-지식-원칙">
        <a name="최소-지식-원칙" class="anchor" href="#최소-지식-원칙">
          <span class="header-link"></span>
        </a>
        최소 지식 원칙
      </h2><p><strong>최소 지식 원칙</strong>은 <strong>객체 사이의 상호작용을 최소화</strong>한다는 원칙입니다. 이는 시스템을 디자인 할 때 상호작용하는 <strong>클래스의 수</strong>와 <strong>상호작용 방식</strong>에 주의를 기울여야 한다는 뜻입니다.</p>
<p>최소 지식 원칙을 따르는 4개의 가이드라인은 다음과 같습니다.</p>
<ol>
<li>객체 자체</li>
<li>메소드에 매개변수로 전달된 객매</li>
<li>메소드를 생성하거나 인스턴스를 만든 객체</li>
<li>객체에 속하는 구성 요소</li>
</ol>
<p>만이 객체와 상호작용을 하도록 한다.</p>
<hr>

      <h2 id="결론">
        <a name="결론" class="anchor" href="#결론">
          <span class="header-link"></span>
        </a>
        결론
      </h2><p><strong>파사드 패턴</strong>은 복잡한 서브시스템을 <strong>간단한 인터페이스</strong>로 제공합니다. 이를 통해 <strong>복잡성</strong>을 감소시키고 <strong>유지보수성</strong>을 높일 수 있습니다.</p>
<p><strong>홈 시어터</strong>의 예시를 통해 설명하면 이는 사용자가 버튼 하나를 <strong>딸깍</strong>하는 것만으로 영화를 볼 수 있게 되는 것과 같습니다. 파사드 패턴이 없었다면 사용자는 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법과 같은 수많은 복잡한 과정을 알아야 했을 것입니다.</p>
<p>이런 것을 통해 파사드 패턴이 가지고 있는 <strong>두 가지 역할</strong>을 알 수 있습니다. 하나는 클라이언트와 구성요소로 이루어진 <strong>서브시스템을 분리</strong>하는 것이고, 나머지 하나는 <strong>여러 클래스를 하나의 인터페이스로 감싸서 사용</strong>할 수 있게 하는 것입니다.</p>
<p><strong>최소 지식 원칙</strong>을 따르는 것은 <strong>객체 사이의 상호작용을 최소화</strong>한다는 원칙입니다. 이는 시스템을 디자인 할 때 <strong>상호작용하는 클래스의 수</strong>와 <strong>상호작용 방식</strong>에 주의를 기울여야 한다는 뜻입니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/디자인패턴/어댑터 패턴">이전 포스트: <!-- -->어댑터 패턴</a></div><div style="text-align:right"><a href="/디자인패턴/템플릿 메소드 패턴">다음 포스트: <!-- -->템플릿 메소드 패턴</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-19-Facade Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-19-Facade Pattern.md","category":"디자인패턴","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 파사드 패턴을 통한 해결\n5. 최소 지식 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**파사드 패턴**은 **복잡한 서브시스템을 간단하게 제공**하는 패턴입니다. 이는 간단한 인터페이스를 통해 까다로운 구현을 숨기고 사용자가 쉽게 사용할 수 있게 합니다. 이는 **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **홈시어터**를 가져옵니다. 홈시어터는 DVD 플레이어, 음향 시스템, 프로젝터 등으로 이루어져 있습니다.\n\n만약 홈시어터에서 영화 한 편을 보기 위해 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 한다면 사용자는 매번 영화를 보기 위해 많은 시간을 소비해야 합니다. 그러다보면 그냥 영화를 안 보고 말게 될 수도 있습니다.\n\n이때 파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 소위 버튼 하나만 **딸깍** 누르면 영화가 시작되는 것과 같습니다.\n\n**최소 지식 원칙**은 **객체 사이의 상호작용**을 **최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n---\n\n## 요약\n\n1. **파사드 패턴**은 복잡한 서브시스템을 **단순한 인터페이스**로 제공합니다.\n2. **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n3. 딸깍 - 파사드, DVD 플레이어/음향 시스템/프로젝터 - 서브시스템\n4. 파사드는 클라이언트와 구성 요소로 이루어진 **서브시스템을 분리**합니다.\n5. 파사드는 여러 클래스를 **하나로 감싸서 사용**할 수 있습니다.\n6. **최소 지식 원칙**은 객체 사이의 **상호작용을 최소화**한다는 원칙입니다.\n\n---\n\n## 문제상황\n\n한 영화광이 자신의 꿈이었던 자기만의 **홈 시어터**를 마침내 구축했습니다. 그런데 막상 꿈이 현실이 되고 보니, 그렇게 행복할 줄만 알았던 영화 생활은 녹록치 않았습니다.\n\n영화를 볼 때마다 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 하고, 심지어 동작하지 않은 것이 있으면 그것을 해결해야 했습니다. 이러다보니 영화를 보는 것이 귀찮아지고, 결국 홈 시어터를 사용하지 않게 되었습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class DvdPlayer {\n    // DvdPlayer의 동작을 위한 메소드들\n}\n\npublic class Amplifier {\n    // Amplifier의 동작을 위한 메소드들\n}\n\npublic class Projector {\n    // Projector의 동작을 위한 메소드들\n}\n\n...\n\npublic static void main(String[] args) {\n\n    Client client = new Client();\n\n    DvdPlayer dvdPlayer = new DvdPlayer();\n    Amplifier amplifier = new Amplifier();\n    Projector projector = new Projector();\n    // ...\n    dvdPlayer.on();\n    amplifier.on();\n    projector.on();\n    // ...\n}\n```\n\n평생의 숙원이었던 홈 시어터를 포기할 수는 없기 때문에 해결하기 위한 방법을 강구하던 중 이에 대한 해결방법에 대한 제안을 듣게 되었습니다.\n\n---\n\n## 파사드 패턴을 통한 해결\n\n**파사드 패턴**을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 버튼 하나만 **딸깍** 누르면 영화를 투영할 스크린은 내려오고, 창문을 가리는 커튼이 닫히고, DVD 플레이어가 켜지고, 음향 시스템이 켜지고, 프로젝터가 켜지는 것과 같습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class HomeTheaterFacade {\n    DvdPlayer dvdPlayer;\n    Amplifier amplifier;\n    Projector projector;\n    // ...\n\n    public HomeTheaterFacade(DvdPlayer dvdPlayer, Amplifier amplifier, Projector projector, ...) {\n        this.dvdPlayer = dvdPlayer;\n        this.amplifier = amplifier;\n        this.projector = projector;\n        // ...\n    }\n\n    public void watchMovie() {\n        dvdPlayer.on();\n        amplifier.on();\n        projector.on();\n        // ...\n    }\n}\n```\n\n파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 이를 통해 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하고, **여러 클래스를 하나로** 감싸서 사용할 수 있습니다.\n\n---\n\n## 최소 지식 원칙\n\n**최소 지식 원칙**은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 상호작용하는 **클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n최소 지식 원칙을 따르는 4개의 가이드라인은 다음과 같습니다.\n\n1. 객체 자체\n2. 메소드에 매개변수로 전달된 객매\n3. 메소드를 생성하거나 인스턴스를 만든 객체\n4. 객체에 속하는 구성 요소\n\n만이 객체와 상호작용을 하도록 한다.\n\n---\n\n## 결론\n\n**파사드 패턴**은 복잡한 서브시스템을 **간단한 인터페이스**로 제공합니다. 이를 통해 **복잡성**을 감소시키고 **유지보수성**을 높일 수 있습니다.\n\n**홈 시어터**의 예시를 통해 설명하면 이는 사용자가 버튼 하나를 **딸깍**하는 것만으로 영화를 볼 수 있게 되는 것과 같습니다. 파사드 패턴이 없었다면 사용자는 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법과 같은 수많은 복잡한 과정을 알아야 했을 것입니다.\n\n이런 것을 통해 파사드 패턴이 가지고 있는 **두 가지 역할**을 알 수 있습니다. 하나는 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하는 것이고, 나머지 하나는 **여러 클래스를 하나의 인터페이스로 감싸서 사용**할 수 있게 하는 것입니다.\n\n**최소 지식 원칙**을 따르는 것은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용하는 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","date":"2024-02-19T00:00:00.000Z","categories":"디자인패턴"}},"title":"파사드 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"어댑터 패턴","category":"디자인패턴"},"next":{"title":"템플릿 메소드 패턴","category":"디자인패턴"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"디자인패턴","title":"파사드 패턴"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>