<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">어댑터 패턴</h1><h1 class="project-subtitle">오리가 되겠다던 칠면조</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>개요</li>
<li>요약</li>
<li>문제상황</li>
<li>어댑터 패턴을 통한 해결</li>
<li>객체 어댑터와 클래스 어댑터</li>
<li>결론</li>
</ol>
<hr>

      <h2 id="개요">
        <a name="개요" class="anchor" href="#개요">
          <span class="header-link"></span>
        </a>
        개요
      </h2><p>본 글은 <strong>head first design patterns</strong> 책을 읽고 정리한 글입니다.</p>
<p><strong>어댑터 패턴</strong>은 다른 인터페이스로 <strong>기존 클래스의 인터페이스를 변환</strong>하는 패턴입니다. 이는 <strong>호환성 문제</strong>를 해결할 수 있습니다. 호환성 문제는 클래스의 인터페이스가 클라이언트의 <strong>요구사항</strong>과 맞지 않을 때 발생합니다.</p>
<p>이때 어댑터 패턴을 사용하면 클라이언트의 요구사항에 맞게 클래스의 인터페이스를 변환할 수 있습니다. 마치 한국 콘센트를 유럽 콘센트에 맞게 변환하는 것과 같습니다.</p>
<p>head first design patterns는 이에 대한 예시로 전에 사용했던 <strong>오리</strong>를 가져옵니다. 어쩌다보니 오리가 모자라서 <strong>칠면조</strong>를 사용해야 상황이 왔는데, 칠면조는 오리와는 다른 울음 소리를 내고 있습니다. 이때 칠면조의 목소리를 오리와 동일하게 변환하는 어댑터를 사용하면 칠면조를 오리로 사용할 수 있습니다.</p>
<p>어댑터를 사용해서 기존에 사용하던 오리 코드를 수정하지 않고 칠면조를 오리로 사용하면 코드의 수정이 최소화됩니다. 이는 <strong>유연성</strong>과 <strong>재사용성</strong>을 높일 수 있습니다.</p>
<p>어댑터 패턴 구현 방식은 <strong>클래스 어댑터</strong>와 <strong>객체 어댑터</strong>로 나뉩니다. 클래스 어댑터는 <strong>상속</strong>을 통해 어댑터를 구현하고, 객체 어댑터는 <strong>구성</strong>을 통해 어댑터를 구현합니다.</p>
<hr>

      <h2 id="요약">
        <a name="요약" class="anchor" href="#요약">
          <span class="header-link"></span>
        </a>
        요약
      </h2><ol>
<li>어댑터 패턴은 <strong>클래스의 인터페이스를 다른 인터페이스로 변환</strong>하는 패턴입니다.</li>
<li><strong>호환성 문제</strong>를 해결할 수 있습니다.</li>
<li>기존의 코드를 수정하지 않고 사용할 수 있어 <strong>유연성</strong>과 <strong>재사용성</strong>을 높일 수 있습니다.</li>
<li>어댑티 - 칠면조, 어댑티 - 오리, 클라이언트 - 사용자</li>
<li>구현 방식에 따라 <strong>클래스 어댑터</strong>와 <strong>객체 어댑터</strong>로 나뉩니다.</li>
</ol>
<hr>

      <h2 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h2><p>동물원에서 기존에 오리만으로 이루어진 공연이 있었습니다. 그런데 어느 날 몇 마리의 오리가 아프게 되어서 공연을 할 수 없게 되었습니다. 그래서 동물원은 칠면조를 대신해서 공연을 하기로 했습니다. 그런데 오리가 &quot;<strong>꽥꽥</strong>&quot; 소리를 내는데 반해 칠면조는 &quot;<strong>고블고블</strong>&quot; 소리를 내기 때문에 공연을 할 수 없었습니다.</p>
<p>위와 같은 상황을 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public interface Duck {
    public void quack();
    public void fly();
}

public interface Turkey {
    public void gobble();
    public void fly();
}
</code></pre>
<p>이런 상황에서 칠면조를 오리로 사용하는 방법이 필요합니다. 칠면조의 &quot;고블고블&quot; 소리가 오리의 &quot;꽥꽥&quot; 소리와 동일하게 동작하도록 만드는 것이죠.</p>
<hr>

      <h2 id="어댑터-패턴을-통한-해결">
        <a name="어댑터-패턴을-통한-해결" class="anchor" href="#어댑터-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        어댑터 패턴을 통한 해결
      </h2><p>이런 상황에서 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 어댑터 패턴을 사용하면 칠면조의 &quot;고블고블&quot; 소리를 오리의 &quot;꽥꽥&quot; 소리로 <strong>변환</strong>할 수 있습니다.</p>
<p>이를 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public class TurkeyAdapter implements Duck {
    Turkey turkey;

    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }

    public void quack() {
        turkey.gobble();
    }

    public void fly() {
        turkey.fly();
    }
}
</code></pre>
<p>이렇게 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 칠면조의 &quot;고블고블&quot; 소리는 어댑터를 통해 &quot;꽥꽥&quot; 소리로 <strong>변환</strong>되어 공연 연출가에게 전달됩니다.</p>
<p>이런 방식으로 어댑터 패턴을 사용하면 기존의 코드를 수정하지 않고 칠면조를 오리로 사용할 수 있습니다. 이는 <strong>유연성</strong>과 <strong>재사용성</strong>을 높일 수 있습니다. 동물원의 입장에서는 새로운 오리를 추가로 구매할 필요가 없어지고, 칠면조의 입장에서는 꽥꽥 소리를 내는 훈련을 할 필요가 없어지는 겁니다. 애초에 불가능하겠지만요.</p>
<hr>

      <h2 id="객체-어댑터와-클래스-어댑터">
        <a name="객체-어댑터와-클래스-어댑터" class="anchor" href="#객체-어댑터와-클래스-어댑터">
          <span class="header-link"></span>
        </a>
        객체 어댑터와 클래스 어댑터
      </h2><p>위와 같이 <strong>인터페이스를 통해 어댑터를 구현</strong>하는 것을 <strong>객체 어댑터</strong>라고 합니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 객체를 <strong>소유</strong>하는 것을 통해 요구되는 인터페이스를 제공합니다.</p>
<p>또 다른 방법으로는 <strong>다중 상속</strong>을 통해 어댑터를 구현할 수도 있습니다. 이를 <strong>클래스 어댑터</strong>라고 합니다. 클래스 어댑터는 변환 대상과 변환 결과를 동시에 상속받아서 변환을 수행합니다. 오리와 칠면조를 <strong>교배</strong>시켜 만든 새로운 종류의 새라고 생각하시면 됩니다.</p>
<p>클래스 어댑터를 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-c++">class TurkeyAdapter : public Duck, public Turkey {
    public:
        void quack() {
            gobble();
        }

        void fly() {
            Turkey::fly();
        }

        void gobble() {
            cout &lt;&lt; &quot;Gobble gobble Quack quack&quot; &lt;&lt; endl;
        }
}
</code></pre>
<hr>

      <h2 id="결론">
        <a name="결론" class="anchor" href="#결론">
          <span class="header-link"></span>
        </a>
        결론
      </h2><p><strong>어댑터 패턴</strong>은 클래스의 인터페이스를 <strong>다른 인터페이스로 변환</strong>하는 패턴입니다. 이를 통해 <strong>호환성 문제</strong>를 해결하면 기존의 코드를 수정하지 않고 사용할 수 있어 <strong>유연성</strong>과 <strong>재사용성</strong>을 높일 수 있습니다. 이는 오리만으로 이루어지던 공연에 칠면조를 추가할 수 있게 되는 것과 동일한 맥락입니다.</p>
<p>어댑터 패턴을 구현하는 방법은 <strong>객체 어댑터</strong>와 <strong>클래스 어댑터</strong>로 나눌 수 있습니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 <strong>객체를 소유</strong>하는 것을 통해 요구되는 인터페이스를 제공합니다. 클래스 어댑터는 변환 대상과 변환 결과를 <strong>동시에 상속</strong>받아서 변환을 수행합니다. 이는 칠면조의 입에 <strong>소리 변환기</strong>를 달아주는 것과 칠면조와 오리를 <strong>교배</strong>시켜 새로운 종류의 새를 만드는 것과 비슷하게 생각하시면 됩니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/디자인패턴/싱글톤 패턴">이전 포스트: <!-- -->싱글톤 패턴</a></div><div style="text-align:right"><a href="/디자인패턴/파사드 패턴">다음 포스트: <!-- -->파사드 패턴</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-18-Adapter Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-18-Adapter Pattern.md","category":"디자인패턴","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 어댑터 패턴을 통한 해결\n5. 객체 어댑터와 클래스 어댑터\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**어댑터 패턴**은 다른 인터페이스로 **기존 클래스의 인터페이스를 변환**하는 패턴입니다. 이는 **호환성 문제**를 해결할 수 있습니다. 호환성 문제는 클래스의 인터페이스가 클라이언트의 **요구사항**과 맞지 않을 때 발생합니다.\n\n이때 어댑터 패턴을 사용하면 클라이언트의 요구사항에 맞게 클래스의 인터페이스를 변환할 수 있습니다. 마치 한국 콘센트를 유럽 콘센트에 맞게 변환하는 것과 같습니다.\n\nhead first design patterns는 이에 대한 예시로 전에 사용했던 **오리**를 가져옵니다. 어쩌다보니 오리가 모자라서 **칠면조**를 사용해야 상황이 왔는데, 칠면조는 오리와는 다른 울음 소리를 내고 있습니다. 이때 칠면조의 목소리를 오리와 동일하게 변환하는 어댑터를 사용하면 칠면조를 오리로 사용할 수 있습니다.\n\n어댑터를 사용해서 기존에 사용하던 오리 코드를 수정하지 않고 칠면조를 오리로 사용하면 코드의 수정이 최소화됩니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다.\n\n어댑터 패턴 구현 방식은 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다. 클래스 어댑터는 **상속**을 통해 어댑터를 구현하고, 객체 어댑터는 **구성**을 통해 어댑터를 구현합니다.\n\n---\n\n## 요약\n\n1. 어댑터 패턴은 **클래스의 인터페이스를 다른 인터페이스로 변환**하는 패턴입니다.\n2. **호환성 문제**를 해결할 수 있습니다.\n3. 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다.\n4. 어댑티 - 칠면조, 어댑티 - 오리, 클라이언트 - 사용자\n5. 구현 방식에 따라 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다.\n\n---\n\n## 문제상황\n\n동물원에서 기존에 오리만으로 이루어진 공연이 있었습니다. 그런데 어느 날 몇 마리의 오리가 아프게 되어서 공연을 할 수 없게 되었습니다. 그래서 동물원은 칠면조를 대신해서 공연을 하기로 했습니다. 그런데 오리가 \"**꽥꽥**\" 소리를 내는데 반해 칠면조는 \"**고블고블**\" 소리를 내기 때문에 공연을 할 수 없었습니다.\n\n위와 같은 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Duck {\n    public void quack();\n    public void fly();\n}\n\npublic interface Turkey {\n    public void gobble();\n    public void fly();\n}\n```\n\n이런 상황에서 칠면조를 오리로 사용하는 방법이 필요합니다. 칠면조의 \"고블고블\" 소리가 오리의 \"꽥꽥\" 소리와 동일하게 동작하도록 만드는 것이죠.\n\n---\n\n## 어댑터 패턴을 통한 해결\n\n이런 상황에서 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 어댑터 패턴을 사용하면 칠면조의 \"고블고블\" 소리를 오리의 \"꽥꽥\" 소리로 **변환**할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n\n    public void quack() {\n        turkey.gobble();\n    }\n\n    public void fly() {\n        turkey.fly();\n    }\n}\n```\n\n이렇게 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 칠면조의 \"고블고블\" 소리는 어댑터를 통해 \"꽥꽥\" 소리로 **변환**되어 공연 연출가에게 전달됩니다.\n\n이런 방식으로 어댑터 패턴을 사용하면 기존의 코드를 수정하지 않고 칠면조를 오리로 사용할 수 있습니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다. 동물원의 입장에서는 새로운 오리를 추가로 구매할 필요가 없어지고, 칠면조의 입장에서는 꽥꽥 소리를 내는 훈련을 할 필요가 없어지는 겁니다. 애초에 불가능하겠지만요.\n\n---\n\n## 객체 어댑터와 클래스 어댑터\n\n위와 같이 **인터페이스를 통해 어댑터를 구현**하는 것을 **객체 어댑터**라고 합니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 객체를 **소유**하는 것을 통해 요구되는 인터페이스를 제공합니다.\n\n또 다른 방법으로는 **다중 상속**을 통해 어댑터를 구현할 수도 있습니다. 이를 **클래스 어댑터**라고 합니다. 클래스 어댑터는 변환 대상과 변환 결과를 동시에 상속받아서 변환을 수행합니다. 오리와 칠면조를 **교배**시켜 만든 새로운 종류의 새라고 생각하시면 됩니다.\n\n클래스 어댑터를 코드로 나타내면 다음과 같습니다.\n\n```c++\nclass TurkeyAdapter : public Duck, public Turkey {\n    public:\n        void quack() {\n            gobble();\n        }\n\n        void fly() {\n            Turkey::fly();\n        }\n\n        void gobble() {\n            cout \u003c\u003c \"Gobble gobble Quack quack\" \u003c\u003c endl;\n        }\n}\n```\n\n---\n\n## 결론\n\n**어댑터 패턴**은 클래스의 인터페이스를 **다른 인터페이스로 변환**하는 패턴입니다. 이를 통해 **호환성 문제**를 해결하면 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다. 이는 오리만으로 이루어지던 공연에 칠면조를 추가할 수 있게 되는 것과 동일한 맥락입니다.\n\n어댑터 패턴을 구현하는 방법은 **객체 어댑터**와 **클래스 어댑터**로 나눌 수 있습니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 **객체를 소유**하는 것을 통해 요구되는 인터페이스를 제공합니다. 클래스 어댑터는 변환 대상과 변환 결과를 **동시에 상속**받아서 변환을 수행합니다. 이는 칠면조의 입에 **소리 변환기**를 달아주는 것과 칠면조와 오리를 **교배**시켜 새로운 종류의 새를 만드는 것과 비슷하게 생각하시면 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","date":"2024-02-18T00:00:00.000Z","categories":"디자인패턴"}},"title":"어댑터 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"싱글톤 패턴","category":"디자인패턴"},"next":{"title":"파사드 패턴","category":"디자인패턴"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"디자인패턴","title":"어댑터 패턴"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>