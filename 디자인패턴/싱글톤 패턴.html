<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">싱글톤 패턴</h1><h1 class="project-subtitle">찰리네 초콜릿 보일러는 세계 유일!</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>개요</li>
<li>요약</li>
<li>문제상황</li>
<li>고전적인 싱글톤 패턴을 통한 해결</li>
<li>멀티 쓰레드 환경에서의 문제점</li>
<li>다양한 방법을 통한 해결 - 이중검사 락, 정적인 초기화, Enum</li>
<li>결론</li>
</ol>
<hr>

      <h2 id="개요">
        <a name="개요" class="anchor" href="#개요">
          <span class="header-link"></span>
        </a>
        개요
      </h2><p>본 글은 <strong>head first design patterns</strong> 책을 읽고 정리한 글입니다.</p>
<p><strong>싱글톤 패턴</strong>은 특정 클래스에 대해 <strong>객체 인스턴스</strong>가 <strong>하나</strong>만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 <strong>자원을 절약</strong>할 수 있고, 객체 간의 <strong>상태를 공유</strong>해서 전역 변수처럼 사용할 수 있습니다.</p>
<p>head first design은 이에 대한 예시로 <strong>초콜릿 보일러</strong>를 예시로 사용합니다. 초콜릿 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 맛있는 초콜릿을 많이 만들기 위해 무려 **500 갤런(약 1892리터)**의 초콜릿을 만들 수 있는 것을 들였습니다.</p>
<p>이 때문에 이 보일러를 두 개나 유지하는 것은 굉장히 비효율적입니다. 이 거대한 초콜릿 보일러 하나를 동작시키는 것도 힘들 뿐더러, 두 개 이상에서 나온 것을 받아 초코바를 만드는 것도 힘들기 때문입니다.</p>
<p>하지만 한 개의 보일러를 <strong>두 명이 동시에 사용</strong>하려하면 어떤 문제가 생길 수 있을까요? 초콜릿 보일러가 가득 차 있는 상태에서 새로운 재료를 붓는다거나, 끓어넘치고 있는데 온도를 더 올려버리는 등의 문제가 생길 수 있습니다. 이런 문제를 해결하기 위해서는 초콜릿 보일러를 하나만 유지하고, 이를 <strong>공유</strong>해서 사용하는 것이 좋습니다.</p>
<p>이런 식으로 싱글톤 패턴은 <strong>리소스를 절약</strong>하고, 객체 간의 <strong>상태를 공유</strong>하기 위해 사용됩니다. 대신 객체 인스턴스가 하나만 만들어지기 때문에, 이 객체 인스턴스를 공유하는 모든 객체들은 멀티 쓰레드 환경에서는 주의할 필요가 있습니다.</p>
<hr>

      <h2 id="요약">
        <a name="요약" class="anchor" href="#요약">
          <span class="header-link"></span>
        </a>
        요약
      </h2><ol>
<li>싱글톤 패턴은 특정 클래스에 대해 <strong>객체 인스턴스</strong>가 <strong>하나만</strong> 만들어지도록 해 주는 패턴입니다.</li>
<li>메모리와 같은 <strong>자원을 절약</strong>할 수 있고, 객체 간의 <strong>상태를 공유</strong>할 수 있습니다.</li>
<li>하나뿐인 인스턴스를 공유하기 때문에 <strong>멀티 쓰레드 환경</strong>에서는 주의해야 합니다.</li>
<li>고전적인 싱글톤 패턴은 <strong>지연 초기화</strong>와 <strong>스레드 안전성</strong>을 보장하지 않습니다.</li>
<li>이를 해결하기 위해 <strong>이중검사 락</strong>을 사용하는 방법이 있습니다.</li>
<li><strong>정적인 초기화</strong>를 사용하는 방법도 있습니다.</li>
<li>java에서는 <strong>Enum</strong>을 사용하는 방법이 권장됩니다.</li>
</ol>
<hr>

      <h2 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h2><p>초콜릿 공장에서 초콜릿을 만드는 보일러를 만들고 있습니다. 이 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 이 보일러는 다음과 같이 구현되어 있습니다.</p>
<pre><code class="language-java">public class ChocolateBoiler {
    private boolean empty;
    private boolean boiled;

    public ChocolateBoiler() {
        empty = true;
        boiled = false;
    }

    public void fill() {
        if (isEmpty()) {
            empty = false;
            boiled = false;
            // 우유/초콜릿을 보일러에 넣는다.
        }
    }

    public void drain() {
        if (!isEmpty() &amp;&amp; isBoiled()) {
            // 끓인 우유/초콜릿을 다음 단계로 넘긴다.
            empty = true;
        }
    }

    public void boil() {
        if (!isEmpty() &amp;&amp; !isBoiled()) {
            // 우유/초콜릿을 끓인다.
            boiled = true;
        }
    }

    public boolean isEmpty() {
        return empty;
    }

    public boolean isBoiled() {
        return boiled;
    }
}
</code></pre>
<p>우유나 초콜릿을 채워넣었는지 여부와 우유나 초콜릿을 끓였는지 여부를 세심하게 관리하고는 있지만, 이 <strong>보일러가 여러 개</strong>가 생성되어서 <strong>동시에 사용</strong>될 경우에는 어떻게 될까요? 차있지 않은 보일러를 끓이려고 하거나, 이미 끓인 보일러에 우유나 초콜릿을 채워넣으려고 하는 등의 문제가 생길 수도 있을 것입니다.</p>
<p>이런 문제를 해결하기 위해서는 이 보일러를 <strong>하나만 유지</strong>하고, 이를 <strong>공유</strong>해서 사용하는 것이 좋습니다. 이것이 싱글톤 패턴의 개념입니다. 500 갤런이나 되는 거대한 보일러를 하나만 유지하되, 여기에다가 많은 직원들이 접근해서 우유나 초콜릿을 채워넣고, 끓이고, 다음 단계로 넘기는 것이죠.</p>
<hr>

      <h2 id="고전적인-싱글톤-패턴을-통한-해결">
        <a name="고전적인-싱글톤-패턴을-통한-해결" class="anchor" href="#고전적인-싱글톤-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        고전적인 싱글톤 패턴을 통한 해결
      </h2><p>고전적인 싱글톤 패턴은 다음과 같이 구현됩니다.</p>
<pre><code class="language-java">public class ChocolateBoiler {
    private static ChocolateBoiler uniqueInstance;

    private ChocolateBoiler() {
        empty = true;
        boiled = false;
    }

    public static ChocolateBoiler getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new ChocolateBoiler();
        }
        return uniqueInstance;
    }
    ...
}
</code></pre>
<p>고전적인 싱글톤 패턴은 위와 같이 생성자를 <strong>private</strong>으로 선언하고, 유일한 객체 인스턴스를 반환하는 <strong>getInstance</strong> 메소드를 만들어서 객체 인스턴스를 하나만 만들도록 합니다. getInstance 메소드는 객체 인스턴스가 없을 때만 객체 인스턴스를 만들고, 객체 인스턴스가 이미 있을 때는 객체 인스턴스를 반환하도록 합니다.</p>
<p>이렇게 하면 <strong>객체 인스턴스가 하나</strong>만 만들어지기 때문에 메모리와 같은 <strong>자원을 절약</strong>할 수 있고, 객체 인스턴스가 하나만 만들어지기 때문에 객체 간의 <strong>상태를 공유</strong>할 수 있습니다.</p>
<hr>

      <h2 id="멀티-쓰레드-환경에서의-문제점">
        <a name="멀티-쓰레드-환경에서의-문제점" class="anchor" href="#멀티-쓰레드-환경에서의-문제점">
          <span class="header-link"></span>
        </a>
        멀티 쓰레드 환경에서의 문제점
      </h2><p>다만 이 방법은 <strong>멀티 쓰레드</strong> 환경에서는 문제가 될 수 있습니다.</p>
<p>만약 아직 객체 인스턴스가 <strong>생성되지 않은 상태</strong>에서 <strong>두 개 이상의 쓰레드</strong>가 getInstance 메소드를 호출하게 되면 무슨 일이 일어날까요? 두 개 이상의 쓰레드가 동시에 getInstance 메소드를 호출하게 되면, 두 개 이상의 객체 인스턴스가 생성될 수 있습니다.</p>
<p>초콜릿 공장에 필요한 보일러를 주문하라는 지령서를 실수로 두 명의 직원이 받아서, 거대한 보일러가 두 개나 도착해버린 상황을 상상해 보세요. 우리 공장에는 이런 보일러를 놓을 공간도 없는데 말입니다.</p>
<p>이런 상황을 방지하기 위해서는 멀티 쓰레드 환경에서도 <strong>스레드 안전성</strong>을 보장해야 합니다.</p>
<p>이를 단순하게 해결하는 방법으로는 생성자에 <strong>synchronized</strong> 키워드를 사용하는 방법이 있습니다. 이 방법은 다음과 같이 구현됩니다.</p>
<pre><code class="language-java">public static synchronized ChocolateBoiler getInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new ChocolateBoiler();
    }
    return uniqueInstance;
}
</code></pre>
<p>그런데 synchronized 키워드를 사용하면, <strong>getInstance</strong> 메소드를 호출할 때마다 synchronized 키워드를 사용한 <strong>동기화</strong>를 해야하기 때문에 <strong>성능</strong>이 떨어질 수 있습니다.</p>
<p>대략적으로 <strong>100배</strong> 정도 성능이 떨어진다고 합니다. 이 과정이 <strong>병목(bottleneck)</strong> 지점이 될 경우 프로그램 성능에 크게 영향을 미칠 수 있습니다.</p>
<p>이런 문제를 해결하기 위해서는 여러 가지 방법이 있습니다. 이 중에서는 <strong>이중검사 락</strong>을 사용하는 방법, <strong>정적인 초기화</strong>를 사용하는 방법, <strong>Enum</strong>을 사용하는 방법 등이 있습니다.</p>
<hr>

      <h2 id="이중검사-락을-사용한-싱글톤-패턴을-통한-해결">
        <a name="이중검사-락을-사용한-싱글톤-패턴을-통한-해결" class="anchor" href="#이중검사-락을-사용한-싱글톤-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        이중검사 락을 사용한 싱글톤 패턴을 통한 해결
      </h2><p>**이중검사 락(Double-Checked Locking)**을 사용하는 방법은 다음과 같이 구현됩니다.</p>
<pre><code class="language-java">public static ChocolateBoiler getInstance() {
    if (uniqueInstance == null) {
        synchronized (ChocolateBoiler.class) {
            if (uniqueInstance == null) {
                uniqueInstance = new ChocolateBoiler();
            }
        }
    }
    return uniqueInstance;
}
</code></pre>
<p>이렇게 하면 getInstance 메소드를 호출할 때마다 <strong>동기화</strong>를 하지 않고도 <strong>스레드 안전성</strong>을 보장할 수 있습니다. 대부분의 경우에 uiqueInstance는 이미 null이 아닐테니까요.</p>
<hr>

      <h2 id="정적인-초기화를-사용한-싱글톤-패턴을-통한-해결">
        <a name="정적인-초기화를-사용한-싱글톤-패턴을-통한-해결" class="anchor" href="#정적인-초기화를-사용한-싱글톤-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        정적인 초기화를 사용한 싱글톤 패턴을 통한 해결
      </h2><p><strong>정적인 초기화</strong>를 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.</p>
<pre><code class="language-java">private static ChocolateBoiler uniqueInstance = new ChocolateBoiler();

public static ChocolateBoiler getInstance() {
    return uniqueInstance;
}
</code></pre>
<p>대신 이렇게 하면, 프로그램이 시작될 때 바로 객체 인스턴스가 생성되기 때문에 <strong>지연 초기화</strong>가 되지 않습니다. 이런 방법은 <strong>지연 초기화</strong>가 필요하지 않은 경우에 사용하는 것이 좋습니다.</p>
<hr>

      <h2 id="enum을-사용한-싱글톤-패턴을-통한-해결">
        <a name="enum을-사용한-싱글톤-패턴을-통한-해결" class="anchor" href="#enum을-사용한-싱글톤-패턴을-통한-해결">
          <span class="header-link"></span>
        </a>
        Enum을 사용한 싱글톤 패턴을 통한 해결
      </h2><p>java에서는 <strong>Enum</strong>을 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.</p>
<pre><code class="language-java">public enum ChocolateBoiler {
    INSTANCE;

    private boolean empty;
    private boolean boiled;

    public void fill() {
        if (isEmpty()) {
            empty = false;
            boiled = false;
            // 우유/초콜릿을 보일러에 넣는다.
        }
    }

...
</code></pre>
<p>위와 같은 방법은 멀티 쓰레드 환경에서 스레드 안정성을 보장하고, 고급 문법인 <strong>직렬화</strong>와 <strong>리플렉션</strong> 등의 문제도 해결할 수 있습니다. 이 때문에 java에서는 이 방법을 사용하는 것을 권장합니다.</p>
<hr>

      <h2 id="결론">
        <a name="결론" class="anchor" href="#결론">
          <span class="header-link"></span>
        </a>
        결론
      </h2><p><strong>싱글톤 패턴</strong>은 특정 클래스에 대해 <strong>객체 인스턴스가 하나</strong>만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 <strong>자원을 절약</strong>할 수 있고, 객체 간의 <strong>상태를 공유</strong>할 수 있습니다.</p>
<p><strong>멀티 쓰레드 환경</strong>에서는 주의해야 하지만, 이를 해결하기 위한 다양한 방법이 있습니다. 이 중에서는 생성자를 <strong>synchronized</strong>하거나, <strong>이중검사 락</strong>을 사용하는 방법, <strong>정적인 초기화</strong>를 사용하는 방법, <strong>Enum</strong>을 사용하는 방법 등이 있습니다. java에서는 Enum을 사용하는 방법을 권장합니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/디자인패턴/커맨드 패턴">이전 포스트: <!-- -->커맨드 패턴</a></div><div style="text-align:right"><a href="/디자인패턴/어댑터 패턴">다음 포스트: <!-- -->어댑터 패턴</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-17-Singleton Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-17-Singleton Pattern.md","category":"디자인패턴","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 고전적인 싱글톤 패턴을 통한 해결\n5. 멀티 쓰레드 환경에서의 문제점\n6. 다양한 방법을 통한 해결 - 이중검사 락, 정적인 초기화, Enum\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스**가 **하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**해서 전역 변수처럼 사용할 수 있습니다.\n\nhead first design은 이에 대한 예시로 **초콜릿 보일러**를 예시로 사용합니다. 초콜릿 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 맛있는 초콜릿을 많이 만들기 위해 무려 **500 갤런(약 1892리터)**의 초콜릿을 만들 수 있는 것을 들였습니다.\n\n이 때문에 이 보일러를 두 개나 유지하는 것은 굉장히 비효율적입니다. 이 거대한 초콜릿 보일러 하나를 동작시키는 것도 힘들 뿐더러, 두 개 이상에서 나온 것을 받아 초코바를 만드는 것도 힘들기 때문입니다.\n\n하지만 한 개의 보일러를 **두 명이 동시에 사용**하려하면 어떤 문제가 생길 수 있을까요? 초콜릿 보일러가 가득 차 있는 상태에서 새로운 재료를 붓는다거나, 끓어넘치고 있는데 온도를 더 올려버리는 등의 문제가 생길 수 있습니다. 이런 문제를 해결하기 위해서는 초콜릿 보일러를 하나만 유지하고, 이를 **공유**해서 사용하는 것이 좋습니다.\n\n이런 식으로 싱글톤 패턴은 **리소스를 절약**하고, 객체 간의 **상태를 공유**하기 위해 사용됩니다. 대신 객체 인스턴스가 하나만 만들어지기 때문에, 이 객체 인스턴스를 공유하는 모든 객체들은 멀티 쓰레드 환경에서는 주의할 필요가 있습니다.\n\n---\n\n## 요약\n\n1. 싱글톤 패턴은 특정 클래스에 대해 **객체 인스턴스**가 **하나만** 만들어지도록 해 주는 패턴입니다.\n2. 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n3. 하나뿐인 인스턴스를 공유하기 때문에 **멀티 쓰레드 환경**에서는 주의해야 합니다.\n4. 고전적인 싱글톤 패턴은 **지연 초기화**와 **스레드 안전성**을 보장하지 않습니다.\n5. 이를 해결하기 위해 **이중검사 락**을 사용하는 방법이 있습니다.\n6. **정적인 초기화**를 사용하는 방법도 있습니다.\n7. java에서는 **Enum**을 사용하는 방법이 권장됩니다.\n\n---\n\n## 문제상황\n\n초콜릿 공장에서 초콜릿을 만드는 보일러를 만들고 있습니다. 이 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 이 보일러는 다음과 같이 구현되어 있습니다.\n\n```java\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n\n    public ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n    public void drain() {\n        if (!isEmpty() \u0026\u0026 isBoiled()) {\n            // 끓인 우유/초콜릿을 다음 단계로 넘긴다.\n            empty = true;\n        }\n    }\n\n    public void boil() {\n        if (!isEmpty() \u0026\u0026 !isBoiled()) {\n            // 우유/초콜릿을 끓인다.\n            boiled = true;\n        }\n    }\n\n    public boolean isEmpty() {\n        return empty;\n    }\n\n    public boolean isBoiled() {\n        return boiled;\n    }\n}\n```\n\n우유나 초콜릿을 채워넣었는지 여부와 우유나 초콜릿을 끓였는지 여부를 세심하게 관리하고는 있지만, 이 **보일러가 여러 개**가 생성되어서 **동시에 사용**될 경우에는 어떻게 될까요? 차있지 않은 보일러를 끓이려고 하거나, 이미 끓인 보일러에 우유나 초콜릿을 채워넣으려고 하는 등의 문제가 생길 수도 있을 것입니다.\n\n이런 문제를 해결하기 위해서는 이 보일러를 **하나만 유지**하고, 이를 **공유**해서 사용하는 것이 좋습니다. 이것이 싱글톤 패턴의 개념입니다. 500 갤런이나 되는 거대한 보일러를 하나만 유지하되, 여기에다가 많은 직원들이 접근해서 우유나 초콜릿을 채워넣고, 끓이고, 다음 단계로 넘기는 것이죠.\n\n---\n\n## 고전적인 싱글톤 패턴을 통한 해결\n\n고전적인 싱글톤 패턴은 다음과 같이 구현됩니다.\n\n```java\npublic class ChocolateBoiler {\n    private static ChocolateBoiler uniqueInstance;\n\n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public static ChocolateBoiler getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new ChocolateBoiler();\n        }\n        return uniqueInstance;\n    }\n    ...\n}\n```\n\n고전적인 싱글톤 패턴은 위와 같이 생성자를 **private**으로 선언하고, 유일한 객체 인스턴스를 반환하는 **getInstance** 메소드를 만들어서 객체 인스턴스를 하나만 만들도록 합니다. getInstance 메소드는 객체 인스턴스가 없을 때만 객체 인스턴스를 만들고, 객체 인스턴스가 이미 있을 때는 객체 인스턴스를 반환하도록 합니다.\n\n이렇게 하면 **객체 인스턴스가 하나**만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 인스턴스가 하나만 만들어지기 때문에 객체 간의 **상태를 공유**할 수 있습니다.\n\n---\n\n## 멀티 쓰레드 환경에서의 문제점\n\n다만 이 방법은 **멀티 쓰레드** 환경에서는 문제가 될 수 있습니다.\n\n만약 아직 객체 인스턴스가 **생성되지 않은 상태**에서 **두 개 이상의 쓰레드**가 getInstance 메소드를 호출하게 되면 무슨 일이 일어날까요? 두 개 이상의 쓰레드가 동시에 getInstance 메소드를 호출하게 되면, 두 개 이상의 객체 인스턴스가 생성될 수 있습니다.\n\n초콜릿 공장에 필요한 보일러를 주문하라는 지령서를 실수로 두 명의 직원이 받아서, 거대한 보일러가 두 개나 도착해버린 상황을 상상해 보세요. 우리 공장에는 이런 보일러를 놓을 공간도 없는데 말입니다.\n\n이런 상황을 방지하기 위해서는 멀티 쓰레드 환경에서도 **스레드 안전성**을 보장해야 합니다.\n\n이를 단순하게 해결하는 방법으로는 생성자에 **synchronized** 키워드를 사용하는 방법이 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static synchronized ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        uniqueInstance = new ChocolateBoiler();\n    }\n    return uniqueInstance;\n}\n```\n\n그런데 synchronized 키워드를 사용하면, **getInstance** 메소드를 호출할 때마다 synchronized 키워드를 사용한 **동기화**를 해야하기 때문에 **성능**이 떨어질 수 있습니다.\n\n대략적으로 **100배** 정도 성능이 떨어진다고 합니다. 이 과정이 **병목(bottleneck)** 지점이 될 경우 프로그램 성능에 크게 영향을 미칠 수 있습니다.\n\n이런 문제를 해결하기 위해서는 여러 가지 방법이 있습니다. 이 중에서는 **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다.\n\n---\n\n## 이중검사 락을 사용한 싱글톤 패턴을 통한 해결\n\n**이중검사 락(Double-Checked Locking)**을 사용하는 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        synchronized (ChocolateBoiler.class) {\n            if (uniqueInstance == null) {\n                uniqueInstance = new ChocolateBoiler();\n            }\n        }\n    }\n    return uniqueInstance;\n}\n```\n\n이렇게 하면 getInstance 메소드를 호출할 때마다 **동기화**를 하지 않고도 **스레드 안전성**을 보장할 수 있습니다. 대부분의 경우에 uiqueInstance는 이미 null이 아닐테니까요.\n\n---\n\n## 정적인 초기화를 사용한 싱글톤 패턴을 통한 해결\n\n**정적인 초기화**를 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\nprivate static ChocolateBoiler uniqueInstance = new ChocolateBoiler();\n\npublic static ChocolateBoiler getInstance() {\n    return uniqueInstance;\n}\n```\n\n대신 이렇게 하면, 프로그램이 시작될 때 바로 객체 인스턴스가 생성되기 때문에 **지연 초기화**가 되지 않습니다. 이런 방법은 **지연 초기화**가 필요하지 않은 경우에 사용하는 것이 좋습니다.\n\n---\n\n## Enum을 사용한 싱글톤 패턴을 통한 해결\n\njava에서는 **Enum**을 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic enum ChocolateBoiler {\n    INSTANCE;\n\n    private boolean empty;\n    private boolean boiled;\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n...\n```\n\n위와 같은 방법은 멀티 쓰레드 환경에서 스레드 안정성을 보장하고, 고급 문법인 **직렬화**와 **리플렉션** 등의 문제도 해결할 수 있습니다. 이 때문에 java에서는 이 방법을 사용하는 것을 권장합니다.\n\n---\n\n## 결론\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스가 하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n\n**멀티 쓰레드 환경**에서는 주의해야 하지만, 이를 해결하기 위한 다양한 방법이 있습니다. 이 중에서는 생성자를 **synchronized**하거나, **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다. java에서는 Enum을 사용하는 방법을 권장합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","date":"2024-02-17T00:00:00.000Z","categories":"디자인패턴"}},"title":"싱글톤 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"커맨드 패턴","category":"디자인패턴"},"next":{"title":"어댑터 패턴","category":"디자인패턴"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"디자인패턴","title":"싱글톤 패턴"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>