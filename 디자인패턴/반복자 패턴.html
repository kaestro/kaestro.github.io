<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">반복자 패턴</h1><h1 class="project-subtitle">저녁밥도 팬케이크도 다 단비꺼야</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>개요</li>
<li>요약</li>
<li>문제상황</li>
<li>반복자 패턴을 사용한 해결책</li>
<li>단일 역할 원칙</li>
<li>결론</li>
</ol>
<hr>

      <h2 id="개요">
        <a name="개요" class="anchor" href="#개요">
          <span class="header-link"></span>
        </a>
        개요
      </h2><p>본 글은 <strong>head first design patterns</strong> 책을 읽고 정리한 글입니다.</p>
<p><strong>반복자 패턴</strong>은 <strong>컬렉션</strong>의 내부 구조를 노출하지 않고 컬렉션의 <strong>모든 요소</strong>에 <strong>접근</strong>할 수 있게 하는 패턴입니다. 이는 항목 내에서 <strong>반복 작업</strong>을 <strong>반복자</strong>로 <strong>캡슐화</strong>해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 <strong>순회</strong>할 수 있게 합니다.</p>
<p>반복자 패턴을 통해 각각의 항목에 대한 접근을 하는 기능을 컬렉션에서 <strong>분리</strong>해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.</p>
<p>head first design patterns는 여러 가지 <strong>음식점 통합</strong>을 해야하는 상황을 이야기합니다. 음식점의 종류에는 팬케이크 하우스, 디너 하우스, 카페가 있고 이들은 각각의 메뉴를 ArrayList, Array, HashMap과 같이 <strong>다른 형태로 관리</strong>하고 있습니다. 이런 상황에서 한 명의 웨이트리스에게 메뉴들을 읽는 다른 방법들을 다 숙지시키고 일을 맡기는 것은 비효율적이고 위험합니다.</p>
<p>이때 반복자 객체를 통한 접근을 사용해서 문제를 해결할 수 있습니다. 웨이트리스는 개별의 객체들을 순회하는 방법들에 대해 인지할 필요 없이 이를 <strong>캡슐화</strong>한 <strong>반복자 객체</strong>를 사용해서 각각의 객체들을 순회할 수 있게 됩니다.</p>
<p><strong>단일 역할 원칙</strong>(Single Responsibility Principle)은 &quot;<strong>클래스는 하나의 변경 이유만을 가져야 한다</strong>.&quot;라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.</p>
<hr>

      <h2 id="요약">
        <a name="요약" class="anchor" href="#요약">
          <span class="header-link"></span>
        </a>
        요약
      </h2><ol>
<li><strong>반복자 패턴</strong>은 컬렉션의 내부 구조를 노출하지 않고 컬렉션의 <strong>모든 요소에 접근</strong>할 수 있게 하는 패턴입니다.</li>
<li>각각의 항목에 대한 <strong>접근</strong>을 하는 기능을 <strong>캡슐화</strong>를 통해 컬렉션에서 <strong>분리</strong>해 반복자 객체가 책임지게 할 수 있습니다.</li>
<li>집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.</li>
<li><strong>단일 역할 원칙</strong>은 &quot;클래스는 하나의 변경 이유만을 가져야 한다.&quot;라는 원칙입니다.</li>
</ol>
<hr>

      <h2 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h2><p>마을의 디너 하우스에서 사업 확장의 일환으로 팬케이크 하우스와 <strong>합병</strong>을 하기로 결정했습니다. 이 합병은, 식사는 훌륭하지만 디저트가 아쉬웠던 약점 보완을 통해 시너지 작용을 해서 더 많은 손님을 유치할 수 있으리라 기대했습니다.</p>
<p>그런데 여기에서 일 할 웨이트리스들 간에서 불만의 목소리가 나왔습니다. &quot;나는 <strong>반대쪽 식당의 메뉴판</strong>을 읽을 수가 없는데요?&quot;</p>
<p>확인해보니, 팬케이크 하우스는 <strong>ArrayList</strong>, 디너 하우스는 <strong>Array</strong>로 메뉴를 관리하고 있었습니다. 이런 상황에서 두 식당을 통합하려면 손님은 자기가 주문하려는 메뉴를 알고 있는 웨이트리스가 누구인지를 알아내든지, 웨이트리스가 두 식당의 메뉴판을 다 숙지하고 있어야 하는 문제가 발생할 것으로 예상됩니다.</p>
<p>이런 상황을 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public class MenuItem {
    String name;
    String description;
    boolean isVegetarian;
    double price;

    public MenuItem(String name, String description, boolean isVegetarian, double price) {
        this.name = name;
        this.description = description;
        this.isVegetarian = isVegetarian;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    ...
}

public class PancakeHouseMenu {
    ArrayList&lt;MenuItem&gt; menuItems;

    public PancakeHouseMenu() {
        menuItems = new ArrayList&lt;MenuItem&gt;();

        addItem(&quot;K&amp;B 팬케이크 세트&quot;, &quot;스크램블드 에그와 토스트가 곁들여진 팬케이크&quot;, true, 2.99);
        addItem(&quot;레귤러 팬케이크 세트&quot;, &quot;달걀 후라이와 소시지가 곁들여진 팬케이크&quot;, false, 2.99);
        addItem(&quot;블루베리 팬케이크&quot;, &quot;신선한 블루베리와 시럽으로 만든 팬케이크&quot;, true, 3.49);
        addItem(&quot;와플&quot;, &quot;와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.&quot;, true, 3.59);
    }

    public void addItem(String name, String description, boolean isVegetarian, double price) {
        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);
        menuItems.add(menuItem);
    }

    public ArrayList&lt;MenuItem&gt; getMenuItems() {
        return menuItems;
    }

    ...
}

public class DinerMenu {
    static final int MAX_ITEMS = 6;
    int numberOfItems = 0;
    MenuItem[] menuItems;

    public DinerMenu() {
        menuItems = new MenuItem[MAX_ITEMS];

        addItem(&quot;채식주의자용 BLT&quot;, &quot;통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴&quot;, true, 2.99);
        addItem(&quot;BLT&quot;, &quot;통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴&quot;, false, 2.99);
        addItem(&quot;오늘의 스프&quot;, &quot;감자 샐러드를 곁들인 오늘의 스프&quot;, false, 3.29);
        addItem(&quot;핫도그&quot;, &quot;사워크라우트, 갖은 양념, 양파, 치즈가 곁들여진 핫도그&quot;, false, 3.05);
    }

    public void addItem(String name, String description, boolean isVegetarian, double price) {
        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);
        if (numberOfItems &gt;= MAX_ITEMS) {
            System.err.println(&quot;죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.&quot;);
        } else {
            menuItems[numberOfItems] = menuItem;
            numberOfItems = numberOfItems + 1;
        }
    }

    public MenuItem[] getMenuItems() {
        return menuItems;
    }

    ...
}

public class Waitress {
    PancakeHouseMenu pancakeHouseMenu;
    DinerMenu dinerMenu;

    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {
        this.pancakeHouseMenu = pancakeHouseMenu;
        this.dinerMenu = dinerMenu;
    }

    public void printMenu() {
        ArrayList&lt;MenuItem&gt; breakfastItems = pancakeHouseMenu.getMenuItems();
        MenuItem[] lunchItems = dinerMenu.getMenuItems();

        System.out.println(&quot;아침 메뉴&quot;);
        for (int i = 0; i &lt; breakfastItems.size(); i++) {
            MenuItem menuItem = breakfastItems.get(i);
            System.out.println(menuItem.getName() + &quot;, &quot;);
            System.out.println(menuItem.getPrice() + &quot; -- &quot;);
            System.out.println(menuItem.getDescription());
        }

        System.out.println(&quot;점심 메뉴&quot;);
        for (int i = 0; i &lt; lunchItems.length; i++) {
            MenuItem menuItem = lunchItems[i];
            System.out.println(menuItem.getName() + &quot;, &quot;);
            System.out.println(menuItem.getPrice() + &quot; -- &quot;);
            System.out.println(menuItem.getDescription());
        }
    }
}
</code></pre>
<p>위와 같은 상황을 개선하지 않으면 앞으로 더 많은 음식점을 통합하려는 목표를 가진 주인 입장에서는 심각한 걸림돌이 될 수 있습니다. 새로운 종업원을 교육하는 것도 힘들고, 주문의 절차도 복잡해지기 때문입니다.</p>
<p>여태까지 디자인 패턴을 적용하면서 이런 문제를 해결해왔듯이, <strong>반복</strong>이 되면서 <strong>변하는 부분</strong>을 찾아내고, 이를 <strong>캡슐화</strong>해서 <strong>재사용</strong>할 수 있게 만들어야 합니다.</p>
<hr>

      <h2 id="반복자-패턴을-사용한-해결책">
        <a name="반복자-패턴을-사용한-해결책" class="anchor" href="#반복자-패턴을-사용한-해결책">
          <span class="header-link"></span>
        </a>
        반복자 패턴을 사용한 해결책
      </h2><p><strong>반복자 패턴</strong>을 사용하면 위와 같은 문제를 해결할 수 있습니다. 반복자 패턴은 컬렉션의 <strong>내부 구조</strong>를 노출하지 않고 <strong>컬렉션</strong>의 <strong>모든 요소에 접근</strong>할 수 있게 하는 패턴입니다. 이는 항목 내에서 <strong>반복 작업</strong>을 <strong>반복자</strong>로 <strong>캡슐화</strong>해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 <strong>순회</strong>할 수 있게 합니다.</p>
<p>비유를 통해 설명하자면 웨이트리스에게 메뉴들을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 <strong>쪽지</strong>를 주는 것과 같습니다. 이 쪽지는 각각의 식당에 대한 메뉴판을 순회하는 방법을 캡슐화한 반복자 객체입니다.</p>
<p>이를 코드로 나타내면 다음과 같습니다.</p>
<pre><code class="language-java">public interface Iterator {
    boolean hasNext();
    Object next();
}

public interface Menu {
    Iterator createIterator();
}

public class PancakeMenuIterator implements Iterator {
    ArrayList&lt;MenuItem&gt; items;
    int position = 0;

    public PancakeMenuIterator(ArrayList&lt;MenuItem&gt; items) {
        this.items = items;
    }

    public Object next() {
        MenuItem menuItem = items.get(position);
        position = position + 1;
        return menuItem;
    }

    public boolean hasNext() {
        return position &lt; items.size();
    }
}

public class PancakeHouseMenu implements Menu {
    ...

    public Iterator createIterator() {
        return new PancakeHouseMenuIterator(menuItems);
    }
}

public class Waitress {
    ...

    public void printMenu() {
        Iterator pancakeIterator = pancakeHouseMenu.createIterator();
        Iterator dinerIterator = dinerMenu.createIterator();

        System.out.println(&quot;아침 메뉴&quot;);
        printMenu(pancakeIterator);
        System.out.println(&quot;점심 메뉴&quot;);
        printMenu(dinerIterator);
    }

    private void printMenu(Iterator iterator) {
        while (iterator.hasNext()) {
            MenuItem menuItem = (MenuItem) iterator.next();
            System.out.println(menuItem.getName() + &quot;, &quot;);
            System.out.println(menuItem.getPrice() + &quot; -- &quot;);
            System.out.println(menuItem.getDescription());
        }
    }
}
</code></pre>
<p>이제 더 많은 식당들을 추가하더라도 각각의 웨이트리스들에게 새로운 메뉴판을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 쪽지를 읽는 방법을 숙지시키는 것만으로도 교육과정을 줄일 수 있습니다.</p>
<hr>

      <h2 id="단일-역할-원칙">
        <a name="단일-역할-원칙" class="anchor" href="#단일-역할-원칙">
          <span class="header-link"></span>
        </a>
        단일 역할 원칙
      </h2><p><strong>단일 역할 원칙</strong>(Single Responsibility Principle)은 **&quot;클래스는 하나의 변경 이유만을 가져야 한다.&quot;**라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 <strong>바뀌는 부분</strong>의 <strong>역할</strong>이 <strong>하나</strong>이도록 하자는 원칙입니다.</p>
<p>반복자 패턴을 사용하면 이 원칙을 지킬 수 있습니다. 웨이트리스는 메뉴판을 읽는 방법을 숙지시키는 역할만을 가지고 있고, 반복자 객체는 메뉴판을 순회하는 역할만을 가지고 있습니다. 이렇게 각각의 객체들은 하나의 역할만을 가지고 있기 때문에 단일 역할 원칙을 지킬 수 있습니다.</p>
<hr>

      <h2 id="결론">
        <a name="결론" class="anchor" href="#결론">
          <span class="header-link"></span>
        </a>
        결론
      </h2><p><strong>반복자 패턴</strong>은 컬렉션의 <strong>내부 구조</strong>를 노출하지 않고 <strong>컬렉션의 모든 요소에 접근</strong>할 수 있게 하는 패턴입니다. 이는 항목 내에서 반복 작업을 <strong>반복자</strong>로 <strong>캡슐화</strong>해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 <strong>순회</strong>할 수 있게 합니다.</p>
<p>이는 마치 여러 가지 <strong>다른 형태의 메뉴판</strong>을 가지고 있는 <strong>음식점의 메뉴</strong>를 통합할 때, 근무할 웨이트리스에게 각각의 메뉴를 숙지하게 하는 것이 아니라 이를 <strong>통합한 쪽지</strong>를 주는 것과 같습니다. 이를 통해 웨이트리스는 각각의 메뉴를 숙지할 필요 없이 쪽지를 통해 메뉴를 <strong>순회</strong>할 수 있게 됩니다.</p>
<p>반복자 패턴을 통해 각각의 항목에 대한 <strong>접근</strong>을 하는 기능을 <strong>캡슐화</strong>를 통해 <strong>컬렉션에서 분리</strong>해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.</p>
<p><strong>단일 역할 원칙</strong>(Single Responsibility Principle)은 &quot;<strong>클래스는 하나의 변경 이유만을 가져야 한다.</strong>&quot;라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/디자인패턴/템플릿 메소드 패턴">이전 포스트: <!-- -->템플릿 메소드 패턴</a></div><div style="text-align:right"><a href="/디자인패턴/컴포지트 패턴">다음 포스트: <!-- -->컴포지트 패턴</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-23-Iterator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-23-Iterator Pattern.md","category":"디자인패턴","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 반복자 패턴을 사용한 해결책\n5. 단일 역할 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**반복자 패턴**은 **컬렉션**의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소**에 **접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 접근을 하는 기능을 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\nhead first design patterns는 여러 가지 **음식점 통합**을 해야하는 상황을 이야기합니다. 음식점의 종류에는 팬케이크 하우스, 디너 하우스, 카페가 있고 이들은 각각의 메뉴를 ArrayList, Array, HashMap과 같이 **다른 형태로 관리**하고 있습니다. 이런 상황에서 한 명의 웨이트리스에게 메뉴들을 읽는 다른 방법들을 다 숙지시키고 일을 맡기는 것은 비효율적이고 위험합니다.\n\n이때 반복자 객체를 통한 접근을 사용해서 문제를 해결할 수 있습니다. 웨이트리스는 개별의 객체들을 순회하는 방법들에 대해 인지할 필요 없이 이를 **캡슐화**한 **반복자 객체**를 사용해서 각각의 객체들을 순회할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다**.\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n\n---\n\n## 요약\n\n1. **반복자 패턴**은 컬렉션의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소에 접근**할 수 있게 하는 패턴입니다.\n2. 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다.\n3. 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n4. **단일 역할 원칙**은 \"클래스는 하나의 변경 이유만을 가져야 한다.\"라는 원칙입니다.\n\n---\n\n## 문제상황\n\n마을의 디너 하우스에서 사업 확장의 일환으로 팬케이크 하우스와 **합병**을 하기로 결정했습니다. 이 합병은, 식사는 훌륭하지만 디저트가 아쉬웠던 약점 보완을 통해 시너지 작용을 해서 더 많은 손님을 유치할 수 있으리라 기대했습니다.\n\n그런데 여기에서 일 할 웨이트리스들 간에서 불만의 목소리가 나왔습니다. \"나는 **반대쪽 식당의 메뉴판**을 읽을 수가 없는데요?\"\n\n확인해보니, 팬케이크 하우스는 **ArrayList**, 디너 하우스는 **Array**로 메뉴를 관리하고 있었습니다. 이런 상황에서 두 식당을 통합하려면 손님은 자기가 주문하려는 메뉴를 알고 있는 웨이트리스가 누구인지를 알아내든지, 웨이트리스가 두 식당의 메뉴판을 다 숙지하고 있어야 하는 문제가 발생할 것으로 예상됩니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class MenuItem {\n    String name;\n    String description;\n    boolean isVegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean isVegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.isVegetarian = isVegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    ...\n}\n\npublic class PancakeHouseMenu {\n    ArrayList\u003cMenuItem\u003e menuItems;\n\n    public PancakeHouseMenu() {\n        menuItems = new ArrayList\u003cMenuItem\u003e();\n\n        addItem(\"K\u0026B 팬케이크 세트\", \"스크램블드 에그와 토스트가 곁들여진 팬케이크\", true, 2.99);\n        addItem(\"레귤러 팬케이크 세트\", \"달걀 후라이와 소시지가 곁들여진 팬케이크\", false, 2.99);\n        addItem(\"블루베리 팬케이크\", \"신선한 블루베리와 시럽으로 만든 팬케이크\", true, 3.49);\n        addItem(\"와플\", \"와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.\", true, 3.59);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        menuItems.add(menuItem);\n    }\n\n    public ArrayList\u003cMenuItem\u003e getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n\n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n\n        addItem(\"채식주의자용 BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", true, 2.99);\n        addItem(\"BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", false, 2.99);\n        addItem(\"오늘의 스프\", \"감자 샐러드를 곁들인 오늘의 스프\", false, 3.29);\n        addItem(\"핫도그\", \"사워크라우트, 갖은 양념, 양파, 치즈가 곁들여진 핫도그\", false, 3.05);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        if (numberOfItems \u003e= MAX_ITEMS) {\n            System.err.println(\"죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n\n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n\n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n\n    public void printMenu() {\n        ArrayList\u003cMenuItem\u003e breakfastItems = pancakeHouseMenu.getMenuItems();\n        MenuItem[] lunchItems = dinerMenu.getMenuItems();\n\n        System.out.println(\"아침 메뉴\");\n        for (int i = 0; i \u003c breakfastItems.size(); i++) {\n            MenuItem menuItem = breakfastItems.get(i);\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n\n        System.out.println(\"점심 메뉴\");\n        for (int i = 0; i \u003c lunchItems.length; i++) {\n            MenuItem menuItem = lunchItems[i];\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n위와 같은 상황을 개선하지 않으면 앞으로 더 많은 음식점을 통합하려는 목표를 가진 주인 입장에서는 심각한 걸림돌이 될 수 있습니다. 새로운 종업원을 교육하는 것도 힘들고, 주문의 절차도 복잡해지기 때문입니다.\n\n여태까지 디자인 패턴을 적용하면서 이런 문제를 해결해왔듯이, **반복**이 되면서 **변하는 부분**을 찾아내고, 이를 **캡슐화**해서 **재사용**할 수 있게 만들어야 합니다.\n\n\n---\n\n## 반복자 패턴을 사용한 해결책\n\n**반복자 패턴**을 사용하면 위와 같은 문제를 해결할 수 있습니다. 반복자 패턴은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션**의 **모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n비유를 통해 설명하자면 웨이트리스에게 메뉴들을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 **쪽지**를 주는 것과 같습니다. 이 쪽지는 각각의 식당에 대한 메뉴판을 순회하는 방법을 캡슐화한 반복자 객체입니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\npublic interface Menu {\n    Iterator createIterator();\n}\n\npublic class PancakeMenuIterator implements Iterator {\n    ArrayList\u003cMenuItem\u003e items;\n    int position = 0;\n\n    public PancakeMenuIterator(ArrayList\u003cMenuItem\u003e items) {\n        this.items = items;\n    }\n\n    public Object next() {\n        MenuItem menuItem = items.get(position);\n        position = position + 1;\n        return menuItem;\n    }\n\n    public boolean hasNext() {\n        return position \u003c items.size();\n    }\n}\n\npublic class PancakeHouseMenu implements Menu {\n    ...\n\n    public Iterator createIterator() {\n        return new PancakeHouseMenuIterator(menuItems);\n    }\n}\n\npublic class Waitress {\n    ...\n\n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n\n        System.out.println(\"아침 메뉴\");\n        printMenu(pancakeIterator);\n        System.out.println(\"점심 메뉴\");\n        printMenu(dinerIterator);\n    }\n\n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = (MenuItem) iterator.next();\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n이제 더 많은 식당들을 추가하더라도 각각의 웨이트리스들에게 새로운 메뉴판을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 쪽지를 읽는 방법을 숙지시키는 것만으로도 교육과정을 줄일 수 있습니다.\n\n---\n\n## 단일 역할 원칙\n\n**단일 역할 원칙**(Single Responsibility Principle)은 **\"클래스는 하나의 변경 이유만을 가져야 한다.\"**라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 **바뀌는 부분**의 **역할**이 **하나**이도록 하자는 원칙입니다.\n\n반복자 패턴을 사용하면 이 원칙을 지킬 수 있습니다. 웨이트리스는 메뉴판을 읽는 방법을 숙지시키는 역할만을 가지고 있고, 반복자 객체는 메뉴판을 순회하는 역할만을 가지고 있습니다. 이렇게 각각의 객체들은 하나의 역할만을 가지고 있기 때문에 단일 역할 원칙을 지킬 수 있습니다.\n\n---\n\n## 결론\n\n**반복자 패턴**은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션의 모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 반복 작업을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n이는 마치 여러 가지 **다른 형태의 메뉴판**을 가지고 있는 **음식점의 메뉴**를 통합할 때, 근무할 웨이트리스에게 각각의 메뉴를 숙지하게 하는 것이 아니라 이를 **통합한 쪽지**를 주는 것과 같습니다. 이를 통해 웨이트리스는 각각의 메뉴를 숙지할 필요 없이 쪽지를 통해 메뉴를 **순회**할 수 있게 됩니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 **컬렉션에서 분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다.**\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","date":"2024-02-23T00:00:00.000Z","categories":"디자인패턴"}},"title":"반복자 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"템플릿 메소드 패턴","category":"디자인패턴"},"next":{"title":"컴포지트 패턴","category":"디자인패턴"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"디자인패턴","title":"반복자 패턴"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>