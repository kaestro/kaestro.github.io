<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">ChatApplication Review(1)</h1><h1 class="project-subtitle">Login API, DBManager, SessionManager</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li>느낀 점</li>
<li>진행 내용</li>
<li>문제 및 해결 방법</li>
</ol>
<hr>

      <h2 id="느낀-점">
        <a name="느낀-점" class="anchor" href="#느낀-점">
          <span class="header-link"></span>
        </a>
        느낀 점
      </h2><p>개발할 때 최초에 생각한 것과 별개로 기능 추가 및 변경이 빈번하게 발생하게 된다. 이 때마다 기존의 코드를 변경하기 용이하게 하기 위한 추상화, business logic 분리, unit test 등의 작업이 필요하다.</p>
<p>원래는 login api를 다루는 서버에서 채팅 역시도 다루게 될 것이라고 생각했다. 그런데 현재 서버 구조는 api를 다루는 형태로 되어 있으니 이를 api 전용 서버로 두고, 채팅을 다루는 서버는 따로 두는 것이 낫지 않을까? 라는 생각이 들었다.</p>
<hr>

      <h2 id="진행-내용">
        <a name="진행-내용" class="anchor" href="#진행-내용">
          <span class="header-link"></span>
        </a>
        진행 내용
      </h2><ul>
<li>프로젝트 개요, 구조, 기술 스택, 개발 환경 등 정리. =&gt; <a target="_self" href="http://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/02/26/Chat-Application-%EA%B0%9C%EC%9A%94.html" title="null">프로젝트 개요</a></li>
<li>메인 서버 구조 설계</li>
<li>User CRUD API 구현</li>
<li>DBManager, SessionManager, PasswordManager internal package 구현</li>
</ul>
<hr>

      <h3 id="메인-서버-구조-설계">
        <a name="메인-서버-구조-설계" class="anchor" href="#메인-서버-구조-설계">
          <span class="header-link"></span>
        </a>
        메인 서버 구조 설계
      </h3><pre><code>myapp
├── api
│   ├── handler
│   │   └── user
│   ├── models
│   └── service
│       └── user
├── internal
│   ├── db
│   ├── session
│   └── password
├── pkg
├── scripts
├── tests
└── main.go
</code></pre>
<ul>
<li>api: API 요청을 처리하는 패키지.<ul>
<li>handler: API 요청을 처리하는 핸들러.</li>
<li>models: API 요청과 응답에 사용되는 모델.</li>
<li>service: API 요청을 처리하는 비즈니스 로직.</li>
<li>user: User API 요청을 처리하는 패키지.</li>
</ul>
</li>
<li>internal: 내부 패키지.<ul>
<li>db: 데이터베이스 관련 패키지.</li>
<li>session: 세션 관리 패키지.</li>
<li>password: 비밀번호 관리 패키지.</li>
</ul>
</li>
<li>pkg: 외부에 공개되는 패키지.(미정)</li>
<li>scripts: 스크립트 파일.<ul>
<li>현재 sql 파일을 실행하는 스크립트만 존재.</li>
</ul>
</li>
<li>tests: 테스트 파일.<ul>
<li>go 서버의 unit test 파일만 존재.</li>
<li>추후 요구하는 규모에 따라 테스트 환경을 구축할 예정.</li>
</ul>
</li>
<li>main.go: 프로그램의 진입점.</li>
</ul>
<hr>

      <h3 id="user-crud-api-구현">
        <a name="user-crud-api-구현" class="anchor" href="#user-crud-api-구현">
          <span class="header-link"></span>
        </a>
        User CRUD API 구현
      </h3><p>: Login, Logout, Signup, deleteAccount API 구현.</p>
<p><strong>구현 내용</strong></p>
<ul>
<li>Login API<ul>
<li>로그인 요청을 처리하는 핸들러 구현.</li>
<li>로그인 성공 시 세션을 생성하고, 세션 ID를 응답.</li>
<li>로그인 실패 시 에러 메시지를 응답.</li>
</ul>
</li>
<li>Logout API<ul>
<li>로그아웃 요청을 처리하는 핸들러 구현.</li>
<li>세션을 삭제.</li>
</ul>
</li>
<li>Signup API<ul>
<li>회원가입 요청을 처리하는 핸들러 구현.</li>
<li>회원가입 실패 시 에러 메시지를 응답.</li>
</ul>
</li>
<li>deleteAccount API<ul>
<li>회원탈퇴 요청을 처리하는 핸들러 구현.</li>
<li>로그인 세션을 통해 회원탈퇴.</li>
<li>회원탈퇴 실패 시 에러 메시지를 응답.</li>
</ul>
</li>
</ul>
<p><a target="_self" href="https://github.com/kaestro/ChatApplication/tree/main/myapp/api" title="null"><strong>구현 상세</strong></a></p>
<p>DBManager와 SessionManager를 통해 유저의 정보를 조회하고, 관리를 위한 로직을 수행.
PasswordManager를 통해 비밀번호를 암호화하여 저장하고, 비밀번호 검증을 수행.</p>
<p>user data model을 구현, 이를 orm 패키지를 사용하여 데이터베이스와 연동한다.</p>
<p>handler에 응답을 처리하는 로직을 구현한 뒤 login 같은 경우는 비즈니스 로직이 변경될 수 있으므로 service 패키지를 통해 자주 변경되는 부분을 분리하였다.</p>
<hr>

      <h3 id="dbmanager,-sessionmanager,-passwordmanager-internal-package-구현">
        <a name="dbmanager,-sessionmanager,-passwordmanager-internal-package-구현" class="anchor" href="#dbmanager,-sessionmanager,-passwordmanager-internal-package-구현">
          <span class="header-link"></span>
        </a>
        DBManager, SessionManager, PasswordManager internal package 구현
      </h3><p>: User CRUD API 구현 과정에서 필요한 패키지 구현</p>
<p><strong>구현 내용</strong></p>
<ul>
<li>DBManager<ul>
<li>데이터베이스와 연동하여 유저 정보를 조회, 추가, 삭제하는 로직을 수행.</li>
<li>orm 패키지를 사용하여 데이터베이스와 연동.</li>
<li>DB 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.</li>
</ul>
</li>
<li>SessionManager<ul>
<li>캐시 서버를 통해 세션을 관리.</li>
<li>세션 생성, 조회, 삭제 로직을 수행.</li>
<li>세션 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.</li>
</ul>
</li>
<li>PasswordManager<ul>
<li>비밀번호를 암호화하여 저장하고, 비밀번호 검증하는 로직을 수행</li>
</ul>
</li>
</ul>
<p><strong>구현 상세</strong></p>
<p><strong>DBManager</strong>는 DB 연결을 gorm을 통해 생성하고, create, read by single field, read all table, update row, delete row 기능을 제공한다.</p>
<p><strong>SessionManager</strong>는 redis를 통해 세션 키 생성, 세션 생성, 조회, 삭제, 정합성 확인 기능을 제공. =&gt; <em>TODO</em> 현재 <u>LoginSessionGenerator.go를 LoginSessionKeyGenerator.go로 파일명 변경한다</u></p>
<p><strong>Store</strong>라는 추상적인 인터페이스를 통해 session을 관리하고, 현재 이를 RedisStore를 통해 구현한다. 이는 추후에 다른 저장소를 사용할 때 변경이 용이하도록 하기 위해서이다.</p>
<p><strong>PasswordManager</strong>는 bcrypt를 통해 비밀번호를 암호화하고, 비밀번호 검증하는 기능을 제공한다.</p>
<hr>

      <h2 id="문제-및-해결-방법">
        <a name="문제-및-해결-방법" class="anchor" href="#문제-및-해결-방법">
          <span class="header-link"></span>
        </a>
        문제 및 해결 방법
      </h2>
      <h3 id="문제상황">
        <a name="문제상황" class="anchor" href="#문제상황">
          <span class="header-link"></span>
        </a>
        문제상황
      </h3><pre><code>1. dbManager가 연결 객체 자체를 반환하고 있었음.
2. 암호화 로직이 api마다 중복되어 있었음.
3. login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.
4. user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.
</code></pre>

      <h3 id="해결-방법">
        <a name="해결-방법" class="anchor" href="#해결-방법">
          <span class="header-link"></span>
        </a>
        해결 방법
      </h3><p><strong>dbManager가 연결 객체 자체를 반환하고 있었음.</strong></p>
<p><strong>문제점</strong>: GetDB() 함수를 통해 db 객체를 반환하고 있었다. 이는 db 객체를 직접 사용하게 되어, dbManager의 로직이 변경될 때마다 모든 곳에서 변경이 필요하게 된다.</p>
<pre><code class="language-go">var (
    once sync.Once

    db *gorm.DB
)

func GetDB() *gorm.DB {
    once.Do(func() {
        var err error
        db, err = gorm.Open(&quot;postgres&quot;, &quot;postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable&quot;)
        if err != nil {
            panic(err)
        }
    })

    return db
}
</code></pre>
<p><strong>해결 방법</strong>: dbManager에서 허용하는 로직만을 public하게 제공하도록 변경.</p>
<pre><code class="language-go">type DBManager struct {
    db *gorm.DB
}

var (
    once sync.Once

    manager *DBManager
)

func GetDBManager() *DBManager {
    once.Do(func() {
        var err error
        db, err := gorm.Open(&quot;postgres&quot;, &quot;postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable&quot;)
        if err != nil {
            panic(err)
        }

        manager = &amp;DBManager{
            db: db,
        }
    })

    return manager
}

func (m *DBManager) Create(value interface{}) error {
    return m.db.Create(value).Error
}
...
</code></pre>
<hr>
<p><strong>암호화 로직이 api마다 중복되어 있었음.</strong></p>
<p><strong>문제점</strong>: 비밀번호 암호화, 비밀번호 검증 로직이 user CRUD api마다 중복되어 있었음.</p>
<pre><code class="language-go">func Signup(c *gin.Context) {
    ...

    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)

    ...
}
</code></pre>
<p><strong>해결 방법</strong>: Password package를 생성하여 비밀번호 암호화, 비밀번호 검증 로직을 분리.</p>
<pre><code class="language-go">package password

import &quot;golang.org/x/crypto/bcrypt&quot;

func HashPassword(password string) (string, error) {
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return &quot;&quot;, err
    }
    return string(hashedPassword), nil
}

func CheckPasswordHash(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
</code></pre>

      <h3 id="login-api는-비즈니스-로직이-계속-변경되고-있어-service-패키지를-통해-분리하고-싶었음.">
        <a name="login-api는-비즈니스-로직이-계속-변경되고-있어-service-패키지를-통해-분리하고-싶었음." class="anchor" href="#login-api는-비즈니스-로직이-계속-변경되고-있어-service-패키지를-통해-분리하고-싶었음.">
          <span class="header-link"></span>
        </a>
        login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.
      </h3><p><strong>문제점</strong>: login api의 비즈니스 로직이 변경될 때마다 handler에서 변경이 필요하게 됨.</p>
<pre><code class="language-go">    db.GetDB().Create(&amp;user)

    // 로그인 정보를 담은 요청 본문을 생성합니다.
    loginInfo := struct {
        EmailAddress string `json:&quot;emailAddress&quot;`
        Password     string `json:&quot;password&quot;`
    }{
        EmailAddress: &quot;test@example.com&quot;,
        Password:     &quot;password&quot;,
    }
    body, _ := json.Marshal(loginInfo)

    // 테스트를 위한 HTTP 요청을 생성합니다.
    req, _ := http.NewRequest(&quot;POST&quot;, &quot;/login&quot;, bytes.NewBuffer(body))
    w := httptest.NewRecorder()

    // Gin 엔진을 생성하고 LogIn 핸들러를 등록합니다.
    r := gin.Default()
    r.POST(&quot;/login&quot;, userAPI.LogIn)

    // HTTP 요청을 처리합니다.
    r.ServeHTTP(w, req)

    // 응답 상태 코드가 200인지 확인합니다.
    assert.Equal(t, http.StatusOK, w.Code)

    // 잘못된 비밀번호로 로그인을 시도합니다.
    loginInfo.Password = &quot;wrongpassword&quot;
    body, _ = json.Marshal(loginInfo)
    req, _ = http.NewRequest(&quot;POST&quot;, &quot;/login&quot;, bytes.NewBuffer(body))
    w = httptest.NewRecorder()

    // HTTP 요청을 처리합니다.
    r.ServeHTTP(w, req)

    // 응답 상태 코드가 401인지 확인합니다.
    assert.Equal(t, http.StatusUnauthorized, w.Code)

    t.Log(&quot;Login test passed!&quot;)
}
</code></pre>
<p>구현 과정에서 DBManager, SessionManager, Password 등의 패키지를 추가하게 됐다. 이 과정에서 추상화, 접근 제어 등의 기능이 도입되었고 이 때마다 handler에서 변경이 필요하게 됨.</p>
<p>이와 관련한 해결 방법으로 service 패키지를 통해 비즈니스 로직을 분리하고자 함.</p>
<pre><code class="language-go">var (
    ErrAlreadyLoggedIn            = errors.New(&quot;user is already logged in&quot;)
    ErrUserNotFound               = errors.New(&quot;failed to find user&quot;)
    ErrInvalidPassword            = errors.New(&quot;invalid password&quot;)
    ErrFailedToGenerateSessionKey = errors.New(&quot;failed to generate session key&quot;)
    ErrFailedToSaveSessionKey     = errors.New(&quot;failed to save session key&quot;)
)

type LoginService struct {
    dbManager      *db.DBManager
    sessionManager *session.SessionManager
}

func NewLoginService(dbManager *db.DBManager, sessionManager *session.SessionManager) *LoginService {
    return &amp;LoginService{
        dbManager:      dbManager,
        sessionManager: sessionManager,
    }
}

func (s *LoginService) LogIn(userEmailAddress, userPassword, userSessionKey string) (string, error) {
    // 세션 키가 sessionManager에 저장되어 있는지 확인합니다.
    if s.sessionManager.IsSessionValid(userSessionKey, userEmailAddress) {
        return &quot;&quot;, ErrAlreadyLoggedIn
    }

    // 사용자 정보를 담을 User 구조체를 선언합니다.
    var user models.User

    // 사용자가 제공한 이메일 주소로 데이터베이스에서 사용자를 찾습니다.
    err := s.dbManager.Read(&amp;user, &quot;email_address&quot;, userEmailAddress)
    if err != nil {
        return &quot;&quot;, ErrUserNotFound
    }

    // 사용자가 제공한 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교합니다.
    if !password.CheckPasswordHash(userPassword, user.Password) {
        return &quot;&quot;, ErrInvalidPassword
    }

    // 세션 키를 생성합니다.
    sessionKey, err := session.GenerateRandomSessionKey()
    if err != nil {
        return &quot;&quot;, ErrFailedToGenerateSessionKey
    }

    // 세션 키를 캐시에 저장합니다.
    err = s.sessionManager.SetSession(sessionKey, user.EmailAddress)
    if err != nil {
        return &quot;&quot;, ErrFailedToSaveSessionKey
    }

    return sessionKey, nil
}
</code></pre>
<hr>

      <h3 id="user-crud-api를-매-빌드시마다-unit-test를-통해-검증하고-싶었음.">
        <a name="user-crud-api를-매-빌드시마다-unit-test를-통해-검증하고-싶었음." class="anchor" href="#user-crud-api를-매-빌드시마다-unit-test를-통해-검증하고-싶었음.">
          <span class="header-link"></span>
        </a>
        user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.
      </h3><p><strong>문제점</strong>: user CRUD api를 구현 때마다 postman을 통해 수동으로 테스트를 진행하고 있었음.</p>
<p><strong>해결 방법</strong>: user CRUD api를 매 빌드시마다 검증할 unit test를 작성.</p>
<pre><code class="language-go">func TestUserHandler(t *testing.T) {
    // 테스트를 위한 사용자 정보를 생성합니다.
    sampleUser := models.User{
        UserName:     &quot;testuser&quot;,
        EmailAddress: &quot;test@example.com&quot;,
        Password:     &quot;password&quot;,
    }

    // Gin 엔진을 생성하고 핸들러들을 등록합니다.
    ginEngine := gin.Default()
    ginEngine.POST(&quot;/login&quot;, userAPI.LogIn)
    ginEngine.POST(&quot;/logout&quot;, userAPI.LogOut)
    ginEngine.POST(&quot;/signup&quot;, userAPI.SignUp)
    ginEngine.POST(&quot;/deleteAccount&quot;, userAPI.DeleteAccount)

    // signup HTTP 요청을 처리합니다.
    body, _ := json.Marshal(sampleUser)
    httpRequest, _ := http.NewRequest(&quot;POST&quot;, &quot;/signup&quot;, bytes.NewBuffer(body))
    responseRecorder := httptest.NewRecorder()
    ginEngine.ServeHTTP(responseRecorder, httpRequest)

    t.Log(responseRecorder.Body.String())

    // 응답 상태 코드가 201인지 확인합니다.
    if assert.Equal(t, http.StatusCreated, responseRecorder.Code) {
        t.Log(&quot;SignUp 테스트 통과&quot;)
    }

    // login HTTP 요청을 처리합니다.
    loginInfo := struct {
        EmailAddress string `json:&quot;emailAddress&quot;`
        Password     string `json:&quot;password&quot;`
    }{
        EmailAddress: sampleUser.EmailAddress,
        Password:     sampleUser.Password,
    }
    body, _ = json.Marshal(loginInfo)
    httpRequest, _ = http.NewRequest(&quot;POST&quot;, &quot;/login&quot;, bytes.NewBuffer(body))
    responseRecorder = httptest.NewRecorder()
    ginEngine.ServeHTTP(responseRecorder, httpRequest)

    // 응답 상태 코드가 200인지 확인합니다.
    if assert.Equal(t, http.StatusOK, responseRecorder.Code) {
        t.Log(&quot;LogIn 테스트 통과&quot;)
    }

    // logout HTTP 요청을 처리합니다.
    httpRequest, _ = http.NewRequest(&quot;POST&quot;, &quot;/logout&quot;, nil)
    httpRequest.Header.Set(&quot;Session-Key&quot;, responseRecorder.Body.String())
    responseRecorder = httptest.NewRecorder()
    ginEngine.ServeHTTP(responseRecorder, httpRequest)

    // 응답 상태 코드가 200인지 확인합니다.
    if assert.Equal(t, http.StatusOK, responseRecorder.Code) {
        t.Log(&quot;LogOut 테스트 통과&quot;)
    }

    // deleteAccount HTTP 요청을 처리합니다.
    body, _ = json.Marshal(loginInfo)
    httpRequest, _ = http.NewRequest(&quot;POST&quot;, &quot;/login&quot;, bytes.NewBuffer(body))
    responseRecorder = httptest.NewRecorder()
    ginEngine.ServeHTTP(responseRecorder, httpRequest)

    // 응답 상태 코드가 200인지 확인합니다.
    if assert.Equal(t, http.StatusOK, responseRecorder.Code) {
        t.Log(&quot;deleteAccount 전 LogIn 테스트 통과&quot;)
    }

    t.Log(&quot;Session-Key:&quot; + responseRecorder.Body.String())
    var responseBody map[string]string
    json.Unmarshal(responseRecorder.Body.Bytes(), &amp;responseBody)
    sessionKey := responseBody[&quot;sessionKey&quot;]

    httpRequest, _ = http.NewRequest(&quot;POST&quot;, &quot;/deleteAccount&quot;, nil)
    httpRequest.Header.Set(&quot;Session-Key&quot;, sessionKey)
    responseRecorder = httptest.NewRecorder()
    ginEngine.ServeHTTP(responseRecorder, httpRequest)

    // 응답 상태 코드가 200인지 확인합니다.
    if assert.Equal(t, http.StatusOK, responseRecorder.Code) {
        t.Log(&quot;deleteAccount 테스트 통과&quot;)
    }
}
</code></pre>
<hr>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/개발일지/ChatApplication 개요">이전 포스트: <!-- -->ChatApplication 개요</a></div><div style="text-align:right"><a href="/개발일지/ChatApplication Review(2)">다음 포스트: <!-- -->ChatApplication Review(2)</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-02-26-Chat Application review(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-26-Chat Application review(1).md","category":"개발일지","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n개발할 때 최초에 생각한 것과 별개로 기능 추가 및 변경이 빈번하게 발생하게 된다. 이 때마다 기존의 코드를 변경하기 용이하게 하기 위한 추상화, business logic 분리, unit test 등의 작업이 필요하다.\n\n원래는 login api를 다루는 서버에서 채팅 역시도 다루게 될 것이라고 생각했다. 그런데 현재 서버 구조는 api를 다루는 형태로 되어 있으니 이를 api 전용 서버로 두고, 채팅을 다루는 서버는 따로 두는 것이 낫지 않을까? 라는 생각이 들었다.\n\n\n---\n\n\n## 진행 내용\n\n* 프로젝트 개요, 구조, 기술 스택, 개발 환경 등 정리. =\u003e [프로젝트 개요](http://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/02/26/Chat-Application-%EA%B0%9C%EC%9A%94.html)\n* 메인 서버 구조 설계\n* User CRUD API 구현\n* DBManager, SessionManager, PasswordManager internal package 구현\n\n---\n\n### 메인 서버 구조 설계\n\n```\nmyapp\n├── api\n│   ├── handler\n│   │   └── user\n│   ├── models\n│   └── service\n│       └── user\n├── internal\n│   ├── db\n│   ├── session\n│   └── password\n├── pkg\n├── scripts\n├── tests\n└── main.go\n```\n\n* api: API 요청을 처리하는 패키지.\n  * handler: API 요청을 처리하는 핸들러.\n  * models: API 요청과 응답에 사용되는 모델.\n  * service: API 요청을 처리하는 비즈니스 로직.\n  * user: User API 요청을 처리하는 패키지.\n* internal: 내부 패키지.\n  * db: 데이터베이스 관련 패키지.\n  * session: 세션 관리 패키지.\n  * password: 비밀번호 관리 패키지.\n* pkg: 외부에 공개되는 패키지.(미정)\n* scripts: 스크립트 파일.\n  * 현재 sql 파일을 실행하는 스크립트만 존재.\n* tests: 테스트 파일.\n  * go 서버의 unit test 파일만 존재.\n  * 추후 요구하는 규모에 따라 테스트 환경을 구축할 예정.\n* main.go: 프로그램의 진입점.\n\n---\n\n### User CRUD API 구현\n: Login, Logout, Signup, deleteAccount API 구현.\n\n**구현 내용**\n* Login API\n  * 로그인 요청을 처리하는 핸들러 구현.\n  * 로그인 성공 시 세션을 생성하고, 세션 ID를 응답.\n  * 로그인 실패 시 에러 메시지를 응답.\n* Logout API\n  * 로그아웃 요청을 처리하는 핸들러 구현.\n  * 세션을 삭제.\n* Signup API\n  * 회원가입 요청을 처리하는 핸들러 구현.\n  * 회원가입 실패 시 에러 메시지를 응답.\n* deleteAccount API\n  * 회원탈퇴 요청을 처리하는 핸들러 구현.\n  * 로그인 세션을 통해 회원탈퇴.\n  * 회원탈퇴 실패 시 에러 메시지를 응답.\n\n[**구현 상세**](https://github.com/kaestro/ChatApplication/tree/main/myapp/api)\n\nDBManager와 SessionManager를 통해 유저의 정보를 조회하고, 관리를 위한 로직을 수행.\nPasswordManager를 통해 비밀번호를 암호화하여 저장하고, 비밀번호 검증을 수행.\n\nuser data model을 구현, 이를 orm 패키지를 사용하여 데이터베이스와 연동한다.\n\nhandler에 응답을 처리하는 로직을 구현한 뒤 login 같은 경우는 비즈니스 로직이 변경될 수 있으므로 service 패키지를 통해 자주 변경되는 부분을 분리하였다.\n\n---\n\n### DBManager, SessionManager, PasswordManager internal package 구현\n: User CRUD API 구현 과정에서 필요한 패키지 구현\n\n**구현 내용**\n\n* DBManager\n  * 데이터베이스와 연동하여 유저 정보를 조회, 추가, 삭제하는 로직을 수행.\n  * orm 패키지를 사용하여 데이터베이스와 연동.\n  * DB 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* SessionManager\n  * 캐시 서버를 통해 세션을 관리.\n  * 세션 생성, 조회, 삭제 로직을 수행.\n  * 세션 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* PasswordManager\n  * 비밀번호를 암호화하여 저장하고, 비밀번호 검증하는 로직을 수행\n  \n**구현 상세**\n\n**DBManager**는 DB 연결을 gorm을 통해 생성하고, create, read by single field, read all table, update row, delete row 기능을 제공한다.\n\n**SessionManager**는 redis를 통해 세션 키 생성, 세션 생성, 조회, 삭제, 정합성 확인 기능을 제공. =\u003e *TODO* 현재 \u003cu\u003eLoginSessionGenerator.go를 LoginSessionKeyGenerator.go로 파일명 변경한다\u003c/u\u003e\n\n**Store**라는 추상적인 인터페이스를 통해 session을 관리하고, 현재 이를 RedisStore를 통해 구현한다. 이는 추후에 다른 저장소를 사용할 때 변경이 용이하도록 하기 위해서이다.\n\n**PasswordManager**는 bcrypt를 통해 비밀번호를 암호화하고, 비밀번호 검증하는 기능을 제공한다.\n\n---\n\n## 문제 및 해결 방법\n\n### 문제상황\n\n```\n1. dbManager가 연결 객체 자체를 반환하고 있었음.\n2. 암호화 로직이 api마다 중복되어 있었음.\n3. login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n4. user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n```\n\n\n### 해결 방법\n\n**dbManager가 연결 객체 자체를 반환하고 있었음.**\n\n**문제점**: GetDB() 함수를 통해 db 객체를 반환하고 있었다. 이는 db 객체를 직접 사용하게 되어, dbManager의 로직이 변경될 때마다 모든 곳에서 변경이 필요하게 된다.\n\n```go\nvar (\n\tonce sync.Once\n\n\tdb *gorm.DB\n)\n\nfunc GetDB() *gorm.DB {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err = gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn db\n}\n```\n\n**해결 방법**: dbManager에서 허용하는 로직만을 public하게 제공하도록 변경.\n\n```go\ntype DBManager struct {\n\tdb *gorm.DB\n}\n\nvar (\n\tonce sync.Once\n\n\tmanager *DBManager\n)\n\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmanager = \u0026DBManager{\n\t\t\tdb: db,\n\t\t}\n\t})\n\n\treturn manager\n}\n\nfunc (m *DBManager) Create(value interface{}) error {\n    return m.db.Create(value).Error\n}\n...\n```\n\n\n---\n\n\n**암호화 로직이 api마다 중복되어 있었음.**\n\n**문제점**: 비밀번호 암호화, 비밀번호 검증 로직이 user CRUD api마다 중복되어 있었음.\n\n```go\nfunc Signup(c *gin.Context) {\n    ...\n\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\n    ...\n}\n```\n\n**해결 방법**: Password package를 생성하여 비밀번호 암호화, 비밀번호 검증 로직을 분리.\n\n```go\npackage password\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(hashedPassword), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n```\n\n### login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n\n**문제점**: login api의 비즈니스 로직이 변경될 때마다 handler에서 변경이 필요하게 됨.\n\n```go\n\tdb.GetDB().Create(\u0026user)\n\n\t// 로그인 정보를 담은 요청 본문을 생성합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\tbody, _ := json.Marshal(loginInfo)\n\n\t// 테스트를 위한 HTTP 요청을 생성합니다.\n\treq, _ := http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw := httptest.NewRecorder()\n\n\t// Gin 엔진을 생성하고 LogIn 핸들러를 등록합니다.\n\tr := gin.Default()\n\tr.POST(\"/login\", userAPI.LogIn)\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\t// 잘못된 비밀번호로 로그인을 시도합니다.\n\tloginInfo.Password = \"wrongpassword\"\n\tbody, _ = json.Marshal(loginInfo)\n\treq, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw = httptest.NewRecorder()\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 401인지 확인합니다.\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\n\tt.Log(\"Login test passed!\")\n}\n```\n\n구현 과정에서 DBManager, SessionManager, Password 등의 패키지를 추가하게 됐다. 이 과정에서 추상화, 접근 제어 등의 기능이 도입되었고 이 때마다 handler에서 변경이 필요하게 됨.\n\n이와 관련한 해결 방법으로 service 패키지를 통해 비즈니스 로직을 분리하고자 함.\n\n```go\nvar (\n\tErrAlreadyLoggedIn            = errors.New(\"user is already logged in\")\n\tErrUserNotFound               = errors.New(\"failed to find user\")\n\tErrInvalidPassword            = errors.New(\"invalid password\")\n\tErrFailedToGenerateSessionKey = errors.New(\"failed to generate session key\")\n\tErrFailedToSaveSessionKey     = errors.New(\"failed to save session key\")\n)\n\ntype LoginService struct {\n\tdbManager      *db.DBManager\n\tsessionManager *session.SessionManager\n}\n\nfunc NewLoginService(dbManager *db.DBManager, sessionManager *session.SessionManager) *LoginService {\n\treturn \u0026LoginService{\n\t\tdbManager:      dbManager,\n\t\tsessionManager: sessionManager,\n\t}\n}\n\nfunc (s *LoginService) LogIn(userEmailAddress, userPassword, userSessionKey string) (string, error) {\n\t// 세션 키가 sessionManager에 저장되어 있는지 확인합니다.\n\tif s.sessionManager.IsSessionValid(userSessionKey, userEmailAddress) {\n\t\treturn \"\", ErrAlreadyLoggedIn\n\t}\n\n\t// 사용자 정보를 담을 User 구조체를 선언합니다.\n\tvar user models.User\n\n\t// 사용자가 제공한 이메일 주소로 데이터베이스에서 사용자를 찾습니다.\n\terr := s.dbManager.Read(\u0026user, \"email_address\", userEmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\t// 사용자가 제공한 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교합니다.\n\tif !password.CheckPasswordHash(userPassword, user.Password) {\n\t\treturn \"\", ErrInvalidPassword\n\t}\n\n\t// 세션 키를 생성합니다.\n\tsessionKey, err := session.GenerateRandomSessionKey()\n\tif err != nil {\n\t\treturn \"\", ErrFailedToGenerateSessionKey\n\t}\n\n\t// 세션 키를 캐시에 저장합니다.\n\terr = s.sessionManager.SetSession(sessionKey, user.EmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrFailedToSaveSessionKey\n\t}\n\n\treturn sessionKey, nil\n}\n```\n\n---\n\n### user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n\n**문제점**: user CRUD api를 구현 때마다 postman을 통해 수동으로 테스트를 진행하고 있었음.\n\n**해결 방법**: user CRUD api를 매 빌드시마다 검증할 unit test를 작성.\n\n```go\nfunc TestUserHandler(t *testing.T) {\n\t// 테스트를 위한 사용자 정보를 생성합니다.\n\tsampleUser := models.User{\n\t\tUserName:     \"testuser\",\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\n\t// Gin 엔진을 생성하고 핸들러들을 등록합니다.\n\tginEngine := gin.Default()\n\tginEngine.POST(\"/login\", userAPI.LogIn)\n\tginEngine.POST(\"/logout\", userAPI.LogOut)\n\tginEngine.POST(\"/signup\", userAPI.SignUp)\n\tginEngine.POST(\"/deleteAccount\", userAPI.DeleteAccount)\n\n\t// signup HTTP 요청을 처리합니다.\n\tbody, _ := json.Marshal(sampleUser)\n\thttpRequest, _ := http.NewRequest(\"POST\", \"/signup\", bytes.NewBuffer(body))\n\tresponseRecorder := httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\tt.Log(responseRecorder.Body.String())\n\n\t// 응답 상태 코드가 201인지 확인합니다.\n\tif assert.Equal(t, http.StatusCreated, responseRecorder.Code) {\n\t\tt.Log(\"SignUp 테스트 통과\")\n\t}\n\n\t// login HTTP 요청을 처리합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: sampleUser.EmailAddress,\n\t\tPassword:     sampleUser.Password,\n\t}\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogIn 테스트 통과\")\n\t}\n\n\t// logout HTTP 요청을 처리합니다.\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/logout\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", responseRecorder.Body.String())\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogOut 테스트 통과\")\n\t}\n\n\t// deleteAccount HTTP 요청을 처리합니다.\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 전 LogIn 테스트 통과\")\n\t}\n\n\tt.Log(\"Session-Key:\" + responseRecorder.Body.String())\n\tvar responseBody map[string]string\n\tjson.Unmarshal(responseRecorder.Body.Bytes(), \u0026responseBody)\n\tsessionKey := responseBody[\"sessionKey\"]\n\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/deleteAccount\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", sessionKey)\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 테스트 통과\")\n\t}\n}\n```\n\n---","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":1,"classes":"wide","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","date":"2024-02-26T00:00:00.000Z","categories":"개발일지"}},"title":"ChatApplication Review(1)","category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"ChatApplication 개요","category":"개발일지"},"next":{"title":"ChatApplication Review(2)","category":"개발일지"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"개발일지","title":"ChatApplication Review(1)"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>