<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">ChatApplication Review(7)</h1><h1 class="project-subtitle">사양이 불명확할 때의 구현, 추상화를 통한 역할 분리</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ul>
<li><a target="_self" href="#목차" title="null">목차</a></li>
<li><a target="_self" href="#느낀-점" title="null">느낀 점</a></li>
<li><a target="_self" href="#진행-내용" title="null">진행 내용</a></li>
<li><a target="_self" href="#진행-과정" title="null">진행 과정</a><ul>
<li><a target="_self" href="#chat-모듈-구현" title="null">Chat 모듈 구현</a><ul>
<li><a target="_self" href="#모듈-사양이-불명확할-때의-구현" title="null">모듈 사양이 불명확할 때의 구현</a><ul>
<li><a target="_self" href="#clientmanagergo" title="null">clientManager.go</a></li>
</ul>
</li>
<li><a target="_self" href="#추상화를-통해-모듈의-작업-단위를-세부적으로-분리" title="null">추상화를 통해 모듈의 작업 단위를 세부적으로 분리</a><ul>
<li><a target="_self" href="#roomgo" title="null">room.go</a></li>
<li><a target="_self" href="#roommanagergo" title="null">roomManager.go</a></li>
</ul>
</li>
<li><a target="_self" href="#이후-진행-방향" title="null">이후 진행 방향</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>

      <h2 id="느낀-점">
        <a name="느낀-점" class="anchor" href="#느낀-점">
          <span class="header-link"></span>
        </a>
        느낀 점
      </h2><ol>
<li>협업에서 모듈의 사양 합의가 돼있지 않을 때, 이에 대응하기 용이한 유연한 코드를 작성하는 방법</li>
<li>MVP 내에서도 더 세부 단계에서 어디서부터 구현을 시작해야 하는지에 대한 고민</li>
<li>추상화를 통해 모듈 내부의 역할을 세부적으로 분리하는 방법</li>
<li>Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 검토의 필요성</li>
</ol>
<hr>

      <h2 id="진행-내용">
        <a name="진행-내용" class="anchor" href="#진행-내용">
          <span class="header-link"></span>
        </a>
        진행 내용
      </h2><ul>
<li>Chat 모듈 구현</li>
</ul>
<hr>

      <h2 id="진행-과정">
        <a name="진행-과정" class="anchor" href="#진행-과정">
          <span class="header-link"></span>
        </a>
        진행 과정
      </h2>
      <h3 id="chat-모듈-구현">
        <a name="chat-모듈-구현" class="anchor" href="#chat-모듈-구현">
          <span class="header-link"></span>
        </a>
        Chat 모듈 구현
      </h3>
      <h4 id="모듈-사양이-불명확할-때의-구현">
        <a name="모듈-사양이-불명확할-때의-구현" class="anchor" href="#모듈-사양이-불명확할-때의-구현">
          <span class="header-link"></span>
        </a>
        모듈 사양이 불명확할 때의 구현
      </h4><ul>
<li><p><strong>문제</strong></p>
<ul>
<li>다른 팀원과 모듈의 사양에 대해 합의가 돼있지 않다</li>
<li>내가 작성한 chat 모듈을 다른 팀원이 사용할 때 어떤 형태로 부를 것인지 불명확하다</li>
<li>내가 chat 모듈에서 이용해야하는 다른 모듈의 형태가 불명확하다</li>
</ul>
</li>
<li><p><strong>해결</strong></p>
<ul>
<li>코드를 가능한 작은 단위로 나누어 유연한 변경이 가능하도록 한다</li>
<li>함수에서 파라미터로 받는 값을 특정한 형태로 제한하고, 이를 활용하는 상위 모듈을 작성한다</li>
<li>상위 모듈에서는 추후에 다른 모듈에서 이를 호출할 때 필요한 값을 제한한다.</li>
</ul>
</li>
</ul>

      <h5 id="clientmanager.go">
        <a name="clientmanager.go" class="anchor" href="#clientmanager.go">
          <span class="header-link"></span>
        </a>
        clientManager.go
      </h5><pre><code class="language-go">func (cm *ClientManager) CheckClient(sessionID string) bool {
  _, ok := cm.clients[sessionID]
  return ok
}

func (cm *ClientManager) GetClient(sessionID string) *Client {
  if !cm.CheckClient(sessionID) {
    fmt.Println(&quot;Client with sessionID&quot;, sessionID, &quot;does not exist&quot;)
    return nil
  }

  return cm.clients[sessionID]
}
</code></pre>

      <h4 id="추상화를-통해-모듈의-작업-단위를-세부적으로-분리">
        <a name="추상화를-통해-모듈의-작업-단위를-세부적으로-분리" class="anchor" href="#추상화를-통해-모듈의-작업-단위를-세부적으로-분리">
          <span class="header-link"></span>
        </a>
        추상화를 통해 모듈의 작업 단위를 세부적으로 분리
      </h4><ul>
<li><p><strong>문제</strong></p>
<ul>
<li>단일 클래스들이 하는 역할이 너무 많아 코드가 복잡해졌다.<ul>
<li>기존에는 client, room, socket이라는 세 개의 클래스를 통해 구현을 작업하려 했음.</li>
</ul>
</li>
<li>각각의 클래스가 하는 일들이 무엇인지 구분하기 어려웠다.<ul>
<li>room, client는 방에 client를 추가하고 이들을 관리하는 작업들을 동시에 했다.</li>
</ul>
</li>
<li>클래스 간에 하는 영역이 겹치는 부분이 많아 코드 중복이 발생했다.</li>
</ul>
</li>
<li><p><strong>해결</strong></p>
<ul>
<li>클래스가 할 일을 더 작은 단위로 나누어 추상화한다.<ul>
<li><a target="_self" href="https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/room.go" title="null">room</a><ul>
<li>방을 crud하는 메소드를 제공한다.</li>
<li>방에 들어온 client의 crud를 관리한다.</li>
<li>방에 들어온 client들 간의 메시지를 주고 받는 작업을 한다.</li>
</ul>
</li>
</ul>
</li>
<li>이 과정에서 사라진 이들을 관리하는 작업을 Manager 클래스로 분리한다.<ul>
<li>ClientManager, RoomManager, ChatManager 등으로 분리한다.</li>
<li><a target="_self" href="https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/chatManager.go" title="null">ChatManager</a>는 최상위 클래스로, RoomManager, ClientManager를 통해 채팅 전반을 관리한다.</li>
</ul>
</li>
</ul>
</li>
</ul>

      <h5 id="room.go">
        <a name="room.go" class="anchor" href="#room.go">
          <span class="header-link"></span>
        </a>
        room.go
      </h5><pre><code class="language-go">func NewRoom() *Room {
  room := &amp;Room{
    client_chan: make(map[*Client]*websocket.Conn),
    broadcast:   make(chan []byte),
    register:    make(chan *ClientConn),
    unregister:  make(chan *ClientConn),
  }

  go room.run()

  return room
}
</code></pre>

      <h5 id="roommanager.go">
        <a name="roommanager.go" class="anchor" href="#roommanager.go">
          <span class="header-link"></span>
        </a>
        roomManager.go
      </h5><pre><code class="language-go">type RoomManager struct {
  rooms map[string]*Room
}

func GetRoomManager() *RoomManager {
  roomOnce.Do(func() {
    roomManager = &amp;RoomManager{
      rooms: make(map[string]*Room),
    }
  })

  return roomManager
}

func (rm *RoomManager) CheckRoom(roomID string) bool {
  _, ok := rm.rooms[roomID]
  return ok
}

func (rm *RoomManager) GetRoom(roomID string) *Room {
  if !rm.CheckRoom(roomID) {
    fmt.Println(&quot;Room with roomID&quot;, roomID, &quot;does not exist&quot;)
    return nil
  }

  return rm.rooms[roomID]
}
</code></pre>

      <h4 id="이후-진행-방향">
        <a name="이후-진행-방향" class="anchor" href="#이후-진행-방향">
          <span class="header-link"></span>
        </a>
        이후 진행 방향
      </h4><ol>
<li>현재 작성중인 포멧의 추가 구현</li>
<li>Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 필요성 검토</li>
</ol>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/개발일지/ChatApplication Review(6)">이전 포스트: <!-- -->ChatApplication Review(6)</a></div><div style="text-align:right"><a href="/개발일지/ChatApplication Review(8)">다음 포스트: <!-- -->ChatApplication Review(8)</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-03-29-Chat Application review(7)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-29-Chat Application review(7).md","category":"개발일지","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","content":"\n## 목차\n\n- [목차](#목차)\n- [느낀 점](#느낀-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [Chat 모듈 구현](#chat-모듈-구현)\n    - [모듈 사양이 불명확할 때의 구현](#모듈-사양이-불명확할-때의-구현)\n      - [clientManager.go](#clientmanagergo)\n    - [추상화를 통해 모듈의 작업 단위를 세부적으로 분리](#추상화를-통해-모듈의-작업-단위를-세부적으로-분리)\n      - [room.go](#roomgo)\n      - [roomManager.go](#roommanagergo)\n    - [이후 진행 방향](#이후-진행-방향)\n\n---\n\n## 느낀 점\n\n1. 협업에서 모듈의 사양 합의가 돼있지 않을 때, 이에 대응하기 용이한 유연한 코드를 작성하는 방법\n2. MVP 내에서도 더 세부 단계에서 어디서부터 구현을 시작해야 하는지에 대한 고민\n3. 추상화를 통해 모듈 내부의 역할을 세부적으로 분리하는 방법\n4. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 검토의 필요성\n\n---\n\n## 진행 내용\n\n- Chat 모듈 구현\n\n---\n\n## 진행 과정\n\n### Chat 모듈 구현\n\n#### 모듈 사양이 불명확할 때의 구현\n\n- **문제**\n  - 다른 팀원과 모듈의 사양에 대해 합의가 돼있지 않다\n  - 내가 작성한 chat 모듈을 다른 팀원이 사용할 때 어떤 형태로 부를 것인지 불명확하다\n  - 내가 chat 모듈에서 이용해야하는 다른 모듈의 형태가 불명확하다\n\n- **해결**\n  - 코드를 가능한 작은 단위로 나누어 유연한 변경이 가능하도록 한다\n  - 함수에서 파라미터로 받는 값을 특정한 형태로 제한하고, 이를 활용하는 상위 모듈을 작성한다\n  - 상위 모듈에서는 추후에 다른 모듈에서 이를 호출할 때 필요한 값을 제한한다.\n\n##### clientManager.go\n\n```go\nfunc (cm *ClientManager) CheckClient(sessionID string) bool {\n  _, ok := cm.clients[sessionID]\n  return ok\n}\n\nfunc (cm *ClientManager) GetClient(sessionID string) *Client {\n  if !cm.CheckClient(sessionID) {\n    fmt.Println(\"Client with sessionID\", sessionID, \"does not exist\")\n    return nil\n  }\n\n  return cm.clients[sessionID]\n}\n```\n\n#### 추상화를 통해 모듈의 작업 단위를 세부적으로 분리\n\n- **문제**\n  - 단일 클래스들이 하는 역할이 너무 많아 코드가 복잡해졌다.\n    - 기존에는 client, room, socket이라는 세 개의 클래스를 통해 구현을 작업하려 했음.\n  - 각각의 클래스가 하는 일들이 무엇인지 구분하기 어려웠다.\n    - room, client는 방에 client를 추가하고 이들을 관리하는 작업들을 동시에 했다.\n  - 클래스 간에 하는 영역이 겹치는 부분이 많아 코드 중복이 발생했다.\n\n- **해결**\n  - 클래스가 할 일을 더 작은 단위로 나누어 추상화한다.\n    - [room](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/room.go)\n      - 방을 crud하는 메소드를 제공한다.\n      - 방에 들어온 client의 crud를 관리한다.\n      - 방에 들어온 client들 간의 메시지를 주고 받는 작업을 한다.\n  - 이 과정에서 사라진 이들을 관리하는 작업을 Manager 클래스로 분리한다.\n    - ClientManager, RoomManager, ChatManager 등으로 분리한다.\n    - [ChatManager](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/chatManager.go)는 최상위 클래스로, RoomManager, ClientManager를 통해 채팅 전반을 관리한다.\n\n##### room.go\n\n```go\nfunc NewRoom() *Room {\n  room := \u0026Room{\n    client_chan: make(map[*Client]*websocket.Conn),\n    broadcast:   make(chan []byte),\n    register:    make(chan *ClientConn),\n    unregister:  make(chan *ClientConn),\n  }\n\n  go room.run()\n\n  return room\n}\n```\n\n##### roomManager.go\n\n```go\ntype RoomManager struct {\n  rooms map[string]*Room\n}\n\nfunc GetRoomManager() *RoomManager {\n  roomOnce.Do(func() {\n    roomManager = \u0026RoomManager{\n      rooms: make(map[string]*Room),\n    }\n  })\n\n  return roomManager\n}\n\nfunc (rm *RoomManager) CheckRoom(roomID string) bool {\n  _, ok := rm.rooms[roomID]\n  return ok\n}\n\nfunc (rm *RoomManager) GetRoom(roomID string) *Room {\n  if !rm.CheckRoom(roomID) {\n    fmt.Println(\"Room with roomID\", roomID, \"does not exist\")\n    return nil\n  }\n\n  return rm.rooms[roomID]\n}\n```\n\n#### 이후 진행 방향\n\n1. 현재 작성중인 포멧의 추가 구현\n2. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 필요성 검토\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":7,"classes":"wide","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","date":"2024-04-09T00:00:00.000Z","categories":"개발일지"}},"title":"ChatApplication Review(7)","category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"ChatApplication Review(6)","category":"개발일지"},"next":{"title":"ChatApplication Review(8)","category":"개발일지"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"개발일지","title":"ChatApplication Review(7)"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>