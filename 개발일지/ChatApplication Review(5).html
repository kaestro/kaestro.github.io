<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_buildManifest.js" defer=""></script><script src="/_next/static/4n-fl_RCrq53WZFFUxusB/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">ChatApplication Review(5)</h1><h1 class="project-subtitle">기술 스택에 대한 점검</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div>
      <h2 id="목차">
        <a name="목차" class="anchor" href="#목차">
          <span class="header-link"></span>
        </a>
        목차
      </h2><ol>
<li><strong>느낀 점</strong></li>
<li><strong>진행 내용</strong></li>
<li><strong>문제 및 해결 방법</strong></li>
</ol>
<hr>

      <h2 id="느낀-점">
        <a name="느낀-점" class="anchor" href="#느낀-점">
          <span class="header-link"></span>
        </a>
        느낀 점
      </h2><ul>
<li><strong>기술 스택</strong>을 선택할 때, <strong>명확한 기준</strong>을 통한 비교를 할 필요성을 체감</li>
<li>당장 수요에 맞는 <strong>가벼운 기술</strong>을 선택하되, 규모가 커질 것을 대비하여 <strong>확장성</strong>을 고려해야 함.</li>
<li><strong>MVP</strong>(Minimum Viable Product)를 정의 내리고 이를 기준으로 기존 <strong>기술 스택 선택</strong>이 <strong>타당성</strong>을 검토해야 함.</li>
<li><strong>결론</strong>:<ul>
<li><strong>MVP</strong>: postgresql, redis, rabbitMQ, golang - gin</li>
<li><strong>확장</strong>: mysql, memcached, kafka, mongodb</li>
</ul>
</li>
</ul>
<hr>

      <h2 id="진행-내용">
        <a name="진행-내용" class="anchor" href="#진행-내용">
          <span class="header-link"></span>
        </a>
        진행 내용
      </h2><ul>
<li><strong>설계도</strong>에서 서비스별 사용하기로 한 <strong>기술스택</strong>에 대한 대안 검토<ul>
<li><a target="_self" href="https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84" title="null"><strong>설계도 링크</strong></a></li>
</ul>
</li>
</ul>
<hr>

      <h2 id="문제-및-해결-방법">
        <a name="문제-및-해결-방법" class="anchor" href="#문제-및-해결-방법">
          <span class="header-link"></span>
        </a>
        문제 및 해결 방법
      </h2>
      <h3 id="[1]-<strong>기술-스택</strong>-선택에-대한-명백한-<strong>근거</strong>-부족">
        <a name="[1]-<strong>기술-스택</strong>-선택에-대한-명백한-<strong>근거</strong>-부족" class="anchor" href="#[1]-<strong>기술-스택</strong>-선택에-대한-명백한-<strong>근거</strong>-부족">
          <span class="header-link"></span>
        </a>
        [1] <strong>기술 스택</strong> 선택에 대한 명백한 <strong>근거</strong> 부족
      </h3><ul>
<li>기술 스택 선택에 대한 <strong>명백한 근거</strong>가 부족.</li>
<li>현재 기술 스택의 <strong>장단점</strong>을 명확히 파악하지 못하고 있음.</li>
<li>단순히 <strong>유명하고 핫하기 때문</strong>에 선택한 경우가 많음.</li>
<li>기술 스택의 <strong>장점</strong>을 <strong>활용</strong>하지 못하고 있음.</li>
<li>이에 따라 <strong>이미 사용 가능한 기술</strong>을 충분히 활용하지 못하고 있음.</li>
<li><strong>프로젝트가 진행</strong>되기보다 새로운 기술을 학습하는 데 더 많은 시간을 할애하고 있음.</li>
</ul>

      <h3 id="[1]-해결-방법">
        <a name="[1]-해결-방법" class="anchor" href="#[1]-해결-방법">
          <span class="header-link"></span>
        </a>
        [1] 해결 방법
      </h3><ul>
<li><p>모듈 혹은 서비스 별로 사용되는 <strong>기술스택</strong>의 <strong>대안</strong>을 조사하고, 이에 대한 <strong>비교</strong>를 통해 명확한 기준을 세움.</p>
</li>
<li><p><strong>웹서버</strong></p>
<ul>
<li>현재 사용중인 기술 스택: <strong>golang - gin</strong></li>
<li><strong>대안</strong>: node.js - express, java - spring boot, python - fast api</li>
<li><strong>기존 기술</strong> 선택 이유: golang이 가진 <strong>웹서버 성능</strong> 및 <strong>동시성 처리</strong>에 대한 장점.</li>
<li>의문점<ul>
<li>다른 기술 스택에 비해 <strong>golang</strong>은 어떤 점에서 <strong>동시성 처리</strong>에 더 유리하다고 말할 수 있는가?<ul>
<li><strong><a target="_self" href="https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/03/19/Golang%EC%9D%80-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%97%90%EC%84%9C-%EC%9C%A0%EB%A6%AC%ED%95%9C%EA%B0%80.html" title="null">Golang은 진정 동시성을 처리하는 데 유리한가?</a></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>데이터베이스</strong></p>
<ul>
<li>현재 사용중인 기술 스택: <strong>postgresql</strong></li>
<li>대안: <strong>mysql</strong></li>
<li><strong>기존 기술</strong> 선택 이유: 사용 <strong>경험</strong>이 있음</li>
<li>조사 결과 PostgreSQL은 mySQL에 비해 <strong>복잡한 동작</strong>을 필요로 할 때 사용하는 기술 스택으로 알려져 있다.<ul>
<li><strong><a target="_self" href="https://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/" title="undefined">https://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/</a></strong></li>
</ul>
</li>
<li>팀원들도 mysql에 경험이 더 많은 편이므로, <strong>mysql로 이전</strong>하도록 생각하고 있다.</li>
</ul>
</li>
<li><p><strong>NoSQL</strong></p>
<ul>
<li>현재 사용중인 기술 스택: <strong>mongodb</strong></li>
<li>대안: 유저 정보 저장에 사용하는 <strong>SQL 데이터베이스</strong>에서의 통합</li>
<li>기존 기술 <strong>선택 이유</strong>: <strong>문서형 데이터베이스</strong>로서 가지는 장점이 있다는 점.</li>
<li><strong>문제점</strong><ul>
<li>그 장점이 뭔지 모름</li>
<li>문서형 데이터베이스가 무엇인지도 잘 모름</li>
</ul>
</li>
<li><strong>mongoDB</strong>의 장점<ul>
<li><strong>데이터 형태</strong>에 구애를 덜 받으므로 <strong>이모티콘</strong>과 같은 string 외 <strong>다양한 데이터</strong>를 처리하는 데에 용이하다</li>
<li><strong>채팅 방 단위</strong>로 데이터를 구현시에 <strong>기존 데이터</strong>를 <strong>신규 입장자</strong>에게 제공하기 유리하다</li>
</ul>
</li>
<li><strong>RDBMS</strong>의 장점<ul>
<li>string만 사용할 경우 table과 로직을 통해서 <strong>기초적인 채팅</strong>을 <strong>빠르게 구현</strong>할 수 있다.</li>
</ul>
</li>
<li><strong>선택</strong>: <strong>RDBMS</strong>(mysql/postgresql) 중에 하나로 <strong>채팅의 interface</strong>를 구현하고, <strong>string에 한정</strong>한 뒤 방 입장시에 <strong>접속 이전 데이터</strong>를 제공하지 않는 방향으로 <strong>mvp</strong>를 구성한 뒤에 기능을 <strong>확장</strong>하는 과정에서 <strong>mongoDB</strong> 도입을 고려한다.</li>
<li><strong>추가</strong>적인 mongoDB 및 문서형 데이터베이스에 대한 <strong>연구</strong> 필요</li>
</ul>
</li>
<li><p><strong>세션</strong></p>
<ul>
<li>현재 사용중인 기술 스택: <strong>redis</strong></li>
<li>대안: <strong>memcached</strong>, 세션이 아닌 <strong>토큰</strong>(JWT 등)을 사용</li>
<li>기존 기술 <strong>선택 이유</strong><ul>
<li>사용해 본 적이 있는 기술 스택</li>
<li>유명해서 자료를 구하는 것이 용이</li>
</ul>
</li>
<li>참고 자료<ul>
<li><a target="_self" href="https://velog.io/@sileeee/Redis-vs-Memcached" title="null"><strong>Redis vs Memcached</strong></a></li>
<li><a target="_self" href="https://1-7171771.tistory.com/127" title="null"><strong>Session storage로 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)</strong></a></li>
<li><a target="_self" href="https://kinsta.com/blog/memcached-vs-redis/" title="null"><strong>Memcached vs Redis: Choose Your In-Memory Cache</strong></a></li>
</ul>
</li>
<li><strong>Memcached</strong><ul>
<li>장점<ul>
<li>적은 <strong>메모리 사용량</strong> - 적은 메타 데이터</li>
<li>안정적인 <strong>응답 시간</strong></li>
<li><strong>데이터 변경이 적은 경우</strong> 메모리 파편화가 적음</li>
<li><strong>수평적 확장</strong>이 쉬움 - <strong>multi-threading</strong> 지원</li>
</ul>
</li>
<li>단점<ul>
<li>적은 <strong>데이터 타입</strong>과 <strong>API</strong></li>
<li><strong>데이터 변경이 잦은 경우</strong>에 파편화가 많이 발생</li>
</ul>
</li>
</ul>
</li>
<li><strong>Redis</strong><ul>
<li>장점<ul>
<li>다양한 <strong>데이터 타입</strong>과 <strong>기능</strong></li>
<li>많은 사용자</li>
<li><strong>디스크</strong>에 저장 가능</li>
<li><strong>Key</strong>에 저장할 수 있는 <strong>데이터의 크기</strong>가 큼</li>
<li><strong>pub/sub</strong>을 지원해서 <strong>메시지 큐</strong>로도 사용 가능</li>
</ul>
</li>
<li>단점<ul>
<li><strong>메모리 사용량</strong>이 많음(실제 필요량보다 <strong>2배</strong> 가까이 사용하는 구조)</li>
<li>트래픽이 많은 경우 <strong>응답 시간</strong>이 불안정 - <strong>발생 가능성 낮음</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>선택</strong><ul>
<li><strong>MVP</strong>의 관점에서 더 빠르게 시작할 수 있는 것은 Redis이다. 이는 <strong>기능 및 데이터 타입</strong>을 여럿 이미 구현돼 있기 때문이다.</li>
<li>트래픽이 많은 경우에 응답 시간이 얼마나 불안정해지는지 <strong>측정</strong>할 방법을 마련해두고, 그에 따라 <strong>Memcached</strong>로 전환할지 여부를 결정한다.</li>
<li>Redis를 사용하면 다른 기술 스택 없이 <strong>메시지 큐</strong>를 처리할 수 있을 지도 모름</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>메시지 큐</strong></p>
<ul>
<li>현재 <strong>사용 예정</strong>이었던 기술 스택: <strong>kafka</strong></li>
<li>대안: <strong>RabbitMQ</strong>, <strong>ActiveMQ</strong></li>
<li>기존 기술 <strong>선택 이유</strong><ul>
<li>메시지 큐 기술들 중 가장 <strong>유명</strong>해서.</li>
</ul>
</li>
<li>추가적으로 따로 글을 파서 고민해봐야 할 듯</li>
<li><strong>참고 자료</strong><ul>
<li><strong><a target="_self" href="https://gwonbookcase.tistory.com/49" title="undefined">https://gwonbookcase.tistory.com/49</a></strong></li>
<li><strong><a target="_self" href="https://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html" title="undefined">https://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html</a></strong></li>
</ul>
</li>
<li><strong>kafka</strong>의 장점<ul>
<li><strong>분산 처리 기능</strong>을 가장 잘 활용할 수 있음.</li>
<li>메모리가 아니라 <strong>파일 시스템</strong>을 이용한다.</li>
<li><strong>TPS</strong>가 높고 <strong>대용량 실시간 로그 처리</strong>에 유리하다</li>
<li>broker가 <strong>push</strong>하는 것이 아니라 <strong>pull</strong>하는 방식</li>
</ul>
</li>
<li><strong>activeMQ</strong> vs <strong>rabbitMQ</strong><ul>
<li>rabbitMQ가 <strong>더 다양한 프로토콜</strong>을 지원하고, activeMQ는 <strong>java</strong>에 더 특화된 모양이라 이 부분은 연구 필요</li>
</ul>
</li>
<li><strong>선택</strong><ul>
<li><strong>RabbitMQ</strong>로 MVP를 구현하고, <strong>확장성</strong>이 필요할 경우 <strong>Kafka</strong>로 전환하는 방향으로 진행한다.</li>
<li>RabbitMQ가 kafka에 비해 보다 기능이 <strong>간단</strong>하고 <strong>빠르게 구현</strong>할 수 있을 것으로 예상되기 때문</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/개발일지/ChatApplication Review(4)">이전 포스트: <!-- -->ChatApplication Review(4)</a></div><div style="text-align:right"><a href="/개발일지/ChatApplication Review(6)">다음 포스트: <!-- -->ChatApplication Review(6)</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-03-19-Chat Application review(5)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-19-Chat Application review(5).md","category":"개발일지","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **문제 및 해결 방법**\n\n---\n\n## 느낀 점\n\n* **기술 스택**을 선택할 때, **명확한 기준**을 통한 비교를 할 필요성을 체감\n* 당장 수요에 맞는 **가벼운 기술**을 선택하되, 규모가 커질 것을 대비하여 **확장성**을 고려해야 함.\n* **MVP**(Minimum Viable Product)를 정의 내리고 이를 기준으로 기존 **기술 스택 선택**이 **타당성**을 검토해야 함.\n* **결론**:\n  * **MVP**: postgresql, redis, rabbitMQ, golang - gin\n  * **확장**: mysql, memcached, kafka, mongodb\n\n---\n\n## 진행 내용\n\n* **설계도**에서 서비스별 사용하기로 한 **기술스택**에 대한 대안 검토\n  * [**설계도 링크**](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n## 문제 및 해결 방법\n\n### [1] **기술 스택** 선택에 대한 명백한 **근거** 부족\n\n* 기술 스택 선택에 대한 **명백한 근거**가 부족.\n* 현재 기술 스택의 **장단점**을 명확히 파악하지 못하고 있음.\n* 단순히 **유명하고 핫하기 때문**에 선택한 경우가 많음.\n* 기술 스택의 **장점**을 **활용**하지 못하고 있음.\n* 이에 따라 **이미 사용 가능한 기술**을 충분히 활용하지 못하고 있음.\n* **프로젝트가 진행**되기보다 새로운 기술을 학습하는 데 더 많은 시간을 할애하고 있음.\n\n### [1] 해결 방법\n\n* 모듈 혹은 서비스 별로 사용되는 **기술스택**의 **대안**을 조사하고, 이에 대한 **비교**를 통해 명확한 기준을 세움.\n\n* **웹서버**\n  * 현재 사용중인 기술 스택: **golang - gin**\n  * **대안**: node.js - express, java - spring boot, python - fast api\n  * **기존 기술** 선택 이유: golang이 가진 **웹서버 성능** 및 **동시성 처리**에 대한 장점.\n  * 의문점\n    * 다른 기술 스택에 비해 **golang**은 어떤 점에서 **동시성 처리**에 더 유리하다고 말할 수 있는가?\n      * **[Golang은 진정 동시성을 처리하는 데 유리한가?](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/03/19/Golang%EC%9D%80-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%97%90%EC%84%9C-%EC%9C%A0%EB%A6%AC%ED%95%9C%EA%B0%80.html)**\n* **데이터베이스**\n  * 현재 사용중인 기술 스택: **postgresql**\n  * 대안: **mysql**\n  * **기존 기술** 선택 이유: 사용 **경험**이 있음\n  * 조사 결과 PostgreSQL은 mySQL에 비해 **복잡한 동작**을 필요로 할 때 사용하는 기술 스택으로 알려져 있다.\n    * **\u003chttps://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/\u003e**\n  * 팀원들도 mysql에 경험이 더 많은 편이므로, **mysql로 이전**하도록 생각하고 있다.\n* **NoSQL**\n  * 현재 사용중인 기술 스택: **mongodb**\n  * 대안: 유저 정보 저장에 사용하는 **SQL 데이터베이스**에서의 통합\n  * 기존 기술 **선택 이유**: **문서형 데이터베이스**로서 가지는 장점이 있다는 점.\n  * **문제점**\n    * 그 장점이 뭔지 모름\n    * 문서형 데이터베이스가 무엇인지도 잘 모름\n  * **mongoDB**의 장점\n    * **데이터 형태**에 구애를 덜 받으므로 **이모티콘**과 같은 string 외 **다양한 데이터**를 처리하는 데에 용이하다\n    * **채팅 방 단위**로 데이터를 구현시에 **기존 데이터**를 **신규 입장자**에게 제공하기 유리하다\n  * **RDBMS**의 장점\n    * string만 사용할 경우 table과 로직을 통해서 **기초적인 채팅**을 **빠르게 구현**할 수 있다.\n  * **선택**: **RDBMS**(mysql/postgresql) 중에 하나로 **채팅의 interface**를 구현하고, **string에 한정**한 뒤 방 입장시에 **접속 이전 데이터**를 제공하지 않는 방향으로 **mvp**를 구성한 뒤에 기능을 **확장**하는 과정에서 **mongoDB** 도입을 고려한다.\n  * **추가**적인 mongoDB 및 문서형 데이터베이스에 대한 **연구** 필요\n* **세션**\n  * 현재 사용중인 기술 스택: **redis**\n  * 대안: **memcached**, 세션이 아닌 **토큰**(JWT 등)을 사용\n  * 기존 기술 **선택 이유**\n    * 사용해 본 적이 있는 기술 스택\n    * 유명해서 자료를 구하는 것이 용이\n  * 참고 자료\n    * [**Redis vs Memcached**](https://velog.io/@sileeee/Redis-vs-Memcached)\n    * [**Session storage로 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)**](https://1-7171771.tistory.com/127)\n    * [**Memcached vs Redis: Choose Your In-Memory Cache**](https://kinsta.com/blog/memcached-vs-redis/)\n  * **Memcached**\n    * 장점\n      * 적은 **메모리 사용량** - 적은 메타 데이터\n      * 안정적인 **응답 시간**\n      * **데이터 변경이 적은 경우** 메모리 파편화가 적음\n      * **수평적 확장**이 쉬움 - **multi-threading** 지원\n    * 단점\n      * 적은 **데이터 타입**과 **API**\n      * **데이터 변경이 잦은 경우**에 파편화가 많이 발생\n  * **Redis**\n    * 장점\n      * 다양한 **데이터 타입**과 **기능**\n      * 많은 사용자\n      * **디스크**에 저장 가능\n      * **Key**에 저장할 수 있는 **데이터의 크기**가 큼\n      * **pub/sub**을 지원해서 **메시지 큐**로도 사용 가능\n    * 단점\n      * **메모리 사용량**이 많음(실제 필요량보다 **2배** 가까이 사용하는 구조)\n      * 트래픽이 많은 경우 **응답 시간**이 불안정 - **발생 가능성 낮음**\n  * **선택**\n    * **MVP**의 관점에서 더 빠르게 시작할 수 있는 것은 Redis이다. 이는 **기능 및 데이터 타입**을 여럿 이미 구현돼 있기 때문이다.\n    * 트래픽이 많은 경우에 응답 시간이 얼마나 불안정해지는지 **측정**할 방법을 마련해두고, 그에 따라 **Memcached**로 전환할지 여부를 결정한다.\n    * Redis를 사용하면 다른 기술 스택 없이 **메시지 큐**를 처리할 수 있을 지도 모름\n* **메시지 큐**\n  * 현재 **사용 예정**이었던 기술 스택: **kafka**\n  * 대안: **RabbitMQ**, **ActiveMQ**\n  * 기존 기술 **선택 이유**\n    * 메시지 큐 기술들 중 가장 **유명**해서.\n  * 추가적으로 따로 글을 파서 고민해봐야 할 듯\n  * **참고 자료**\n    * **\u003chttps://gwonbookcase.tistory.com/49\u003e**\n    * **\u003chttps://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html\u003e**\n  * **kafka**의 장점\n    * **분산 처리 기능**을 가장 잘 활용할 수 있음.\n    * 메모리가 아니라 **파일 시스템**을 이용한다.\n    * **TPS**가 높고 **대용량 실시간 로그 처리**에 유리하다\n    * broker가 **push**하는 것이 아니라 **pull**하는 방식\n  * **activeMQ** vs **rabbitMQ**\n    * rabbitMQ가 **더 다양한 프로토콜**을 지원하고, activeMQ는 **java**에 더 특화된 모양이라 이 부분은 연구 필요\n  * **선택**\n    * **RabbitMQ**로 MVP를 구현하고, **확장성**이 필요할 경우 **Kafka**로 전환하는 방향으로 진행한다.\n    * RabbitMQ가 kafka에 비해 보다 기능이 **간단**하고 **빠르게 구현**할 수 있을 것으로 예상되기 때문\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":5,"classes":"wide","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","date":"2024-03-19T00:00:00.000Z","categories":"개발일지"}},"title":"ChatApplication Review(5)","category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"ChatApplication Review(4)","category":"개발일지"},"next":{"title":"ChatApplication Review(6)","category":"개발일지"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"개발일지","title":"ChatApplication Review(5)"},"buildId":"4n-fl_RCrq53WZFFUxusB","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>