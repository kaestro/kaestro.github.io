{"pageProps":{"posts":[{"postName":"2024-03-30-Blog 기능 개발","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/2024-03-30-Blog 기능 개발.md","category":"개발일지","title":"블로그 기능 개발 일지","subtitle":"세로 화면, 목차 및 카테고리 aside, subtitle 등","content":"\n## 기능 추가 이유\n\n기존에 블로그를 사용하면서 있었으면 좋겠다고 생각했던 **기능**들이 있었습니다. 읽기에 **불편한 인터페이스**나, **예쁘지 않은 디자인**과 같은 부분들이었습니다. 이번에 기능들을 추가해서 그런 아쉬움들을  어느 정도 **개선**했습니다.\n\n### 문제\n\n* **글과 카테고리의 수**가 늘어나서 읽고자 하는 글을 **탐색**하기 어려웠다.\n* 글 하나를 읽은 후 **다음 글**로 넘어가기가 어려웠다.\n* **subtitle**을 title에 형식적으로 포함돼어 있어 **다양한 layout**에서 사용하는 **확장성**이 떨어졌다.\n* 글 내용이 길어졌을 때 **원하는 지점으로 이동**하기가 어려웠다.\n\n이 밖에도 많았지만, 그 중 **핵심적인 불편사항**들은 위와 같았습니다. 이 문제들을 아래에서 **도입한 기능**들을 통해 해결했습니다.\n\n### 해결 방법\n\n* **카테고리 페이지** 추가\n* 카테고리 페이지에 접근하기 위한 **aside 추가**(세로 화면일 시 보이지 않음)\n\n* **이전 글, 다음 글 버튼**이 직관적으로 동작하게 **알고리즘 변경**\n* **홈**으로 돌아가는 버튼 추가(세로, 가로 화면 모두)\n\n* title과 subtitle을 **구분**하기 위해 **subtitle 추가**\n* subtitle을 이용하도록 기존의 **layout들을 수정**\n\n* **목차**를 이용하는 **aside** 추가(세로 화면일 시 보이지 않음)\n\n---\n\n## 느낀 점\n\n### 남들만큼 무난한 것을 만드는 것은 어려운 일이다\n\n일단 뭐라도 써야한다는 생각에 시작부터 한 블로그였던 만큼, **디자인이나 기능적으로 모자란 부분**들이 굉장히 많았습니다. 이를 나중에 보완하고, 수정된 템플릿에 맞춰 기존 글을 수정하는 일은 쉽지 않았습니다. 제가 **자바스크립트, html과 같은 웹에서 사용하는 기술**에 대한 지식이 모자라기도 했지만, 특히 제가 **미적 감각이나 경험**이 부족해서 **디자인을 수정**하는 일은 더 어려웠습니다. 다행히도 **지인분의 도움**을 얻어 일순간 테러 수준이었던 디자인을 무난한 수준으로 만들 수 있었습니다. 감사합니다 선생님.\n\n최근에 **마케팅** 관련해서 공부하는 과정에서, 어떻게 하면 사람에게 **잘 전달되고 끌리는 것**을 만들 수 있을지에 대해 많은 고민을 하는 경험을 하게 됐습니다. **기존의 블로그**는 이 부분을 신경쓰지 않았어서 양쪽에서 많이 아쉬웠기 때문에, 가급적 그 부분에 **집중해서 개선**하려고 노력했습니다. 이 과정에서 나온 것들이 이제 aside에 추가된 **목차와 카테고리 페이지, subtitle** 등입니다.\n\n이 정도 글을 확보하고 형태를 갖추는 데 **3개월**이나 걸렸다니, 좀 괜찮은 블로그라고 말할 수 있는 수준이 되려면 얼마나 걸릴지 조금 막막하긴 합니다. 아직도 많이 모자라지만, 그래도 이젠 최소한의 읽을거리가 있는 **컨텐츠**가 확보됐고 이들을 읽는 데 있어서 **많이 불편하지 않게** 만드는 데 성공했다 말할 수 있지 않을까 싶어 조금은 뿌듯하네요. 다음에는 **무난한 것**을 넘어서는 **흥미로운 것**이 되도록 발전하고 싶습니다.\n\n### 환경이 변화를 가져온다\n\n이번에 추가한 기능 중 가장 획기적이라 할만한 것은 **aside**로 움직이면서 **헤더들에 대한 하이퍼링크**를 제공하는 **목차**입니다. 이 기능을 추가한 이유는 제가 블로그를 이용하면서 글을 읽을 때 종종 **원하는 부분으로 바로 이동**하고 싶다는 생각이 들었기 때문이었습니다.\n\n단순히 **편의성 기능**이라 생각했던 부분이었는데, 이를 추가하고 나서 기존의 글들을 보니 이전에 **보이지 않았던 아쉬운 부분**들이 보이기 시작했습니다. 헤더로 처리한 내용들이 너무 장황하거나, 전달하고자하는 내용을 제대로 담고 있지 못한 경우가 꽤나 많았기 때문입니다.\n\n다시 말해, 쓸 때는 잘 쓴 줄 알았는데 퇴고도 거쳐놓고도 **미숙한 글**이란 사실을 깨닫고 **부끄러움**에 몸서리치게 됐단 뜻입니다. 초창기에 비해서는 그래도 많이 나은 글을 쓰고 있다고 생각하고 있습니다만, 이전 글들을 볼때마다 더 잘 할 수 있는 부분들이 많았다 싶어서 아쉽네요. 기회가 되면 시간을 내서라도 이전 글들에서 헤더들 만큼은 **개선**해보고 싶습니다.\n\n그래도 목차 기능 덕분에 앞으로는 제가 쓰고 있는 헤더 및 소제목들이 글의 내용을 얼마나 잘 반영하고 있는지가 더 선명하게 드러나게 돼서 이전보다는 좀 덜 부끄러운 글을 쓸 수 있게 되지 않을까 합니다.\n\n---\n\n## 앞으로의 계획\n\n이번에 기능들을 추가하게 된 것은 제게 있어서 **시험 기간에 방 청소**를 한 것과 같은 경험이었습니다. 사실 이 기능들을 추가하기 전에는 js, html에 대한 지식이 모자라다보니 너무 오랜 시간이 걸릴 것 같아 막막해서 미루고 있었습니다. 그런데 우연히 **여유 시간**이 생겼는데 기존에 하던 일들은 하기가 싫어서 잠깐 **딴짓**을 한 것이 이번 **블로그 개발**이었습니다.\n\n그런데 막상 시작하고 보니 생각보다 굉장히 **즐거운 경험**이었고, 결과물에도 나름 **만족**스럽네요. 아쉽게도 지난 3개월간 떠오른 모든 아이디어 구현이 완료가 된 상태이기에 당장은 더 추가할 기능 계획은 없습니다. 뭐 좀 지나면 '내가 이렇게 끔찍한 블로그를 사용하고 있었다고?'라는 생각을 하게 되면서 주섬주섬 계획을 하나씩 늘려나가지 않을까 싶습니다.\n\n그럼 한동안 또 새로 청소한 방을 실컷 어지르러 가보겠습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"블로그 기능 개발 일지","subtitle":"세로 화면, 목차 및 카테고리 aside, subtitle 등","date":"2024-03-30T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-17-처음으로 오픈소스 참여하기","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/2024-04-17-처음으로 오픈소스 참여하기.md","category":"개발일지","title":"처음으로 오픈소스 참여하기","subtitle":"다양한 형태의 프로젝트와의 협업을 통한 배움의 시작","content":"\n### 목차\n\n- [도움을 구하는 입장에서 벗어나 주는 입장으로](#도움을-구하는-입장에서-벗어나-주는-입장으로)\n- [회사에서 스폰서하고 모든 것이 잘 갖춰져 있는 vizro](#회사에서-스폰서하고-모든-것이-잘-갖춰져-있는-vizro)\n- [초창기 가상환경 구축이 인상적인 tagsy-discord](#초창기-가상환경-구축이-인상적인-tagsy-discord)\n- [아직 협업을 위한 노력이 더 필요해보이는 BTC-ETF-Tracker](#아직-협업을-위한-노력이-더-필요해보이는-btc-etf-tracker)\n- [마치며](#마치며)\n\n---\n\n## 도움을 구하는 입장에서 벗어나 주는 입장으로\n\n다른 사람과 협업하는 것으로 혼자 하는 것보다 많은 것을 배울 수 있다는 것을 이번에 채팅 프로그램을 작성하면서 알 수 있었기 때문에 제 기존의 프로젝트에 팀을 구성해보려는 생각을 했지만, 다른 대단한 프로젝트들에 비해 매력적으로 보이지도 않고 홍보하는 것이 용이하지 않아 쉽지 않았습니다. 그래서 반대로 다른 사람의 프로젝트에 참여해보면 어떨까 싶어 고민하던 와중 [다음 글](https://well-balanced.medium.com/%EA%BC%BC%EC%88%98%EB%A1%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%97%AC%ED%95%98%EA%B8%B0-b34ee4cc2bc2)을 읽게 됐습니다.\n\n해당 팁을 받아들여 이후 약 3일간 github에서 good first issue를 탐색하고 연락을 취하는 과정을 통해 총 3개의 다른 프로젝트에서 issue에 참가해서 오픈소스에 기여하는 경험하고 있는 중입니다. 해당 프로젝트는 각각 [vizro](https://github.com/mckinsey/vizro), [tagsy-discord](https://github.com/tarto-dev/tagsy-discord), [BTC-ETF-Tracker](https://github.com/BuildWithData/BTC-ETF-Tracker)입니다. good first issue라는 라벨을 통해 다른 사람들의 참여에 대해 생각할 정도로 관리를 신경쓰는 프로젝트들이었기 때문에 잠깐의 경험으로도 재밌는 것을 배울 수 있었습니다.\n\n---\n\n## 회사에서 스폰서하고 모든 것이 잘 갖춰져 있는 vizro\n\nvizro는 mckinsey에서 개발한 데이터 시각화 어플리케이션을 만들 때 사용하는 툴킷으로 주로 python을 사용해서 작성돼 있습니다. 프로젝트에 참여하게 된 issue는 [이것](https://github.com/mckinsey/vizro/issues/424#issuecomment-2061052264)이었습니다. 이슈의 내용은 현재 작성하고 있는 문서에 대한 링크들이 자신들이 규칙으로 정해놓은 것들을 제대로 따르면서 이용하는 사람이 편하게 읽을 수 있도록 정리하는 것이었습니다.\n\n해당 프로젝트는 hatch라는 CI 솔루션을 채용한 잘 만들어진 시스템을 갖추고 있었기 때문에, 공식 문서를 잠깐 읽는 것만으로 한번에 가상환경을 개발할 수 있는 형태로 세팅할 수 있는 것이 굉장히 놀라웠습니다. 덕분에 저는 단 한 번의 코멘트로 된 조언을 받고도 해당 프로젝트에 기여를 시작할 수 있었습니다. 또한 곳곳에 사용하기 편하게 배치된 문서를 읽으면서 오픈 소스에 참여하는 사람이 편하게 느끼도록 돕기 위해 어떤 부분들을 고려해야하는 지에 대해 배울 수 있었습니다.\n\n---\n\n## 초창기 가상환경 구축이 인상적인 tagsy-discord\n\ntagsy-discord는 discord에서 사용할 수 있는 태그를 통한 key-value 저장소를 만들어주는 봇입니다. 해당 프로젝트에 참여하게 된 issue는 [이것](https://github.com/tarto-dev/tagsy-discord/issues/26#issuecomment-2067624087)이었습니다. 이슈의 내용은 author에게서 모든 tag를 가져오는 기능을 추가하는 것이었습니다.\n\n이 프로젝트는 주로 venv, pip requirements를 통해 가상환경을 구축해서 개발 환경을 관리했고 commit message를 관리하기 위한 방법으로 contribution guide를 새로 만들어두고, pre-commit hooks란 것을 만들어서 코딩 스타일을 맞추는 것을 강제한 것이 인상 깊었습니다. 차후에 다른 사람들과 협업을 하기 위해 오픈소스 프로젝트를 만들 때 이런 것들을 참고해야겠다는 생각이 들었습니다.\n\n---\n\n## 아직 협업을 위한 노력이 더 필요해보이는 BTC-ETF-Tracker\n\nBTC-ETF-Tracker는 비트코인으로 구성한 ETF를 추적하는 프로젝트입니다. 해당 프로젝트에 참여하게 된 issue는 [이것](https://github.com/BuildWithData/BTC-ETF-Tracker/issues/34#issuecomment-2065411254)이었습니다. 이슈의 내용은 sqlite에서 데이터를 저장할 때 데이터가 rounded 되지 않고 소수점이 일정하지 않게 저장되는 것이었습니다.\n\n세 프로젝트 중에는 가장 모자란 점이 많았고 초창기의 것이었기 때문에 아쉬운 부분도 많았지만, 그렇기 때문에 제가 느낄때 가장 우선이었던 250여줄의 DRY 원칙을 위배하는 raw sql로 작성된 테이블 생성 python 스크립트를 수정하는 것이었습니다. 당분간은 리팩토링 위주로 정리를 하고 프로젝트에 기여를 시작하게 되지 않을까 생각 중입니다.\n\n---\n\n## 마치며\n\n오픈 소스에 기여하는 것이 막연하게 어렵게만 느껴졌는데 이번 일을 계기로 도움을 원하는 곳은 많고, 동시에 도움을 받기 위해서도 굉장히 많은 노력을 해야한다는 것을 알 수 있었습니다. 그리고 열정적으로 활동하는 사람들과 교류를 하면서 새로운 것을 배울 수 기회를 얻고 싶다는, 제가 기존에 원했던 목표를 달성할 수 있어서 기쁘게 생각합니다. 모든 프로젝트를 꼭 끝까지 완수할 때까지 도전하지는 않겠지만, 꾸준히 여러 프로젝트에 참여하면서 다양한 경험을 쌓아보고 싶습니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"처음으로 오픈소스 참여하기","subtitle":"다양한 형태의 프로젝트와의 협업을 통한 배움의 시작","date":"2024-04-17T00:00:00.000Z","categories":"개발일지","published":true}},{"postName":"2024-02-25-Chat Application 0.개요","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-25-Chat Application 0.개요.md","category":"개발일지","title":"ChatApplication 개요","subtitle":"","content":"\n## 목차\n\n1. 프로젝트 소개\n2. 프로젝트 구조\n3. 기술 스택 및 개발 환경\n\n\n---\n\n\n## 프로젝트 소개\n\nGo 및 백엔드에서 사용하는 전반적인 기술을 익히는 것을 목표로 하는 프로젝트로, 최종 결과물로는 다수의 사용자들이 실시간으로 채팅을 주고받을 수 있는 **[웹 어플리케이션](https://github.com/kaestro/ChatApplication)**을 개발하는 것을 목표로 합니다.\n\n채팅은 다수의 유저가 동시에 접속해서 실시간으로 메시지를 주고 받는 기능을 필요로 합니다. 이 때문에 현대 서버 기술에서 중요하게 여겨지는 동시성, 캐시, 데이터베이스 등의 기술의 필요성을 느낄 수 있는 프로젝트라고 생각했습니다. 동시에 이런 기능을 테스트하는 방법을 만들어보는 것도 목표로 하고 있습니다.\n\n여기서 다수란 약 15000명의 사용자가 동시에 접속할 수 있는 서비스로, 이는 스팀 서비스에서 인기 게임 100위 안에 들어가는 게임의 동시 접속자 수와 비슷한 수치입니다. 이와 관련해서 세부적인 테스트 환경은 추후에 다시 정의할 예정입니다.\n\n\n---\n\n\n## 프로젝트 구조\n\n\n메인 서버: 회원 가입, 로그인 등의 유저 관리 기능 처리. 채팅 서버로 유저와의 연결 담당. 캐시 및 데이터베이스 서버와의 연결 담당.\n\n캐시 서버: 로그인 정보, 채팅 메시지 등을 저장하고 조회하는 서버.\n\n데이터베이스 서버: 유저 정보, 채팅 메시지 등을 저장하고 조회하는 서버.\n\n\n---\n\n\n## 기술 스택 및 개발 환경\n\n```\n1. 서버 개발 언어: Go\n2. 사용 프레임워크: Gin\n3. 배포 환경: Microsoft Azure\n4. 데이터베이스: PostgreSQL\n5. 채팅 메시지 전달 및 로그인 캐시 서버: Redis\n6. 채팅 메시지 저장 및 조회: MongoDB\n7. 테스트 방법: Postman, websocket king\n```\n\n\n### 서버 개발 언어: Go\n\n\n* Go가 서버단에서 개발 편리성이 높고, 빠른 속도로 동작하는 것으로 알려져 있는데 이를 체험해보기 위해\n* Go 루틴과 같은 기능을 통해 동시성 처리를 쉽게 할 수 있기 때문에, 채팅 서버에서 동시성 처리가 많이 필요한 부분이 있을 것으로 예상되기 때문에\n* Go의 수요가 높아질 것으로 예상되는데, 이에 대한 경험을 쌓기 위해\n\n\n### 사용 프레임워크: Gin\n\n\n* Go를 활용한 웹 프레임워크 중에서 가장 인기 있는 프레임워크 중 하나로 학습자료가 많고, 현업에서 사용하는 곳도 많아서\n\n\n### 배포 환경: Microsoft Azure\n\n\n* 배포를 위해 사용되는 클라우드 서비스는 크게 AWS, Azure, GCP가 있습니다.\n* 그런데 Azure를 제외하고는 이전에 사용해 본다고 무료 크레딧을 이미 다 활용했기 때문에 이 참에 Azure를 사용해보기로 했습니다.\n\n\n### 데이터베이스: PostgreSQL\n\n\n* MySQL과 비교했을 때, 한글 처리가 더 용이해서 문제가 덜 발생했기 때문.\n* 최초에는 MySQL을 통한 개발 환경을 구축했으나, 한글 처리에 문제가 발생해서 변경함.\n\n\n### 채팅 메시지 전달 및 로그인 캐시 서버: Redis\n\n\n* 캐시 서버로 현재 가장 많이 쓰이는 솔루션 중 하나이기 때문에\n* Azure에서도 Redis를 제공하기 때문에\n\n\n### 채팅 메시지 저장 및 조회: MongoDB\n\n\n* 개발 목적 중 하나는 NoSQL 데이터베이스를 경험해보는 것이었기 때문에\n* 채팅 어플리케이션으로 기획을 한 것도 이러한 이유\n* MongoDB는 Azure에서도 제공한다.\n* MongoDB는 채팅 메시지와 같은 비정형 데이터를 저장하기에 적합하고 알려져 있다.\n\n\n### 테스트 방법: Postman, websocket king\n\n\n* Postman은 기존에 사용해본 경험이 있고, websocket king은 웹소켓을 테스트하기 위한 툴로 알려져 있기 때문에\n* 이외의 것을 하려면 클라이언트를 개발해야 하는데, 클라이언트 개발 경험 자체가 없어 이를 개발하려하면 시작 자체가 어려울 것으로 예상되기 때문에.\n* 때문에 해당 부분은 개발에서 목표로 하고 있는 수치인 15000명의 동시 접속자 수를 테스트하기에 현재 부적합하며, 추후에 다시 정의할 예정입니다.\n* 15000명의 동시 접속 역시도 해당 접속자들이 어느 정도의 메시지를 주고받는지, 어느 정도의 메시지를 저장하는지에 따라서 달라질 수 있기 때문에, 이에 대한 테스트 방법 또한 추후에 다시 정의할 예정입니다.\n* 대략적으로 생각중인 것은 얼마 전 아프리카 tv에서 7만명의 동접자가 1분에 1번의 채팅을 소화하지 못해서 방송이 다운되는 사태가 있었기 때문에, 이와 비슷한 수치를 목표로 테스트를 진행할 예정입니다.\n\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":0,"classes":"wide","title":"ChatApplication 개요","date":"2024-02-25T00:00:00.000Z","categories":"개발일지","subtitle":""}},{"postName":"2024-02-26-Chat Application review(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-26-Chat Application review(1).md","category":"개발일지","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n개발할 때 최초에 생각한 것과 별개로 기능 추가 및 변경이 빈번하게 발생하게 된다. 이 때마다 기존의 코드를 변경하기 용이하게 하기 위한 추상화, business logic 분리, unit test 등의 작업이 필요하다.\n\n원래는 login api를 다루는 서버에서 채팅 역시도 다루게 될 것이라고 생각했다. 그런데 현재 서버 구조는 api를 다루는 형태로 되어 있으니 이를 api 전용 서버로 두고, 채팅을 다루는 서버는 따로 두는 것이 낫지 않을까? 라는 생각이 들었다.\n\n\n---\n\n\n## 진행 내용\n\n* 프로젝트 개요, 구조, 기술 스택, 개발 환경 등 정리. => [프로젝트 개요](http://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/02/26/Chat-Application-%EA%B0%9C%EC%9A%94.html)\n* 메인 서버 구조 설계\n* User CRUD API 구현\n* DBManager, SessionManager, PasswordManager internal package 구현\n\n---\n\n### 메인 서버 구조 설계\n\n```\nmyapp\n├── api\n│   ├── handler\n│   │   └── user\n│   ├── models\n│   └── service\n│       └── user\n├── internal\n│   ├── db\n│   ├── session\n│   └── password\n├── pkg\n├── scripts\n├── tests\n└── main.go\n```\n\n* api: API 요청을 처리하는 패키지.\n  * handler: API 요청을 처리하는 핸들러.\n  * models: API 요청과 응답에 사용되는 모델.\n  * service: API 요청을 처리하는 비즈니스 로직.\n  * user: User API 요청을 처리하는 패키지.\n* internal: 내부 패키지.\n  * db: 데이터베이스 관련 패키지.\n  * session: 세션 관리 패키지.\n  * password: 비밀번호 관리 패키지.\n* pkg: 외부에 공개되는 패키지.(미정)\n* scripts: 스크립트 파일.\n  * 현재 sql 파일을 실행하는 스크립트만 존재.\n* tests: 테스트 파일.\n  * go 서버의 unit test 파일만 존재.\n  * 추후 요구하는 규모에 따라 테스트 환경을 구축할 예정.\n* main.go: 프로그램의 진입점.\n\n---\n\n### User CRUD API 구현\n: Login, Logout, Signup, deleteAccount API 구현.\n\n**구현 내용**\n* Login API\n  * 로그인 요청을 처리하는 핸들러 구현.\n  * 로그인 성공 시 세션을 생성하고, 세션 ID를 응답.\n  * 로그인 실패 시 에러 메시지를 응답.\n* Logout API\n  * 로그아웃 요청을 처리하는 핸들러 구현.\n  * 세션을 삭제.\n* Signup API\n  * 회원가입 요청을 처리하는 핸들러 구현.\n  * 회원가입 실패 시 에러 메시지를 응답.\n* deleteAccount API\n  * 회원탈퇴 요청을 처리하는 핸들러 구현.\n  * 로그인 세션을 통해 회원탈퇴.\n  * 회원탈퇴 실패 시 에러 메시지를 응답.\n\n[**구현 상세**](https://github.com/kaestro/ChatApplication/tree/main/myapp/api)\n\nDBManager와 SessionManager를 통해 유저의 정보를 조회하고, 관리를 위한 로직을 수행.\nPasswordManager를 통해 비밀번호를 암호화하여 저장하고, 비밀번호 검증을 수행.\n\nuser data model을 구현, 이를 orm 패키지를 사용하여 데이터베이스와 연동한다.\n\nhandler에 응답을 처리하는 로직을 구현한 뒤 login 같은 경우는 비즈니스 로직이 변경될 수 있으므로 service 패키지를 통해 자주 변경되는 부분을 분리하였다.\n\n---\n\n### DBManager, SessionManager, PasswordManager internal package 구현\n: User CRUD API 구현 과정에서 필요한 패키지 구현\n\n**구현 내용**\n\n* DBManager\n  * 데이터베이스와 연동하여 유저 정보를 조회, 추가, 삭제하는 로직을 수행.\n  * orm 패키지를 사용하여 데이터베이스와 연동.\n  * DB 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* SessionManager\n  * 캐시 서버를 통해 세션을 관리.\n  * 세션 생성, 조회, 삭제 로직을 수행.\n  * 세션 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* PasswordManager\n  * 비밀번호를 암호화하여 저장하고, 비밀번호 검증하는 로직을 수행\n  \n**구현 상세**\n\n**DBManager**는 DB 연결을 gorm을 통해 생성하고, create, read by single field, read all table, update row, delete row 기능을 제공한다.\n\n**SessionManager**는 redis를 통해 세션 키 생성, 세션 생성, 조회, 삭제, 정합성 확인 기능을 제공. => *TODO* 현재 <u>LoginSessionGenerator.go를 LoginSessionKeyGenerator.go로 파일명 변경한다</u>\n\n**Store**라는 추상적인 인터페이스를 통해 session을 관리하고, 현재 이를 RedisStore를 통해 구현한다. 이는 추후에 다른 저장소를 사용할 때 변경이 용이하도록 하기 위해서이다.\n\n**PasswordManager**는 bcrypt를 통해 비밀번호를 암호화하고, 비밀번호 검증하는 기능을 제공한다.\n\n---\n\n## 문제 및 해결 방법\n\n### 문제상황\n\n```\n1. dbManager가 연결 객체 자체를 반환하고 있었음.\n2. 암호화 로직이 api마다 중복되어 있었음.\n3. login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n4. user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n```\n\n\n### 해결 방법\n\n**dbManager가 연결 객체 자체를 반환하고 있었음.**\n\n**문제점**: GetDB() 함수를 통해 db 객체를 반환하고 있었다. 이는 db 객체를 직접 사용하게 되어, dbManager의 로직이 변경될 때마다 모든 곳에서 변경이 필요하게 된다.\n\n```go\nvar (\n\tonce sync.Once\n\n\tdb *gorm.DB\n)\n\nfunc GetDB() *gorm.DB {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err = gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn db\n}\n```\n\n**해결 방법**: dbManager에서 허용하는 로직만을 public하게 제공하도록 변경.\n\n```go\ntype DBManager struct {\n\tdb *gorm.DB\n}\n\nvar (\n\tonce sync.Once\n\n\tmanager *DBManager\n)\n\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmanager = &DBManager{\n\t\t\tdb: db,\n\t\t}\n\t})\n\n\treturn manager\n}\n\nfunc (m *DBManager) Create(value interface{}) error {\n    return m.db.Create(value).Error\n}\n...\n```\n\n\n---\n\n\n**암호화 로직이 api마다 중복되어 있었음.**\n\n**문제점**: 비밀번호 암호화, 비밀번호 검증 로직이 user CRUD api마다 중복되어 있었음.\n\n```go\nfunc Signup(c *gin.Context) {\n    ...\n\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\n    ...\n}\n```\n\n**해결 방법**: Password package를 생성하여 비밀번호 암호화, 비밀번호 검증 로직을 분리.\n\n```go\npackage password\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(hashedPassword), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n```\n\n### login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n\n**문제점**: login api의 비즈니스 로직이 변경될 때마다 handler에서 변경이 필요하게 됨.\n\n```go\n\tdb.GetDB().Create(&user)\n\n\t// 로그인 정보를 담은 요청 본문을 생성합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\tbody, _ := json.Marshal(loginInfo)\n\n\t// 테스트를 위한 HTTP 요청을 생성합니다.\n\treq, _ := http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw := httptest.NewRecorder()\n\n\t// Gin 엔진을 생성하고 LogIn 핸들러를 등록합니다.\n\tr := gin.Default()\n\tr.POST(\"/login\", userAPI.LogIn)\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\t// 잘못된 비밀번호로 로그인을 시도합니다.\n\tloginInfo.Password = \"wrongpassword\"\n\tbody, _ = json.Marshal(loginInfo)\n\treq, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw = httptest.NewRecorder()\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 401인지 확인합니다.\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\n\tt.Log(\"Login test passed!\")\n}\n```\n\n구현 과정에서 DBManager, SessionManager, Password 등의 패키지를 추가하게 됐다. 이 과정에서 추상화, 접근 제어 등의 기능이 도입되었고 이 때마다 handler에서 변경이 필요하게 됨.\n\n이와 관련한 해결 방법으로 service 패키지를 통해 비즈니스 로직을 분리하고자 함.\n\n```go\nvar (\n\tErrAlreadyLoggedIn            = errors.New(\"user is already logged in\")\n\tErrUserNotFound               = errors.New(\"failed to find user\")\n\tErrInvalidPassword            = errors.New(\"invalid password\")\n\tErrFailedToGenerateSessionKey = errors.New(\"failed to generate session key\")\n\tErrFailedToSaveSessionKey     = errors.New(\"failed to save session key\")\n)\n\ntype LoginService struct {\n\tdbManager      *db.DBManager\n\tsessionManager *session.SessionManager\n}\n\nfunc NewLoginService(dbManager *db.DBManager, sessionManager *session.SessionManager) *LoginService {\n\treturn &LoginService{\n\t\tdbManager:      dbManager,\n\t\tsessionManager: sessionManager,\n\t}\n}\n\nfunc (s *LoginService) LogIn(userEmailAddress, userPassword, userSessionKey string) (string, error) {\n\t// 세션 키가 sessionManager에 저장되어 있는지 확인합니다.\n\tif s.sessionManager.IsSessionValid(userSessionKey, userEmailAddress) {\n\t\treturn \"\", ErrAlreadyLoggedIn\n\t}\n\n\t// 사용자 정보를 담을 User 구조체를 선언합니다.\n\tvar user models.User\n\n\t// 사용자가 제공한 이메일 주소로 데이터베이스에서 사용자를 찾습니다.\n\terr := s.dbManager.Read(&user, \"email_address\", userEmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\t// 사용자가 제공한 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교합니다.\n\tif !password.CheckPasswordHash(userPassword, user.Password) {\n\t\treturn \"\", ErrInvalidPassword\n\t}\n\n\t// 세션 키를 생성합니다.\n\tsessionKey, err := session.GenerateRandomSessionKey()\n\tif err != nil {\n\t\treturn \"\", ErrFailedToGenerateSessionKey\n\t}\n\n\t// 세션 키를 캐시에 저장합니다.\n\terr = s.sessionManager.SetSession(sessionKey, user.EmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrFailedToSaveSessionKey\n\t}\n\n\treturn sessionKey, nil\n}\n```\n\n---\n\n### user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n\n**문제점**: user CRUD api를 구현 때마다 postman을 통해 수동으로 테스트를 진행하고 있었음.\n\n**해결 방법**: user CRUD api를 매 빌드시마다 검증할 unit test를 작성.\n\n```go\nfunc TestUserHandler(t *testing.T) {\n\t// 테스트를 위한 사용자 정보를 생성합니다.\n\tsampleUser := models.User{\n\t\tUserName:     \"testuser\",\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\n\t// Gin 엔진을 생성하고 핸들러들을 등록합니다.\n\tginEngine := gin.Default()\n\tginEngine.POST(\"/login\", userAPI.LogIn)\n\tginEngine.POST(\"/logout\", userAPI.LogOut)\n\tginEngine.POST(\"/signup\", userAPI.SignUp)\n\tginEngine.POST(\"/deleteAccount\", userAPI.DeleteAccount)\n\n\t// signup HTTP 요청을 처리합니다.\n\tbody, _ := json.Marshal(sampleUser)\n\thttpRequest, _ := http.NewRequest(\"POST\", \"/signup\", bytes.NewBuffer(body))\n\tresponseRecorder := httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\tt.Log(responseRecorder.Body.String())\n\n\t// 응답 상태 코드가 201인지 확인합니다.\n\tif assert.Equal(t, http.StatusCreated, responseRecorder.Code) {\n\t\tt.Log(\"SignUp 테스트 통과\")\n\t}\n\n\t// login HTTP 요청을 처리합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: sampleUser.EmailAddress,\n\t\tPassword:     sampleUser.Password,\n\t}\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogIn 테스트 통과\")\n\t}\n\n\t// logout HTTP 요청을 처리합니다.\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/logout\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", responseRecorder.Body.String())\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogOut 테스트 통과\")\n\t}\n\n\t// deleteAccount HTTP 요청을 처리합니다.\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 전 LogIn 테스트 통과\")\n\t}\n\n\tt.Log(\"Session-Key:\" + responseRecorder.Body.String())\n\tvar responseBody map[string]string\n\tjson.Unmarshal(responseRecorder.Body.Bytes(), &responseBody)\n\tsessionKey := responseBody[\"sessionKey\"]\n\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/deleteAccount\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", sessionKey)\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 테스트 통과\")\n\t}\n}\n```\n\n---","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":1,"classes":"wide","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","date":"2024-02-26T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-02-27-Chat Application review(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-27-Chat Application review(2).md","category":"개발일지","title":"ChatApplication Review(2)","subtitle":"컨테이너화, ChatDBManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n\n단순히 프로그램이 동작하는 것을 넘어서, 오랜 기간동안 개발 및 유지될 것을 고려하면 많은 부분이 달라진다는 것을 경험할 수 있었다. unittest들이 작성돼있었던 덕분에 sessionManager 같은 것들을 refactor했는데도 동작이 여전히 가능하단 것을 쉽게 확인할 수 있었지만, 동시에 이를 자동화하기 위한 방법도 고려해 둬야한다는 것도 알 수 있었다.\n\n또한 이후 개발에 있어서 현재 예측할 수 없는 스펙 부분에 대응하기 위해 가능한 많은 부분을 유연하게 만들어두는 것이 중요하다는 것도 알 수 있었다. 내가 현재 생각해 둔 디렉토리의 형태부터 시작해서 변수/파일명, 인터페이스 접근 방식 등 생각보다 훨씬 많은 것들에 대해 유연하게 대응할 수 있도록 만들어둘 수 있는 부분이 많았다.\n\n그리고 containerization이 끝났다 해서 이를 remote cloud server에 올리는 것이 단순하지만은 않다는 것도 느낀다.\n\n---\n\n\n## 진행 내용\n\n* 배포를 위한 containerization 작업 완료\n* 채팅 기능을 위한 모듈들의 기본적인 구조 설계 및 이에 따른 구조 refactoring\n* 채팅에서 사용할 mongodb 인터페이스 설계\n\n---\n\n## 문제 및 해결 방법\n\n### 문제: 빌드한 어플리케이션이 로컬에서와 다르게 동작함\n  1. postgresql과의 연결이 안됨\n     * 기존에 hostname이 localhost로 돼있었는데, containerization을 할 경우 이를 postgresql로 DBManager를 바꿔야하기 때문.\n     * 로컬에서 테스트할 경우에 문제가 되는 부분이기 때문에 이를 양쪽 환경에서 다르게 쓸 방법을 찾아야함.\n  2. Failed to process session key 에러가 발생하고 있음.\n\t * 이는 로컬에서는 발생하지 않았던 에러로, 이를 해결하기 위해선 어떤 부분이 문제인지 파악해야함.\n\t * 이를 위해선 로컬에서와 동일한 환경을 만들어야함.\n\t * postgresql과 마찬가지로 hostname을 localhost를 쓰던 것이 문제였고, 이를 redis로 바꿔야함.\n   \n### 해결 방법:\n  * ENV를 사용하여 환경변수를 설정하고, 없을 경우에는 default인 localhost를 사용하게 해서 local에서 동작하도록 변경함.\n  * 해당 ENV는 docker-compose.yml와 dockerfile에서 사용하도록 변경함.\n   * [https://github.com/kaestro/ChatApplication/commit/e6258879d661345d7aeeac0a05ed953e8bd05a0e](https://github.com/kaestro/ChatApplication/commit/e6258879d661345d7aeeac0a05ed953e8bd05a0e)\n  * ex)\n\n    * before)\n```go\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n```\n\n\t* after)\n```go\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdbURL := os.Getenv(\"DB_URL\")\n\t\tif dbURL == \"\" {\n\t\t\tdbURL = \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\" // default value\n\t\t}\n\t\tdb, err := gorm.Open(\"postgres\", dbURL)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n```\n\n---\n\n### 문제: 몽고 db의 인터페이스 설정\n\n1. 허용하고자 하는 동작은 어느 것들이 있는가\n2. 기존의 디렉토리와 함께했을 때 구성은 어떻게 해야하는가\n  * models같은 경우에는 api/models 디렉토리 상에 위치하고 있는데, 이를 몽고 db의 internal에서도 사용해야하는 시점에서 디렉토리 구성을 개선할 필요가 발생함.\n\n### 해결 방법:\n\n1. 일단 나머지 모듈들을 만들어서 테스트하는 데에 필요한 AddMessage, GetMessages, CreateChatRoom, GetChatRooms 정도의 함수를 만든다.\n2. internal/db/mongodb 디렉토리를 만들고 여기에 ChatDBManager.go를 만들어 몽고 db들 중 chat에 한정한 인터페이스로 이번에 작성한 모듈이 국한되도록 한다.","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":2,"classes":"wide","title":"ChatApplication Review(2)","subtitle":"컨테이너화, ChatDBManager","date":"2024-02-27T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-06-Chat Application review(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-06-Chat Application review(3).md","category":"개발일지","title":"ChatApplication Review(3)","subtitle":"팀원 모집, 확장성 높은 디자인, CI/CD","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n---\n\n## 느낀 점\n\n---\n\n## 진행 내용\n\n* 추가 진행에서 협업할 인원 모집\n* 채팅 기능을 위한 모듈들의 작성\n* 설계 조건 맞추기 위한 이론적인 구상\n* 협업을 위한 환경 설정\n\n---\n\n## 문제 및 해결 방법\n\n### 문제 요구 스펙 관련해서 Redis와 같은 세션을 여러개 사용해야할 가능성이 높다는 것을 확인\n\n* RedisStore가 고정적으로 하나의 Redis와의 연결만을 생성할 수 있었음.\n\n### 해결 방법\n\n* StoreFactory를 만들고, RedisStoreFactory를 분리.\n* RedisStoreFactory가 추후에 여러가지 Redis연결을 생성하는 것이 용이하도록 구성함.\n\n```go\ntype RedisStoreFactory struct{}\n\nfunc (factory *RedisStoreFactory) Create(sessionTypeNum SessionType) SessionStore {\n\tvar store SessionStore\n\tif sessionTypeNum == LoginSession {\n\t\tredisAddr := os.Getenv(\"REDIS_ADDR\")\n\t\tif redisAddr == \"\" {\n\t\t\tredisAddr = \"localhost:6379\" // default value\n\t\t}\n\n\t\tstore = &RedisStore{\n\t\t\tclient: redis.NewClient(&redis.Options{\n\t\t\t\tAddr:     redisAddr,\n\t\t\t\tPassword: \"redisPassword\", // no password set\n\t\t\t\tDB:       0,               // use default DB\n\t\t\t}),\n\t\t}\n\t} else if sessionTypeNum == OtherSession {\n\t\tpanic(\"Unauthorized session type number given to RedisStoreFactory.\")\n\t}\n\treturn store\n}\n```\n\n---\n\n### 문제: 여러가지 측면에서 다른 사람의 도움이 있으면 속도가 빨라질 것 같다는 생각이 듬\n\n1. 설계적인 측면에서 second opinion이 필요함.\n2. 코드 리뷰를 통해 유지보수성을 높일 필요가 있음.\n3. 작성해야하는 코드의 양이 많아짐.\n\n### 해결 방법\n\n- 커뮤니티에 모집글을 게시\n- 연락이 온 사람과 화상 미팅 진행\n  - 2명 모집.\n  - 일주일간 진행해보고 계속할 지 여부에 대해 결정하기로 함.\n\n\n---\n\n### 문제: 협업을 위한 환경 설정\n\n1. 브랜치를 관리하기 위한 규칙이 필요\n2. ci를 위한 설정이 필요\n\n\n### 해결 방법\n\n1. 브랜치 관리 규칙을 정함\n\t* main: 배포용 브랜치\n    \t* push 불가능\n\t* pull request 규칙 설정\n\t\t* 승인을 받아야만 merge 가능\n\t\t* 코드 소유자의 리뷰가 필요\n2. github action을 통해 ci를 설정함\n\t* go 프로젝트 빌드/테스트가 성공해야만 merge 가능\n\t\t* [TODO] 기존의 테스트 코드들이 mock을 사용하지 않아서 테스트가 불가능한 상황 해소 필요\n\t* docker 빌드가 성공해야만 merge 가능\n\n```yaml\nname: CI\n\non:\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: 1.22\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Dockerfile main_server 빌드\n      run: docker build -t main_server:latest .\n      working-directory: myapp\n\n    - name: Build with docker-compose\n      run: docker-compose up -d\n      working-directory: myapp\n\n    - name: Test\n      run: go test ./...\n      working-directory: myapp\n\n    - name: Build\n      run: go build ./...\n      working-directory: myapp\n```\n\n---\n\n### 문제: azure에 컨테이너를 통한 배포\n\n* 컨테이너에 앞서 이에 포함된 main_server를 acr(azure container registry)에 올리는 과정에서 문제가 발생함.\n  * [Docker를 통한 어플리케이션 생성 wiki](https://github.com/kaestro/ChatApplication/wiki/Docker%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%83%9D%EC%84%B1)\n  * [Azure Container Registry](https://github.com/kaestro/ChatApplication/wiki/Azure-Container-Registry)\n\n### 해결 방법\n\n* 기존에 acr의 이름이 너무 길어서 camelCase를 사용했던 것이 문제였음. docker는 push할 때 대/소문자가 있을 경우 인증 오류를 발생시킬 수 있음.\n* [공식문서](https://learn.microsoft.com/ko-kr/azure/container-registry/container-registry-faq#az-acr-login-succeeds-but-docker-fails-with-error--unauthorized--authentication-required)\n* 기존의 purmirContainerRegistry를 purmir로 변경함.\n\n---\n\n### Kubernetes를 통한 배포\n\n### 문제: kubernetes로 로컬에 클러스터를 생성한 상태에서 요청이 이루어지지 않고 있음.\n\n### 해결 방법\n\n* log를 일단 읽어야 문제 해결이 가능할 것 같음.\n* kubernetes에 대한 이해 필요\n* 혹은 kubernetes 이외의 방법을 통한 배포를 고려해야할 수도 있음.","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":3,"classes":"wide","title":"ChatApplication Review(3)","subtitle":"팀원 모집, 확장성 높은 디자인, CI/CD","date":"2024-03-06T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-17-Chat Application review(4)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-17-Chat Application review(4).md","category":"개발일지","title":"ChatApplication Review(4)","subtitle":"code study, 설계도, azure cost analysis","content":"\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n---\n\n## 느낀 점\n\n* 팀원 간에 목표를 공유하고 지식을 전파해 두는 것의 어려움과 필요성.\n* 공유해야하는 지식들의 다양함과 효율적인 공유 방법.\n* 프로젝트를 진행할 때 cost analysis의 중요성.\n\n---\n\n## 진행 내용\n\n* 팀원에게 프로젝트 목표 공유\n* 프로젝트 상세 내용 설명 및 진입점 제안\n* 설계도 작성\n* Azure Cost Analysis\n\n---\n\n## 문제 및 해결 방법\n\n### [1] 모집한 팀원이 프로젝트 작업을 시작하기 위한 목표 공유가 필요했음\n\n### [1] 해결 방법\n\n* 코드를 함께 읽어나가는 study session을 진행함.\n* README.md 업데이트를 통해 프로젝트 목표를 제시함.\n* mockTestImplementation이라는 브랜치 생성 및 팀원들에게 이를 진입점으로 제안함.\n* draw.io를 통한 설계도 작성 및 공유\n  * [설계도 링크](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n### [2] Azure Cost Analysis\n\n* Azure의 무료 이용 기간이 끝나고 한달 예상 비용이 40만원으로 예측됨.\n\n### [2] 해결 방법\n\n* 현재 Azure 구독을 정지시켜둔 상태.\n* 주로 발생하는 비용은 ACR(Azure Container Registry)와 AKS(Azure Kubernetes Service)의 비용으로 예상됨.\n* ACR을 Docker Hub로 변경하고, serverless로 전환하여 비용을 절감 가능할 것으로 예상.\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":4,"classes":"wide","title":"ChatApplication Review(4)","subtitle":"code study, 설계도, azure cost analysis","date":"2024-03-17T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-19-Chat Application review(5)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-19-Chat Application review(5).md","category":"개발일지","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **문제 및 해결 방법**\n\n---\n\n## 느낀 점\n\n* **기술 스택**을 선택할 때, **명확한 기준**을 통한 비교를 할 필요성을 체감\n* 당장 수요에 맞는 **가벼운 기술**을 선택하되, 규모가 커질 것을 대비하여 **확장성**을 고려해야 함.\n* **MVP**(Minimum Viable Product)를 정의 내리고 이를 기준으로 기존 **기술 스택 선택**이 **타당성**을 검토해야 함.\n* **결론**:\n  * **MVP**: postgresql, redis, rabbitMQ, golang - gin\n  * **확장**: mysql, memcached, kafka, mongodb\n\n---\n\n## 진행 내용\n\n* **설계도**에서 서비스별 사용하기로 한 **기술스택**에 대한 대안 검토\n  * [**설계도 링크**](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n## 문제 및 해결 방법\n\n### [1] **기술 스택** 선택에 대한 명백한 **근거** 부족\n\n* 기술 스택 선택에 대한 **명백한 근거**가 부족.\n* 현재 기술 스택의 **장단점**을 명확히 파악하지 못하고 있음.\n* 단순히 **유명하고 핫하기 때문**에 선택한 경우가 많음.\n* 기술 스택의 **장점**을 **활용**하지 못하고 있음.\n* 이에 따라 **이미 사용 가능한 기술**을 충분히 활용하지 못하고 있음.\n* **프로젝트가 진행**되기보다 새로운 기술을 학습하는 데 더 많은 시간을 할애하고 있음.\n\n### [1] 해결 방법\n\n* 모듈 혹은 서비스 별로 사용되는 **기술스택**의 **대안**을 조사하고, 이에 대한 **비교**를 통해 명확한 기준을 세움.\n\n* **웹서버**\n  * 현재 사용중인 기술 스택: **golang - gin**\n  * **대안**: node.js - express, java - spring boot, python - fast api\n  * **기존 기술** 선택 이유: golang이 가진 **웹서버 성능** 및 **동시성 처리**에 대한 장점.\n  * 의문점\n    * 다른 기술 스택에 비해 **golang**은 어떤 점에서 **동시성 처리**에 더 유리하다고 말할 수 있는가?\n      * **[Golang은 진정 동시성을 처리하는 데 유리한가?](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/03/19/Golang%EC%9D%80-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%97%90%EC%84%9C-%EC%9C%A0%EB%A6%AC%ED%95%9C%EA%B0%80.html)**\n* **데이터베이스**\n  * 현재 사용중인 기술 스택: **postgresql**\n  * 대안: **mysql**\n  * **기존 기술** 선택 이유: 사용 **경험**이 있음\n  * 조사 결과 PostgreSQL은 mySQL에 비해 **복잡한 동작**을 필요로 할 때 사용하는 기술 스택으로 알려져 있다.\n    * **<https://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/>**\n  * 팀원들도 mysql에 경험이 더 많은 편이므로, **mysql로 이전**하도록 생각하고 있다.\n* **NoSQL**\n  * 현재 사용중인 기술 스택: **mongodb**\n  * 대안: 유저 정보 저장에 사용하는 **SQL 데이터베이스**에서의 통합\n  * 기존 기술 **선택 이유**: **문서형 데이터베이스**로서 가지는 장점이 있다는 점.\n  * **문제점**\n    * 그 장점이 뭔지 모름\n    * 문서형 데이터베이스가 무엇인지도 잘 모름\n  * **mongoDB**의 장점\n    * **데이터 형태**에 구애를 덜 받으므로 **이모티콘**과 같은 string 외 **다양한 데이터**를 처리하는 데에 용이하다\n    * **채팅 방 단위**로 데이터를 구현시에 **기존 데이터**를 **신규 입장자**에게 제공하기 유리하다\n  * **RDBMS**의 장점\n    * string만 사용할 경우 table과 로직을 통해서 **기초적인 채팅**을 **빠르게 구현**할 수 있다.\n  * **선택**: **RDBMS**(mysql/postgresql) 중에 하나로 **채팅의 interface**를 구현하고, **string에 한정**한 뒤 방 입장시에 **접속 이전 데이터**를 제공하지 않는 방향으로 **mvp**를 구성한 뒤에 기능을 **확장**하는 과정에서 **mongoDB** 도입을 고려한다.\n  * **추가**적인 mongoDB 및 문서형 데이터베이스에 대한 **연구** 필요\n* **세션**\n  * 현재 사용중인 기술 스택: **redis**\n  * 대안: **memcached**, 세션이 아닌 **토큰**(JWT 등)을 사용\n  * 기존 기술 **선택 이유**\n    * 사용해 본 적이 있는 기술 스택\n    * 유명해서 자료를 구하는 것이 용이\n  * 참고 자료\n    * [**Redis vs Memcached**](https://velog.io/@sileeee/Redis-vs-Memcached)\n    * [**Session storage로 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)**](https://1-7171771.tistory.com/127)\n    * [**Memcached vs Redis: Choose Your In-Memory Cache**](https://kinsta.com/blog/memcached-vs-redis/)\n  * **Memcached**\n    * 장점\n      * 적은 **메모리 사용량** - 적은 메타 데이터\n      * 안정적인 **응답 시간**\n      * **데이터 변경이 적은 경우** 메모리 파편화가 적음\n      * **수평적 확장**이 쉬움 - **multi-threading** 지원\n    * 단점\n      * 적은 **데이터 타입**과 **API**\n      * **데이터 변경이 잦은 경우**에 파편화가 많이 발생\n  * **Redis**\n    * 장점\n      * 다양한 **데이터 타입**과 **기능**\n      * 많은 사용자\n      * **디스크**에 저장 가능\n      * **Key**에 저장할 수 있는 **데이터의 크기**가 큼\n      * **pub/sub**을 지원해서 **메시지 큐**로도 사용 가능\n    * 단점\n      * **메모리 사용량**이 많음(실제 필요량보다 **2배** 가까이 사용하는 구조)\n      * 트래픽이 많은 경우 **응답 시간**이 불안정 - **발생 가능성 낮음**\n  * **선택**\n    * **MVP**의 관점에서 더 빠르게 시작할 수 있는 것은 Redis이다. 이는 **기능 및 데이터 타입**을 여럿 이미 구현돼 있기 때문이다.\n    * 트래픽이 많은 경우에 응답 시간이 얼마나 불안정해지는지 **측정**할 방법을 마련해두고, 그에 따라 **Memcached**로 전환할지 여부를 결정한다.\n    * Redis를 사용하면 다른 기술 스택 없이 **메시지 큐**를 처리할 수 있을 지도 모름\n* **메시지 큐**\n  * 현재 **사용 예정**이었던 기술 스택: **kafka**\n  * 대안: **RabbitMQ**, **ActiveMQ**\n  * 기존 기술 **선택 이유**\n    * 메시지 큐 기술들 중 가장 **유명**해서.\n  * 추가적으로 따로 글을 파서 고민해봐야 할 듯\n  * **참고 자료**\n    * **<https://gwonbookcase.tistory.com/49>**\n    * **<https://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html>**\n  * **kafka**의 장점\n    * **분산 처리 기능**을 가장 잘 활용할 수 있음.\n    * 메모리가 아니라 **파일 시스템**을 이용한다.\n    * **TPS**가 높고 **대용량 실시간 로그 처리**에 유리하다\n    * broker가 **push**하는 것이 아니라 **pull**하는 방식\n  * **activeMQ** vs **rabbitMQ**\n    * rabbitMQ가 **더 다양한 프로토콜**을 지원하고, activeMQ는 **java**에 더 특화된 모양이라 이 부분은 연구 필요\n  * **선택**\n    * **RabbitMQ**로 MVP를 구현하고, **확장성**이 필요할 경우 **Kafka**로 전환하는 방향으로 진행한다.\n    * RabbitMQ가 kafka에 비해 보다 기능이 **간단**하고 **빠르게 구현**할 수 있을 것으로 예상되기 때문\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":5,"classes":"wide","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","date":"2024-03-19T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-29-Chat Application review(6)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-29-Chat Application review(6).md","category":"개발일지","title":"ChatApplication Review(6)","subtitle":"MVP, Develop Branch, Chat 모듈","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **진행 과정**\n\n---\n\n## 느낀 점\n\n---\n\n## 진행 내용\n\n* MVP(Minimum Viable Product) 설정\n* Develop Branch 생성\n* Chat 모듈 구현\n\n---\n\n## 진행 과정\n\n### MVP(Minimum Viable Product) 설정\n\n#### 문제: 너무 많은 기능을 구현하려고 하다 보니 진행이 되지 않음\n\n* 사용할 줄 모르고, **먼 훗날**에 사용할 것 같은 기능을 구현하려고 하다 보니 진행이 되지 않았다.\n  * kubernetes, message queue, etc...\n* 해당 기술들의 **필요성**이나 **장점**에 대한 인식도 모자랐다.\n\n#### 해결 방법\n\n* **MVP**를 설정하여 **필요한 기능만** 구현하도록 목표를 재설정했다.\n  * MVP: 사용자가 최소한으로 사용할 수 있는 제품\n* 재설정한 **목표**\n  * **User** 관련: 로그인, 회원가입\n  * **Chat** 관련: 채팅방 생성, 채팅방 입장, 채팅방 메시지 전송\n  * **Log** 관련: 채팅방 로그 저장, 채팅방 로그 조회\n\n---\n\n### Develop Branch 생성\n\n#### 문제: Main Branch 이전에 병합을 통한 확인이 필요\n\n* **Main Branch**는 실제로 배포를 해야하기 때문에 가능한 **안정적인 코드**가 들어가야 한다.\n* Main Branch 이전에 작성한 모듈들 간에 **호환성 확인 및 통합**을 위한 중간 Branch가 필요를 체감.\n\n#### 해결 방법\n\n* **Develop Branch**를 생성하여 Main Branch 이전에 코드를 병합하여 확인하도록 하였다.\n* Main Branch와 달리 Develop Branch는 **Admin**은 직접 코드 수정이 가능하도록 해 개발 진행 속도를 올릴 수 있도록 함.\n\n---\n\n### Chat 모듈 구현\n\n#### 진행 과정\n\n**최초**에는 참고자료 없이 **직접 구현** 시도. 이 과정에서 다음과 같은 것들을 구현 및 수정하였다.\n\n* **Room**과 **Client** 객체를 구현\n  * **Room**: 채팅방을 나타내는 객체\n    * 사용자를 추가, 제거\n    * 메시지 전송\n  * **Client**: 채팅방에 참여하는 사용자를 나타내는 객체\n    * 웹소켓을 소유\n    * loginSessionID를 통해 구분(userID로 구분이 나은가?)\n    * 메시지 전송\n* **connect**, **disconnect** 이벤트를 구현\n  * **connect**: 클라이언트가 채팅방에 입장\n  * **disconnect**: 클라이언트가 채팅방에서 퇴장\n\n#### 의문점\n\n* 방 관련\n  * 방들은 어느 **자료구조**로 저장해야하는가?\n  * **저장하는 장소**는 file인가 메모리인가?\n  * 메모리에 저장한다면 **서버가 감당할 수 있는 크기**는 어느 정도인가?\n  * 이것을 **별개의 서버**로 감당하게 하는 것이 좋은가?\n* 클라이언트 관련\n  * 웹소켓은 얼마나 오랫동안 **유지**해야하는가?\n  * 연결이 끊어질 경우 Client 객체를 **삭제**해야하는가?\n  * Client 객체를 만들고 삭제하는 것의 **부하**는 어느 정도인가?\n  * Client 객체는 방과 마찬가지로 어떻게 **관리**해야하는가?\n\n#### 진행 예정 사항\n\n다른 다중 채팅 프로그램이 구현된 오픈소스를 공부해보는 시간을 가질 예정\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":6,"classes":"wide","title":"ChatApplication Review(6)","subtitle":"MVP, Develop Branch, Chat 모듈","date":"2024-03-29T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-03-29-Chat Application review(7)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-29-Chat Application review(7).md","category":"개발일지","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","content":"\n## 목차\n\n- [목차](#목차)\n- [느낀 점](#느낀-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [Chat 모듈 구현](#chat-모듈-구현)\n    - [모듈 사양이 불명확할 때의 구현](#모듈-사양이-불명확할-때의-구현)\n      - [clientManager.go](#clientmanagergo)\n    - [추상화를 통해 모듈의 작업 단위를 세부적으로 분리](#추상화를-통해-모듈의-작업-단위를-세부적으로-분리)\n      - [room.go](#roomgo)\n      - [roomManager.go](#roommanagergo)\n    - [이후 진행 방향](#이후-진행-방향)\n\n---\n\n## 느낀 점\n\n1. 협업에서 모듈의 사양 합의가 돼있지 않을 때, 이에 대응하기 용이한 유연한 코드를 작성하는 방법\n2. MVP 내에서도 더 세부 단계에서 어디서부터 구현을 시작해야 하는지에 대한 고민\n3. 추상화를 통해 모듈 내부의 역할을 세부적으로 분리하는 방법\n4. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 검토의 필요성\n\n---\n\n## 진행 내용\n\n- Chat 모듈 구현\n\n---\n\n## 진행 과정\n\n### Chat 모듈 구현\n\n#### 모듈 사양이 불명확할 때의 구현\n\n- **문제**\n  - 다른 팀원과 모듈의 사양에 대해 합의가 돼있지 않다\n  - 내가 작성한 chat 모듈을 다른 팀원이 사용할 때 어떤 형태로 부를 것인지 불명확하다\n  - 내가 chat 모듈에서 이용해야하는 다른 모듈의 형태가 불명확하다\n\n- **해결**\n  - 코드를 가능한 작은 단위로 나누어 유연한 변경이 가능하도록 한다\n  - 함수에서 파라미터로 받는 값을 특정한 형태로 제한하고, 이를 활용하는 상위 모듈을 작성한다\n  - 상위 모듈에서는 추후에 다른 모듈에서 이를 호출할 때 필요한 값을 제한한다.\n\n##### clientManager.go\n\n```go\nfunc (cm *ClientManager) CheckClient(sessionID string) bool {\n  _, ok := cm.clients[sessionID]\n  return ok\n}\n\nfunc (cm *ClientManager) GetClient(sessionID string) *Client {\n  if !cm.CheckClient(sessionID) {\n    fmt.Println(\"Client with sessionID\", sessionID, \"does not exist\")\n    return nil\n  }\n\n  return cm.clients[sessionID]\n}\n```\n\n#### 추상화를 통해 모듈의 작업 단위를 세부적으로 분리\n\n- **문제**\n  - 단일 클래스들이 하는 역할이 너무 많아 코드가 복잡해졌다.\n    - 기존에는 client, room, socket이라는 세 개의 클래스를 통해 구현을 작업하려 했음.\n  - 각각의 클래스가 하는 일들이 무엇인지 구분하기 어려웠다.\n    - room, client는 방에 client를 추가하고 이들을 관리하는 작업들을 동시에 했다.\n  - 클래스 간에 하는 영역이 겹치는 부분이 많아 코드 중복이 발생했다.\n\n- **해결**\n  - 클래스가 할 일을 더 작은 단위로 나누어 추상화한다.\n    - [room](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/room.go)\n      - 방을 crud하는 메소드를 제공한다.\n      - 방에 들어온 client의 crud를 관리한다.\n      - 방에 들어온 client들 간의 메시지를 주고 받는 작업을 한다.\n  - 이 과정에서 사라진 이들을 관리하는 작업을 Manager 클래스로 분리한다.\n    - ClientManager, RoomManager, ChatManager 등으로 분리한다.\n    - [ChatManager](https://github.com/kaestro/ChatApplication/blob/4-chat-%EB%AA%A8%EB%93%88-%EC%9E%91%EC%84%B1/myapp/internal/chat/chatManager.go)는 최상위 클래스로, RoomManager, ClientManager를 통해 채팅 전반을 관리한다.\n\n##### room.go\n\n```go\nfunc NewRoom() *Room {\n  room := &Room{\n    client_chan: make(map[*Client]*websocket.Conn),\n    broadcast:   make(chan []byte),\n    register:    make(chan *ClientConn),\n    unregister:  make(chan *ClientConn),\n  }\n\n  go room.run()\n\n  return room\n}\n```\n\n##### roomManager.go\n\n```go\ntype RoomManager struct {\n  rooms map[string]*Room\n}\n\nfunc GetRoomManager() *RoomManager {\n  roomOnce.Do(func() {\n    roomManager = &RoomManager{\n      rooms: make(map[string]*Room),\n    }\n  })\n\n  return roomManager\n}\n\nfunc (rm *RoomManager) CheckRoom(roomID string) bool {\n  _, ok := rm.rooms[roomID]\n  return ok\n}\n\nfunc (rm *RoomManager) GetRoom(roomID string) *Room {\n  if !rm.CheckRoom(roomID) {\n    fmt.Println(\"Room with roomID\", roomID, \"does not exist\")\n    return nil\n  }\n\n  return rm.rooms[roomID]\n}\n```\n\n#### 이후 진행 방향\n\n1. 현재 작성중인 포멧의 추가 구현\n2. Interface 등의 더 상위 추상화를 통해 모듈 간의 의존성을 줄이는 작업 필요성 검토\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":7,"classes":"wide","title":"ChatApplication Review(7)","subtitle":"사양이 불명확할 때의 구현, 추상화를 통한 역할 분리","date":"2024-04-09T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-10-Chat Application review(8)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-10-Chat Application review(8).md","category":"개발일지","title":"ChatApplication Review(8)","subtitle":"팀 해체, 모듈 재설계 및 구현, CI 환경 구축","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [팀 해체](#팀-해체)\n  - [Chat 모듈 구현](#chat-모듈-구현)\n    - [Client/Room 로직 재설계 및 구현](#clientroom-로직-재설계-및-구현)\n    - [디버깅 및 테스트](#디버깅-및-테스트)\n  - [API 모듈 구현](#api-모듈-구현)\n    - [API 로직 분리 및 테스트 구현](#api-로직-분리-및-테스트-구현)\n  - [CI 환경 구축](#ci-환경-구축)\n    - [docker-compose](#docker-compose)\n    - [github actions](#github-actions)\n\n---\n\n## 배운 점\n\n1. 혼자서 개발하는 것과 팀으로 개발하는 것의 차이\n2. 잘못된 설계를 재설계하는 방법 및 설계의 중요성\n3. 시스템 구축의 어려움\n4. docker 서비스간 의존성 해소 방법\n5. 문제 발생의 주 원인은 휴먼에러다.\n\n---\n\n## 진행 내용\n\n- 팀 해체\n- Chat 모듈 구현\n- api 모듈 구현\n- CI 환경 구축\n\n---\n\n## 진행 과정\n\n### 팀 해체\n\n- **문제**\n  - 팀원 간의 기술 스택 이해도, 투여 시간 등의 차이로 협업의 장점이 발휘되지 않음\n  - 상대방에게 의존성을 강제한 협업 방식이 참여율이 저조해지면서\n    - code review가 없으면 pull request가 승인 되지 않음\n    - 독립적인 모듈들의 개발의 통합까지 도달하지 못함\n- **해결**\n  - 팀 해체\n- **결과**\n  - 실력과 현재 상황에 맞는 목표 재설정\n  - 개발 속도 향상\n\n결국 해체하기는 했지만, 다른 사람과 협업할 때 그 사람들과 소통하는 방법이나 이를 위해 통합 환경을 구축하는 방법에 대해서 배울 수 있었다. 또한 혼자서 개발을 진행했다면 구체적이고 실현 가능한 목표 설정에는 도달하는데는 지금보다 더 오랜 시간이 걸렸을 것이라 생각한다.\n\n---\n\n### Chat 모듈 구현\n\n#### Client/Room 로직 재설계 및 구현\n\n![image](https://imgur.com/eKEJVT0.jpg)\n\n- **문제**\n  - Client, Room 객체가 너무 많은 역할을 수행하고 있었음\n  - 한 개의 방이 여러 클라이언트를 가지는 구조에 대한 고려가 된 설계가 아니었음\n  - 하나의 client가 연결된 방마다 websocket connection을 가지고 있어야 해서 load가 높음\n\n- **[해결](https://github.com/kaestro/ChatApplication/tree/main/myapp/internal/chat)**\n  - Client, Room의 역할을 분리하는 객체를 추가\n    - clientManager, roomManager: client, room의 관리를 담당. 생성, 삭제, 조회 등의 기능을 제공한다.\n    - clientSession: client에서 room으로의 연결을 담당. client의 메시지를 room에 전달한다.\n    - roomClientHandler: room에서 client로의 연결을 담당. room의 메시지를 client에 전달한다.\n  - 구조 변경\n    - roomManager에서 관리하는 key를 roomName이라는 변수로 고정. 이에 따라 roomId를 삭제\n    - client는 여러 연결을 clientSession으로 관리\n    - room은 여러 연결을 roomClientHandler로 관리\n    - chatManager를 제외한 객체의 메소드는 private으로 변경\n  - client 재설계\n    - client는 websocket을 하나만 가지고, room 별로 chan을 clientSession을 통해 가진다.\n    - 이에 따라 메시지는 단순 byte가 아니라 ChatMessage 구조체로 전달한다.\n    - 이를 위한 ChatMessage 구조체를 정의하고, json으로 marshal/unmarshal하는 함수를 추가한다.\n\n여러 연결을 서로 가져야 하는 m to n 관계에서 중간 객체를 추가하여 관리하는 방법을 배웠다. 이를 통해 client와 room의 역할을 명확히 구분하고, 각 객체의 역할을 명확히 할 수 있었다. 결과적으로 client와 room의 수명을 분리하여 관리할 수 있게 되는 등 코드의 전반적인 유연성과 가독성이 향상되었다.\n\n#### 디버깅 및 테스트\n\n- **문제**\n  - 함수의 파라미터, 반환값의 타입이 겹치는 것이 많아 순서를 틀리는 휴먼 에러가 주 원인이 되었음\n  - 소켓 프로그래밍 프로세스 및 프로토콜에 대한 이해 부족\n  - 설계 이상으로 필요한 하위 모듈이 많아짐\n- **해결 방안**\n  - types, jsonProperties 패키지를 추가하여 타입을 명확히 구분\n  - 이들을 이용한 재구조화 진행 예정.\n  - 모듈의 추가적인 분리 및 통합을 진행하고 테스트 코드를 작성할 예정\n  - 소켓의 handshake와 같은 프로토콜에 대한 이해를 높이기 위한 학습 예정\n\n시스템적으로 사람이 실수할 수 있는 부분을 최소화하기 위한 노력이 많이 필요하고, 이것이 가장 많은 시간을 소요하는 부분이었다. 컴퓨터가 이해하는 코드를 짜는 것은 쉽지만, 사람이 이해하는 코드를 짜는 것은 어렵다.\n\n---\n\n### API 모듈 구현\n\n#### API 로직 분리 및 테스트 구현\n\n![image](https://imgur.com/BJgnieR.jpg)\n\n- **문제**\n  - 기존의 모듈이 handler와 logic이 혼재되어 확장성(테스트, 로직 변경 및 추가)이 떨어짐\n  - 테스트 코드에 대한 규약을 변경하면서 기존의 테스트 코드에 대한 전면적인 수정이 필요함\n\n- **해결**\n  - logic과 handler를 분리\n  - 해당 과정에서 로직을 더 작은 단위로 나누어 작성\n  - handler와 loginc에 대한 테스트 코드 작성\n\nhandler와 service를 분리하는 이유에 대해 이해할 수 있었다. 이를 구분함으로써 handler는 요청을 받아서 응답을 보내는 역할만 하게 되었고, logic은 handler에게 요청을 받아서 데이터를 처리하는 역할만 하게 되었다. 이를 통해 각각의 테스트 코드를 작성하고 신뢰성을 확보하기 용이하고, 유연한 코드 작성을 통해 코드의 확장성을 높일 수 있었다.\n\n### CI 환경 구축\n\n#### docker-compose\n\n```yml\n# docker-compose.yml\nversion: '3'\nservices:\n  postgresql:\n    image: postgres:latest\n    environment:\n      - POSTGRES_DB=postgres\n      - POSTGRES_PASSWORD=rootpassword\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgresql_data:/var/lib/postgresql/data\n\n  db_init:\n    build: ./db_init\n    environment:\n      - POSTGRES_PASSWORD=rootpassword\n    depends_on:\n      - postgresql\n\n  redis:\n    image: redis:latest\n    command: redis-server --requirepass redisPassword\n    ports:\n      - \"6379:6379\"\n  \n  chatroom_list:\n    image: redis:latest\n    command: redis-server --requirepass redisPassword\n    ports:\n      - \"6380:6380\"\n\n  mongodb:\n    image: mongo:latest\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongodb_data:/data/db\n  \n  main_server:\n    build: ./myapp\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - postgresql\n      - redis\n      - mongodb\n    environment:\n      - REDIS_ADDR=redis:6379\n      - REDIS_PASSWORD=redisPassword\n      - DB_URL=postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\n      - MONGO_URL=mongodb://mongodb:27017  \n\n  test:\n    build: \n      context: ./myapp\n      dockerfile: Dockerfile.test\n    depends_on:\n      - main_server\n      - postgresql\n      - redis\n      - mongodb\n      - db_init\n    environment:\n      - REDIS_ADDR=redis:6379\n      - REDIS_PASSWORD=redisPassword\n      - DB_URL=postgres://postgres:rootpassword@postgresql:5432/postgres?sslmode=disable\n      - MONGO_URL=mongodb://mongodb:27017\n\n\nvolumes:\n  postgresql_data:\n  mongodb_data:\n```\n\n- **문제**\n  - 기존의 테스트 방식은 자동화 돼있지 않았음.\n    - 테스트의 오류가 발생시 로직 상의 문제인지, 환경의 문제인지 판단하기 어려웠음\n    - 테스트를 까먹는 경우가 발생함\n    - 새로운 환경에서 테스트를 진행할 때 환경 구축에 시간이 소요됨\n\n- **해결**\n  - docker-compose를 통한 테스트 환경 구축\n    - 테스트 환경을 [docker-compose](https://github.com/kaestro/ChatApplication/blob/main/docker-compose.yml)로 구축한다\n      - db_init, wait-for-it, wait-for-postgres 등의 서비스를 추가\n    - 테스트 환경을 구축하는 과정을 자동화하여 테스트 환경을 쉽게 구축할 수 있게 함\n\n빌드를 할 경우에, 단순 빌드 뿐 아니라 내부 테스트를 진행하고 오류의 여부에 대해 시스템적으로 확인할 수 있게 됐다. 이를 통해 테스트를 까먹는 경우를 방지하고, 테스트 환경을 구축할 필요가 없어진다. 이를 통해 테스트를 자주 진행할 수 있게 되었고, 테스트를 통해 코드의 신뢰성을 확보할 수 있게 되었다.\n\n#### github actions\n\n```yml\n# .github/workflows/ci.yml\nname: CI\n\non:\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n\n    - name: Set up Go\n      uses: actions/setup-go@v2\n      with:\n        go-version: 1.22\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n\n    - name: Build and Test with docker-compose\n      run: |\n        docker-compose run --rm test\n        docker-compose logs test > test.log\n        echo \"exit_code=$?\" >> $GITHUB_ENV\n        docker-compose down\n\n    - name: Upload test log\n      uses: actions/upload-artifact@v2\n      with:\n        name: test-log\n        path: test.log\n\n    - name: Exit with code\n      run: exit ${{ env.exit_code }}\n```\n\n- **문제**\n  - 테스트 결과를 확인하기 위해 로컬에서 테스트를 진행해야 함\n  - 여러 독립적인 모듈을 리모트한 환경에서 테스트하는 것이 불가능해 이를 수동으로 진행해야 함\n  - 테스트가 다른 모듈이 준비가 완료되기 전에 진행되거나, table이 없는 상태에서 테스트가 진행되는 등의 문제가 발생함\n  - github actions 테스트 결과를 확인할 방법이 없었음\n\n- **해결**\n  - github actions를 통한 테스트 자동화\n  - db_init, wait-for-it, wait-for-postgres 등을 통한 테스트 환경이 remote에서도 구축됨\n  - upload-artifact를 통해 테스트 결과를 확인할 수 있음\n\n여러 모듈을 독립적으로 개발한 뒤 통합하는 과정에서 테스트를 자동화 하는 시스템을 구축했다. 또한 docker 내에서 여러 서비스 간의 의존성을 해결하는 방법을 배웠다.\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":8,"classes":"wide","title":"ChatApplication Review(8)","subtitle":"팀 해체, 모듈 재설계 및 구현, CI 환경 구축","date":"2024-04-10T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-12-Chat Application Readme","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-12-Chat Application Readme.md","category":"개발일지","title":"API Server For ChatApplication","subtitle":"","content":"\n## 개요\n\n백엔드 개발에서 요구되는 능력들 중 **실시간 통신, 데이터베이스 및 API 서버 구축, 인증 및 보안** 등의 능력 향상을 목적으로 한 **[채팅 어플리케이션 API 서버](https://github.com/kaestro/chatapplication)**입니다.\n\n기초적인 채팅 메시지 전송 및 수신, 사용자 인증, 사용자 정보 관리에서 시작해, 최종적으로는 대규모 인원의 동시 접속 및 트래픽을 처리할 수 있는 서버를 구축하는 것을 목표로 하고 있습니다.\n\n최신의 테스트가 끝난 형태의 코드는 **main branch**에서, 테스트 진행중인 코드는 **develop branch**, 개발중인 기능은 **feature branch**에서 확인하실 수 있습니다.\n\n---\n\n## 목차\n\n- [개요](#개요)\n- [목차](#목차)\n- [MVP(Mininum Viable Product)](#mvpmininum-viable-product)\n- [기술 스택](#기술-스택)\n- [구조](#구조)\n  - [chat](#chat)\n  - [api](#api)\n  - [db/session](#dbsession)\n- [프로젝트 규칙](#프로젝트-규칙)\n  - [코드 컨벤션](#코드-컨벤션)\n  - [git branch 전략](#git-branch-전략)\n  - [test](#test)\n  - [github actions](#github-actions)\n- [확장 계획](#확장-계획)\n  - [1차 목표](#1차-목표)\n  - [2차 목표](#2차-목표)\n- [인프라 현상황 및 차후 구상](#인프라-현상황-및-차후-구상)\n\n---\n\n## MVP(Mininum Viable Product)\n\n현재 목표로 하는 채팅 프로그램의 가장 **기본적인 기능**은 다음과 같습니다.\n\n```md\n1. 로그인 및 회원가입\n2. 채팅방 생성 및 입장\n3. 채팅 메시지 전송 및 수신\n```\n\n---\n\n## 기술 스택\n\n현재 진행 중인 프로젝트의 기술 스택은 다음과 같습니다.\n\n- 웹서버\n  - goLang\n  - gin framework\n- 데이터베이스\n  - postgresql\n- 세션 관리\n  - redis\n- CI\n  - github actions\n  - docker\n- 형상관리\n  - git\n\n다중 접속자 간의 실시간 통신은 동시에 여러 사용자가 상호작용하는 웹서버를 구축해야하기 때문에, 이를 위해 동시성 처리에 유리한 goLang을 선택했습니다. gin framework는 goLang의 웹 프레임워크 중 사용이 간편하고 속도가 빠르다는 평가가 있어 선택했으며, 그 밖의 기술들은 기존에 제가 사용해 본 적이 있는 것들이거나 배우는 데에 많은 부하가 걸리지 않는 것들 위주로 선택했습니다.\n\n이들을 선택한 자세한 이유는 **[다음 포스트](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/03/19/Chat-Application-5%EC%A3%BC%EC%B0%A8-review.html)**에서 확인하실 수 있습니다.\n\n---\n\n## 구조\n\n진행 중인 프로젝트의 구조는 크게 api, db/session, chat 3가지로 나누어져 있습니다.\n\n```md\nmyapp\n├── api\n│   ├── handler\n│   ├── model\n│   └── service\n├── internal\n│   ├── db\n│   ├── chat\n│   └── session\n├── main.go\n└── go.mod\n```\n\n### chat\n\nchat 모듈은 사용자의 실시간 통신을 위한 내부 로직을 처리하는 중추적인 역할을 합니다. 사용자의 메시지 전송 및 수신, 채팅방의 생성 및 입장 등의 기능을 처리합니다. 구조는 다음과 같습니다.\n\n```md\nchat\n├── chatManager.go\n├── roomManager.go\n├── clientManager.go\n├── room.go\n├── roomClientHandler.go\n├── client.go\n└── clientSession.go\n```\n\n[chatManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/chatManager.go)는 chat 모듈 외부에서 chat 모듈을 사용하기 위한 인터페이스를 제공합니다.\n\n[roomManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/roomManager.go)/[clientManager](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/clientManager.go)는 room/client의 생성 및 삭제와 같은 기능을 처리합니다.\n\n[room](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/room.go)은 채팅방을 나타내는 구조체로, 채팅방의 정보와 채팅방에 속한 클라이언트들을 관리합니다. 이 때 roomClientHandler를 통해 클라이언트에게 메시지를 전송하는 등의 상호작용을 처리합니다.\n\n[client](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/chat/client.go)는 사용자를 나타내는 구조체로, 사용자의 정보와 사용자의 세션을 관리합니다. 이 때 clientSession을 통해 room에 메시지를 전송하는 등의 상호작용을 처리합니다.\n\n### api\n\n```plaintext\napi\n│\n├───handlers\n│   ├───userHandler\n│   └───chatHandler\n│\n├───service\n│   ├───userService\n│   └───chatService\n│\n└───models\n```\n\napi는 사용자의 http request를 받아 처리하는 역할을 합니다. 사용자의 요청을 받아 처리하는 handler, 데이터베이스와 통신하는 model, 비즈니스 로직을 처리하는 service로 나누어져 있습니다.\n\n작성한 될 api의 종류에는 user의 인증, 채팅방의 생성 및 입장, 채팅 메시지의 전송 및 수신 등이 있습니다.\n\n주로 사용하는 기술 스택은 goLang과 gin framework입니다.\n\n### db/session\n\n![db](/images/chatapplication%20소개/db.png)\n![session](/images/chatapplication%20소개/session.png)\n\ndb와 session은 데이터베이스와 세션을 관리하는 역할을 합니다. 데이터베이스는 사용자의 정보, 채팅방의 정보, 채팅 메시지 등을 저장하고, 세션은 사용자의 로그인 상태를 관리합니다.\n\n데이터베이스는 postgresql을 사용하고, 세션은 redis를 사용합니다. interface로 추상화돼 있어 추후 다른 데이터베이스나 세션 관리 시스템을 사용할 수 있도록 설계했고, factory 패턴을 사용해 데이터베이스와 세션을 생성합니다. 각각의 객체는 싱글톤 패턴을 사용해 객체를 생성하고 관리합니다.\n\n---\n\n## 프로젝트 규칙\n\n프로젝트를 진행하면서 지키고자 하는 규칙은 다음과 같습니다.\n\n### 코드 컨벤션\n\n- goLang의 gofmt 규칙을 따른다\n- single responsibility principle을 따른다\n- 변수명이 하는 역할을 명확하게 반영하도록 한다\n\n### git branch 전략\n\n- main branch는 통합 테스트가 완료된 안정적인 상태를 유지한다\n- develop branch는 feature를 병합해서 테스트 중인 최신 상태를 유지한다.\n- feature branch는 기능별로 나누어 작성한다\n\n### test\n\n- 모든 코드는 unit test를 작성한다\n- 소스 코드의 test코드는 _test.go로 작성한다\n  - ex) chat.go -> chat_test.go\n- 모든 코드는 테스트 통과 후 pull request를 진행한다\n- 테스트는 가능한 자동화한다\n\n### github actions\n\n- develop/main branch에 대해 pull request가 올라오면 자동으로 [다음의 테스트](https://github.com/kaestro/ChatApplication/blob/main/.github/workflows/ci.yml)를 진행한다\n  - docker 빌드\n  - 웹서버 테스트\n\n---\n\n## 확장 계획\n\n### 1차 목표\n\n최소한의 채팅 기능이 구현된 이후에는 채팅 기능은 아니지만, 부가적인 기능들과 최소 기능을 구현하는 과정에서 생긴 의문점과 TODO로 작성하고 넘어간 부분들을 해소하는 것을 목표로 하고 있습니다.\n\n- 부가적인 기능의 예시\n  - 내부 로직 처리의 로그 기능 추가\n  - 로그 기능의 debugging, running mode 추가\n  - 미들웨어를 통한 반복적인 검증 로직 추가\n  - **[github issues](https://github.com/kaestro/ChatApplication/issues)**\n\n- **[의문점 예시](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/Questions.md)**\n  - clientManager/roomManager는 얼마나 오랫동안, 얼마나 많은 client/room를 관리할 수 있는가?\n  - garbage collection을 통해 client/room을 어떻게 관리할 것인가?\n  - key의 충돌 등이 일어나는 예외 사항에 대한 처리는 어떻게 할 것인가?\n\n- **[TODO](https://github.com/kaestro/ChatApplication/blob/main/myapp/internal/TODO.md)**\n\n### 2차 목표\n\n1차 목표를 달성한 이후에는 **대규모 인원과 트래픽을 처리**할 수 있는 서버를 구축하는 것을 목표로 하고 있습니다.\n\n**목표**로하고 있는 대규모 인원과 트래픽은 다음과 같이 **정의**했습니다.\n\n```md\n1. 15000명 이상의 동시 접속자 - steam 기준 인기 순위 100위의 동접자\n2. 분당 7000건 이상의 메시지 전송 - 아프리카 TV 기준 채팅방이 감당할 수 없었던 트래픽\n```\n\n이는 **분당 1억건** 이상의 메시지 전송을 처리할 수 있는 서버를 구축해야 한다는 것을 의미합니다. 이를 위해 추가적으로 **도입할 계획이 있는 기술**들은 다음과 같습니다.\n\n```md\n1. message queue\n2. load balancer\n3. nosql\n4. 부하 테스트\n```\n\n이 외에 유틸적인 측면 등에서 추가할 예정인 기능들은 다음 [문서](https://github.com/kaestro/ChatApplication/wiki/%EC%B6%94%ED%9B%84-%EC%B6%94%EA%B0%80-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%B6%80%EB%B6%84%EB%93%A4)를 참고해 주세요.\n\n---\n\n## 인프라 현상황 및 차후 구상\n\n현재 진행 중인 프로젝트의 인프라 구성 및 [설계도](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)는 다음과 같습니다.\n\n![image](https://camo.githubusercontent.com/b0ca2b60dbacab06d3aa600efaec77524fd96b74f9b7059b74288cac6c9ab486/68747470733a2f2f64726976652e676f6f676c652e636f6d2f75633f6578706f72743d646f776e6c6f61642669643d3176483557387a384d6333764a6262384e566b75384f704f687049686e6259477a)\n\n```md\n1. github actions\n2. docker\n3. go web server\n4. postgresql\n5. redis\n```\n\n차후 구상중인 인프라 구성 및 설계도는 다음과 같습니다.\n\n![image](https://github.com/kaestro/ChatApplication/assets/32026095/5d97f107-028d-476d-803e-e64a1f86e078)\n\n```md\n1. load balancer\n2. message queue\n3. nosql\n4. 부하 테스트\n5. cloud server\n```\n\n---\n","layout":"default","recommended":true,"data":{"layout":"default","classes":"wide","title":"API Server For ChatApplication","date":"2024-04-12T00:00:00.000Z","categories":"개발일지","recommended":true,"subtitle":""}},{"postName":"2024-04-15-Chat Application review(9)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-04-15-Chat Application review(9).md","category":"개발일지","title":"ChatApplication Review(9)","subtitle":"EnterChat 재설계, logging 기능 구현, routes 패키지 추가","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [EnterChat 재설계 및 구현](#enterchat-재설계-및-구현)\n  - [logging 기능 구현](#logging-기능-구현)\n  - [routes 패키지 추가](#routes-패키지-추가)\n  - [chat 테스트 CI에 추가](#chat-테스트-ci에-추가)\n\n---\n\n## 배운 점\n\n1. 혼자서 개발하는 것과 팀으로 개발하는 것의 차이\n2. 잘못된 설계를 재설계하는 방법 및 설계의 중요성\n3. 시스템 구축의 어려움\n4. docker 서비스간 의존성 해소 방법\n5. 문제 발생의 주 원인은 휴먼에러다.\n\n---\n\n## 진행 내용\n\n- EnterChat 재설계 및 구현\n- logging 기능 구현\n- routes 패키지 추가\n- chat 테스트 CI에 추가\n\n---\n\n## 진행 과정\n\n### EnterChat 재설계 및 구현\n\n- **문제**\n  - websocket이 연결되는 방식에 대한 이해 부족에 따른 잘못된 설계\n    - 접속 정보를 request body로 전송\n    - http request로 접속 정보를 전송 후 소켓 연결을 저장해두지 않음\n- **해결**\n  - websocket을 요청할 때 client.do가 아니라 dialer.Dial로 연결해서 connection을 저장\n  - 접속 정보 중 비밀번호를 제외한 정보를 loginSessionInfo라는 새로운 구조체로 전송\n  - 이 때 request body가 아닌 header에 저장\n- **결과**\n  - 채팅 메시지 송수신 확인\n\n### logging 기능 구현\n\n- **문제**\n  - 로그를 print로만 출력하고 있어서 디버깅이 어려움\n  - debug 로그만 남기고 있어, release 버전용 로그 기능이 필요함\n- **해결**\n  - gin의 Logger middleware를 통한 initialization을 구현\n  - 해당 과정에서 logging 패키지 추가\n\n### routes 패키지 추가\n\n- **문제**\n  - routes를 main.go에 직접 작성하고 있어 가독성과 확장성이 떨어짐\n- **해결**\n  - routes 패키지를 추가하여 routes를 분리\n\n### chat 테스트 CI에 추가\n\n- **문제**\n  - 기존에 db와의 연결 혹은 websocket 연결이 필요한 테스트를 CI에 추가하지 않음\n  - 이에 대한 테스트를 수동으로 진행함\n- **해결**\n  - chat 테스트를 CI에 추가\n  - github actions의 로그를 별도의 파일로 저장해서 확인 기능 추가\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":9,"classes":"wide","title":"ChatApplication Review(9)","subtitle":"EnterChat 재설계, logging 기능 구현, routes 패키지 추가","date":"2024-04-15T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-05-06-Chat Application review(10)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-06-Chat Application review(10).md","category":"개발일지","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [grafana k6를 통한 테스트용 client 작성](#grafana-k6를-통한-테스트용-client-작성)\n  - [pre-commit을 통한 코드 품질 관리 도입](#pre-commit을-통한-코드-품질-관리-도입)\n  - [docker를 통한 시스템 구축 시도 및 실패](#docker를-통한-시스템-구축-시도-및-실패)\n\n---\n\n## 배운 점\n\n1. grafana k6의 사용법\n2. 섣부른 시스템 구축의 위험성\n\n---\n\n## 진행 내용\n\n- grafana k6를 통한 테스트용 client 작성\n- pre-commit을 통한 코드 품질 관리 도입\n- docker를 통한 시스템 구축 시도 및 실패\n\n---\n\n## 진행 과정\n\n### grafana k6를 통한 테스트용 client 작성\n\n![테스트 클라이언트](/images/chatapplication%20review/testclient.png)\n\n- javascript, grafana k6를 통해 테스트용 클라이언트 작성\n- httpRequests, loadTest, utils 패키지로 구성\n- 기본 모듈단 작성 완료했으며, 이후에는 테스트 케이스를 작성할 예정\n\n---\n\n### pre-commit을 통한 코드 품질 관리 도입\n\n- **문제**\n  - 완전히 코드가 저장되지 않은 상태로 커밋을 하거나, 코드의 품질이 낮은 상태로 커밋을 하는 경우가 발생\n- **해결**\n  - pre-commit을 통해 코드 품질을 관리하고, 코드가 저장되지 않은 상태로 커밋하는 것을 방지\n- **결과**\n\n![pre-commit](/images/chatapplication%20review/precommit.png)\n\n---\n\n### docker를 통한 시스템 구축 시도 및 실패\n\n- **문제**\n  - docker를 통해 부하 테스트 시스템을 구축하려 했으나, mounting volume이나 복잡한 명령어 사용 등에 어려움을 겪음\n- **해결**\n  - docker를 통한 부하 테스트 시스템 구축 포기 및 로컬 환경에서 진행하기로 결정\n- **결과**\n  - 부하테스트 작성 시작\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":10,"classes":"wide","title":"ChatApplication Review(10)","subtitle":"test용 클라이언트 작성, pre-commit 도입, docker 시스템 구축 시도 및 실패","date":"2024-05-06T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-05-16-Chat Application review(11)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-05-16-Chat Application review(11).md","category":"개발일지","title":"ChatApplication Review(11)","subtitle":"작성중","content":"\n## 목차\n\n- [목차](#목차)\n- [배운 점](#배운-점)\n- [진행 내용](#진행-내용)\n- [진행 과정](#진행-과정)\n  - [client의 load test debugging](#client의-load-test-debugging)\n    - [signout이 진행이 안되고 있었음](#signout이-진행이-안되고-있었음)\n    - [enterchat 요청이 받아들여지지 않고 있었음](#enterchat-요청이-받아들여지지-않고-있었음)\n\n---\n\n## 배운 점\n\n- 주고받는 데이터 프로토콜 정확성의 중요성\n- 로그를 어느 정도까지 디테일하게 찍어주느냐의 중요성\n\n---\n\n## 진행 내용\n\n- client의 load test debugging\n\n---\n\n## 진행 과정\n\n### client의 load test debugging\n\n1. signout이 진행이 안되고 있었음\n2. enterchat 요청이 받아들여지지 않고 있었음\n\n#### signout이 진행이 안되고 있었음\n\nloadtest에서 header에 value의 key를 sessionkey로 보내고 있었는데 Session-Key가 올바른 키의 이름이었음.\n\n#### enterchat 요청이 받아들여지지 않고 있었음\n\n(진행중)\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":11,"classes":"wide","title":"ChatApplication Review(11)","subtitle":"작성중","date":"2024-05-16T00:00:00.000Z","categories":"개발일지"}},{"postName":"2024-04-21-re 제로부터 시작하는 블로그(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-21-re 제로부터 시작하는 블로그(1).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","content":"\n### 목차\n\n- [나를 드러내기 위해서 라는 세속적인 계기](#나를-드러내기-위해서-라는-세속적인-계기)\n- [그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을](#그-때는-아직-몰랐습니다-남들이-다-하는-데에는-이유가-있다는-것을)\n- [부족하고 모자랐던 흑역사](#부족하고-모자랐던-흑역사)\n- [그래도 남이 봐주니 즐겁고 고마웠던 시간](#그래도-남이-봐주니-즐겁고-고마웠던-시간)\n\n---\n\n## 나를 드러내기 위해서 라는 세속적인 계기\n\n블로그를 다시 시작하게 된 계기는 굉장히 세속적이었습니다. 구직을 하는 초창기에 한 면접관께서 면접 중간에 제게 피드백으로 '이력서가 다른 사람들보다 많이 모자라기 때문에 이를 채우기 위한 노력을 할 필요가 있다, 일단 기술 블로그를 쓰는 것이 좋을 것 같다.'라는 조언을 해주셨기 때문입니다.\n\n저는 운이 좋은 편이라 이력서가 많이 미비한 상태에서도 꽤나 많은 면접을 볼 수 있기는 했지만, 그것이 이력서가 모자라도 괜찮다는 것과는 또 다른 이야기였습니다. 이력서가 모자라다는 것은 제가 어떤 사람인지, 어떤 경험을 가지고 있는지, 어떤 역량을 가지고 있는지를 제대로 보여주지 못한다는 것이기 때문입니다. 이 부분을 채우고 저를 채용 과정에서 더 잘 보여주면서 스스로에 대해 더 잘 알아볼 필요가 있다는 생각을 하게 되어 블로그를 다시 시작하게 되었습니다. 이전의 것을 경험이라고 할 수 있다면 말이죠.\n\n---\n\n## 그 때는 아직 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 것을\n\n블로그를 시작하기 위해서는 일단 여러 플랫폼 중에서 무엇을 고를 지부터 선택해야 했습니다. 최근에 국내 1세대 블로그인 이글루스가 문을 닫는 것을 보고 가능하면 제가 작성한 글들에 대한 소유권을 유지하고 싶다는 생각이 들었고, 동시에 github pages를 이용한 블로그를 하면 깃허브에 글을 쓰는 것만으로도 contribution의 수를 늘릴 수 있기 때문에 굉장히 이득이라는 생각이 들었습니다. 그리고 남들이 주로 쓰는 플랫폼을 벗어나면 힙 해보이지 않을까 하는 망상도 조금 있었습니다.\n\n그러나 그 때는 몰랐습니다, 남들이 다 하는 데에는 이유가 있다는 걸 말이죠. github pages를 통한 블로그를 운영한다는 것은 결국 조그마한 웹 서비스를 스스로 운영하는 것과 같기 때문에 내가 거의 모든 통제를 가지고 있지만, 동시에 내가 하지 않은 그 어떤 것도 주어지지 않는다는 것을 말입니다. 그리고 인터넷 상에는 내가 눈치채지 못한 곳에서 생각보다 엄청나게 많은 것들이 바쁘게 동작하고 있다는 사실도 알 수 있었습니다.\n\n---\n\n## 부족하고 모자랐던 흑역사\n\n지금이야 '네가 작가냐, 글 쓸 시간에 코드 좀 짜라'는 말을 듣고 반성할 정도로 활발하게 글을 쓰는 편입니다만, 첫 글을 쓸 때에는 굉장히 막막했던 기억이 납니다. 우선은 무엇을 써야할지도 모르겠고, 무엇을 써야할지 알겠다고 해도 어떻게 써야할지도 모르겠었습니다. 그래서 그냥 블로그를 만들었다는 것을 기념하기 위해 블로그를 만들었다는 글을 쓰는 것으로 시작했지만, 끝나자마자 바로 그 다음 글은 어떻게 써야할 지에 대한 고민이 시작되었습니다.\n\n이 때 제가 도움을 크게 받은 것은 chatgpt였습니다. 아직도 얼추 어떤 질문을 넣었는지 기억이 납니다. '내가 요 근래 이런저런 것들을 공부했는데 이걸 기반으로 기술 블로그를 쓴다면 무슨 주제들을 다루면 좋을까? 그리고 그 주제별로 목차 제시해줘.' 마침 그 때가 의존성 역전에 대해 공부한 시기였고 기술적으로 매력있는 주제라는 생각이 들었기 때문에 그 주제를 기반으로 한 목차를 채우는 것으로 작문을 시작했습니다. 그리고 해당 글을 게재하고 많은 분들의 피드백을 받고 제가 크게 잘못했다는 것을 알 수 있었습니다.\n\n해당 글은 이제 블로그에서 내려두고 피드백을 기반으로 수정한 것이 이 [천원돌파 의존성 역전](https://kaestro.github.io/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/2024/02/07/%EC%B2%9C%EC%9B%90%EB%8F%8C%ED%8C%8C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84.html)입니다. 피드백을 받고 많이 고친 것인데도 저 정도이니 원래는 어느 정도였는지 알 수 있으실 겁니다. 하지만 레포지토리 내에는 남겨둔 상태이니 혹시라도 궁금하신 분이면 쓰레기통에 버려진 기밀 문서를 뒤진다는 마음가짐을 가지고 찾아보시면 제 흑역사를 즐기실 수도 있을 겁니다.\n\n---\n\n## 그래도 남이 봐주니 즐겁고 고마웠던 시간\n\n그래도 블로그를 시작하고 남이 글을 읽고 반응을 보여주는 경험은 너무나도 즐겁고 소중하면서도 고마운 순간들이었습니다. 아직도 많이 모자라지만, 그 끔찍했던 글들을 홍차넷과 pgr21이란 커뮤니티에 퍼날랐을 때 이를 읽고 달아주신 댓글들 하나하나 덕분에 여태까지 이 블로그를 그만두지 않고 이어나갈 수 있었습니다. 읽기 불편하고 모자랐던 글들에 힘내라는 응원과 피드백, 잘 읽었다는 칭찬과 격려 모두다 저에게 큰 힘이 되는 소중한 말씀들이었습니다. 그럼 앞으로도 계속해서 글로 이 공간을 채워나가겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":true,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(1)","subtitle":"github pages를 이용한 블로그 시작하기","date":"2024-04-21T00:00:00.000Z","categories":"개발일지","published":true,"recommended":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":1}},{"postName":"2024-04-22-re 제로부터 시작하는 블로그(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-22-re 제로부터 시작하는 블로그(2).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","content":"\n### 목차\n\n- [다른 사람과 다른 길을 걷는 용기에 박수를](#다른-사람과-다른-길을-걷는-용기에-박수를)\n- [github pages, jekyll이란](#github-pages-jekyll이란)\n- [기술 블로거는 작가이자, 개발자이다](#기술-블로거는-작가이자-개발자이다)\n- [기술 블로거는 개발자이자, 마케터이다](#기술-블로거는-개발자이자-마케터이다)\n- [마치며](#마치며)\n\n---\n\n## 다른 사람과 다른 길을 걷는 용기에 박수를\n\n'개발자라면 역시 깃허브지!'라는 생각으로 깃허브로 블로그를 시작하기로 결심하신 용감하신 분들께 우선 박수드립니다. 스스로 블로그를 구축하는 것은 많이들 하지 않는 선택이니만큼 쉬운 길이라고는 할 수 없겠지만, 그만큼 할 수 있는 것도 많고 이를 통해 많은 것을 배울 수 있는 개발자로써 한 번쯤 해보면 좋은 경험이라고 생각합니다. 그럼 이제 웹 개발에 대한 지식이라곤 기초적인 api 서버를 구축하는 것 밖에 없었던 제가, github page와 jekyll을 통해 기술 블로그를 운영하면서 겪은 좌충우돌에 대해 잠깐 이야기해보겠습니다.\n\n---\n\n## github pages, jekyll이란\n\n이 둘을 활용하는 자세한 가이드는 [이 페이지](https://pages.github.com/)에서 확인하실 수 있습니다.\n\ngithub pages는 github에서 직접 호스팅을 제공하는 블로그 서비스로 단순히 깃허브 레포지토리에 블로그 정적 파일을 올리기만 하면 이와 관련한 웹페이지와 도메인을 무료로 제공해주는 서비스입니다. 해당 페이지의 빌드와 배포에 관련한 작업은 무려 github에서 직접 만들어둔 workflow인 pages-build-deployment를 통해 관리되며, 본인이 지정해 둔 브랜치를 기반으로 푸시가 일어날 때마다 해당 브랜치의 파일을 빌드하여 배포합니다. 웹 서비스를 경험해 보신 분이라면 이 정도만 해도 충분히 블로그를 운영하는 데에는 문제가 없을 것이며 '생각보다 되게 편리한데? 뭐가 그렇게 힘들었단거야?'라는 생각을 하실 수도 있겠네요.\n\njekyll은 github pages에서 추천하는 정적 사이트 생성기로, 마크다운 파일을 작성되어 있는 layout에 맞는 형태인 HTML로 변환해주는 역할을 합니다. 또한 그 밖에 웹사이트를 만들 때 신경써야 하는 timezone, sitemap, rss feed 등의 기능을 설정만으로도 쉽게 구현할 수 있도록 도와줍니다. 이를 통해 jekyll은 블로그를 운영하는 데 있어 개발보다는 글을 작성하는 데에 많은 시간을 쓸 수 있도록 도움을 줍니다. 또한, jekyll은 liquid라는 템플릿 언어를 사용하여 비교적 간단하게 javascript를 사용하지 않고도 동적인 웹페이지를 만들 수 있으며, 단순히 페이지에 몇 가지 항목을 등록하는 것만으로도 포스트와 관련한 카테고리나 태그, 추천 등의 추가적인 정보를 쉽게 관리할 수 있습니다.\n\n그리고 여기까지가 github pages와 jekyll이 제공하는 모든 것입니다. 사실 저는 이런 것들이 제공되고 있다는 사실도 알지 못하고 블로그가 동작한다는 사실만 인지할 정도로 웹 개발이 모자란 상태에서 운영을 시작했던 데다가, 이 외에도 블로그에 필요한 기능들이 굉장히 많고 유용하다는 것을 깨닫는 과정을 통해 네이버와 같이 여타의 플랫폼에서 제공하는 서비스들이 그만큼 대단하다는 것을 절감할 수 있었습니다.\n\n---\n\n## 기술 블로거는 작가이자, 개발자이다\n\n기술 블로거는 우선은 글을 쓰는 사람이 맞습니다. 하지만 그것은 필요조건일 뿐, 충분 조건은 아닙니다. 말 그대로 깃허브 페이지와 jekyll이 제공하는 것은 글을 작성하면 배포해주고, 이에 필요한 기본적인 포맷인 레이아웃이 끝입니다. 그러면 가장 먼저 시작해야하는 것은 우리에게 너무나 익숙한 웹 사이트의 index 페이지 작성 및 여기에 글이 나열될 수 있는 포스트 페이지를 만드는 것입니다. 즉, 깃허브 페이지로 블로그를 운영하려는 사람은 프론트엔드 개발자가 되어야 합니다.\n\n유명한 블로그 플랫폼인 네이버 블로그를 예시로 들자면 이제 누군가의 네이버 블로그에 들어갔을 때 가장 먼저 맨 위에 글들을 카테고리 별로 나눠주는 메뉴가 놓여있는 것이 대부분입니다. 잠깐, 그런데 내 블로그에 카테고리 별로 나눠주는 버튼은 어디 있죠? 지금부터 만드시면 됩니다. 작성한 글을 읽고 나서 다음 글로 넘어가거나 이전 글로 넘어가는 방법은요? 지금부터 만드시면 됩니다. 댓글은요? 지금부터 만드시면 됩니다.\n\n이처럼 기존에 서비스하던 블로그에서 이미 이러한 수많은 우리가 있는게 너무나도 자연스럽다 생각했던 기능들은 사실 당연한 것이 아니란 것을 깨닫게 되는 첫 순간에는 굉장히 당황스러웠습니다. 그걸 내가 어떻게 해? 그런데 개발자라는 직업의 사람이 모두들 그렇듯, 하다보면 다 된다는 것도 배울 수 있었습니다. 모든걸 제가 만들어야하는 것이 힘들고 괴로운 대신 그만큼 우리가 블로그에 모든 전권을 가지고 있기 때문에, 이런 못생긴 신호등 버튼을 만들어도 아무도 말릴 사람이 없다는 쾌락을 누릴 수 있었던 것은 소소한 재미입니다. 이제는 디자인을 변경했지만요.\n\n![신호등](/images/re%20제로부터%20시작하는%20블로그/신호등.png)\n\n---\n\n## 기술 블로거는 개발자이자, 마케터이다\n\n그렇게 고생해서 다른 블로그들에 있고 나한테 필요한 기능들을 개발해서 글을 쓰는 데까지 오는 데 성공하고 나니 나름대로 뿌듯함을 느낄 수 있습니다. 그런데 이번에는 다른 문제가 있다는 사실을 깨달을 수 있었습니다. 제가 그것을 깨달은 것은 제 블로그 글이나 블로그 자체가  구글이나 네이버 검색엔진을 통해 검색이 되지 않고 있기 때문에, 사실상 제가 작성하고 있는 것은 잘 연결된 인터넷 상에 자리한 것이 아니라 아는 사람만 드나들 수 있는 외딴 섬에 있는 것과 다름이 없다는 사실을 알 수 있었습니다.\n\n아직 구글 검색엔진을 기준으로 가장 먼저 이 부분을 해결하기 위해 제가 조사한 바에 따르면, 구글 검색엔진에 글이 노출이 되기 위해서는 두 가지 해결책을 취할 수 있습니다. 하나는 트래픽이 굉장히 많이 발생하도록 만들어서 구글이 중요한 사이트라고 인식해 검색 엔진에 스스로 등록하게 하는 것입니다. 당연히 이것은 불가능하기 때문에 저는 두 번째 방법을 사용했습니다. 그것은 구글에 직접 이 블로그의 주인임을 증명하고, 구글이 이 블로그를 검색 엔진에 등록하는데 필요한 모든 정보를 제공하는 것입니다. 이것을 [구글 서치 콘솔](https://search.google.com/search-console/about)이라고 합니다.\n\n저는 미련하게도 서치 콘솔에 등록한 이후에 '트래픽이 발생하기만 하면 알아서 잘 되겠지. 글을 쓰고 홍보하기만 하면 어떻게든 될 거야'하는 잘못된 생각을 가지고 일단 글만 쓰다가, 두 달이 넘도록 구글 검색 엔진에 노출이 되지 않아서 문제가 있다 생각해 다시 해결 방법을 찾아 나섰습니다. 그 결과, 구글 검색 엔진에 순수하게 트래픽을 통해 노출되는 것이 아니라 직접 [indexing을 요구](https://support.google.com/webmasters/answer/7440203?hl=ko)하거나 [sitemap을 제출](https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap?hl=ko&visit_id=638493812450328388-2387940056&rd=1)하는 등의 노력을 해야 작은 트래픽이라도 구글 검색 엔진에 노출이 된다는 것을 알 수 있었습니다.\n\n결과적으로 현재 저는 무려 블로그를 시작한 근 세달만에 블로그에 트래픽이 생기기 시작한 사실을 확인할 수 있었습니다.\n\n![디스커버](/images/re%20제로부터%20시작하는%20블로그/디스커버.png)\n![검색결과](/images/re%20제로부터%20시작하는%20블로그/검색%20결과.png)\n\n---\n\n## 마치며\n\n비록 제가 생각한 것보다 기술 블로그를 github pages를 통해 스스로 운영하는 과정은 많은 작업을 요구하는 일이었습니다. 하지만 그 덕분에 제가 알지 못했던 웹과 관련한 많은 기술들을 학습할 수 있었고, 처음으로 사이트에 트래픽이 생긴 날은 굉장히 감격스럽기도 했습니다. 그만큼 블로그를 운영하는 것은 개발자로써 나름대로 힘든 만큼 재미있고 굉장히 많이 자극이 되는 경험이었습니다.\n\n그럼 다음 편에서는 조금 더 구체적으로 블로그를 운영하면서 겪은 일들에 대해 이야기해보겠습니다. 긴 글 읽어주셔서 감사합니다.\n\n---\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(2)","subtitle":"글 쓰기 이외에 해야하는 것들","date":"2024-04-22T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":2}},{"postName":"2024-04-23-re 제로부터 시작하는 블로그(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/re 제로부터 시작하는 블로그/2024-04-23-re 제로부터 시작하는 블로그(3).md","category":"개발일지","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","content":"\n### 목차\n\n- [개발자의 블로그는 살아서 변화한다](#개발자의-블로그는-살아서-변화한다)\n- [사람들의 눈을 끌기 위한 노력](#사람들의-눈을-끌기-위한-노력)\n- [ui이 바뀌면 컨텐츠도 변화한다](#ui이-바뀌면-컨텐츠도-변화한다)\n- [심심할 틈이 없었던 3개월](#심심할-틈이-없었던-3개월)\n\n---\n\n## 개발자의 블로그는 살아서 변화한다\n\n개발자의 블로그란 것은 굳이 말하자면 디자이너와 작가가 개발자에게 직통 연결을 상시 가지고 있는 서비스와도 같다고 말할 수 있습니다. 글을 쓰다가 다음 포스트로 넘어가기 기능이 있으면 좋겠다는 생각이 들면 이를 바로 만들어 주고, 글이 몇 개 없을 때는 일렬로 늘어놓다가 글이 많아지면 카테고리로 분류하고 싶어지는 등의 변화의 요구가 즉각적으로 반영되기 때문입니다.\n\n다음은 제 블로그의 변천사 사진 몇 장입니다.\n\n|![image](/images/re%20제로부터%20시작하는%20블로그/before_grid_colorful.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_before_grid.png)|\n|---|---|\n|![image](/images/re%20제로부터%20시작하는%20블로그/front_without_recommend.png)|![image](/images/re%20제로부터%20시작하는%20블로그/front_recent.png)|\n\n처음에는 단순하게 흰 화면에 일렬로 글을 늘어놓았다가, 여백이 신경쓰여 그라데이션을 넣어보고, 숱한 항의(?) 끝에 이를 삭제하고, 가운데를 그림자 처리를 통해 종이가 놓인 것 같은 이미지에 카테고리 버튼을 넣은 뒤에, 끝내는 격자 형태로 글을 나열하고, 추천글 항목을 추가한 뒤에 최근 글을 보여주는 것으로 마무리되었습니다. 이처럼 자신에게 전권이 주어진 개발자의 블로그는 끊임없이 변화하고 발전하는 생명체와 같다고 생각합니다.\n\n---\n\n## 사람들의 눈을 끌기 위한 노력\n\n녹조라떼 급의 안구 테러 수준이었던 제 최초의 블로그 디자인이 제가 장난 친 것으로 보일 수도 있지만, 제 나름대로는 어떻게 하면 들어온 사람이 제가 작성한 컨텐츠에 집중할 수 있을까를 고민해서 나온 결과입니다. 해당 디자인을 한 것은 마케팅 관련한 책 중에서 '좋아 보이는 것들의 비밀'이라는 것을 읽고 나서 하게 된 결정이었습니다. 해당 책에서는 색상과 빛의 밝기, 각도와 같은 것을 활용해서 좋아 '보이는' 것을 통해 사람의 시선을 끌 것을 이야기하고 있었고 그 관점에서 봤을 때 저기에 표현돼있지 않은 제 블로그 더 이전의 형태는 너무 단조로웠기 때문입니다.\n\n'사람의 시선을 가운데로 유도하기 위해서는 어떻게 빛을 배치하면 될까?'라는 고민에서 시작해 제 블로그 전체 테마인 초록색 그라데이션에 억지로 맞추려다보니 나왔던 저 끔찍한 디자인은 주변 분의 꾸짖음과 함께 그림자를 이용해서 종이가 가운데에 올라온 것 같은 심플한 디자인으로 변경됐습니다.\n\n그리고 여기에 더해 글의 카테고리가 4개를 넘어가면서부터 한 줄로는 사람들이 읽고 싶은 글을 찾기 어려워지는 문제가 발생했기 때문에, 이를 해결하기 위해 격자 패턴 배열을 자주 사용하는 커뮤니티(pgr21, 홍차넷 등) 것들을 참조해서 추가하고, 여기에 더해 추천 글 항목과 최신글을 보여주는 기능을 더해서 홈 페이지를 지금의 모습으로 만들었습니다.\n\n---\n\n## ui이 바뀌면 컨텐츠도 변화한다\n\n이렇게 새로운 기능을 추가하면 재밌는 것은, 제가 쓰는 글 역시도 이에 맞춰서 변화한다는 것입니다. 예를 들어 제가 가장 크게 글쓰기에 변화가 생긴 시점은 화면에 맞추어 이동하는 목차 기능을 추가한 이후였습니다.\n\n|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/before_toc.PNG?raw=true)|![image](https://github.com/kaestro/kaestro.github.io/blob/main/docs/images/re%20%EC%A0%9C%EB%A1%9C%EB%B6%80%ED%84%B0%20%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94%20%EB%B8%94%EB%A1%9C%EA%B7%B8/after_toc.PNG?raw=true)|\n\n해당 기능은 장문의 글을 작성한 것을 제가 면접 전에 복기하는 과정에서 원하는 구간으로 넘어다닐 수 있는 기능이 있으면 글을 읽기에 편리할 것 같다는 생각에서 추가한 것이었습니다. 헤더로 소제목들을 작성해두면 이를 목차로 자동 생성해주는 해당 기능을 만든 이후와 이전에 쓴 글을 비교하면 이후의 글들은 훨씬 더 명확하게 구조화 되어 되는 것을 확인할 수 있었습니다. 이는 그런 기능에 적합한 글이 되게끔 제가 글을 쓸 때 의식하게 되기 때문이라고 생각하고 덕분에 블로그를 막 시작했을 때보다는 조금은 덜 부끄러운 글들을 쓸 수 있게 되지 않았나 생각합니다.\n\n---\n\n## 심심할 틈이 없었던 3개월\n\n절대 쉬운 일이었다고 말하기는 힘듭니다만, 굳이 말하자면 지난 세 달 동안 기술 블로그를 운영한 경험은 자영업자로 비유할 수 있을 것 같습니다. 무료로 웹 호스팅을 해주는 서비스 하나만 가지고 글을 쓰고, 이를 보기 쉽고 가능한 예쁘게(이게 제 최선 맞습니다) 디자인하고, 이를 남들이 보게 만들기 위해 모든 방법을 동원해야 하는 경험을 할 수 있었기 때문입니다.\n\n이 때문에 지난 3개월 동안 블로그를 운영하면서 단 한 순간도 심심할 일은 없었네요. 글을 쓰다보면 새로운 기능을 만들고 싶어지고, 새로운 기능을 만들면 이를 글로 쓰고 싶어지고, 그 글을 쓰면 이를 남들에게 알리고 싶어지는 등의 선순환이 꾸준히 이루어지다보니 어느 새 제 블로그도 곧 100개의 포스트를 채울 날이 얼마 남지 않았습니다.\n\n본인이 한번쯤 스스로 개발한 서비스를 운영하는 경험을 해보고 싶은데 방법을 잘 모르신다면, 깃허브 페이지와 jekyll을 이용한 기술 블로그 운영을 추천드립니다. 그것은 분명히 개발자로써의 인생에 웃으면서 추억할만한 제 신호등 같은 경험 하나쯤은 남겨줄 것이라 생각합니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"re: 제로부터 시작하는 기술 블로그(3)","subtitle":"3개월 간의 블로그 변천사","date":"2024-04-23T00:00:00.000Z","categories":"개발일지","published":true,"series":"제로부터 시작하는 기술 블로그","seriesIndex":3}}],"category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"]},"__N_SSG":true}