{"pageProps":{"posts":[{"postName":"2024-03-07-좋은 테스트에 대한 고민","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-07-좋은 테스트에 대한 고민.md","category":"개발이야기","title":"좋은 테스트에 대한 고민","subtitle":"구글 엔지니어는 이렇게 일한다를 읽으며","content":"\n## 목차\n\n0. 계기\n1. 단위 테스트에 적용하는 원칙\n2. 경험\n\n---\n\n## 계기\n\n최근 ChatApplication 프로젝트를 3주간 진행하면서 초기에 생각한 것과 다르게 프로젝트를 변경해야하는 일이 굉장히 자주 발생했습니다. Redis가 사실은 서버 한개에 대해서만 연결하는 모듈이었다든가, Manager 모듈이 단순히 raw한 연결 자체를 넘겨주는 등의 형태로 구현돼있단 사실들을 리뷰하는 단계에서 발견한 일 등 다 기억은 안 나지만 수도 없이 많았습니다.\n\n그래서 이런 코드들을 다 리팩토링하는 과정에서 처음에 했던 걱정은 '근데 이거 고치고 나서 동작하는지는 어떻게 확인하지?'였습니다. 다행히도 굉장히 운이 좋았던 것은 제가 그때까지 작성한 모든 코드들에 대한 unittest들이 있었기 때문에 이들에 대한 테스트를 통과시키는 것만으로도 굉장히 많은 것들을 확인할 수 있었습니다.\n\n즉, **테스트가 생산성과 속도를 높여주는 도구**라는 것을 깨닫는 경험을 했습니다.\n\n그런데 이와 별개로 ci/cd를 위해 github actions를 작성하고 테스트하는 과정에서 제가 작성한 테스트들을 이 시스템에 통합하는 것이 불가능하단 사실들을 알았습니다. 그리고 현재 제가 작성하고 있는 테스트들이 충분히 좋지 못한 테스트라는 생각을 하게 됐습니다.\n\n그렇다면 앞으로는 지금보다 더 좋은 테스트들을 작성하면 규모가 크고 오래 진행하는 프로젝트를 진행할 때 많은 도움을 받을 수 있겠다는 생각하게 됐습니다. 마침 요 근래 읽고 있는 책인 '구글 엔지니어는 이렇게 일한다'의 테스트 항목들에서 이에 대한 이야기들을 많이 하고 있고, 도움이 된다고 생각되어 이에 대한 정리 및 고민을 해보려고 합니다.\n\n---\n\n## 단위 테스트에 적용하는 원칙\n\n1. 유지보수하기 쉬워야 한다.\n2. 깨지기 쉬운 테스트가 되지 않아야 한다\n   - 버그가 없고 검증 대상 코드와 관련 없는 변경으로 인해 테스트가 실패하면 안된다.\n   - 공개 API를 이용해 테스트한다.\n   - 상호작용이 아니라 상태를 테스트하자.\n     - 상태: 기능 호출 이후에 시스템이 어떻게 변하는지\n     - 상호작용: 기능 호출 이후에 시스템이 어떤 행동을 하는지\n3. 명확한 테스트 작성하기\n   - 완전한 테스트를 작성하자.\n     - 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보가 본문에 있다.\n   - 간결한 테스트를 작성하자.\n     - 관련 없는 정보를 제거하자.\n   - 메서드가 아니라 행위를 테스트하자.\n     - given, when, then을 사용하자.\n        - given: 시스템의 설정\n        - when: 시스템이 수행할 작업\n        - then: 결과 검증\n    - 테스트에 논리를 넣지 말자.\n    - 실패 메시지를 명확하게 작성하자.\n4. DAMP: Descriptive And Meaningful Phrases\n    - 단순하고 명료하게 테스트를 작성하자.\n    - 테스트에서 다소의 중복은 괜찮다.\n\n---\n\n## 경험\n\n위와 같은 원칙들을 적용하면서 테스트를 작성하기 시작하다보니, 이전보다 나은 테스트를 작성할 수 있게 된 장점은 있었습니다. 그렇지만 동시에 어려움을 겪은 부분도 있습니다.\n\n제시한 원칙 중에 특히 **공개 API를 이용해 테스트한다**는 원칙 같은 경우 현재 CI/CD의 방법으로 git actions를 사용하는 중이고, 어플리케이션이 서버에 올라가있지 않은 상태여서 문제가 됐습니다. 로컬에서 서버를 띄우고 api에 요청을 보내는 것은 가능하지만, 이를 github actions에서 하는 것은 불가능했기 때문입니다.\n\n현재는 이 부분에서 테스트를 mock_tests, open_api_tests 두 가지로 분리하고 기존의 작성한 테스트들을 open_api_tests로 옮긴 뒤 검증하지 않게 해 두었습니다. 그리고 mock_tests를 추가로 작성하려고 생각 중입니다.\n\n오래 유지될 서비스의 측면에서 open_api_tests들을 결국 사용해야겠습니다만, 개발 비용 측면에서 이런 부분에 대한 고민이 들어가면 원칙은 항상 지키기 어렵다는 생각을 하게 됩니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"좋은 테스트에 대한 고민","subtitle":"구글 엔지니어는 이렇게 일한다를 읽으며","date":"2024-03-07T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-08-February Code Review copy","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-08-February Code Review copy.md","category":"개발이야기","title":"2월의 코드 복기","subtitle":"알고리즘, Go 문법","content":"\n## <https://github.com/kaestro/algorithms_v3/commit/886b271b3be97d6af2af270d2754ebb8127f4d88>\n\nbinary search tree가 있을 때, 이를 펴는 방법\n\n* 순회하고, 붙이고, 올려보내라\n\n```python\ndef inorder_traversal(node):\n  if node is None:\n    return\n\n  inorder_traversal(node.left)\n  self.current_node.right = node.val\n  self.current_node = self.current_node.right\n  inorder_traversal(node.right)\n```\n\n---\n\n## <https://github.com/kaestro/algorithms_v3/commit/449fc65f0fbc29330042bb3b0153b16b0049a167>\n\nstring을 element로 갖는 array를 입력받았을 때, 모든 element에 공통으로 들어간 character의 리스트를 구하는 문제. 중복을 허용하여 동일 character가 정답에 2번 이상 등장할 수도 있다.\n\n직접 count하는 방법, python dictionary의 & 연산자를 이용하는 방법, set을 이용해서 정의역 자체를 줄인 뒤에 갯수를 count하고 객체는 최후에 만든다.\n\n* 연산을 하기 전에 대상을 줄인다.\n* 객체를 만드는 것은 최후에, 꼭 필요한 순간에만 한다.\n\n---\n\n## <https://github.com/kaestro/algorithms_v3/commit/90c7db2c8ff37d1ddf24b0a187fbe85de7ddd380>\n\n세 명의 아이에게 줄 사탕의 갯수와 한 아이에게 줄 수 있는 최대 사탕의 갯수가 주어졌을 때, 이를 나눠 줄 수 있는 경우의 수를 구하는 문제.\n\n* 최대 값에 제한이 있는 문제를 풀 때, 이를 합을 통해서 경우의 수를 만들지 않고 뺄셈을 통한 경우의 수 생성이 유리할 수 있다.\n\n---\n\n## <https://github.com/kaestro/algorithms_v3/commit/77ec890aefcc049d6cc8f0d8437909e4b6bf72db>\n\n* 값이 존재하는지 계속해서 확인할 경우, hashtable을 사용하자.\n* python의 set은 hashtable로 구현되어 있다.\n\n---\n\n## <https://github.com/kaestro/algorithms_v3/commit/ea23a451316766fde8bfce5213a8e9e23781da50>\n\n* sliding window\n\n---\n\nAwesome!\n\n## <https://github.com/kaestro/algorithms_v3/commit/471f6fb0b0c8cba6890b13ca1fbce871dd05eada>\n\n: list의 partial sum = 0 되는 구간을 삭제한 list를 구하는 문제.\n\n* accumulative sum이 key이고, 해당 sum이 나온 마지막 node가 value인 hashtable을 만든다.\n* 다시 accumulative sum을 순회하면서, 해당 sum이 나온 마지막 노드가 현재 노드보다 뒤에 있으면, 그 사이의 구간은 0이 된다.\n* currentNode.next = savedNode.next 로 중간 삭제\n\n---\n\n## <https://github.com/kaestro/algorithms_v3/commit/5309222eb2af9bb8cc830a05ebe554f870f2ffb3>\n\n* backtracking\n\n---\n\n## <https://github.com/kaestro/weekly-reviews/blob/main/February/Code%20-%20Week%204th.md>\n\n* Go와 관련한 전반적인 문법사항\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"2월의 코드 복기","subtitle":"알고리즘, Go 문법","date":"2024-03-08T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-12-시스템 설계 방법","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-12-시스템 설계 방법.md","category":"개발이야기","title":"시스템 설계 방법","subtitle":"설계 과정","content":"\n## 목차\n\n1. 서론\n2. 개요\n3. 설계 과정\n4. 결론\n\n---\n\n## 서론\n\n여러가지 요소들이 상호작용을 해서 동작하는 시스템을 작성하기 위해서 가장 먼저 해야 할 일들이 무엇인지에 대해 계획을 짜야합니다. 목표가 무엇인지부터 명확하게 정의하지 않으면, 어느 곳에도 도달하지 못하고 표류하게 될 것이기 때문입니다. 이런 목표를 달성하기 위해 계획을 세우는 시스템 설계 방법 중의 제가 사용하고 있는 **설계 과정**에 대해 이야기해보려고 합니다.\n\n최근에 채팅 어플리케이션 프로젝트를 진행하면서 '일단 시작하고 보자'라는 생각으로 프로그램을 작성하기 시작한 적이 있습니다. 그랬더니 한발짝 나아갈 때마다 내가 지금 이 프로그램을 작성하는 것이 나중에 시스템이 다 구성됐을 때 목표한 대로 작동할 지에 대해서 확신할 수 없었습니다. 이 때문에 뭔가를 작성할 때마다 그것이 옳은지 검토하는 과정을 거쳐야만 했습니다. 그리고 이에 따라 구상도 변경되면서 지속적인 수정이 필요했습니다.\n\n이러한 경험을 통해 프로그램을 작성하기 전에 시스템을 좀 더 체계적으로 설계하는 경험을 들어볼 기회가 있으면 비교적 적은 시행착오를 통해 목표한 시스템을 구현할 수 있을 것이라고 생각했습니다. 마침 이 때 추천받은 책이 **\"가상 면접 사례로 배우는 대규모 시스템 설계 기초\"**였습니다.\n\n읽다보니 이를 제가 진행중인 프로젝트에 적용하는 방식을 정리하는 것이 좋겠다는 생각이 들었고, 되도록 다른 사람과 공유하고 싶다는 생각이 들어 이렇게 글을 작성하게 되었습니다. 이 글이 저와 비슷한 고민을 하며 답을 찾는 분들에게 도움이 되었으면 좋겠습니다.\n\n---\n\n## 개요\n\n5가지 단계로 나눈 설계 과정을 제가 작성중인 ChatApplication의 예시를 들어 설명하고 있습니다. 해당 과정은 '요구사항 분석', '설계 범위 결정', '개략적인 설계', '상세 설계', '검토'로 나눌 수 있습니다.\n\n---\n\n## 설계 과정\n\n시스템을 설계하는 과정은 크게 5가지로 나눌 수 있습니다.\n\n```\n1. 요구사항 분석.\n2. 설계 범위 결정.\n3. 개략적인 설계.\n4. 상세 설계.\n5. 검토.\n```\n\n---\n\n### 요구사항 분석\n\n**요구사항을 분석**할 때는 우선 **문제를 정의**해야 합니다. 제가 작성중인 채팅 어플리케이션을 예시로 들자면 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 구체적으로 어떤 기능을 제공해야 하는가?\n* 목표로 하는 수용 가능 제품 사용자 수는 얼마나 되는가?\n* 주로 사용하는 기술 스택은 무엇인가?\n```\n\n이에 대해 저는 다음과 같은 답을 생각해냈습니다.\n\n```md\n* 로그인, 채팅방 개설, 채팅방 입장, 메시지 전송, 메시지 수신, 채팅방 삭제 등의 기능을 제공해야 합니다.\n* 사용자 수는 채팅방 당 최대 15,000명이라고 가정합니다.\n* 주로 사용하는 기술 스택은 go, postgresql, redis, docker, azure 등입니다.\n```\n\n기능들 같은 경우는 다른 채팅방에서 일반적으로 제공하는 기능들을 기준으로 가장 기본적이라고 생각하는 것들을 작성했습니다. 사용자 수는 steam 인기 게임 기준으로 100위에 드는 게임의 동시접속자가 15,000여 명인 것을 기준으로 잡았습니다. 기술 스택은 동시성, 안정성, 확장성과 같은 부분들을 고려해서 선택했습니다.\n\n---\n\n### 설계 범위 결정\n\n**설계 범위를 결정**할 때는 우선 설계의 목표를 설정해야 합니다. 제가 작성중인 채팅 어플리케이션을 예시로 들자면 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 당장 작성하기 시작할 수 있는 기능은 무엇인가?\n* 어떤 기능을 먼저 작성해야 하는가?\n* 그 중요도는 무엇을 기준으로 선정해야 하는가?\n```\n\n이에 대해 저는 다음과 같은 답을 생각해냈습니다.\n\n```md\n* 유저의 CRUD 기능을 먼저 작성하기 시작할 수 있습니다.\n* 채팅방에서 공용으로 사용하게 될 모듈인 DBManager, SessionManager 등을 먼저 작성해야 합니다.\n* 중요도는 이후에 변경이 있을 때 이를 검증할 수 있는 시스템과 다른 사람의 협업을 위한 시스템을 먼저 작성해야 합니다.\n```\n\n이래서 현재 가장 먼저 작성한 것은 **User CRUD API**인 login, logout, signup, delete 등의 기능입니다.\n\n채팅방에서 공용으로 사용할 모듈은 **재활용도**가 높기 때문에 우선도가 높다고 판단해서 DBManager, SessionManager, PasswordManager을 작성했습니다.\n\nunittest들을 작성하고, 이들을 **자동으로 검증**하기 위한 시스템으로 github action을 사용했습니다. 현재 github action은 소스 코드의 unittest 및 빌드를 자동으로 검증하고 있습니다.\n\n또한 서버에 올려서 동작을 확인하기위한 **containerization** 및 **orchestrization**에 대한 작업을 진행하는 중입니다.\n\n---\n\n### 개략적인 설계\n\n**개략적인 설계**는 일단 시작하기 위한 prototype이라 생각합니다. 제가 ChatApplication 프로젝트 readme에 작성한 개요와 같습니다. 제가 익숙한 기술스택 내에서 기능들에 어울린다고 가장 먼저 떠오르는 것들을 이용해서 작성했습니다.\n\n이에 따른 최초 제 ChatApplication의 개략적인 설계는 다음과 같습니다.\n\n```md\n메인 서버: go, gin\n유저 관리 DB: postgresql\n세션 관리: redis\n메시지 큐: redis\n채팅 데이터 DB: MongoDB\n사용 서버: Azure\n```\n\n이에 대한 설계는 현재 진행중이며, 이를 통해 어떤 문제가 발생하는지, 어떤 문제를 해결해야 하는지에 대한 경험을 쌓고 있습니다. 현재 **메시지 큐**로 **redis**를 사용하는 것이 적절하지 않아 **kafka**를 사용하는 부분에 대해 고민하고 있으며, 클라우드 서비스 같은 경우도 **gcp**로 이전을 고민하고 있습니다.\n\n---\n\n### 상세 설계 및 검토\n\n**상세 설계**는 개략적인 설계를 바탕으로 **구체적인 기능**들을 작성하는 것입니다. 이를 위해선 먼저 개략적인 설계를 바탕으로 작성한 기능들을 검토해야 합니다. 이를 위해선 다음과 같은 질문을 해볼 수 있습니다.\n\n```md\n* 15,000명이라는 사용자를 넘어선 인원이 채팅방에 들어왔을 때 어떤 일이 일어나야 하는가?\n* 유저 세션은 몇초 단위로 유지되어야 하고, 없어지는 경우에는 어떤 일이 일어나야 하는가?\n* 채팅방에 유저가 들어왔을 때 어느 정도까지 이전의 메시지를 볼 수 있어야 하는가?\n```\n\n이에 대한 부분들은 아직 명확하게 답을 내리지 못했고, **검토**의 과정을 포함해서 다른 사람의 의견을 참고하고자 해서 현재는 책을 읽고 다른 팀원을 모집해서 프로젝트를 진행하는 중입니다.\n\n---\n\n## 결론\n\n**시스템을 설계하는 과정**은 크게 다음 5가지로 나눌 수 있습니다. 요구사항 분석, 설계 범위 결정, 개략적인 설계, 상세 설계, 검토입니다.\n\n저는 해당 과정을 적용해서 진행하려는 채팅 어플리케이션을 설계하고 있는 중이며, 이를 통해 모자란 부분이 많지만 현재 프로젝트를 진행하고 있는 중입니다. 방향성이 틀린 부분이 있을 수 있지만, 방향을 일단 잡았기 때문에 이를 수정하는 것이 용이하고 앞으로도 계속해서 덜 틀린 방향으로 나아갈 수 있을 것이라 믿습니다. 그리고 그것이 설계 과정을 거치는 이유라고 생각합니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"시스템 설계 방법","subtitle":"설계 과정","date":"2024-03-12T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-13-Docker - 멀티 스테이지 빌드","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-13-Docker - 멀티 스테이지 빌드.md","category":"개발이야기","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","content":"\n해당 내용은 [쿠버네티스 교과서 부록](https://github.com/sixeyed/diamol)의 내용을 참고하여 작성하였습니다.\n\n---\n\n## 멀티 스테이지 빌드란\n\nDocker에서 **멀티 스테이지 빌드**는 여러개의 **FROM 명령어**를 사용하여 **여러개의 이미지**를 생성하는 방법입니다. 이를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다.\n\n다음 두 빌드 dockerfile을 비교해보겠습니다.\n\n---\n\n## 예시\n\n### 단일 스테이지 빌드\n\n```dockerfile\nFROM diamol/golang \n\nWORKDIR web\nCOPY index.html .\nCOPY main.go .\n\nRUN go build -o /web/server\nRUN chmod +x /web/server\n\nCMD [\"/web/server\"]\nENV USER=sixeyed\nEXPOSE 80\n```\n\n\n### 멀티 스테이지 빌드\n```dockerfile\nFROM diamol/golang AS builder\n\nCOPY main.go .\nRUN go build -o /server\nRUN chmod +x /server\n\n#app\nFROM diamol/base\n\nEXPOSE 80\nCMD [\"/web/server\"]\nENV USER=\"sixeyed\"\n\nWORKDIR web\nCOPY --from=builder /server .\nCOPY index.html .\n```\n\n둘은 동일한 go로 작성된 웹 서버를 빌드하는 dockerfile입니다. 하지만 두번째 dockerfile은 **멀티 스테이지 빌드**를 사용하여 빌드 **프로세스를 단순화하고 이미지 크기를 줄였습니다.** 해당 방법을 통해 대략 5.2GB의 크기였던 기존의 이미지는 260MB 수준으로 줄어들게 됩니다.\n\n처음으로 멀티 스테이지가 적용된 부분은 처음에 **FROM diamol/golang AS builder** 부분으로 여기에서 빌드를 수행했습니다.\n\n그 다음으로 멀티 스테이지가 적용된 부분은 **FROM diamol/base** 부분으로 여기에서 빌드가 완성된 실행 파일만을 web 디렉토리에 복사하여 사용했습니다.\n\n---\n\n## 결과\n\nDocker의 **멀티 스테이지 빌드**를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다. 또 불필요한 파일이 제거됐기 때문에 **공격 표면**이 줄어들어 **보안도 강화**됐습니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","date":"2024-03-13T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-03-19-Golang은 동시성이 어떤 점에서 유리한가","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-19-Golang은 동시성이 어떤 점에서 유리한가.md","category":"개발이야기","title":"동시성(Concurrency)과 Golang","subtitle":"Golang은 진정 동시성을 처리하는 데 유리한가?","content":"\n## 개요\n\n컴퓨터에서 **여러 프로그램을 한꺼번에 처리**하는 방법 중에 **동시성**과 **병렬성**이 있다. **Golang**은 **동시성**을 처리하기에 용이하도록 설계한 언어로, 이를 위해 **Goroutine**, **Channel** 등의 기능을 제공한다. 해당 기능들 덕분에 Golang은 다른 언어에 비해 **동시성을 처리하는 데 유리하다**고 할 수 있다.\n\n---\n\n## 목차\n\n1. **동시성**이란: 병렬성 vs 동시성\n2. **기존**의 동시성 **처리 방법**: 멀티 태스킹, 스레드, context switching\n3. **Goroutine**: Go에서 스레드를 다루는 방법\n4. **Channel**: Goroutine 간의 통신\n5. **결론**: GoLang은 동시성 처리가 용이하게 설계됐고, **다른 언어에 없는 기능**을 통해 이를 실천하고 있다.\n6. **의문점**: 다른 언어들은 어떻게 동시성을 처리하는가?\n7. 참고자료\n\n---\n\n## 동시성이란\n\n### 병렬성 vs 동시성\n\n컴퓨터에서 **여러 작업**을 **동시**에 처리하는 방법에는 **병렬성**과 **동시성**이 있다. 이 때 병렬성과 동시성은 다음과 같이 정리할 수 있다.\n\n* 병렬성(Parallelism): 여러 일을 **한꺼번에 실행하는 방법**에 관한 것이다.\n* 동시성(Concurrency): 여러 일을 **한꺼번에 다루는 문제**에 관한 것이다.\n\n이 때 **병렬성**은 **여러 프로세서**가 **동시에** 여러 작업을 처리하는 것을 의미하고, **동시성**은 **하나의 프로세서**가 여러 작업을 **번갈아**가며 처리하는 것을 의미한다.[^1]\n\n#### 즉, Go가 동시성을 처리하는 데 유리하다면 작업 간에 **전환이 빠르다**는 것을 의미한다. 그리고 Go는 동시성을 처리하는 데 유리하게 **설계**된 언어이다[^3]\n\n---\n\n## 기존의 동시성 처리 방법\n\n* **멀티 태스킹**\n  * 여러 작업들을 **번갈아가며 처리**하는 것\n  * **시분할 시스템**을 통해 **CPU를 공유**하여 여러 작업을 처리한다.\n* **스레드**를 이용한 동시성 처리\n  * 스레드는 프로세스 내에서 **코드 실행**을 담당하는 **최소의 단위**이다.\n* **context switching**\n  * **스레드** 간에 **전환**을 하는 것\n  * **system call**을 통해 **커널**에 요청을 하여 스레드를 전환한다.\n  * system call은 **비용**이 많이 든다.\n\n---\n\n## Goroutine: Go에서 스레드를 다루는 방법\n\n* **goroutine**은 스레드가 아니라, **runtime scheduler**를 통해 관리된다.\n* **runtime scheduler**를 통해 **system call**을 더 **적게** 사용하고 동시성을 구현할 수 있다.\n* **system call 필요한 연산**이 생길 경우 발생하는 **blocking**은 runtime scheduler가 **다른 goroutine**으로 **context switching**해서 해결한다.[^2]\n\n---\n\n## Channel: Goroutine 간의 통신\n\n* **channel**은 **goroutine** 간에 **데이터를 주고 받는** 방법이다.\n* [할당하고 전달할 수 있는 1급 객체 값(first-class value)이다.](https://go.dev/doc/effective_go#chan_of_chan)\n  * [1급 객체란?](https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059)\n    * **변수/데이터**에 할당할 수 있다.\n    * 객체의 **인자(parameter)**로 사용할 수 있다.\n    * 객체의 **반환값(return value)**으로 사용할 수 있다.\n* 장점\n  * **동기화**를 위해 **mutex**를 사용하지 않아도 된다.\n  * *공유*가 아닌 **소유권 이전**이므로 **데이터 레이스**가 발생하지 않는다.\n  * **비동기**로 데이터를 주고 받을 수 있다.\n* 단점\n  * **데이터를 주고 받는 비용**이 발생한다.\n  * **성능**이 mutex에 비해 **떨어질 수 있다**\n\n| Channel | Mutex |\n| ------- | ----- |\n| 데이터의 소유권을 이전한다 | 캐시 |\n| 일의 단위를 나누어서 처리한다 | 상태 |\n| 비동기 결과를 소통한다 | 데이터를 공유한다 |\n\n---\n\n## 결론\n\n**GoLang**은 태생적으로 **동시성**을 처리하기에 효율적인 방법을 고안하여 만들어진 언어이다. 이를 위해 **Goroutine**과 **Channel**과 같은 기능을 제공하고 있다. 이 때문에 Golang이 **동시성을 처리하는 데 유리**하다고 할 수 있다.\n\n---\n\n## 의문점\n\n* **다른 언어**들은 어떻게 동시성을 처리하는가?\n* 어떤 점에서 이들은 Golang에 비해 동시성을 처리하는 것이 **불편**한가?\n\n---\n\n## 참고자료\n\n* [effective go - concurrency](https://go.dev/doc/effective_go#concurrency)\n* [Mutex or Channel](https://go.dev/wiki/MutexOrChannel)\n* [동시성을 구현하는 기술](https://deview.kr/data/deview/session/attach/1_Inside%20React%20(%E1%84%83%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF).pdf)\n* [Go에서 동시성이란](https://seung.tistory.com/entry/GoLang-Go%EC%97%90%EC%84%9C-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4%EB%9E%80)\n* [1급 객체란?](https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059)\n\n[^1]: [동시성과 병렬성의 개념 차이](https://velog.io/@kwontae1313/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4)\n[^2]: [Golang은 왜 동시성에 좋다고 할까](https://velog.io/@hyeok3011/Goroutine)\n[^3]: [Concurrency is not parallelism](https://go.dev/blog/waza-talk)\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","subtitle":"Golang은 진정 동시성을 처리하는 데 유리한가?","title":"동시성(Concurrency)과 Golang","date":"2024-03-19T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-04-21-k6 vs Locust","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-04-21-k6 vs Locust.md","category":"개발이야기","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","content":"\n## 개요\n\nChatApplication의 RestAPI 서버에 대한 MVP 개발 완료 및 예정해뒀던 정비가 어느 정도 끝나가고 있어, 이제는 부하 테스트를 작성해야 할 때가 왔다는 생각에 어떻게 하면 좋을지에 대해 고민을 하게 됐습니다.\n\n크게는 두 가지 방법을 생각했습니다. 시작부터 직접 부하 테스트를 작성하는 방법과 부하 테스트 도구를 사용하는 방법이 그것입니다. 그리고 부하 테스트 도구를 사용하는 것이 시간이 지나치게 오래 걸리고 메리트가 없다 싶으면 직접 부하 테스트를 작성하고, 그렇지 않다면 부하 테스트 도구를 사용하는 것이 좋겠다는 생각에 도달했습니다.\n\n이를 검토하기 위해 부하 테스트 도구로 주로 사용되는 오픈 소스 솔루션에 무엇이 있는지 찾아보고 그 중에 후보로 `Locust`, `k6`, `JMeter`를 고민하게 됐습니다.\n\n---\n\n## 기준 세우기\n\n비교하기에 앞서 어떤 도구를 내가 원하는 지에 대한 기준을 세워야 했고, 그 기준은 다음과 같았습니다.\n\n```plaintext\n1. 자유도가 높으며, 다양한 테스트 케이스를 작성할 수 있는가?\n2. websocket을 지원하는가?\n3. 부하 테스트 결과를 쉽게 분석할 수 있는가?\n4. 활발한 커뮤니티를 기반으로 유지보수가 잘 되고 있는가?\n5. 적당한 학습 부하를 통한 자극이 되는가?\n```\n\n각각의 기준을 선정한 이유는 다음과 같습니다.\n\n1. ChatApplication의 RestAPI 서버는 현재 작은 규모의 트래픽만을 다루지만, 여기에 더해 다양한 기술들을 장기간에 걸쳐 새로 도입하는 것을 목표로 하기 때문입니다.\n2. 채팅을 주 기능으로 설정했기 때문에 이에 대해서는 확실한 부하 테스트를 해야 하기 때문입니다.\n3. 어떤 부분이 병목이 되는지, 어떤 부분이 더 개선이 필요한지를 빠르게 파악할 수 있기 때문입니다.\n4. 활발한 커뮤니티가 있을 경우 제가 부딪히게 될 문제들을 빠르게 해결할 수 있으며 동시에 오픈 소스에 참여할 수 있는 기회도 늘어나기 때문입니다.\n5. 마지막으로 이 프로젝트는 장기간 동안 새로운 것을 배우면서 적용해나가는 것을 목표로 하고 있기 때문에 적당한 학습 부하를 통한 자극이 되어야 합니다.\n\n---\n\n## 후보군 선정\n\n`Locust`, `k6`, `JMeter`는 현재 가장 널리 쓰이는 부하 테스트 도구들 중 하나였기 때문에 우선적으로 후보군으로 선정했지만, JMeter의 경우에는 위의 기준에 부합하지 못하는 부분이 많다고 판단했습니다. 이는 JMeter는 GUI 기반의 도구이기 때문에 테스트 케이스를 작성하고 실행하는 데에 시간이 많이 소요되며, 제가 원하는 수준의 자유도를 제공하거나 학습 부하를 제공하지 못한다고 생각했기 때문입니다.\n\n따라서 `Locust`와 `k6`를 후보군으로 선정하게 됐습니다.\n\n---\n\n## Locust vs k6\n\n`Locust`는 파이썬으로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. 파이썬을 사용하기 때문에 파이썬에 익숙한 제가 자유도 높게 테스트 코드를 작성하기에 적합하고, github repository가 23.6k의 star를 받고 contributor가 274명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. websocket을 자체적으로 지원하지 않는 것은 python의 websocket 패키지를 사용하면 되기 때문에 큰 문제가 되지 않았습니다.\n\n`k6`는 Go로 작성된 오픈 소스 부하 테스트 도구로, 코드 기반의 테스트 케이스를 작성할 수 있으며, 분산 부하 테스트를 지원합니다. Go로 작성돼있기 때문에 Locust와 비교해 더 대규모의 부하 테스트를 수행할 수 있으며, websocket을 내부 로직으로 지원하기 때문에 채팅 서버에 대한 부하 테스트를 진행하기에 적합합니다. github repository가 23.3k의 star를 받고 contributor가 1400여명이나 될 정도로 활발한 커뮤니티를 가지고 있었습니다. javascript를 사용하기 때문에 마침 javascript를 공부할 계기가 필요했던 저에게 충분한 학습 부하를 제공할 것이라는 생각이 들었습니다.\n\n---\n\n## k6를 선택하다\n\nlocust 역시 굉장히 잘 운영되고 있는 매력적인 도구였지만, 제가 정해 둔 기준들에서 대부분 k6가 우세했고 무엇보다 이를 계기로 javascript를 공부할 수 있는 기회가 될 것이라는 생각에 k6를 사용해서 부하 테스트를 진행하기로 결정했습니다. 이를 통해 ChatApplication의 RestAPI 서버에 대한 부하 테스트를 진행하고, 이를 통해 어떤 부분이 개선이 필요한지 파악하고 개선해나가는 것이 목표입니다.\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"Locust vs k6 - 부하 테스트 도구 선택","subtitle":"","date":"2024-04-21T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-05-07-Docker mount","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-07-Docker mount.md","category":"개발이야기","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","content":"\n## 개요 - Docker mount란\n\n도커 컨테이너는 호스트와 별도로 파일 시스템을 가지고 있습니다. 이 파일 시스템은 컨테이너가 생성될 때 생성되며, 컨테이너가 종료되면 함께 삭제됩니다. 이 때문에 컨테이너가 종료되면 컨테이너 내부에 저장된 데이터는 모두 사라지게 됩니다. 이러한 문제를 해결하기 위해 도커는 컨테이너 내부의 파일 시스템을 호스트의 파일 시스템과 연결하는 방법을 제공합니다. 이를 도커 mount라고 합니다.\n\n도커 mount는 크게 두 가지 방법으로 구분됩니다. 하나는 볼륨(volume)을 사용하는 방법이고, 다른 하나는 바인드 마운트(bind mount)를 사용하는 방법입니다. 볼륨과 바인드 마운트는 각각 장단점이 있으며, 상황에 따라 적절한 방법을 선택해야 합니다.\n\n![docker mount](https://docs.docker.com/storage/images/types-of-mounts.webp?w=450&h=300)\n\n---\n\n## 볼륨(volume)\n\n볼륨은 Docker가 관리하는 호스트 파일 시스템의 일부에 저장됩니다. Docker가 아닌 프로세스는 파일 시스템의 이 부분을 수정해서는 안되며,\n Docker에서 데이터를 유지하는 가장 좋은 방법이다.\n\n볼륨은 Docker에 의해 생성되고 관리됩니다. 명령을 사용하여 명시적으로 볼륨을 생성할 수 있습니다. 또는 Docker는 컨테이너나 서비스 생성\n 중에 볼륨을 생성할 수 있습니다.\n\n`docker volume create my-vol`\n\n특정 볼륨을 여러 컨테이너에 동시에 마운트하는 것도 가능합니다. 실행 중인 컨테이너가 볼륨을 사용하지 않더라도 Docker에서 계속 사용할 수\n 있으며, 자동으로 제거되지 않고 다음 명령을 사용하여 수동으로 제거해야 합니다.\n\n`docker volume prune my-vol`\n\n---\n\n## 바인드 마운트(bind mount)\n\n바인드 마운트는 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트하는 방식입니다. 바인드 마운트는 볼륨에 비해 기능이 제한되어 있지만 파일 또는 디렉터리는 호스트 시스템의 전체 경로로 참조되며 파일이나 디렉터리가 Docker 호스트에 이미 존재할 필요는 없습니다. 바인드 마운트는 빠르지만 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존하며 공식 문서에서는 볼륨을 사용하는 것을 권장합니다.\n\n---\n\n## 볼륨(volume) vs 바인드 마운트(bind mount)\n\n| 볼륨(volume) | 바인드 마운트(bind mount) |\n|---|---|\n| 호스트의 파일 시스템의 일부를 사용 | 호스트의 디렉토리를 컨테이너의 디렉토리에 마운트 |\n| Docker가 관리 | Docker가 관리하지 않음 |\n| 볼륨을 여러 컨테이너에 동시에 마운트 가능 | 특정 디렉토리 구조를 사용할 수 있는 호스트의 파일 시스템에 의존 |\n\n---\n\n## tmpfs 마운트\n\ntmpfs는 호스트의 메모리에 저장되는 가상 파일 시스템입니다. 컨테이너 수명 동안 컨테이너에서 비지속적 상태 또는 중요한 정보, 예를 들면 secrets, keys, tokens 등을 저장하는 데 사용됩니다. tmpfs는 컨테이너가 종료되면 삭제되므로 컨테이너가 종료되면 데이터가 사라지게 됩니다.\n\n---\n\n## 출처\n\n- [Docker Documentation](https://docs.docker.com/storage/)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"docker mount: volume vs bind","subtitle":"도커 마운트란","date":"2024-05-07T00:00:00.000Z","categories":"개발이야기"}},{"postName":"2024-05-12-Desk setting(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting(2).md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 지난 이야기\n\n<https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/05/12/Desk-setting.html>\n에서 보실 수 있습니다. 이미지는 아래와 같고 주로 큼직큼직한 물건들 모니터, 스피커, 스위치, 팔 받침, 모니터 받침에\n대해 설명했습니다.\n\n이번에는 좀 더 작은 주변기기들에 대해 이야기해보려 합니다\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n---\n\n## 인체공학 키보드 microsoft ergonomic\n\n저는 피씨방에서 키보드 소리가 씨끄럽다는 이유로... 항의를 들어본 적이 있을 정도로 굉장히 키보드를 세게 두드리는\n편입니다. 대체 왜 그런지 모르겠습니다만 엔터키를 칠 때는 오른쪽 손을 들었다가 내려찍는 식으로 치는 경우도 굉장히\n잦았죠. 이제는 많이 고쳤고, 소리 자체도 작게 나는 것을 쓰기 위해 멤브레인 키보드를 쓰기는 합니다만 이런 습관\n때문에 키보드를 오래 쓰는 직업이란 것이 겹치면서 손목에 부담이 많이 갔습니다.\n\n이 때문에 사용하기 시작한 것이 인체공학 키보드이고 핵심은 손목은 손가락보다 높은 곳으로, 키보드가 방사형으로\n구성되어 있어 어깨가 자연스럽게 펴지는 키보드가 되는 것입니다. 본 모델은 뭐 워낙에 유명한 하드웨어 명가 마소의\nergonomic 제품으로 텐키리스이면서 텐키리스가 아닙니다. 텐키용 무선 키보드가 따로 있거든요.\n\n저 같은 경우는 n버튼을 오른 손으로 누른다는 점도 겹쳐서 인체공학 키보드를 쓰는 것에 금방 적응할 수 있었고,\n지금은 일반 키보드를 쓰면 자세가 불편해서 도저히 못 쓸 정도입니다. 이것이 아니라도 어깨, 손목 등에 부담이 많이\n가는 사무직이라면 인체공학 키보드를 사용해보는 것은 강추합니다.\n\n---\n\n## 트랙볼\n\n구매한 지 이제 이틀 된 트랙볼입니다. 원래는 인체공학 버티컬 마우스를 사용했구요. 그것도 굉장히 편해서 제가\n롤을 접게 만든 원흉 중 하나였습니다만(일반 마우스를 쓸 수 없는 몸이 돼버림) 이 역시도 손목이나 어깨에 부담이\n가는 것 같아서 이번에 아예 트랙볼로 바꿨습니다.\n\n제가 선택한 기준은 엄지로 좌클릭을 하고 검~약지로 스크롤을 할 수 있으면서 환불이 가능한 국내 제품이었습니다.\n일단은 만족하고 사용중인데 아직 게임과 같은 작업을 할 때는 조금 어색하긴 하네요. 일단 어깨를 전혀 쓰지 않는\n것과 손목도 거의 쓰지 않아 몸에 부담이 덜 간다는 느낌은 들고 있습니다.\n\n---\n\n## 모니터 암 - 이라 쓰고 태블릿 거치대라 부른다\n\n분명 구매할 때는 모니터 암으로 샀습니다만 모니터랑 호환이 안 돼서 한동안 노트북 거치대로 쓰다가 이제는 태블릿\n및 휴대폰, 펜슬 등 자석이 달린 물건을 고정하는 물건으로 주로 사용중입니다. 그리고 의외로 태블릿을 거치해두면\n책 읽을 때 굉장히 편리하단 장점이 있습니다.\n\n나중에 호환이 되는 모니터를 구하거나 하게 되면 모니터 암으로 사용할 생각입니다만 지금은 꽤 만족 중이네요.\n\n---\n\n## 샤오미 무선 램프\n\n전에 요즘 [바꾼 물건 6선](https://kaestro.github.io/etc/2024/05/04/%EC%B5%9C%EA%B7%BC-%EB%82%B4-%EC%82%B6%EC%9D%84-%EB%B0%94%EA%BE%BC-%EC%A0%9C%ED%92%88%EB%93%A4.html)\n에서 언급한 적이 있는 물건인데, 최종적인 위치를 여기로 확정했습니다. pc 앞에 두고 모니터암과 함께 각도를 자유롭게\n돌리면서 직/간접적으로 백색광부터 따뜻한 빛까지 다양한 색상을 이용할 수 있습니다. 해당 위치가 태블릿 등을 거치하는\n곳이다보니 충전하기에도 용이하고 밤에 필요하면 뽑아서 밖으로 이동하기에도 편리합니다.\n\n---\n\n## 웹캠\n\n면접 등을 보는 용도로 구매한 웹캠입니다.\n\n---\n\n## 기타 무선 제품\n\n책상 좌측 하단에 있는 박스들에 주로 있는데, 게이밍 마우스(요즘엔 거의 사용하지 않는), 게이밍 무선 헤드셋,\n음감용 무선 헤드셋, 배터리 충전기, 링피트 컨트롤러(솔직히 다들 있으시죠?), 무선 엑스박스 컨트롤러, 스위치 팩,\n에어건 등이 있습니다.\n\n---\n\n## 의자\n\n얼마 전에 사망하셔서 집에 있던 식탁 의자 사용중입니다. 근데 원래 의자보다 더 편한 거 같네요?\n\n---\n\n## 마치며\n\n아무래도 불편한게 있으면 참지않고 바로바로 고치는 성격이다보니 무선과 인체공학 제품들로 둘러싸인 책상이\n완성됐네요. 다른 분들은 내 데스크는 이런 부분이 불편해서 사용중인 솔루션에 뭐가 있으신가요? 제 데스크에서\n개선할 만한 부분이 있다 싶으신 부분이 있으면 제 금전이 허락하는 한 참고해보도록 하겠습니다.\n\n긴 글 읽어주셔서 감사합니다.\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(2)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":2}},{"postName":"2024-05-12-Desk setting","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-12-Desk setting.md","category":"개발이야기","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","content":"\n## 서론\n\n아무래도 저는 직업적으로나 취미 적인 측면에서 하루에 컴퓨터를 8시간 이상 사용하는 것은 부지기수이기 때문에,\n가능하면 아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅은 굉장히 공을 들여 만든 부분입니다. 문득 이것 역시도\n컴퓨터를 사용하는 게이머이자 개발자로서 공유하고 이야기를 나누면 재미있을 것 같다는 생각이 들어 글을 쓰게 됐습니다.\n\n광고글로 오해받지 않기 위해 가능한 제품들의 링크 및 제품명은 언급하지 않았습니다.\n\n---\n\n## 현재 내 책상 세팅\n\n현재 제 책상의 전면 상태는 다음과 같습니다.\n\n![책상 전면](/images/Desk%20setting/내%20pc%20세팅.jpg)\n\n오타쿠스러운 취미가 그대로 반영돼 가장 먼저 눈길을 사로잡는 것은 장패드와 각종 실리콘 스탠드 등이겠지만, 그 뒤에\n감춰둔(?) 제 나름의 가능한 아프지 않게 컴퓨터를 사용하기 위한 노력이 있습니다. 이에 대해 한번 천천히 좌측에서\n우측으로 설명해보겠습니다.\n\n---\n\n## 듀얼 모니터\n\n집중력이 떨어지게 하는 역할을 하기도 합니다만, 개발 결과물을 확인하면서 진행하는 용도로 사용한다든가, 구글링\n레퍼런스를 찾아보는 용도로 사용한다는 것이 가장 큰 핑계인 듀얼 모니터입니다. 가장 유용할 때는 롤 경기를 보면서\n카카오톡을 확인하거나, 게임을 플레이하면서 디스코드를 띄워두는 등의 용도입니다.\n\n평소에 높은 집중력을 필요로 할 때는 화면을 하나 꺼두는 어플리케이션을 적극적으로 사용합니다만, 어쩔 수 없이\n두 화면의 활용도가 필요할 때는 듀얼 모니터가 굉장히 유용하게 사용됩니다. 다만 가끔 좌측 화면만 쳐다보고 우측\n화면은 카톡으로만 쓰는 경우를 보면 이럴거면 왜 듀얼 모니터를 쓰는지 의문이 들기도 합니다.\n\n---\n\n## 닌텐도 스위치\n\n작업을 하다가 모든 걸 때려치고 싶은 충동이 들 때 제 안의 흑염룡을 잠재워주는 닌텐도 스위치입니다. 정작 오디오\n인터페이스가 되어 있지 않아 게임을 할 때는 싸구려 모니터 스피커로만 게임을 한다는 것은 안 비밀입니다. 그래도\n젤다 시리즈, 파이어 엠블렘 시리즈, 마리오 시리즈, 컵헤드, 오버쿡드, 하데스, 유니콘 오버로드, 야추 등의 게임을\n플레이한 나름 효자 게임기입니다.\n\n최근에는 스트레스 풀고 싶을 때 태고의 달인을 켜고 신나게 팔을 흔들어서 제 진을 빼놓는 용도로 사용하고 있습니다.\n\n---\n\n## creative pebble v2\n\n가성비로 유명한 스피커입니다. 사실 책상에 놓을만한 사이즈의 물건이 이것 밖에 없었고, 생각보다 음향이 다른 저가형\n스피커와 다른 것을 못 느껴서 사기 당한건가 하는 생각도 처음엔 들었지만 그냥 썼었는데 마지막에 레퍼런스로 달아둔\n링크들을 통해 음향 설정을 하고 나니 많이 달라진 것을 확인할 수 있었습니다.\n\n가격, 크기, 음향과 같은 부분을 고려했을 때 굉장히 훌륭한 제품이라고 생각합니다.\n\n---\n\n## 데스크 팔 받침\n\n책상을 놓을 공간이 협소하다보니 작은 책상을 샀는데, 문제는 팔을 거치할 공간이 없어 팔꿈치가 공중에 떠 있고\n몸이 지나치게 모니터에 붙어있는 자세가 된다는 것이었습니다. 이 때문에 겨드랑이, 어깨 등의 통증이 심해서\n해결하기 위해 구매한 데스크 팔 받침이고 굉장히 많은 도움을 받고 있습니다. 책상이 작아서 조금만 더 늘렸으면\n좋겠다는 생각이 드시면 추천드립니다.\n\n---\n\n## 모니터 받침\n\n모니터 높이를 높게 쓰는 것이 경추 및 척추 위생에 도움이 된다해서 구매한 모니터 받침입니다. 높이 조절은 되지\n않아 아쉽지만 클래식한 목재 디자인에 이것저것 수납할 공간이 있는 것이 마음에 듭니다. 높이가 조금 모자란 것은\n제가 구매한 태블릿 pc의 박스로 조절해서 추가로 높여서 맞췄습니다.\n\n---\n\n## 추가자료\n\n1. <https://gall.dcinside.com/mgallery/board/view/?id=speakers&no=181872>\n2. <https://gall.dcinside.com/mgallery/board/view/?id=speakers&no=189902>\n","layout":"series","recommended":false,"data":{"layout":"series","classes":"wide","title":"인체공학을 염두에 둔 내 pc용 책상 세팅(1)","subtitle":"아프지 않고 오래 컴퓨터를 사용하기 위한 책상 세팅에 대한 이야기","date":"2024-05-12T00:00:00.000Z","categories":"개발이야기","series":"인체공학을 염두에 둔 내 pc용 책상 세팅","seriesIndex":1}},{"postName":"2024-05-17-socket hijack","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-05-17-socket hijack.md","category":"개발이야기","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","content":"\n## 개요 - hijack을 맞이하다\n\n나름대로 테스트코드도 다 돌려 본 채팅이 동작하는 것을 확인한 서버 프로그램을 가지고 있으니 클라이언트에서 부하\n테스트를 작성하는 것은 그렇게 어렵지 않을 것이라 생각했었습니다. 그리고 착각은 무엇인가 할 때마다 산산히 부서져\n나가고 있는 것을 체감하는 요즘입니다. 이번에 맞이한 녀석은 바로 `hijack`입니다.\n\nk6를 잘 모르는 상태에서 소켓 연결을 위해 메시지를 보내고, get request도 보내고 하다가 마침내는 ws의 connect를\n이용해서 요청을 보내는 데 성공했는데 이게 웬걸, 서버사이드에서 황당한 에러 메시지가 나왔습니다.\n\n![hijack log](/images/hijack/error%20-%20hijack.png)\n\n?? http response code는 200인데 error는 발생했고, 내 연결은 hijack(탈취)되었다고? 보자마자 제 머리 속에서\n떠오른 이미지는 이것이었습니다.\n\n![이게 무슨 소리요 의사양반](https://i.namu.wiki/i/uf88vRFdi3xVPlSMkSblePa7NN6QL1pmvUzCWe5rqlxLXvMtjHxqXTTapVkKUh4gSAvYdrI2DkfpWkFo8vpX_A.mp4)\n\n이게 대체 무슨 소리요 의사양반, 제가 여태까지 짜 둔 로직은 탈 생각은 하지도 않고 왜 클라이언트가 내 소켓을\n훔쳐가는 것이오. 이 도동놈을 내 대체 어찌해야 한다는 말이오. 우리 솔로몬급 판결사 copilot님께서는 이 도둑은\n의적으로 필수불가결하니 보내줘야하고, 오히려 제 서버가 이에 맞춰줘야 한다는 의견을 제시하였고 저는 이에 저항할\n도리 없이 일단 이 도둑에 맞춰 서버를 수정해야 하는 상황에 놓였습니다.\n\n그런데 누군지도 모르는 녀석에게 내 소켓을 탈취당한 것도 모자라 훔쳐가기 편하라고 집을 뜯어고치는 것은 너무\n억울해 이번에 한번 조사를 해보기로 했습니다.\n\n---\n\n## 웹소켓이 연결되는 과정\n\n하이잭에 대해 알기 위해서는 제가 대충 알고 있었던 웹소켓의 연결 과정부터 다시 짚어볼 필요가 있다 생각했습니다.\n웹소켓의 연결 과정은 소위 말하는 handshake를 통해 이루어집니다. 이 과정은 다음과 같습니다.\n\n1. 클라이언트가 서버에게 웹소켓 연결을 요청합니다.\n2. 서버는 클라이언트에게 응답을 보냅니다.\n3. 클라이언트는 서버에게 응답을 보냅니다.\n4. 연결이 성공하면 서버와 클라이언트는 데이터를 주고받을 수 있습니다.\n\n이런 교양 넘치는 사람들 간의 합의를 통해 연결이 이루어지는 것이 일반적인 연결 과정입니다. 여기까지가 제가 알고\n있는 내용이고, 서버사이드에서 유닛테스트 및 통합테스트를 통해 이 과정을 정상적으로 마칠 경우에 메시지 역시\n정상적으로 주고받을 수 있었습니다.\n\n---\n\n## 도동놈, 아니 도둑님 잡아라\n\n그런데 이번에는 클라이언트가 서버에게 연결을 요청하고, 서버가 응답을 보내고, 클라이언트가 응답을 보내는\n과정은 제가 서버 내에서 임의의 클라이언트를 상정하던 것과는 달랐습니다. 아무래도 그것은 제가 사용하는 k6의\nws.connect가 연결을 요청하는 과정에서 hijack이라는 go의 websocket 패키지의 메서드와 다른 방식으로 연결을\n하는 것일 가능성이 높아보였습니다.\n\n![나는 능이버섯이다](/images/hijack/능이버섯.png)\n\n뭐 여기까지 왔는데 어쩌겠습니까. 제 반려 프로그램을 포기할 수는 없으니 이 도둑님께 굴복하는 수밖에요. 조금 더\n찾아보니 websocket hijack 관련해서는 보안 관련 이슈들이 주를 이루고 있었으나, 다른 것은 go의 http 패지키의\nhijack interface였습니다. 즉 제가 쓰는 k6도 go를 기반으로 만들어졌고, 제 서버 역시도 go로 만들어졌기 때문에\n단순히 웹소켓 연결을 요청하는 것이 아니라 hijack을 통해 연결을 요청하는 것이었습니다.\n\n---\n\n## 내가 해야하는 조치\n\n현재 제 서버는 연결을 할 때 연결이 hijack에 의해서가 아니라 기존의 gin Context의 connection을 이용한 것입니다.\n이 때문에 hijack을 통해 연결을 요청하는 경우에는 연결이 되지 않는 문제가 발생하게 되었습니다. 이 문제를 해결하기 위해서\n제가 해야할 조치는 기존에 작성한 채팅쪽 서비스 코드와 소켓 연결 모듈을 새로운 인터페이스에 맞게 수정하는 것이네요.\n별 것 아니네요!\n\n는 그럴리가 없으니, 이슈를 새로 따서 현재 작성된 hijack이 이루어지지 않을 때의 연결을 위한 코드에서 최소한의\n수정을 통해 더 높은 단의 추상 interface를 제공하고 이를 통해 양쪽의 연결을 이루어지게끔 수정하는 것이 가능한\n지에 대한 검토 및 재설계의 과정을 거쳐야 할 것 같습니다. 개발은 너무 재밌어요.(농담 아님)\n","layout":"산문","recommended":false,"data":{"layout":"산문","classes":"wide","title":"hijack - 웹소켓 도둑놈, 아니 도둑님 잡아라","subtitle":"웹 소켓을 위한 통신 프로토콜","date":"2024-05-17T00:00:00.000Z","categories":"개발이야기"}}],"category":"개발이야기","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"]},"__N_SSG":true}