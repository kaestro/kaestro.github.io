{"pageProps":{"posts":[{"postName":"2024-04-03-4월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-03-4월 1주차 알고리즘 문제.md","category":"Algorithm","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","content":"\n### 목차\n\n- [\\[이번 주의 문제\\] Can Make Palindrome from Substring](#이번-주의-문제-can-make-palindrome-from-substring)\n- [가능한 적게 저장하라](#가능한-적게-저장하라)\n- [integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법](#integer-보다-string이-더-빠른-경우-input에-적절한-보정을-사용하는-방법)\n- [pattern 찾기 =\\> 변환하기](#pattern-찾기--변환하기)\n- [가능한 적게 저장하라 - 2](#가능한-적게-저장하라---2)\n\n---\n\n## [이번 주의 문제] Can Make Palindrome from Substring\n\n[문제 링크](https://leetcode.com/problems/can-make-palindrome-from-substring/description/)\n\n문제 요약: inputs[left:right+1]를 rearrange하고 k번 이하의 문자를 변경해서 palindrome을 만들 수 있는지 확인하는 문제이다.\n\ndp, prefix sum을 통한 (i, j) 구간의 저장 공간 줄이기, xor 연산의 사용, binary로 변환하는 방법 등을 통해 풀이를 개선할 수 있다. [참고자료](https://leetcode.com/problems/can-make-palindrome-from-substring/solutions/371999/python-100-runtime-and-memory/)\n\n내 풀이 개선 과정\n\n1. [prototype without rearrange](https://github.com/kaestro/algorithms_v3/commit/4e0178afb27014628516dc2a47c0c557b9969d19)\n2. [saving everything is too much](https://github.com/kaestro/algorithms_v3/commit/3e5f988d9bf8e79222c52e4d2f4bb22d6034436c)\n3. [using prefix sum to reduce space](https://github.com/kaestro/algorithms_v3/commit/78b0945d61b74012b3f331c2829354404e73424e)\n4. [Use List instead of Dictionary When index range is small and limited. If only odd/even matters don't add and %= 2, use xor](https://github.com/kaestro/algorithms_v3/commit/f8bd0f94ea3eee84ddf7df8df5130967efc02ea5)\n5. [If only odd/even number matters, you may change integer into binary](https://github.com/kaestro/algorithms_v3/commit/d3a4fbeb4c0c86ada9266748c5b848a7b8b0782f)\n\n---\n\n## 가능한 적게 저장하라\n\n- [문제 링크](https://leetcode.com/problems/toeplitz-matrix/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/6208041d46052adfabceeb6c1b34685d68896482)\n\n문제 요약: 대각선의 값들이 모두 동일한 value를 가지는 지 확인하는 문제이다.\n\n최초의 풀이는 대각선의 값들을 dictionary 안에 저장하고, 이들을 같은지 확인하는 방식으로 구현했다. key로는 (row, col)을 쓰고, mat[(row, col)] == mat[(row-1, col-1)]인지 확인했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0]))}\n```\n\n그런데 이는 최초의 첫 row/col만 확인하면 되는 문제이기 때문에, dictionary에 해당 값들만 저장하고 이를 비교하도록 구현을 변경했다.\n\n```python\nmatrix_dict = {(i, j) : matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) if i == 0 or j == 0}\n```\n\n이 밖에 key로 row - col을 사용하는 것도 한가지 방법이며, 이 방법을 사용할 경우 dictionary가 아니라 조금의 튜닝을 통해 일반적인 list로도 구현이 가능하다.\n\n---\n\n## integer 보다 string이 더 빠른 경우. input에 적절한 보정을 사용하는 방법\n\n- [문제 링크](https://leetcode.com/problems/split-with-minimum-sum/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/825c371389d1f69d10666d23fc8f38bbf650c2b3)\n\n문제 요약: 각 수의 자릿수를 가지고 split number를 만든 뒤에 이 중 합이 가장 작은 split sum을 구하는 문제이다.\n\n내 기존 풀이는 integer를 나누고, 나머지를 digits list에 저장하는 방식이었다. 그런데 이러는 것보다 string으로 변환한 뒤 처리하는 것이 더 유리할 수 있다. 이는 각각을 나누는 연산을 진행하는 것보다 string으로 변환하는 것이 빠르기 때문으로 추측된다.\n\n```python\ndef save_digits_as_int(num: int):\n    digits = []\n    while num > 0:\n        digits.append(num % 10)\n        num //= 10\n    return digits\n```\n\n```python\ndef save_digits_as_char(num: int):\n    return list(str(num))\n```\n\n해당 문제는 맨 앞에 0이 나오는 경우를 허용하는 문제이기 때문에 input integer의 자리수가 홀수일 경우 0을 추가해주는 보정을 하면 해결이 쉬워진다.\n\n---\n\n## pattern 찾기 => 변환하기\n\n- [문제 링크](https://leetcode.com/problems/number-of-subarrays-that-match-a-pattern-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/c0515d3bf3ab61a79de9f97679ffe965902ea9bb)\n\n문제 요약: 주어진 integer에 대해 pattern이 [1, 0, -1] 세 가지로 주어지고, 이것들이 부분 순열에서의 증가, 동일, 감소 패턴을 나타내는 문제이다. 그리고 이 pattern이 몇 번 나오는지 확인하는 문제이다.\n\n기존의 내 문제 풀이는 모든 index에 대해 pattern이 존재하는지 확인하는 방식으로 구현했다.\n\n```python\nfor i in range(len(nums) - len(patterns)):\n    for j in range(len(patterns)):\n        if patterns[j] == 1 and nums[i + j + 1] <= nums[i + j]:\n            break\n        elif patterns[j] == 0 and nums[i + j + 1] != nums[i + j]:\n            break\n        elif patterns[j] == -1 and nums[i + j + 1] >= nums[i + j]:\n            break\n    else:\n        result += 1\n```\n\n이 문제는 pattern을 만드는 문제로 바꾸어 생각해서 해결할 수 있다.\n\n```python\ndef apply_pattern(nums: List[int], pattern: List[int]) -> List[int]:\n    ans = []\n    for i in range(1, len(nums)):\n        if (nums[i] == nums[i - 1]):\n            ans.append(0)\n        elif (nums[i] > nums[i - 1]):\n            ans.append(1)\n        else:\n            ans.append(-1)\n    return ans\n```\n\n둘의 시간복잡도는 동일하지만 두 번째 방법이 더 직관적이고 이해하기도 쉬우면서, 더 적은 비교 연산을 수행하기 때문에 성능이 좋게 나타나는 것을 확인할 수 있었다.\n\n---\n\n## 가능한 적게 저장하라 - 2\n\n- [문제 링크](https://leetcode.com/problems/design-an-ordered-stream/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/f38f736837c54887b8a31bbb59a0806a8b7f2c7b)\n\n문제 요약: stream이 들어올 때, id 지점 기준으로 내보낼 수 있는 연속된 chunk가 형성되면 이를 내보내는 문제이다.\n\n기존의 내 풀이는 stream에서 return할 값들을 새로운 list에 저장하고, 이를 return하는 방식으로 구현했다.\n\n```python\nresult = []\nfor i in range(self.idx, len(self.stream)):\n    if self.stream[i] is None:\n        break\n    result.append(self.stream[i])\n    self.idx += 1\nreturn result\n```\n\n그러나 이는 정직한 부분 리스트를 반환하는 함수이기 때문에 새로운 list를 생성할 필요가 없다.\n\n```python\nbegin = self.idx\nwhile self.stream[self.idx]:\n    self.idx += 1\n\nreturn self.stream[begin:self.idx]\n```\n\n---\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"4월 1주차 알고리즘 문제","subtitle":"가능한 적게 저장하라, 패턴을 찾기보다 패턴을 만들어라","date":"2024-04-03T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-09-4월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-09-4월 2주차 알고리즘 문제.md","category":"Algorithm","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","content":"\n### 목차\n\n- [\\[금주의 문제\\] sliding window를 통해 더 적게 비교하기](#금주의-문제-sliding-window를-통해-더-적게-비교하기)\n- [trailing zeros 제거하는 다양한 방법](#trailing-zeros-제거하는-다양한-방법)\n- [저장을 통해 연산 횟수 줄이기](#저장을-통해-연산-횟수-줄이기)\n\n---\n\n## [금주의 문제] sliding window를 통해 더 적게 비교하기\n\n- [문제 링크](https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2200%20-%20LeetCode.py)\n\n- 문제 요약\n  - list integer에서 key값과 좌우로 k만큼 떨어진 index로 구성된 list를 구하는 문제이다.(findKthDistanceIndices)\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(k*n)$\n    - set을 이용해서 key가 발견되면 좌우 index range를 update하고, 최후에 sorted된 list를 반환하는 방식으로 구현했다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - sliding window를 통해 update해야할 필요가 있는 index를 범위를 줄인다\n    - 한 번만의 loop만으로 문제를 해결할 수 있다.\n\n---\n\n## trailing zeros 제거하는 다양한 방법\n\n- [문제 링크](https://leetcode.com/problems/remove-trailing-zeros-from-a-string/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/1057a28ce89c643e18d6b9f72a6aa5f3de68044b)\n\n- 문제 요약\n  - 문자열로 저장한 수에서 맨 뒤의 0들을 모두 제거하는 문제이다.\n- 풀이 요약\n  - 내 풀이\n    - 내 풀이는 input string을 list로 변환한 뒤 pop을 사용해 0을 제거하는 방식으로 구현했다.\n    - 이는 python에서 list pop은 stack과 같이 동작하기 때문에 효율적이기 때문이다.\n  - 다른 풀이\n    - rstrip을 사용한다\n    - 수를 integer로 변환하고 뒤집었다가 다시 뒤집는다\n\n---\n\n## 저장을 통해 연산 횟수 줄이기\n\n- [문제 링크](https://leetcode.com/problems/count-the-number-of-incremovable-subarrays-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/blob/main/Daily%20Practices/March/Week%203rd/2970%20-%20LeetCode.py)\n\n- 문제 요약\n  - integer array에서 subarrary를 삭제한 뒤에 전 구간에서 increasing하는 array가 되는 경우, 삭제한 subarray를 incremovable subarray라 한다. 이때 incremovable subarray의 개수를 구하는 문제이다.\n- 풀이 요약\n  - Brute Force 풀이\n    - Time Complexity: $O(n^3)$\n    - 모든 subarray에 대해 잘라지지 않은 subarray가 increasing한지 확인하는 방법\n  - 개선 풀이\n    - Time Complexity: $O(n^2)$\n    - 모든 subarray들의 increasing 여부를 저장한다. 그런 다음 자르고 나서 좌 우가 increasing하고, 연결부가 increasing한 경우를 찾는다.\n\n```python\nfor i in range(len(nums)):\n    for j in range(i, len(nums)):\n        if isIncreasingSubarray.get((0, i - 1), True) and isIncreasingSubarray.get((j + 1, len(nums) - 1), True):\n            if nums[j+1] > nums[i-1] if i > 0 and j < len(nums) - 1 else True:\n                result += 1\n```\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 2주차 알고리즘 문제","subtitle":"sliding window, integer trimming, 저장을 통한 연산 횟수 줄이기","date":"2024-04-09T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-15-4월 3주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-15-4월 3주차 알고리즘 문제.md","category":"Algorithm","title":"4월 3주차 알고리즘 문제","subtitle":"더 적은 연산으로 문제 해결하기, 사용중인 저장 공간을 재활용","content":"\n### 목차\n\n- [주어진 조건을 더 적은 연산으로 해결하기](#주어진-조건을-더-적은-연산으로-해결하기)\n- [이미 사용중인 메모리의 저장 공간을 활용한 문제 해결](#이미-사용중인-메모리의-저장-공간을-활용한-문제-해결)\n\n---\n\n## 주어진 조건을 더 적은 연산으로 해결하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-strong-pair-xor-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/fedf633e9215df5a417ccc3aaeaddf51b1497ce2)\n\n- 문제 요약\n  - Strong Pair는 $\\|(x - y)\\| \\leq min(x, y)$를 만족하는 pair이다.\n- 풀이 요약\n  - 기존 풀이\n    - if (abs(x - y) <= min(x, y))\n  - 개선 풀이\n    - if y <= 2 * x\n\n---\n\n## 이미 사용중인 메모리의 저장 공간을 활용한 문제 해결\n\n- [문제 링크](https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/2f8a28a20ab10b13af7c892818c92ee7b52ea371)\n\n- 문제 요약\n  - list에서 가장 작은 수의 index를 찾는다. 이 때 같은 수가 여러개라면 가장 작은 index를 찾는다.\n  - 해당 값을 결과 값에 더하고, 좌우의 값을 visited로 만든다.\n- 풀이 요약\n  - 기존 풀이\n    - heap을 이용해서 가장 작은 수를 찾는다.\n    - 좌우의 값을 확인한 뒤 이를 heap에서 제거한다.\n    - 실제로 추가/제거하는 연산이 많아진다.\n  - 개선 풀이\n    - 연산 완료 및 visited 처리된 index의 값을 -1로 변경한다.\n    - heap이 아니라 sort한 이후에 visit을 이용해 처리한다.\n\n---\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 3주차 알고리즘 문제","subtitle":"더 적은 연산으로 문제 해결하기, 사용중인 저장 공간을 재활용","date":"2024-04-15T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-21-4월 4주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-21-4월 4주차 알고리즘 문제.md","category":"Algorithm","title":"4월 4주차 알고리즘 문제","subtitle":"gap 채우기, sum of all odd length subarrays","content":"\n### 목차\n\n- [정렬된 수 사이에 gap을 채우기](#정렬된-수-사이에-gap을-채우기)\n- [sum of all odd length subarrays](#sum-of-all-odd-length-subarrays)\n\n---\n\n## 정렬된 수 사이에 gap을 채우기\n\n- [문제 링크](https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/4d05a526eabd8241f08d206d321e807fa5017fb8)\n\n- 문제 요약\n  - 주어진 integer array에서 각 요소를 재배열하거나 작아지게 하는 연산을 통해 각 element 간의 차이가 1 이하가 되도록 만들 때, 마지막 요소의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - 각 수를 set으로 만들어 정렬한다\n    - 수 사이의 gap을 찾는다.\n    - gap이 1 이상인 경우, gap을 채운다.\n  - 개선 풀이\n    - 수를 정렬한다.\n    - 이전 수와 현재 수의 차이가 1 이상인 경우, 현재 수를 이전 수 + 1로 만든다.\n\n```python\ndef maximumElementAfterDecrementingAndRearranging(arr: List[int]) -> int:\n  arr sort()\n  prev = 0\n  for i in range(1, len(arr)):\n      if arr[i] - arr[prev] > 1:\n          arr[i] = arr[prev] + 1\n      prev = i\n\n  return arr[-1]\n```\n\n---\n\n## sum of all odd length subarrays\n\n- [문제 링크](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/cd8f5cd113d3a4f802efe154e84989e8746f9ab9)\n\n- 문제 요약\n  - 주어진 integer array에서 odd length subarray의 합을 구하라.\n- 기존 풀이\n  - prefix sum을 구한다.\n  - 이를 이용해 odd length subarray의 합을 구한다.\n  - Time complexity: $$O(n^2)$$\n- [개선 풀이](https://leetcode.com/problems/sum-of-all-odd-length-subarrays/solutions/854184/java-c-python-o-n-time-o-1-space/?source=submission-ac)\n  - arr[k]가 포함된 subarray의 개수는 $$(k+1) * (n-k)$$이다.\n  - 따라서, arr[k]가 포함된 subarray의 합은 $$arr[k] * (k+1) * (n-k)$$이다.\n  - 이 중 홀수 길이의 subarray의 갯수는 전체 길이가 홀수인 경우 짝수보다 1개 더 많다.\n  - Time complexity: $$O(n)$$\n\n```python\ndef sumOddLengthSubarrays(arr: List[int]) -> int:\n  n = len(arr)\n  ans = 0\n  for i in range(n):\n      ans += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n  return ans\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 4주차 알고리즘 문제","subtitle":"gap 채우기, sum of all odd length subarrays","date":"2024-04-21T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-28-4월 5주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-04-28-4월 5주차 알고리즘 문제.md","category":"Algorithm","title":"4월 5주차 알고리즘 문제","subtitle":"2 pointer, 초기화, projection","content":"\n### 목차\n\n- [두 수의 합이 주어진 수가 되는 경우 찾기](#두-수의-합이-주어진-수가-되는-경우-찾기)\n- [반대 경우의 수가 나왔을 때 초기화를 통한 처리 방법](#반대-경우의-수가-나왔을-때-초기화를-통한-처리-방법)\n- [3d 입체를 2d로 투영할때의 면적 구하기](#3d-입체를-2d로-투영할때의-면적-구하기)\n\n---\n\n## 두 수의 합이 주어진 수가 되는 경우 찾기\n\n- [문제 링크](https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/ea58957b4a598a7f38fbbfa2a04d8230c3d57115)\n\n- 문제 요약\n  - 주어진 integer array에서 두 수를 선택하여 더한 값이 같은 경우를 찾은 뒤, 그 곱이 가장 큰 경우를 찾아라\n- 풀이 요약\n  - sorted array에서 2 pointer를 사용하여 두 수를 선택한다.\n\n```python\ndef maxOperations(self, nums: List[int], k: int) -> int:\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    result = 0\n    while left < right:\n        if nums[left] + nums[right] == k:\n            result += 1\n            left += 1\n            right -= 1\n        elif nums[left] + nums[right] < k:\n            left += 1\n        else:\n            right -= 1\n    return result\n```\n\n---\n\n## 반대 경우의 수가 나왔을 때 초기화를 통한 처리 방법\n\n- [문제 링크](https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/0ad2579f8b8c4c2218b5fe4c8b675fa50330290d)\n\n- 문제 요약\n  - 주어진 binary string에서 연속된 1의 개수가 연속된 0의 개수보다 많은 경우 True를 반환하라\n- 풀이 요약\n  - longestOne/Zero, currentOne/Zero를 사용하여 연속된 1과 0의 개수를 센다.\n  - 반대 것이 나오면 currentOne/Zero를 0으로 초기화하면서 반대 것의 개수를 센다.\n\n```python\ndef checkZeroOnes(self, s: str) -> bool:\n    longestOne, longestZero = 0, 0\n    currentOne, currentZero = 0, 0\n    for ch in s:\n        if ch == '1':\n            currentOne += 1\n            currentZero = 0\n        else:\n            currentZero += 1\n            currentOne = 0\n        longestOne = max(longestOne, currentOne)\n        longestZero = max(longestZero, currentZero)\n    return longestOne > longestZero\n```\n\n---\n\n## 3d 입체를 2d로 투영할때의 면적 구하기\n\n- [문제 링크](https://leetcode.com/problems/projection-area-of-3d-shapes/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/27901b40b7156cc68d9593cb5f28f000712bc489#diff-0226d5b537395ebe798252e8565dadecfa5545dbc7de1dc158294433b7627e03)\n\n- 문제 요약\n  - 3d 블록 입체를 2d array 형태로 주었을 때, xy, yz, zx 평면으로 투영한 면적의 합을 구하라\n- 풀이 요약\n  - xy: 2d array에서 0이 아닌 값의 개수\n  - yz: 2d array에서 각 row의 최대값의 합\n  - zx: 2d array에서 각 column의 최대값의 합\n\n```python\ndef projectionArea(self, grid: List[List[int]]) -> int:\n    xy = sum(1 for row in grid for val in row if val)\n    yz = sum(max(row) for row in grid)\n    zx = sum(max(col) for col in zip(*grid))\n    return xy + yz + zx\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"4월 5주차 알고리즘 문제","subtitle":"2 pointer, 초기화, projection","date":"2024-04-28T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-05-5월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-05-5월 1주차 알고리즘 문제.md","category":"Algorithm","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","content":"\n### 목차\n\n- [두 수가 교차하는 경우의 수를 다루는 방법](#두-수가-교차하는-경우의-수를-다루는-방법)\n\n---\n\n## 두 수가 교차하는 경우의 수를 다루는 방법\n\n- [문제 링크](https://leetcode.com/problems/semi-ordered-permutation/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/eb87856177f2836c0da339976e9473f63910c9dc)\n\n- 문제 요약\n  - Semi-Ordered Permutation이란, 처음이 가장 작은 수이고 가장 마지막이 가장 큰 수이며, 중간에는 어떤 수든 나타날 수 있는 순열이다.\n  - 순열이 주어졌을때 인접한 두 수를 swap하여 Semi-Ordered Permutation을 만드는 최소 교환 횟수를 구하라.\n- 풀이 요약\n  - 가장 작은 수가 1에 도착하는 횟수 + 가장 큰 수가 n에 도착하는 횟수를 구하면 된다.\n  - **이 때 두 수가 교차하는 경우 1을 빼주면 된다.**\n\n```python\ndef semiOrderedPermutation(self, A: List[int]) -> int:\n    n = len(A)\n    i, j = A.index(1), A.index(n)\n    return i + n - 1 - j - (i > j)\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","date":"2024-05-05T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-12-5월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-12-5월 2주차 알고리즘 문제.md","category":"Algorithm","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","content":"\n### 목차\n\n- [$O(n)$으로 배열 내 요소 간 최대 차이 구하기](#on으로-배열-내-요소-간-최대-차이-구하기)\n- [필요 없는 중간과정 생략하기](#필요-없는-중간과정-생략하기)\n- [3개의 distinct한 subarray를 구하는 방법](#3개의-distinct한-subarray를-구하는-방법)\n\n---\n\n## $O(n)$으로 배열 내 요소 간 최대 차이 구하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea)\n\n- 문제 요약\n  - int array가 주어졌을 때, i < j이고 A[i] < A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(n^2)$\n    - i < j이고 A[i] < A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.\n    - 따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - A[j] > A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.\n    - 그렇지 않을 경우에는 i를 j로 갱신한다.\n\n```python\ndef maxDifference(self, nums: List[int]) -> int:\n    max_diff = -1\n    min_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n    return max_diff\n```\n\n---\n\n## 필요 없는 중간과정 생략하기\n\n- [문제 링크](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2)\n\n- 문제 요약\n  - n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.\n  - 개선 풀이\n    - 어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.\n    - 따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.\n    - 이 때문에 처음과 끝만 보면 된다.\n\n```python\ndef mostVisited(self, n: int, rounds: List[int]) -> List[int]:\n    start, end = rounds[0], rounds[-1]\n    if start <= end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(1, end + 1)) + list(range(start, n + 1))\n```\n\n---\n\n## 3개의 distinct한 subarray를 구하는 방법\n\n- [문제 링크](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6)\n\n- 문제 요약\n  - int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.\n  - subarray는 연속된 요소들의 집합이다.\n- 풀이 요약\n  - Time Complexity: $O(n^2)$\n  - 3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n\n```go\nfunc minCost(nums []int) int {\n    n := len(nums)\n\n    minCost := math.MaxInt32\n    for i := 1; i < n - 1; i++ {\n        for j := i + 1; j < n; j++ {\n            cost := nums[0] + nums[i] + nums[j]\n            minCost = min(minCost, cost)\n        }\n    }\n    return minCost\n}\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","date":"2024-05-12T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-24-Dynamic Programming","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-24-Dynamic Programming.md","category":"Algorithm","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","content":"\n## Dynamic Programming은 Optimization Problem 해결 방법이다\n\n여러 가지 문제 중에 Dynamic Programming을 사용해서 푸는 문제들은 Optimization Problem을 푸는 경우로 한정됩니다. 그렇다면 Optimization Problem은 무엇을 의미하는 것일까요?\n\n이는 여러개의 [선택 가능한 후보 중에서 최적의 해 또는 최적의 해에 근접한 값을 찾는 문제](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)를 말합니다. 이는 종종 [특정 기능의 최대값 또는 최소값을 찾는 것](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)이 포함됩니다. 예를 들면 이동에 소요되는 최소 시간, 작업 수행에 필요한 최소 비용, 장치에서 생성할 수 있는 최대 전력 등이 있습니다.\n\n---\n\n## Dynamic Programming을 사용하는 문제의 특징\n\n최적값을 문제를 푸는 문제들 중에서도 Dynamic Programming을 통해 해결할 수 있는 문제들은 다음의 두 가지 특징을 가지고 있습니다.\n\n1. **Optimal Substructure** : 문제의 최적해가 부분 문제의 최적해로 구성되어 있습니다.\n2. **Overlapping Subproblems** : 부분 문제들이 중복되어 계산되는 경우가 있습니다.\n\n### Optimal Substructure\n\n문제의 최적해가 부분 문제의 최적해로 구성돼 있다는 다음과 같은 의미를 나타냅니다. 우선, 주어진 문제의 최적해를 선택할 수 있다고 가정해 보겠습니다. 이 최적해를 구하는 구조의 특징을 통해 최적해의 값을 정의내릴 때, 부분 문제의 최적해를 사용할 수 있습니다.\n\n예를 들어, Rod-Cutting 문제 즉 막대기를 가장 비싼 가격의 단위 막대기들로 자르는 최적의 해를 구하는 문제를 생각해보겠습니다. 이 문제에서 막대기는 단위 길이별로 가격이 정해져 있습니다.\n\n$$Price_1 = 1, Price_2 = 5, Price_3 = 8$$과 같이 말입니다.\n\n이 때 길이가 4인 막대기를 자르는 최적의 해를 구한다고 가정했을 때, 길이가 5인 막대기를 자르는 최적의 해를 구하는 방법은 다음과 같습니다.\n\n$$Price_5 = \\max_{k=1}^{3}(Price_k + Price_{5-k})$$\n\n이처럼 특정 순간의 최적해를 구할 때, 그 최적해를 구성하는 부분 문제의 최적해를 사용해서 표현할 수 있습니다.\n\n### Overlapping Subproblems\n\n이 때 부분 문제들을 구하는 과정 역시 중복되어 계산되는 경우가 있습니다. 방금의 Rod-Cutting 문제를 예시로 들면 Price(5)의 최적해를 구하기 위해서는 Price(4), Price(3), Price(2)의 값을 계산해야합니다. 그리고 이는 다시 {Price(3), Price(2), Price(1)}, {Price(2), Price(1), Price(0)}의 값을 계산해야합니다. 이 때 Price(3)은 Price(2)를 계산할 때도 필요하고 Price(1)을 계산할 때도 필요합니다.\n\n---\n\n## Dynamic Programming의 구현 방법\n\nDynamic Programming을 구현하는 방법은 요약하자면 다음과 같습니다.\n\n```markdown\n1. 최적해를 구하는 경우를 나타내는 함수를 부분 문제의 최적해를 이용해 표현합니다.\n2. 부분 문제가 더 나눌 수 없는 경우를 찾아내고, 이를 기저 조건으로 설정합니다.\n3. 부분 문제를 구하는 과정에서 중복되는 계산을 피하기 위해, 부분 문제의 최적해를 저장하는 배열을 사용합니다.\n```\n\n### Top-Down Approach\n\nTop-Down Approach는 재귀적인(recursive) 방법을 사용하여 문제를 푸는 방법입니다. 예를 들어 rod-cutting 문제를 해결하려 할 때 Price(5)의 값을 구하기 위해 Price(4), Price(3), Price(2)의 값을 구하는 방법입니다. 이는 보통 재귀적인 방법을 사용하여 구현되며 이를 memoization이라고 합니다.\n\n### Bottom-Up Approach\n\nBottom-Up Approach는 반복적인(iterative) 방법을 사용하여 문제를 푸는 방법입니다. 이는 보통 반복문을 사용하여 작은 값부터 큰 값까지 순차적으로 계산하는 방법입니다. 이를 tabulation이라고 합니다.\n\n문제의 성향에 따라 Top-down approach가 더 적은 연산을 필요로 할 수도 있지만, Bottom-up approach가 더 직관적이고 iterative한 계산 방식을 사용하기 때문에 디버깅에 용이한 등의 장점을 가지고 있습니다.\n\n---\n\n## 참고 자료\n\n- Introduction To algorithms pg.380 ~ 434\n- [Convex Optimization for All](https://convex-optimization-for-all.github.io/contents/chapter01/2021/01/07/01_01_optimization_problems/)\n- [Optimization Problems](https://www.sfu.ca/math-coursenotes/Math%20157%20Course%20Notes/sec_Optimization.html)\n- [tabulation vs memoization](https://www.geeksforgeeks.org/tabulation-vs-memoization/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Dynamic Programming","subtitle":"최적해를 구하기 위해, 부분 문제의 최적해를 이용하는 방법","date":"2024-04-24T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-04-25-BFS and DFS","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-04-25-BFS and DFS.md","category":"Algorithm","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","content":"\n## BFS와 DFS는 그래프를 탐색하는 방법 중 두 가지입니다\n\nBFS(Breadth First Search)와 DFS(Depth First Search)는 그래프를 탐색하는 방법 중 하나입니다. 여기서 그래프를 탐색한다는 것은 그래프의 정점(vertex)에 접근해서 해당 정점이 가지고 있는 정보를 이용해 자신이 원하는 연산을 수행하는 것을 의미합니다. 미로 찾기 문제를 풀 때, 미로를 그래프로 표현하고 출발점에서 도착점까지의 경로를 찾는 문제를 풀 때 각각의 정점을 방문하면서 탈출구에 도달할 때까지 탐색하는 것이 그래프 탐색의 한 예입니다.\n\n### BFS(Breadth First Search)\n\nBFS는 그래프를 탐색할 때 너비를 우선으로 탐색하는 방법입니다. 즉, 시작 정점에서 가까운 정점부터 탐색을 진행하며 큐(Queue)를 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산의 경우에는 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 시간 복잡도는 $O(V+E)$입니다. 이를 통해 풀 수 있는 문제의 예시로는 모든 정점 간의 거리가 같을 때 최단 경로를 찾는 문제가 있습니다.\n\n#### shortest path\n\n### DFS(Depth First Search)\n\nDFS는 그래프를 탐색할 때 깊이를 우선으로 탐색하는 방법입니다. 시작 정점에서 깊이를 우선으로 탐색을 진행하며 스택(Stack)을 이용하여 구현할 수 있습니다. 이 때 최대로 진행하는 연산은 모든 정점을, 모든 간선을 한 번씩 방문하는 것을 통해 방문하는 것이므로 BFS와 마찬가지로 시간 복잡도는 $O(V+E)$입니다.\n\nDFS는 각각의 간선을 다음의 네 가지로 구분하는 데 사용할 수 있습니다.\n\n```plaintext\n1. 트리 간선(tree edge): DFS 트리에서 나온 간선(edge)\n2. 순방향 간선(forward edge): DFS 트리에서 나온 간선이 아니지만, 자식 노드로 가는 간선(edge)\n3. 역방향 간선(back edge): DFS 트리에서 나온 간선이 아니지만, 조상 노드로 가는 간선(edge)\n4. 교차 간선(cross edge): DFS 트리에서 나온 간선이 아니지만, 서로 다른 서브트리 간의 간선(edge)\n```\n\n여기서 dfs트리란 DFS를 수행하면서 만들어지는 각 정점을 방문하는 순서대로 정렬된 트리를 의미합니다. DFS 트리에서 나온 간선(edge)이라는 것은 DFS를 수행하면서 만들어지는 트리에서 나온 것을 의미하며 나머지 간선(edge)들은 DFS 트리에서 나오지 않는 것들입니다.\n\n#### topological sort\n\n구성 요소 간에 우선순위가 존재하는 경우 이를 정렬하는 것을 위상정렬(topological sort)이라고 합니다. 위상정렬은 DFS를 이용하여 구현할 수 있으며 다음과 같은 순서를 따릅니다.\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다. 탐색하는 과정에서 각각의 정점을 방문하는데 걸린 시간을 기록한다.\n2. 모든 정점을 방문한 후, 각 정점을 방문한 시간을 기준으로 내림차순으로 정렬한 linked list를 반환한다.\n```\n\n```plaintext\n1. DFS를 이용하여 그래프를 탐색한다.\n2. 탐색하고 빠져나오는 순간에 해당 정점을 linked list의 맨 앞에 추가한다.\n3. 이를 모든 정점을 방문할 때까지 반복한다.\n4. linked list를 반환한다.\n```\n\n```python\ndef topological_sort(graph):\n    visited = [False] * len(graph)\n    topological_order = []\n    stack = []\n\n    for v in range(len(graph)):\n        if not visited[v]:\n            stack.append(v)\n            while stack:\n                node = stack[-1]\n                if not visited[node]:\n                    visited[node] = True\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            stack.append(neighbor)\n                else:\n                    stack.pop()\n                    topological_order.append(node)\n\n    return topological_order[::-1]\n```\n\n#### acyclic graph\n\nacyclic graph는 사이클이 없는 그래프를 의미합니다. 이 때 acyclic graph는 위상정렬을 통해 정렬할 수 있습니다.\n\n#### strongly connected components\n\nstrongly connected component는 모든 구성 vertex(정점)들이 서로 도달 가능한 그래프의 부분 그래프를 의미합니다. 이를 수학적으로 표현하면 다음과 같습니다.\n\nvertices C is strongly connected component when\n\n$$G = (V, E)$$\n$$C \\subseteq V$$\n$$\\forall u, \\forall v \\in C, u \\rightarrow v \\text{ and } v \\rightarrow u$$\n\n이를 DFS를 이용해 구하는 방법은 다음과 같습니다.\n\n1. 그래프 $G$에 대해 DFS를 수행해서 모든 정점에 대해 끝나는 시간을 기록한다.\n2. 그래프 $G$의 간선을 뒤집어서 그래프 $G^T$를 만든다.\n3. $G^T$에 대해 DFS를 수행해서 끝나는 시간이 큰 정점부터 탐색한다.\n4. 탐색하는 과정에서 방문하는 정점들이 하나의 strongly connected component를 형성한다.\n\n```python\ndef strongly_connected_components(graph):\n    visited = [False] * len(graph)\n    stack = []\n    for v in range(len(graph)):\n        if not visited[v]:\n            dfs(graph, v, visited, stack)\n\n    graph_reverse = [[] for _ in range(len(graph))]\n    for v in range(len(graph)):\n        for neighbor in graph[v]:\n            graph_reverse[neighbor].append(v)\n\n    visited = [False] * len(graph)\n    components = []\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            component = []\n            dfs_reverse(graph_reverse, node, visited, component)\n            components.append(component)\n\n    return components\n```\n\n---\n\n## 출처\n\n- Introduction to Algorithms, 3rd Edition. Thomas H. Cormen, Charles E. pg.610 ~ 644\n- [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-directed-acyclic-graph/)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"BFS and DFS","subtitle":"그래프를 탐색하는 두 가지 단순한 방법","date":"2024-04-25T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-07-Shortest Path(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-07-Shortest Path(1).md","category":"Algorithm","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","content":"\n### 목차\n\n- [Introduction](#introduction)\n- [Optimal substructure](#optimal-substructure)\n- [negative-weight edges](#negative-weight-edges)\n- [Cycles](#cycles)\n- [relaxation](#relaxation)\n- [References](#references)\n\n---\n\n## Introduction\n\nShortest path problem은 그래프에서 두 정점 사이의 최단 경로를 찾는 문제이다. 이 문제는 다양한 분야에서 응용되며, 다양한 알고리즘이\n 제안되어 있다. Shortest path problem은 다음과 같은 세 가지 유형으로 나뉜다.\n\n1. Single-source shortest path problem\n    - 주어진 그래프에서 특정 정점에서 다른 모든 정점까지의 최단 경로를 찾는 문제이다.\n2. Single-destination shortest path problem\n    - 주어진 그래프에서 모든 정점에서 특정 정점까지의 최단 경로를 찾는 문제이다.\n3. All-pairs shortest path problem\n    - 주어진 그래프에서 모든 정점 사이의 최단 경로를 찾는 문제이다.\n\n이 글에서는 single-source shortest path problem에 대해 다룬다. single-source shortest path problem은 다음과 같은 두 가지 유형으로 나뉜다.\n\n1. Unweighted graph: 그래프의 간선에 가중치가 없는 경우\n2. Weighted graph: 그래프의 간선에 가중치가 있는 경우\n\n이 글에서는 weighted graph에 대해 다룬다. weighted graph에서 single-source shortest path problem을 해결하는 대표적인 알고리즘은\n 다음과 같다.\n\n1. Dijkstra's algorithm\n2. Bellman-Ford algorithm\n\n---\n\n## Optimal substructure\n\nShortest path problem은 optimal substructure를 가진다. Optimal substructure란 문제의 최적해가 부분 문제의 최적해로부터 구해질 수\n 있는 성질을 말한다.\n Shortest path problem에서 optimal substructure는 다음과 같이 정의된다.\n\n> Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. If $p$ contains an intermediate vertex $x$, then $p$ can be divided into two subpaths $s \\rightarrow x$ and $x \\rightarrow v$. The subpath $s \\rightarrow x$ is a shortest path from $s$ to $x$, and the subpath $x \\rightarrow v$ is a shortest path from $x$ to $v$.\n\n즉, 최단 경로 $p$가 중간 정점 $x$를 포함하고 있다면, $p$는 두 개의 부분 경로 $s \\rightarrow x$와 $x \\rightarrow v$로 나눌 수 있다.\n 부분 경로 $s \\rightarrow x$는 $s$에서 $x$로 가는 최단 경로이며, 부분 경로 $x \\rightarrow v$는 $x$에서 $v$로 가는 최단 경로이다.\n\n---\n\n## negative-weight edges\n\n그래프의 간선이 음수 가중치를 가지는 경우, cycle이 존재할 수 있다. 이 경우, shortest path problem을 해결하는 알고리즘은 cycle을\n 탐지하여 음의 무한대로 수렴할 수 있다.\n\nDijkstra's algorithm의 경우 모든 간선의 가중치가 양수인 경우에만 사용할 수 있다. Bellman-Ford algorithm은 음수 가중치를 가지는\n 간선이 존재하고 cycle이 없는 경우에 사용할 수 있다.\n\n---\n\n## Cycles\n\nShortest path problem에서 cycle이 존재하는 경우, 해당 cycle이 음수 가중치를 가지는 경우와 양수 가중치를 가지는 경우로 나뉜다.\n 음수 가중치를 가지는 cycle이 존재하는 경우, shortest path problem을 해결하는 알고리즘은 cycle을 탐지하여 음의 무한대로 수렴할 수\n 있어 해를 구할 수 없다. 반면 양수 가중치를 가지는 cycle이 존재하는 경우, 해당 cycle을 포함하는 경로는 무한히 큰 가중치를 가지므로\n 최단 경로가 될 수 없다. 즉 우리는 shortest path problem에서 cycle을 포함하는 경로를 고려하지 않는다.\n\n---\n\n## relaxation\n\nShortest path problem을 해결하는 알고리즘은 relaxation이라는 연산을 사용한다. relaxation은 다음과 같이 정의된다.\n\n> Let $G = (V, E)$ be a directed graph with a weight function $w: E \\rightarrow \\mathbb{R}$, and let $s$ be a source vertex in $V$. For any vertex $v \\in V$, let $p$ be a shortest path from $s$ to $v$. The relaxation operation updates the shortest path estimate $v.d$ and the predecessor $v.\\pi$ of vertex $v$ if a shorter path from $s$ to $v$ is found.\n\n즉, 매 정점 $v$에 대해 $s$에서 $v$로 가는 최단 경로 $v.d$와 이전 정점 $v.\\pi$를 업데이트하는 연산이다.\n\n---\n\n## References\n\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n  by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, p.643 ~ p.650\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Introduction to Shortest Path algorithm","subtitle":"single-source shortest path algorithm(1)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":1}},{"postName":"2024-05-10-Graph","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Graph.md","category":"Algorithm","title":"Graph","subtitle":"탐색을 위한 자료구조","content":"\n### 목차\n\n- [1. 그래프란?](#1-그래프란)\n- [2. 그래프의 활용](#2-그래프의-활용)\n- [3. 그래프 표현 방법](#3-그래프-표현-방법)\n  - [3.1 인접 행렬(Adjacency Matrix)](#31-인접-행렬adjacency-matrix)\n  - [3.2 인접 리스트(Adjacency List)](#32-인접-리스트adjacency-list)\n- [Reference](#reference)\n\n---\n\n## 1. 그래프란?\n\n그래프는 정점과 간선으로 이루어진 자료구조이다. 그래프는 다음과 같은 특징을 가진다.\n\n- 정점(Vertex): 데이터를 저장하는 공간\n- 간선(Edge): 정점과 정점을 연결하는 선\n- 방향성: 간선에 방향이 있는 경우 방향 그래프, 없는 경우 무방향 그래프\n- 가중치: 간선에 가중치가 있는 경우 가중치 그래프, 없는 경우 비가중치 그래프\n\n## 2. 그래프의 활용\n\n그래프는 주로 탐색을 위해 사용된다. 여기에서 탐색이란 그래프의 정점(vertex)을 방문하기 위해\n간선(edge)을 따라 이동하는 것을 의미한다. 탐색을 통해 그래프의 구조를 파악하거나 특정 정점을\n 찾는 등의 작업을 수행할 수 있다. 대표적인 예시로는 미로 찾기, 최단 경로 찾기, 네트워크 경로\n 찾기 등이 있다.\n\n그래프 탐색 알고리즘에는 다음과 같은 것들이 있다.\n\n- 깊이 우선 탐색(DFS, Depth First Search)\n- 너비 우선 탐색(BFS, Breadth First Search)\n- 다익스트라 알고리즘(Dijkstra Algorithm)\n- 벨만-포드 알고리즘(Bellman-Ford Algorithm)\n- ...\n\n## 3. 그래프 표현 방법\n\n대표적으로 그래프는 대표적으로 다음의 두 가지 방법으로 표현할 수 있다\n\n- 인접 행렬(Adjacency Matrix)\n- 인접 리스트(Adjacency List)\n\n### 3.1 인접 행렬(Adjacency Matrix)\n\n인접 행렬은 2차원 배열로 그래프를 표현하는 방법이다. 인접 행렬은 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V x V` 크기의 2차원 배열이 필요하다.\n- 정점 `u`와 정점 `v`가 연결되어 있으면 `matrix[u][v] = 1`, 연결되어 있지 않으면 `matrix[u][v] = 0`이다.\n- 가중치 그래프의 경우 `matrix[u][v] = w`로 표현한다.\n\n```python\nmatrix = [[1, 0, 0, 1, 0],\n          [0, 1, 1, 0, 0],\n          [0, 1, 1, 1, 1],\n          [1, 0, 1, 1, 0],\n          [0, 0, 1, 0, 1]]\n```\n\n인접 행렬은 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(1)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 유용하다.\n  - 가중치 그래프의 경우 간선의 가중치를 쉽게 확인할 수 있다.\n  - 무방향 그래프의 경우 대각선을 기준으로 대칭성을 가진다.\n  - 행렬의 곱셈을 이용해 그래프의 연결 여부를 확인할 수 있다.\n  - ...\n- 단점\n  - 정점의 개수가 많을 경우 메모리 낭비가 심하다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 낭비가 심하다.\n  - ...\n\n인접 행렬은 정점의 개수가 적고 간선의 개수가 많은 밀집 그래프(Dense Graph)의 경우에 적합하다.\n\n### 3.2 인접 리스트(Adjacency List)\n\n인접 리스트는 리스트를 이용해 그래프를 표현하는 방법이다. 인접 리스트는 다음과 같은 특징을 가진다.\n\n- 정점의 개수가 `V`일 때, `V`개의 리스트가 필요하다.\n- 각 리스트는 해당 정점과 연결된 정점들을 저장한다.\n- 가중치 그래프의 경우 각 리스트의 원소는 정점과 가중치를 저장한다.\n\n```python\nadj_list = [[(3, 1)],\n            [(1, 1), (2, 1)],\n            [(1, 1), (2, 1), (3, 1), (4, 1)],\n            [(0, 1), (2, 1), (3, 1)],\n            [(2, 1), (4, 1)]]\n```\n\n인접 리스트는 다음과 같은 장단점을 가진다.\n\n- 장점\n  - 메모리 사용량이 적다.\n  - 특정 정점과 연결된 간선을 찾는데 `O(E)`의 시간 복잡도가 소요된다.\n  - 희소 그래프(Sparse Graph)의 경우 메모리 사용량이 적다.\n  - ...\n- 단점\n  - 두 정점이 연결되어 있는지 확인하는데 `O(V)`의 시간 복잡도가 소요된다.\n  - 두 정점 사이의 간선을 찾는데 비효율적이다.\n  - 가중치 그래프의 경우 간선의 가중치를 확인하기 어렵다.\n  - ...\n\n인접 리스트는 정점의 개수가 많고 간선의 개수가 적은 희소 그래프(Sparse Graph)의 경우에 적합하다.\n\n---\n\n## Reference\n\n- [Introduction to Algorithms, 3rd Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein](https://en.wikipedia.org/wiki/Introduction_to_Algorithms)\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"Graph","subtitle":"탐색을 위한 자료구조","date":"2024-05-10T00:00:00.000Z","categories":"Algorithm"}},{"postName":"2024-05-10-Shortest Path(2)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(2).md","category":"Algorithm","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`벨만-포드 알고리즘`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n 포함된 그래프에서도 사용할 수 있다. 음수 가중치를 가진 간선이 포함된 그래프에서도 사용할\n 수 있다는 장점이 있으며, 음수 사이클이 존재하는 경우 false/error를 반환하는 방식으로\n 음수 사이클을 탐지할 수 있다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n벨만-포드 알고리즘은 다음과 같은 방식으로 동작한다.\n\n```plaintext\nBELLMAN-FORD(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  for i = 1 to |V[G]| - 1  // 그래프의 정점 수 - 1만큼 반복합니다.\n3      for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n4          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n5  for each edge (u, v) in E[G]  // 그래프의 모든 간선에 대해\n6      if d[v] > d[u] + w(u, v)  // u를 통해 v로 가는 경로가 v의 현재 거리 값보다 작다면\n7          return false  // 음의 사이클이 존재하므로 false를 반환합니다.\n8  return true  // 모든 간선에 대해 음의 사이클이 없다면 true를 반환합니다.\n```\n\n`BELLMAN-FORD(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `d`: 정점 `s`로부터 정점 `v`까지의 최단 거리를 저장하는 배열\n- V[G]: 그래프 `G`의 정점 집합\n- E[G]: 그래프 `G`의 간선 집합\n\n---\n\n## Algorithm by python\n\n```python\ndef bellman_ford(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 간선들에 대해 반복적으로 거리를 갱신(relax)합니다\n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbour in graph[node]:\n                if distance[neighbour] > distance[node] + graph[node][neighbour]:\n                    distance[neighbour], predecessor[neighbour] = distance[node] + graph[node][neighbour], node\n\n    # 음수 사이클을 확인합니다\n    for node in graph:\n        for neighbour in graph[node]:\n            assert distance[neighbour] <= distance[node] + graph[node][neighbour]\n\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n벨만-포드 알고리즘의 시간 복잡도는 $O(VE)$이다. 이는 모든 간선에 대해 최단 거리를 갱신하는\n 과정을 $|V| - 1$번 반복하기 때문이다.\n\n---\n\n## Reference\n\n- [Bellman-Ford algorithm - Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\n- [Introduction to Algorithms, 3rd Edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Bellman-ford algorithm","subtitle":"single-source shortest path algorithm(2)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":2}},{"postName":"2024-05-10-Shortest Path(3)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/이론/2024-05-10-Shortest Path(3).md","category":"Algorithm","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","content":"\n### 목차\n\n- [1. Introduction](#1-introduction)\n- [2. Algorithm by pseudocode](#2-algorithm-by-pseudocode)\n- [Algorithm by python](#algorithm-by-python)\n- [Time complexity](#time-complexity)\n- [Reference](#reference)\n\n---\n\n## 1. Introduction\n\n`Dijkstra algorithm`은 `단일 출발점 최단 경로 알고리즘` 중 하나로, `음수 가중치`를 가진 간선이\n포함된 그래프에서는 사용할 수 없다. 대신 음수 가중치를 가진 간선이 없는 그래프에서는 `Bellman-ford algorithm`보다\n더 빠르게 동작한다.\n\n이를 위해 `Dijkstra algorithm`은 `priority queue`를 사용하여 최단 거리를 계산하며, 이미 계산이 완료된 정점\n들은 다시 계산하지 않는다. 이 때문에 `Dijkstra algorithm`은 `그리디 알고리즘`으로 분류된다.\n\n---\n\n## 2. Algorithm by pseudocode\n\n`Dijkstra algorithm`은 다음과 같은 방식으로 동작한다.\n\n```plaintest\nDIJKSTRA(G, w, s)\n1  INITIALIZE-SINGLE-SOURCE(G, s)  // 모든 정점의 거리 값을 무한대로 초기화하고, 시작점의 거리 값을 0으로 설정합니다.\n2  S = {}  // 최단 경로가 발견된 정점들의 집합 S를 초기화합니다.\n3  Q = V[G]  // 모든 정점들을 포함하는 우선순위 큐 Q를 생성합니다.\n4  while Q != {}  // Q가 빌 때까지 반복합니다.\n5      u = EXTRACT-MIN(Q)  // Q에서 거리 값이 가장 작은 정점 u를 추출합니다.\n6      S = S append {u}  // u를 S에 추가합니다.\n7      for each vertex v in Adj[u]  // u의 모든 인접 정점 v에 대해\n8          RELAX(u, v, w)  // u를 통해 v로 가는 경로가 더 짧은지 확인하고, 더 짧다면 v의 거리 값을 갱신합니다.\n```\n\n`DIJKSTRA(G, w, s)`: 그래프 `G`와 가중치 함수 `w`, 시작 정점 `s`를 입력으로 받아 최단 경로를 계산한다.\n\n이 때 사용하는 자료구조는 다음과 같다.\n\n- `S`: 이미 최단 거리를 계산한 정점의 집합\n- `Q`: 아직 최단 거리를 계산하지 않은 정점의 집합\n- `V[G]`: 그래프 `G`의 정점 집합\n- `Adj[u]`: 정점 `u`에 인접한 정점들의 집합\n\n---\n\n## Algorithm by python\n\n```python\nimport heapq\n\ndef dijkstra(graph, start):\n    distance, predecessor = dict(), dict()\n    # 각 노드의 거리와 선행 노드를 초기화합니다\n    for node in graph:\n        distance[node], predecessor[node] = float('inf'), None\n    distance[start] = 0\n\n    # 우선순위 큐를 초기화합니다\n    queue = [(0, start)]\n\n    while queue:\n        # 우선순위 큐에서 가장 가까운 노드를 추출합니다\n        current_distance, current_node = heapq.heappop(queue)\n        # 이미 처리된 노드인 경우 건너뜁니다\n        if current_distance > distance[current_node]:\n            continue\n        # 인접 노드에 대해 최단 거리를 갱신합니다\n        for neighbor, weight in graph[current_node].items():\n            new_distance = current_distance + weight\n            if new_distance < distance[neighbor]:\n                distance[neighbor] = new_distance\n                predecessor[neighbor] = current_node\n                heapq.heappush(queue, (new_distance, neighbor))\n    return distance, predecessor\n```\n\n---\n\n## Time complexity\n\n`Dijkstra algorithm`의 시간 복잡도는 `O((V + E) log V)`이다. 이는 `priority queue`를 사용하여\n최단 거리를 계산하기 때문에 정점을 추출하는 과정이 `O(log V)`이기 때문이다. Bellman-ford algorithm과\n달리 모든 간선이 아니라 `최소 거리를 가진 정점만`을 추출하여 계산하기 때문에 더 빠르게 동작한다.\n\n---\n\n## Reference\n\n- [Dijkstra algorithm - wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n- [Dijkstra algorithm - geeksforgeeks](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)\n- [Introduction to algorithms, 3rd edition](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)\n","layout":"series_mathjax","recommended":false,"data":{"layout":"series_mathjax","classes":"wide","title":"Dijkstra algorithm","subtitle":"single-source shortest path algorithm(3)","date":"2024-05-07T00:00:00.000Z","categories":"Algorithm","series":"single-source shortest path algorithm","seriesIndex":3}}],"category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"]},"__N_SSG":true}