{"pageProps":{"postDataJson":{"postName":"2024-02-26-Chat Application review(1)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-02-26-Chat Application review(1).md","category":"개발일지","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","content":"\n\n## 목차\n\n1. 느낀 점\n2. 진행 내용\n3. 문제 및 해결 방법\n\n\n---\n\n\n## 느낀 점\n\n개발할 때 최초에 생각한 것과 별개로 기능 추가 및 변경이 빈번하게 발생하게 된다. 이 때마다 기존의 코드를 변경하기 용이하게 하기 위한 추상화, business logic 분리, unit test 등의 작업이 필요하다.\n\n원래는 login api를 다루는 서버에서 채팅 역시도 다루게 될 것이라고 생각했다. 그런데 현재 서버 구조는 api를 다루는 형태로 되어 있으니 이를 api 전용 서버로 두고, 채팅을 다루는 서버는 따로 두는 것이 낫지 않을까? 라는 생각이 들었다.\n\n\n---\n\n\n## 진행 내용\n\n* 프로젝트 개요, 구조, 기술 스택, 개발 환경 등 정리. => [프로젝트 개요](http://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80/2024/02/26/Chat-Application-%EA%B0%9C%EC%9A%94.html)\n* 메인 서버 구조 설계\n* User CRUD API 구현\n* DBManager, SessionManager, PasswordManager internal package 구현\n\n---\n\n### 메인 서버 구조 설계\n\n```\nmyapp\n├── api\n│   ├── handler\n│   │   └── user\n│   ├── models\n│   └── service\n│       └── user\n├── internal\n│   ├── db\n│   ├── session\n│   └── password\n├── pkg\n├── scripts\n├── tests\n└── main.go\n```\n\n* api: API 요청을 처리하는 패키지.\n  * handler: API 요청을 처리하는 핸들러.\n  * models: API 요청과 응답에 사용되는 모델.\n  * service: API 요청을 처리하는 비즈니스 로직.\n  * user: User API 요청을 처리하는 패키지.\n* internal: 내부 패키지.\n  * db: 데이터베이스 관련 패키지.\n  * session: 세션 관리 패키지.\n  * password: 비밀번호 관리 패키지.\n* pkg: 외부에 공개되는 패키지.(미정)\n* scripts: 스크립트 파일.\n  * 현재 sql 파일을 실행하는 스크립트만 존재.\n* tests: 테스트 파일.\n  * go 서버의 unit test 파일만 존재.\n  * 추후 요구하는 규모에 따라 테스트 환경을 구축할 예정.\n* main.go: 프로그램의 진입점.\n\n---\n\n### User CRUD API 구현\n: Login, Logout, Signup, deleteAccount API 구현.\n\n**구현 내용**\n* Login API\n  * 로그인 요청을 처리하는 핸들러 구현.\n  * 로그인 성공 시 세션을 생성하고, 세션 ID를 응답.\n  * 로그인 실패 시 에러 메시지를 응답.\n* Logout API\n  * 로그아웃 요청을 처리하는 핸들러 구현.\n  * 세션을 삭제.\n* Signup API\n  * 회원가입 요청을 처리하는 핸들러 구현.\n  * 회원가입 실패 시 에러 메시지를 응답.\n* deleteAccount API\n  * 회원탈퇴 요청을 처리하는 핸들러 구현.\n  * 로그인 세션을 통해 회원탈퇴.\n  * 회원탈퇴 실패 시 에러 메시지를 응답.\n\n[**구현 상세**](https://github.com/kaestro/ChatApplication/tree/main/myapp/api)\n\nDBManager와 SessionManager를 통해 유저의 정보를 조회하고, 관리를 위한 로직을 수행.\nPasswordManager를 통해 비밀번호를 암호화하여 저장하고, 비밀번호 검증을 수행.\n\nuser data model을 구현, 이를 orm 패키지를 사용하여 데이터베이스와 연동한다.\n\nhandler에 응답을 처리하는 로직을 구현한 뒤 login 같은 경우는 비즈니스 로직이 변경될 수 있으므로 service 패키지를 통해 자주 변경되는 부분을 분리하였다.\n\n---\n\n### DBManager, SessionManager, PasswordManager internal package 구현\n: User CRUD API 구현 과정에서 필요한 패키지 구현\n\n**구현 내용**\n\n* DBManager\n  * 데이터베이스와 연동하여 유저 정보를 조회, 추가, 삭제하는 로직을 수행.\n  * orm 패키지를 사용하여 데이터베이스와 연동.\n  * DB 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* SessionManager\n  * 캐시 서버를 통해 세션을 관리.\n  * 세션 생성, 조회, 삭제 로직을 수행.\n  * 세션 연결 자체가 아니라, Manager에서 허용하는 로직만을 public하게 제공.\n* PasswordManager\n  * 비밀번호를 암호화하여 저장하고, 비밀번호 검증하는 로직을 수행\n  \n**구현 상세**\n\n**DBManager**는 DB 연결을 gorm을 통해 생성하고, create, read by single field, read all table, update row, delete row 기능을 제공한다.\n\n**SessionManager**는 redis를 통해 세션 키 생성, 세션 생성, 조회, 삭제, 정합성 확인 기능을 제공. => *TODO* 현재 <u>LoginSessionGenerator.go를 LoginSessionKeyGenerator.go로 파일명 변경한다</u>\n\n**Store**라는 추상적인 인터페이스를 통해 session을 관리하고, 현재 이를 RedisStore를 통해 구현한다. 이는 추후에 다른 저장소를 사용할 때 변경이 용이하도록 하기 위해서이다.\n\n**PasswordManager**는 bcrypt를 통해 비밀번호를 암호화하고, 비밀번호 검증하는 기능을 제공한다.\n\n---\n\n## 문제 및 해결 방법\n\n### 문제상황\n\n```\n1. dbManager가 연결 객체 자체를 반환하고 있었음.\n2. 암호화 로직이 api마다 중복되어 있었음.\n3. login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n4. user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n```\n\n\n### 해결 방법\n\n**dbManager가 연결 객체 자체를 반환하고 있었음.**\n\n**문제점**: GetDB() 함수를 통해 db 객체를 반환하고 있었다. 이는 db 객체를 직접 사용하게 되어, dbManager의 로직이 변경될 때마다 모든 곳에서 변경이 필요하게 된다.\n\n```go\nvar (\n\tonce sync.Once\n\n\tdb *gorm.DB\n)\n\nfunc GetDB() *gorm.DB {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err = gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t})\n\n\treturn db\n}\n```\n\n**해결 방법**: dbManager에서 허용하는 로직만을 public하게 제공하도록 변경.\n\n```go\ntype DBManager struct {\n\tdb *gorm.DB\n}\n\nvar (\n\tonce sync.Once\n\n\tmanager *DBManager\n)\n\nfunc GetDBManager() *DBManager {\n\tonce.Do(func() {\n\t\tvar err error\n\t\tdb, err := gorm.Open(\"postgres\", \"postgres://postgres:rootpassword@localhost:5432/postgres?sslmode=disable\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmanager = &DBManager{\n\t\t\tdb: db,\n\t\t}\n\t})\n\n\treturn manager\n}\n\nfunc (m *DBManager) Create(value interface{}) error {\n    return m.db.Create(value).Error\n}\n...\n```\n\n\n---\n\n\n**암호화 로직이 api마다 중복되어 있었음.**\n\n**문제점**: 비밀번호 암호화, 비밀번호 검증 로직이 user CRUD api마다 중복되어 있었음.\n\n```go\nfunc Signup(c *gin.Context) {\n    ...\n\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\n    ...\n}\n```\n\n**해결 방법**: Password package를 생성하여 비밀번호 암호화, 비밀번호 검증 로직을 분리.\n\n```go\npackage password\n\nimport \"golang.org/x/crypto/bcrypt\"\n\nfunc HashPassword(password string) (string, error) {\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(hashedPassword), nil\n}\n\nfunc CheckPasswordHash(password, hash string) bool {\n\terr := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))\n\treturn err == nil\n}\n```\n\n### login api는 비즈니스 로직이 계속 변경되고 있어 service 패키지를 통해 분리하고 싶었음.\n\n**문제점**: login api의 비즈니스 로직이 변경될 때마다 handler에서 변경이 필요하게 됨.\n\n```go\n\tdb.GetDB().Create(&user)\n\n\t// 로그인 정보를 담은 요청 본문을 생성합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\tbody, _ := json.Marshal(loginInfo)\n\n\t// 테스트를 위한 HTTP 요청을 생성합니다.\n\treq, _ := http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw := httptest.NewRecorder()\n\n\t// Gin 엔진을 생성하고 LogIn 핸들러를 등록합니다.\n\tr := gin.Default()\n\tr.POST(\"/login\", userAPI.LogIn)\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\t// 잘못된 비밀번호로 로그인을 시도합니다.\n\tloginInfo.Password = \"wrongpassword\"\n\tbody, _ = json.Marshal(loginInfo)\n\treq, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tw = httptest.NewRecorder()\n\n\t// HTTP 요청을 처리합니다.\n\tr.ServeHTTP(w, req)\n\n\t// 응답 상태 코드가 401인지 확인합니다.\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\n\tt.Log(\"Login test passed!\")\n}\n```\n\n구현 과정에서 DBManager, SessionManager, Password 등의 패키지를 추가하게 됐다. 이 과정에서 추상화, 접근 제어 등의 기능이 도입되었고 이 때마다 handler에서 변경이 필요하게 됨.\n\n이와 관련한 해결 방법으로 service 패키지를 통해 비즈니스 로직을 분리하고자 함.\n\n```go\nvar (\n\tErrAlreadyLoggedIn            = errors.New(\"user is already logged in\")\n\tErrUserNotFound               = errors.New(\"failed to find user\")\n\tErrInvalidPassword            = errors.New(\"invalid password\")\n\tErrFailedToGenerateSessionKey = errors.New(\"failed to generate session key\")\n\tErrFailedToSaveSessionKey     = errors.New(\"failed to save session key\")\n)\n\ntype LoginService struct {\n\tdbManager      *db.DBManager\n\tsessionManager *session.SessionManager\n}\n\nfunc NewLoginService(dbManager *db.DBManager, sessionManager *session.SessionManager) *LoginService {\n\treturn &LoginService{\n\t\tdbManager:      dbManager,\n\t\tsessionManager: sessionManager,\n\t}\n}\n\nfunc (s *LoginService) LogIn(userEmailAddress, userPassword, userSessionKey string) (string, error) {\n\t// 세션 키가 sessionManager에 저장되어 있는지 확인합니다.\n\tif s.sessionManager.IsSessionValid(userSessionKey, userEmailAddress) {\n\t\treturn \"\", ErrAlreadyLoggedIn\n\t}\n\n\t// 사용자 정보를 담을 User 구조체를 선언합니다.\n\tvar user models.User\n\n\t// 사용자가 제공한 이메일 주소로 데이터베이스에서 사용자를 찾습니다.\n\terr := s.dbManager.Read(&user, \"email_address\", userEmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrUserNotFound\n\t}\n\n\t// 사용자가 제공한 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교합니다.\n\tif !password.CheckPasswordHash(userPassword, user.Password) {\n\t\treturn \"\", ErrInvalidPassword\n\t}\n\n\t// 세션 키를 생성합니다.\n\tsessionKey, err := session.GenerateRandomSessionKey()\n\tif err != nil {\n\t\treturn \"\", ErrFailedToGenerateSessionKey\n\t}\n\n\t// 세션 키를 캐시에 저장합니다.\n\terr = s.sessionManager.SetSession(sessionKey, user.EmailAddress)\n\tif err != nil {\n\t\treturn \"\", ErrFailedToSaveSessionKey\n\t}\n\n\treturn sessionKey, nil\n}\n```\n\n---\n\n### user CRUD api를 매 빌드시마다 unit test를 통해 검증하고 싶었음.\n\n**문제점**: user CRUD api를 구현 때마다 postman을 통해 수동으로 테스트를 진행하고 있었음.\n\n**해결 방법**: user CRUD api를 매 빌드시마다 검증할 unit test를 작성.\n\n```go\nfunc TestUserHandler(t *testing.T) {\n\t// 테스트를 위한 사용자 정보를 생성합니다.\n\tsampleUser := models.User{\n\t\tUserName:     \"testuser\",\n\t\tEmailAddress: \"test@example.com\",\n\t\tPassword:     \"password\",\n\t}\n\n\t// Gin 엔진을 생성하고 핸들러들을 등록합니다.\n\tginEngine := gin.Default()\n\tginEngine.POST(\"/login\", userAPI.LogIn)\n\tginEngine.POST(\"/logout\", userAPI.LogOut)\n\tginEngine.POST(\"/signup\", userAPI.SignUp)\n\tginEngine.POST(\"/deleteAccount\", userAPI.DeleteAccount)\n\n\t// signup HTTP 요청을 처리합니다.\n\tbody, _ := json.Marshal(sampleUser)\n\thttpRequest, _ := http.NewRequest(\"POST\", \"/signup\", bytes.NewBuffer(body))\n\tresponseRecorder := httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\tt.Log(responseRecorder.Body.String())\n\n\t// 응답 상태 코드가 201인지 확인합니다.\n\tif assert.Equal(t, http.StatusCreated, responseRecorder.Code) {\n\t\tt.Log(\"SignUp 테스트 통과\")\n\t}\n\n\t// login HTTP 요청을 처리합니다.\n\tloginInfo := struct {\n\t\tEmailAddress string `json:\"emailAddress\"`\n\t\tPassword     string `json:\"password\"`\n\t}{\n\t\tEmailAddress: sampleUser.EmailAddress,\n\t\tPassword:     sampleUser.Password,\n\t}\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogIn 테스트 통과\")\n\t}\n\n\t// logout HTTP 요청을 처리합니다.\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/logout\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", responseRecorder.Body.String())\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"LogOut 테스트 통과\")\n\t}\n\n\t// deleteAccount HTTP 요청을 처리합니다.\n\tbody, _ = json.Marshal(loginInfo)\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/login\", bytes.NewBuffer(body))\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 전 LogIn 테스트 통과\")\n\t}\n\n\tt.Log(\"Session-Key:\" + responseRecorder.Body.String())\n\tvar responseBody map[string]string\n\tjson.Unmarshal(responseRecorder.Body.Bytes(), &responseBody)\n\tsessionKey := responseBody[\"sessionKey\"]\n\n\thttpRequest, _ = http.NewRequest(\"POST\", \"/deleteAccount\", nil)\n\thttpRequest.Header.Set(\"Session-Key\", sessionKey)\n\tresponseRecorder = httptest.NewRecorder()\n\tginEngine.ServeHTTP(responseRecorder, httpRequest)\n\n\t// 응답 상태 코드가 200인지 확인합니다.\n\tif assert.Equal(t, http.StatusOK, responseRecorder.Code) {\n\t\tt.Log(\"deleteAccount 테스트 통과\")\n\t}\n}\n```\n\n---","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":1,"classes":"wide","title":"ChatApplication Review(1)","subtitle":"Login API, DBManager, SessionManager","date":"2024-02-26T00:00:00.000Z","categories":"개발일지"}},"title":"ChatApplication Review(1)","category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"ChatApplication 개요","category":"개발일지"},"next":{"title":"ChatApplication Review(2)","category":"개발일지"}}},"__N_SSG":true}