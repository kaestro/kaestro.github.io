{"pageProps":{"posts":[{"postName":"2024-02-07-천원돌파 의존성 역전","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-07-천원돌파 의존성 역전.md","category":"디자인패턴","title":"천원돌파 의존성 역전","subtitle":"","content":"\n## 목차\n\n0. 요약\n1. 문제 상황\n2. 의존성 역전을 통한 개선\n3. 다양한 방식의 의존성 역전\n4. 마치며\n\n---\n\n## 요약\n\n* 의존성 역전 패턴은 객체지향 프로그래밍의 핵심 원리 중 하나로, 객체 간의 결합도를 낮추고 유연성을 높이는 방법입니다.\n* 의존성 역전은 상위 모듈이 하위 모듈을 추상화한 인터페이스나 추상 클래스에 의존하도록 하는 것을 말합니다.\n* 제어 역전을 통해 필요한 의존 객체의 생성부터 사용, 생명주기 관리까지 모든 것을 외부에서 관리하도록 하는 것도 가능합니다.\n\n---\n\n## 문제 상황\n\n실제로 이런 끔찍한 사례를 마주하지 않으면 더 좋겠지만, 만약 우리에게 다음과 같은 억지스러운 프로그램을 작성해야하는 상황이 닥쳤을 때를 한 번 생각해보겠습니다. 우리에게는 특정 바이너리 파일을 읽고 이 파일에 1이 얼마나 들어가 있는지 세는 프로그램을 만들라는 요구사항이 주어졌습니다. 그렇다면 다음과 같은 코드를 작성할 수도 있을 겁니다.\n\n```python\nclass BinaryFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass DataAnalyzer:\n    def __init__(self):\n        self.file_manager = BinaryFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n그런데 만약에 나중에 요구사항이 변화해서, 바이너리 파일에서 1의 갯수를 세는 것 만이 아니라 텍스트 파일에서 1의 갯수를 세는 것도 요구사항으로 추가된다면 어떻게 될까요? 어쩌면 우리는 다음과 같은 끔찍한 코드를 작성해야할 수도 있을겁니다.\n\n```python\nclass BinaryFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass TextFileManager:\n    def open_file(self, file_name):\n        self.file = open(file_name, 'r')\n\n    def read_file(self):\n        return self.file.read()\n\nclass DataAnalyzer:\n    def __init__(self, file_type):\n        if file_type == 'Binary':\n            self.file_manager = BinaryFileManager()\n        elif file_type == 'Text':\n            self.file_manager = TextFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n우리는 단순히 DataAnalyzer 객체에서 사용할 새로운 클래스를 추가했을 뿐인데, DataAnalyzer 내부의 메서드 역시도 구현을 변환해야했습니다. 만약 이후에 새로운 파일 타입이 추가된다면, 또 다시 DataAnalyzer 내부의 메서드를 수정해야할 것입니다. 이런 상황에서 우리는 어떻게 해야할까요?\n\n---\n\n## 의존성 역전을 통한 개선\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass IFileManager(ABC):\n    @abstractmethod\n    def open_file(self, file_name):\n        pass\n\n    @abstractmethod\n    def read_file(self):\n        pass\n\nclass BinaryFileManager(IFileManager):\n    def open_file(self, file_name):\n        self.file = open(file_name, 'rb')\n\n    def read_file(self):\n        return self.file.read().decode('utf-8', 'ignore')\n\nclass TextFileManager(IFileManager):\n    def open_file(self, file_name):\n        self.file = open(file_name, 'r')\n\n    def read_file(self):\n        return self.file.read()\n\nclass DataAnalyzer:\n    def __init__(self, file_manager: IFileManager):\n        self.file_manager = file_manager\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n개선한 코드는 Binary와 text 형태를 동시에 처리할 수 있게 사양이 변화됐는데도, 상위 모듈인 DataAnalyzer의 내부 구현은 영향을 받지 않았습니다. 이처럼 소프트웨어 간의 모듈이 상대에게 의존하게 될 때, 상대의 세부 구현이 변하더라도 상대적으로 적은 영향을 받도록 추구하는 패턴의 프로그래밍 작성 방식 중 하나를 우리는 의존성 역전이라 부릅니다.\n\n의존성 역전은 구체적으로 상위 모듈이 하위 모듈에 의존하는 상황에서 그것의 구체적인 구현에 의존하지 않고, 하위 모듈을 추상화한 상위 모듈에 의존하도록 하는 것을 말합니다. 여기에서 말한 하위 모듈을 추상화한 상위 모듈이란 위의 예시에서 본 IFileManager와 같은 인터페이스, 혹은 추상 클래스들을 말합니다. 다른 예시를 들어 살펴보자면 컴퓨터와 주변 기기들을 다음과 같이 작성할 수 있을 것입니다.\n\n```java\n\nimport java.util.ArrayList;\n\ninterface PeripheralDevice {\n    void connect();\n}\n\nclass Mouse implements PeripheralDevice {\n    @Override\n    public void connect() {\n        System.out.println(\"Mouse is connected.\");\n    }\n}\n\n\nclass Keyboard implements PeripheralDevice {\n    @Override\n    public void connect() {\n        System.out.println(\"Keyboard is connected.\");\n    }\n}\n\nclass Computer {\n    private ArrayList<PeripheralDevice> peripheralDevices;\n\n    public Computer() {\n        this.peripheralDevices = new ArrayList<>();\n    }\n\n    public void start() {\n        System.out.println(\"Computer is starting...\");\n    }\n\n    public void addPeripheral(PeripheralDevice peripheralDevice) {\n        peripheralDevices.add(peripheralDevice);\n    }\n\n    public void connectPeripherals() {\n        for (PeripheralDevice peripheralDevice : peripheralDevices) {\n            peripheralDevice.connect();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // PeripheralDevice를 구현한 Mouse와 Keyboard 객체 생성\n        PeripheralDevice mouse = new Mouse();\n        PeripheralDevice keyboard = new Keyboard();\n\n        // Computer 객체 생성 및 PeripheralDevice로 Mouse와 Keyboard 연결\n        Computer desktop = new Computer();\n        desktop.addPeripheral(mouse);\n        desktop.addPeripheral(keyboard);\n\n        // Computer 시작 및 PeripheralDevice 연결\n        desktop.start();\n        desktop.connectPeripherals();\n    }\n}\n\n```\n\n위에서 구현한 자바 코드는 컴퓨터를 OOP의 형태로 표현한 것입니다. 컴퓨터에는 다양한 주변기기를 연결할 수 있습니다. 그리고 그 주변기기의 동작에는 여러가지 형태가 존재하고, 앞으로도 새로운 주변기기가 생성될 것이니 interface라는 추상화된 상위 모듈에 구현을 의존한다면 더 유연하게 추가 구현이 발생할 때 대응할 수 있습니다.\n\n의존성 역전 패턴을 활용하면 새로운 저수준의 모듈을 구현에 추가하려 할 때 뿐 아니라, 저수준 모듈의 구현이 변했을 때 이에 대응할 수 있다는 장점도 가지고 있습니다.\n\n이제 예시를 통해 의존성 역전의 장점을 설명해보겠습니다.\n\n기존에는 UserRepository 객체가 MySQL 데이터베이스에 저장하는 로직을 구현했다고 가정해봅시다. 그런데 MySQL이 유료화가 된다거나 심각한 보안 문제가 있는 것이 발견돼서 PostgreSQL 데이터베이스를 사용하도록 변경해야하는 상황을 맞이했습니다. 만약 기존 UserRepository가 다음과 같이 데이터베이스에 종속적이라면, 기존의 UserRepository 객체를 수정해야 할 것입니다.\n\n```java\npublic class UserRepository {\n    public void save(User user) {\n        // MySQL 데이터베이스에 저장하는 로직\n        try {\n            MysqlDataSource dataSource = new MysqlDataSource();\n            dataSource.setUrl(\"jdbc:mysql://localhost:3306/mydatabase\");\n            dataSource.setUser(\"username\");\n            dataSource.setPassword(\"password\");\n\n            Connection connection = dataSource.getConnection();\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO users (username, email) VALUES (?, ?)\");\n            statement.setString(1, user.getUsername());\n            statement.setString(2, user.getEmail());\n            statement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class UserRepository {\n    public void save(User user) {\n        // PostgreSQL 데이터베이스에 저장하는 로직\n        try {\n            PGSimpleDataSource dataSource = new PGSimpleDataSource();\n            dataSource.setUrl(\"jdbc:postgresql://localhost:5432/mydatabase\");\n            dataSource.setUser(\"username\");\n            dataSource.setPassword(\"password\");\n\n            Connection connection = dataSource.getConnection();\n            PreparedStatement statement = connection.prepareStatement(\"INSERT INTO users (username, email) VALUES (?, ?)\");\n            statement.setString(1, user.getUsername());\n            statement.setString(2, user.getEmail());\n            statement.executeUpdate();\n            connection.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n[위는 기존에 MySQL을 사용하다가 PostgreSQL을 사용하도록 변경한 코드입니다. 이렇게 변경하면 UserRepository 객체의 구현이 변경되어야 하므로 의존성 역전 패턴을 활용하지 않은 것입니다.]\n\n하지만 의존성 역전 패턴을 활용하면 UserRepository 객체가 Database 인터페이스에 의존하도록 하고, MySQLDatabase와 PostgreSQLDatabase 클래스가 Database 인터페이스를 구현하도록 하면 UserRepository 객체는 Database 인터페이스에만 의존하게 되어 MySQL 데이터베이스를 사용하는 것이 아닌 PostgreSQL 데이터베이스를 사용하는 것으로 쉽게 변경할 수 있습니다.\n\n```java\npublic interface Database {\n    void save(User user);\n}\n\npublic class MySQLDatabase implements Database {\n    @Override\n    public void save(User user) {\n        // MySQL 데이터베이스에 저장하는 로직\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"username\", \"password\")) {\n            String query = \"INSERT INTO users (username, email) VALUES (?, ?)\";\n            try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n                preparedStatement.setString(1, user.getUsername());\n                preparedStatement.setString(2, user.getEmail());\n                preparedStatement.executeUpdate();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class PostgreSQLDatabase implements Database {\n    @Override\n    public void save(User user) {\n        // PostgreSQL 데이터베이스에 저장하는 로직\n        try (Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost:5432/mydatabase\", \"username\", \"password\")) {\n            String query = \"INSERT INTO users (username, email) VALUES (?, ?)\";\n            try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n                preparedStatement.setString(1, user.getUsername());\n                preparedStatement.setString(2, user.getEmail());\n                preparedStatement.executeUpdate();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class UserRepository {\n    private Database database;\n\n    public UserRepository(Database database) {\n        this.database = database; // 의존성 주입을 통해 Database 객체를 외부에서 받음\n    }\n\n    public void save(User user) {\n        database.save(user);\n    }\n}\n```\n\n[위는 의존성 역전 패턴을 활용하여 MySQL을 사용하다가 PostgreSQL을 사용하도록 변경한 코드입니다. UserRepository 객체는 Database 인터페이스에만 의존하고 있으며, Database 인터페이스를 구현한 MySQLDatabase와 PostgreSQLDatabase 클래스가 Database 인터페이스를 구현하고 있습니다.]\n\n---\n\n## 다양한 방식의 의존성 역전\n\n여태까지는 의존성 역전을 구현하는 방법으로 상위 모듈이 하위 모듈을 추상화한 인터페이스나 추상 클래스에 의존하도록 하는 방법을 살펴봤습니다. 그러나 제가 이야기하는 것은 추상화한 인터페이스나 클래스 도입에 따른 결합도 감소 및 유연성 높이는 방법이 아닌, 의존성 역전 패턴입니다. 그 이유는 이제 다음에 이야기할 추가적인 두가지 형태로 의존성 역전을 구현하는 것이 가능하기 때문입니다.\n\n* 의존성 주입\n* 제어 역전\n\n### 의존성 주입\n\n의존성 주입은 객체가 직접 자신이 사용할 객체를 생성하는 것이 아니라, 외부에서 객체를 주입받아 사용하는 방식을 말합니다. 이는 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있습니다. 의존성 주입은 다음과 같은 코드를 개선해야 하는 상황에서 사용할 수 있습니다.\n\n```python\nclass DataAnalyzer:\n    def __init__(self):\n        self.file_manager = BinaryFileManager()\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n위의 코드에서 DataAnalyzer는 BinaryFileManager를 직접 생성하고 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하고 있음을 의미합니다. 이를 의존성 주입을 통해 개선하면 다음과 같이 작성할 수 있습니다.\n\n```python\nclass DataAnalyzer:\n    def __init__(self, file_manager):\n        self.file_manager = file_manager\n\n    def process_data(self, file_name):\n        self.file_manager.open_file(file_name)\n        self.analyze_data()\n\n    def analyze_data(self):\n        data = self.file_manager.read_file()\n        if data:\n            ones_count = self.count_ones(data)\n            print(f\"Number of ones in the file: {ones_count}\")\n        else:\n            print(\"No file open.\")\n\n    def count_ones(self, data):\n        return data.count('1')\n```\n\n의존성 주입을 통해 DataAnalyzer는 BinaryFileManager를 직접 생성하지 않고, 외부에서 주입받아 사용하고 있습니다. 이는 DataAnalyzer가 BinaryFileManager에 의존하지 않고, 외부에서 주입받은 객체에 의존하고 있음을 의미합니다.\n\n그러나 의존성 주입은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점이 있지만, 객체를 생성하고 주입하는 코드가 복잡해질 수 있습니다.\n\n이를 해결하기 위해 등장한 개념이 바로, 제어 역전입니다. 제어 역전은 객체의 생성과 사용을 분리함으로써 객체의 재사용성을 높이고, 유연성을 높이는 장점을 가지면서도, 객체를 생성하고 주입하는 코드가 복잡해지는 문제를 해결하기 위해 등장한 개념입니다.\n\n### 제어 역전\n\n제어 역전은 객체의 생성과 사용을 분리하기 위해 객체를 생성하고 사용하는 책임을 외부에 위임하는 것을 말합니다. 아까 전까지 이야기 한 의존성 주입과 얼핏 보면 동일한 이야기를 하는 것으로 이야기하기 쉽습니다. 하지만 의존성 주입은 객체를 생성하고 사용하는 책임을 외부에 위임하는 반면, 제어 역전은 객체를 생성하고 사용하는 책임을 객체 자신이 가지고 있는 것을 말합니다.\n\n말이 좀 어렵죠? 집을 청소하는 상황을 비유를 들어서 한 번 이야기해보려 합니다. 집을 청소하는 상황에서, 집주인이 직접 청소를 하지 않고, 청소부에게 청소를 맡기는 것을 의존성 주입이라고 할 수 있습니다. 이 때 우리가 기존에 이야기 해 온 의존성 주입의 방식들은 집주인이 청소부에게 청소를 위임할 때, 필요한 도구들을 직접 전달하는 것과 같습니다.\n\n그런데 이러기 위해서는 청소 도구들을 주인이 직접 관리해야할 뿐더러, 청소부가 어떤 도구를 사용해야 하는지에 대한 지시를 직접 해야하는 등의 문제가 있을 수 있습니다. 우리는 청소를 하기 싫어서 서비스를 이용하려는 것인데 오히려 더 많은 일을 해야하는 상황이 되는 것이죠.\n\n그렇다면 아예 집안 청소 서비스를 이용한다면 어떻게 될까요? 우리는 단순히 서비스 업체를 이용하기만 하면 업체는 우리 집의 상황을 판단하고, 우리에게 필요한 모든 도구를 가져온 뒤에 청소를 해주는 것입니다. 이렇게 서비스를 이용하면 우리는 청소에 집중할 수 있고, 다른 것에 신경 쓰지 않아도 되는 것이죠.\n\n그리고 이것이 바로 **제어 역전**입니다. 제어 역전은 우리가 맞이한 문제를 해결하기 위해 외부에 일을 맡기고, 그 일을 외부에서 해결하는 것을 말합니다. 마치 집안 청소 서비스를 이용하는 것처럼 말이죠.\n\n비유를 통해 이야기해봤으니, 그러면 이제 코드를 통해 한 번 살펴보겠습니다. 예시로는 이제 우리에게 친숙해진 DataAnalyzer와 FileManager를 사용하겠습니다.\n\n```python\ndata_analyzer = DataAnalyzer(BinaryFileManager())\ndata_analyzer.process_data(sample_file_name)\n```\n\n만약 우리가 data_analyzer를 통해 BinaryFileManager를 사용하려 한다면, 위와 같은 코드를 사용하게 됩니다. 하지만 만약 기획이 바뀌어 우리에게 TextFileManager를 사용하라는 요구사항이 생긴다면, 우리는 다음과 같이 코드를 변경해야 할 것입니다.\n\n```python\ndata_analyzer = DataAnalyzer(TextFileManager())\n```\n\n이처럼 의존성 주입을 사용하고 있더라도, 기존의 방식으로는 여전히 객체를 생성하고 사용할 때 마다 문제 상황에 맞는 객체를 생성해야 하는 문제가 있습니다. 이런 현상을 이제 제어 역전을 사용하여 해결해보겠습니다.\n\n```python\nclass FileManagerController:\n    def __init__(self):\n        self.file_manager = None\n\n    def get_file_manager(self):\n        return self.file_manager\n\n    def set_file_manager(self, file_type):\n        if file_type == 'binary':\n            self.file_manager = BinaryFileManager()\n        elif file_type == 'text':\n            self.file_manager = TextFileManager()\n\nfile_manager_controller = FileManagerController()\nfile_manager_controller.set_file_manager(filename.split('.')[-1])\n\ndata_analyzer = DataAnalyzer(file_manager_controller.get_file_manager())\ndata_analyzer.process_data(sample_file_name)\n```\n\n이를 통해 DataAnalyzer는 들어온 파일을 처리할 때 더 이상 파일의 정보를 알 필요가 없어졌습니다. 이는 파일 매니저 컨트롤러가 파일의 정보를 알고 있기 때문입니다. 이처럼 제어 역전을 사용하면 객체를 생성하고 사용할 때 마다 문제 상황에 맞는 객체를 생성해야 하는 문제를 해결할 수 있습니다.\n\n다만 분명 FileManagerController가 들어와서 제어가 역전됐는데, 얼핏 보기에는 코드가 복잡해지고 있는 것처럼 보일 수 있습니다. 그러면 더 나아가서, 만약 우리가 이 데이터 분석 모듈을 웹서버에 탑재해야하는 경우를 상정해보면 어떨까요?\n\n```python\nclass WebServer:\n    def __init__(self, data_analyzer):\n        self.data_analyzer = data_analyzer\n\n    def handle_request(self, file_name, file_type):\n        self.file_manager_controller.set_file_manager(file_type)\n        self.data_analyzer = DataAnalyzer(self.file_manager_controller.get_file_manager())\n        self.data_analyzer.process_data(file_name)\n```\n\n이제 우리는 보내오는 파일이 어떤 형태이든지간에, FileManagerController만이 이것을 처리할 뿐 이를 이용하는 WebServer는 어떤 파일이 들어오든지간에, FileManagerController에게 파일의 형태를 알려주기만 하면 됩니다. 다음처럼 말입니다. 사실 조금만 더 손 보면 파일 형태도 FileManagerController에게 알려주지 않아도 될 것입니다.\n\n```python\nfile_manager_controller = FileManagerController()\nweb_server = WebServer(file_manager_controller)\n\nweb_server.handle_request(\"data.bin\", 'binary')\nweb_server.handle_request(\"data.txt\", 'text')\n```\n\n---\n\n## 마치며\n\n긴 여정을 통해 의존성 역전에 대해 알아보았습니다. 의존성 역전은 객체지향 프로그래밍의 핵심 원리 중 하나로 객체 간의 결합도를 낮추고 유연성을 높이는 방법으로, 잘 사용하면 코드의 재사용성을 높이고 유지보수성을 높일 수 있습니다. 하지만 집안에 쓰레기가 얼마 없을 때는 빗자루를 집어드는 것이 청소 업체에 연락을 하는 것보다 우선하듯이, 의존성 역전 역시 코드의 유연성을 높일 필요한 상황에서 사용하는 것이 중요합니다.\n\n여러분이 앞으로 프로그램을 개발하는 데 있어, 그리고 제가 개발하는 과정에 있어서, 마주하게 될 많은 문제 상황들 중에 한번 쯤 의존성 역전이 이를 천원돌파하는 최강의 드릴이 되길 기원합니다. 그리고 이 글이 여러분의 그 드릴을 조금이나마 빛나게 해줄 수 있었다면 저에게는 더할나위 없는 즐거움이 될 것입니다. 긴 글 읽어주셔서 감사합니다. 다음 주제는... 뭐 당장 생각해 둔 것은 없습니다만 다른 디자인 패턴 중 하나를 써보면 어떨까 싶네요.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"천원돌파 의존성 역전","date":"2024-02-07T00:00:00.000Z","categories":"디자인패턴","subtitle":""}},{"postName":"2024-02-13-Strategy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-13-Strategy Pattern.md","category":"디자인패턴","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. interface를 통한 해결의 문제점\n5. 전략 패턴을 통한 해결\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**전략 패턴**은 **알고리즘**을 독립적인 객체로 **캡슐화**해서, 클라이언트와 **분리**하는 디자인 패턴입니다. 이를 통해 클라이언트는 알고리즘을 변경하지 않고도 다양한 알고리즘을 사용할 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 오리의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 오리의 **꽥꽥** 소리를 낸다는 행동은 오리의 종류에 따라 다르게 구현될 수 있습니다. 또한 여기에 **날다**와 같은 기능을 추가하는 것이 요구될 수도 있습니다. 이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 **전략 패턴**입니다.\n\n---\n\n## 요약\n\n* 전략 패턴은 알고리즘을 독립적인 객체로 캡슐화해서, 클라이언트와 분리하는 디자인 패턴입니다.\n* 클라이언트 - 오리, 알고리즘 - 날다, 꽥꽥\n* 상속이나 구현보다는 **구성**을 활용한다.\n\n---\n\n## 문제상황\n\n기존에 수영하고, 소리만 낼 수 있는 오리가 구현돼고 있던 다음과 같은 프로그램이 있었습니다. 모든 오리들은 밖에 표현되는 방식만 다르게 구현돼 있습니다.\n\n```java\npublic abstract class Duck {\n    public void swim() {\n        System.out.println(\"수영\");\n    }\n\n    public void quack() {\n        System.out.println(\"꽥꽥\");\n    }\n\n    public abstract void display();\n}\n\npublic class MallardDuck extends Duck {\n    public void display() {\n        System.out.println(\"MallardDuck\");\n    }\n}\n\npublic class RedheadDuck extends Duck {\n    public void display() {\n        System.out.println(\"RedheadDuck\");\n    }\n}\n\n...\n\n```\n\n그런데 어느날, 오리에 날다 행동을 추가하라는 기획이 내려왔습니다. 그래서 당신은 다음과 같이 날다의 행동을 추가했습니다.\n\n```java\npublic abstract class Duck {\n    ...\n\n    public void fly() {\n        System.out.println(\"날다\");\n    }\n}\n```\n\n그리고 대재앙을 맞이하게 됩니다. 이 오리 클래스를 상속하던 클래스 중에는 날아서는 안되는 rubberduck이 존재했던 것입니다. 이 노란빛 귀염둥이는 화면을 가득 수놓으며 우리를 괴롭히는 상황을 만들어냅니다.\n\n이런 식으로, 상속을 통해 구현된 클래스들에 새로운 행동을 추가하거나, 기존 행동을 변경하는 것은 많은 예상불가능한 결과를 낳을 수 있기 때문에 어렵습니다.\n\n---\n\n## Interface를 통한 해결의 문제점\n\n이 문제를 해결하기 위해 duck을 interface로 만들어서, 각각의 오리들이 이를 구현하도록 할 수 있습니다. 그런데, rubberduck과 같이 가끔 발생하는 예외가 있을 뿐 대부분의 경우에는 동일한 행동을 반복해서 사용하면 될 상황에서 interface를 사용하는 것은 매우 비효율적입니다.\n\n```java\npublic interface Duck {\n    public void swim();\n    public void quack();\n    public void display();\n    public void fly();\n}\n```\n\n위와 같은 Duck을 구현하는 수많은 클래스들에 대해 우리는 모두 4가지 메소드를 구현해야합니다. 그 뿐 아니라 이번에 fly를 추가해야했던 것과 같은 상황이 발생하면, Duck을 **구현**한 모든 클래스들에 해당 메소드들을 다 작성해주어야하는 번거로움이 생깁니다.\n\n---\n\n## 전략 패턴을 통한 해결\n\n이를 해결하기 위해 나온 것이 전략 패턴입니다. 전략 패턴은 **알고리즘**(날다, 꽥꽥 소리내다 등)을 독립적인 객체로 **캡슐화**한 뒤, 클라이언트와 **분리**하는 디자인 패턴입니다. 전략패턴을 사용할 경우 클래스를 만들 때 **변화가 필요한** 메소드는 상속하거나 구현하지 않습니다. 대신 각각의 행동을 독립적인 객체로 만든 뒤 이를 필요한 클래스에 **구성으로 추가**합니다.\n\n```java\npublic interface FlyBehavior {\n    public void fly();\n}\n\npublic interface QuackBehavior {\n    public void quack();\n}\n\n...\n\npublic class Duck {\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n\n    public void performFly() {\n        flyBehavior.fly();\n    }\n\n    public void performQuack() {\n        quackBehavior.quack();\n    }\n\n    public void setFlyBehavior(FlyBehavior fb) {\n        flyBehavior = fb;\n    }\n\n    public void setQuackBehavior(QuackBehavior qb) {\n        quackBehavior = qb;\n    }\n}\n```\n\n위와 같은 방식을 통해 우리는 각각의 행동을 독립적인 객체로 만들어서 필요한 클래스에 구성해 추가할 수 있습니다. 이를 통해 우리는 새로운 행동을 추가하거나, 기존 행동을 변경하는 것이 매우 쉬워집니다. 또한, 각각의 행동을 동적으로 변경하거나 확장할 수 있습니다.\n\n다시 말해, 우리는 전략 패턴을 통해 다음과 같은 장점을 얻을 수 있습니다.\n\n1. 한번 구현한 행동을 다른 클래스에도 쉽게 **재사용**할 수 있습니다.\n2. 행동을 **변경**하거나 **확장**하기가 매우 쉬워집니다.\n3. 행동을 **동적**으로 변경하는 것도 가능합니다.\n\n---\n\n## 결론\n\n프로그램의 구체적인 **동작**을 **캡슐화**하고 이를 클래스에서 **구성**하는 형태를 우리는 전략 패턴이라고 부릅니다. 이를 통해 우리는 한 번 작성한 코드를 **재사용**하는 장점을 유지하면서도, 새로운 행동을 **추가**하거나 기존 행동을 **동적으로 변경**하는 것이 용이한 프로그램을 작성할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"전략 패턴","subtitle":"고무 오리는 날 수 없다, 엄마에게 혼났죠","date":"2024-02-13T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-14-Decorator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-14-Decorator Pattern.md","category":"디자인패턴","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 데코레이터 패턴을 통한 해결\n5. OCP(Open-Closed Principle)\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n데코레이터 패턴은 **객체의 행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다. 이를 통해 상속을 통한 확장의 문제점을 해결할 수 있습니다.\n\nhead first design은 이에 대한 예시로 커피의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 커피숍에서 판매하는 커피의 **종류**와 **첨가물**을 추가하는 것이 요구될 수 있습니다. 이런 다양한 요구사항을 상속을 통해 구현하는 것은 모든 서브 클래스를 만들어야 하는 등의 이유 때문에 불편하고, 비효율적입니다. 이런 불편을 해소하기 위한 방법 중 하나가 **데코레이터 패턴**입니다.\n\n---\n\n## 요약\n\n* 데코레이터 패턴은 객체의 **행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다.\n* 음료에 들어가는 **첨가물**들을 **데코레이터**로 구현합니다.\n* **서브 클래스**를 만드는 대신, **데코레이터**를 사용하면 런타임에 행동을 확장할 수 있습니다.\n\n---\n\n## 문제상황\n\n커피 샵 시스템을 만들고 있다고 가정해겠습니다. 기존에 커피 숍의 주문 시스템에서 사용하던 음료 클래스는 다음과 같습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic class Espresso extends Beverage {\n    public Espresso() {\n        description = \"에스프레소\";\n    }\n\n    public double cost() {\n        return 1.99;\n    }\n}\n\npublic class HouseBlend extends Beverage {\n    public HouseBlend() {\n        description = \"하우스 블렌드 커피\";\n    }\n\n    public double cost() {\n        return .89;\n    }\n}\n\n...\n```\n\n이런 구현 방식은 새로운 **첨가물**을 **추가**하는 것이 어렵다는 문제가 있습니다. 첨가물이란 모카나 우유와 같이 음료에 추가해서 맛을 바꾸는 것들을 말합니다. 예를 들어 모카라는 첨가물을 제공하려면 어떻게 해야할까요? 우리는 다음과 같은 class를 추가해야할 것입니다.\n\n```java\npublic class EspressoWithMocha extends Beverage {\n    ...\n}\n```\n\n만약 음료의 종류가 10가지였다면 모카를 첨가하게 될 음료에 대해 최대 10가지의 서브 클래스를 만들어야 합니다. 이는 매우 비효율적입니다.\n\n그런데 여기에 더해 모카가 아닌 새로운 첨가물이 추가된다면 어떻게 해야할까요? 심지어 모카와 함께 들어갈 수 있는 우유와 같은 첨가물이라면요? 이런 경우에는 **조합의 수**가 무수히 많아질 수 있습니다.\n\n```java\n\npublic class EspressoWithMilk extends Beverage {\n    ...\n}\n\npublic class EspressoWithMochaAndMilk extends Beverage {\n    ...\n}\n\npublic class HouseBlendWithMochaAndMilk extends Beverage {\n    ...\n}\n\n...\n\n```\n\n이런 식으로 **서브 클래스**를 만드는 것은 매우 비효율적입니다. 이를 해결하기 위해 등장한 것이 바로 **데코레이터 패턴**입니다.\n\n---\n\n## 데코레이터 패턴을 통한 해결\n\n데코레이터 패턴은 커피에 다양한 첨가물을 추가할 수 있는 상황처럼, 객체에 **다양한 추가 요소**를 **동적으로 추가**할 필요가 있을 때 사용할 수 있는 패턴입니다.\n\n데코레이터 패턴은 일종의 **투명한 래퍼**를 만드는 것과 같습니다. 이 래퍼는 자신이 감싸고 있는 객체와 같은 인터페이스를 구현합니다.\n\n데코레이터 패턴을 통해 위의 커피 숍 문제를 다음과 같이 해결할 수 있습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic abstract class CondimentDecorator extends Beverage {\n    Beverage beverage;\n    public abstract String getDescription();\n}\n```\n\n위의 데코레이터 패턴이 존재하는 상태에서 다음과 같은 서브 클래스들이 구현돼있다 가정해보겠습니다.\n\n1. **Beverage**\n    * Espresso\n    * HouseBlend\n    * DarkRoast\n\n2. **CondimentDecorator**\n    * Mocha\n    * Soy\n    * Whip\n    * Milk\n\n이제 우리는 Espresso에 Mocha와 Milk를 추가하는 것을 다음과 같이 구현할 수 있습니다.\n\n```java\nBeverage beverage = new Espresso();\nbeverage = new Mocha(beverage);\nbeverage = new Milk(beverage);\n\nSystem.out.println(beverage.getDescription() + \" $\" + beverage.cost());\n```\n\n위의 방식은 기존에 서브 클래스를 만드는 방식과는 다르게 수많은 조합을 일일이 구현할 필요가 없습니다. 또한, 런타임에 행동을 확장할 수 있게 되었습니다.\n\n---\n\n## OCP(Open-Closed Principle)\n\n이처럼 우리는 데코레이터 패턴을 통해 음료에 다양한 첨가물을 추가하더라도 새로운 행동을 추가하는 서브 클래스를 만들 필요가 없어졌습니다. 또한, 다양한 객체들을 조합할 수 있게 되었습니다.\n\n이런 식으로 객체의 행동을 **확장할 수 있으면서, 변화에는 닫혀있는 특징**을 우리는 **OCP(Open-Closed Principle)**라고 합니다.\n\n---\n\n## 결론\n\n데코레이터 패턴은 **객체의 행동을 동적으로 확장**할 수 있게 해주는 디자인 패턴입니다. 기존처럼 상속을 통해 확장을 하려할 경우에는 변화하는 부분에 대한 **캡슐화**가 어렵고, 불필요한 서브 클래스의 생성이 발생할 수 있습니다.\n\n데코레이터 패턴은 기존의 **객체를 장식(decorate)**하는 방식으로 객체의 행동을 확장합니다. 이를 통해 객체의 행동을 동적으로 확장할 수 있으면서, **OCP**를 준수할 수 있게 됩니다.\n\n대신 데코레이터 패턴을 사용하기 위해 다양한 객체를 조합하는 것은 관리하기 어려울 수 있습니다. 이를 해결하기 위해 **팩토리 패턴**과 같은 디자인 패턴을 함께 사용할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","date":"2024-02-14T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-14-Observer Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-14-Observer Pattern.md","category":"디자인패턴","title":"옵저버 패턴","subtitle":"어느새 빗물이 내 발목에 고이기 전에 알려줬어야지!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 옵저버 패턴을 통한 해결.\n5. Pull 방식의 옵저버 패턴\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**옵저버 패턴**은 객체의 **상태 변화**를 **관찰**하는 객체를 만들어, 상태 변화가 있을 때마다 이를 **통보**하는 패턴입니다. 이 패턴에서는, **주제**와 **옵저버**가 있습니다. 주제는 상태를 가지고 있으며, 옵저버는 주제의 상태를 관찰하고 있다가 상태가 변화하면 이를 통보받아 처리합니다.\n\nhead first design patterns는 이에 대한 예시로 날씨 정보를 제공하는 서비스를 제시해서 설명합니다. 날씨 정보를 제공하는 서비스는 날씨 정보를 제공하는 주제가 되고, 날씨 정보를 받아서 처리하는 서비스는 옵저버가 됩니다.\n\n---\n\n## 요약\n\n1. 옵저버 패턴은 **신문사**와 **구독자**로 비유할 수 있습니다. 신문사는 구독자에게 새로운 뉴스가 나올 때마다 이를 통보합니다. 이때 신문사는 주제가 되고, 구독자는 옵저버가 됩니다.\n2. 날씨 정보 서비스 - **주제**, 디스플레이 - **옵저버**\n3. 옵저버 패턴은 주제가 통보하는 **push** 방식과 주제에게 상태를 요청하는 **pull** 방식이 있습니다.\n4. 상호작용하는 객체들 사이에서 **느슨한** 결합을 사용해서, 객체들을 서로 **독립적**으로 **재사용**할 수 있게 합니다.\n\n---\n\n## 문제 상황\n\n현재 온도, 습도, 기압을 제공하는 날씨 정보 서비스를 만들고 있습니다. 이 서비스는 다음과 같은 요구사항을 가지고 있습니다.\n\n1. 어딘가에서 보내주는 날씨 정보를 받아서, 이를 표시하는 **다양한 디스플레이**를 만들어야 합니다.\n2. **날씨 정보**를 제공하는 서비스는 날씨 정보가 **변경**될 때마다 **디스플레이**에게 이를 **통보**해야 합니다.\n3. 디스플레이는 날씨 정보가 변경될 때마다, 자신의 디스플레이를 **갱신**해야 합니다.\n\n이를 다음과 같이 구현을 했다고 가정해보겠습니다.\n\n```java\npublic class WeatherData {\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public void measurementsChanged() {\n        float temp = getTemperature();\n        float humidity = getHumidity();\n        float pressure = getPressure();\n\n        currentConditionsDisplay.update(temp, humidity, pressure);\n        statisticsDisplay.update(temp, humidity, pressure);\n        forecastDisplay.update(temp, humidity, pressure);\n    }\n\n    ...\n}\n```\n\n위 코드의 문제점은, 새로운 디스플레이 항목이 추가될 때마다 WeatherData 클래스를 수정해야 한다는 것입니다. 또, 실행 중에 디스플레이를 추가하거나 제거하는 것이 불가능합니다. 즉, 바뀌는 부분을 **캡슐화**하지 못했기 때문에 **확장성**이 떨어집니다.\n\n이를 구현하는 과정에서 생길 수 있는 많은 불편을 해소하기 위한 방법 중 하나가 **옵저버 패턴**입니다.\n\n---\n\n## 옵저버 패턴을 통한 해결 (push 방식)\n\n다음과 같이 위의 코드를 옵저버 패턴을 통해 수정해보겠습니다.\n\n```java\npublic interface Subject {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObservers();\n}\n\npublic interface Observer {\n    public void update(float temp, float humidity, float pressure);\n}\n\npublic class WeatherData implements Subject {\n    private ArrayList<Observer> observers;\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherData() {\n        observers = new ArrayList<Observer>();\n    }\n\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void removeObserver(Observer o) {\n        int i = observers.indexOf(o);\n        if (i >= 0) {\n            observers.remove(i);\n        }\n    }\n\n    public void notifyObservers() {\n        for (int i = 0; i < observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(temperature, humidity, pressure);\n        }\n    }\n\n    public void measurementsChanged() {\n        notifyObservers();\n    }\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        measurementsChanged();\n    }\n}\n\npublic class CurrentConditionsDisplay implements Observer {\n    private float temperature;\n    private float humidity;\n    private Subject weatherData;\n\n    public CurrentConditionsDisplay(Subject weatherData) {\n        this.weatherData = weatherData;\n        weatherData.registerObserver(this);\n    }\n\n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\n...\n// 기타 다른 Display 클래스들\n```\n\n이제 WeatherData 클래스는 Subject 인터페이스를 구현하고, Observer 인터페이스를 구현하는 디스플레이 클래스들은 이를 구독하고 있습니다. 따라서, WeatherData 클래스는 디스플레이 클래스들을 알 필요가 없어졌습니다. 이것이 바로 **느슨한 결합**입니다.\n\n디스플레이 객체들은 WeatherData 객체에 등록되어 있으며, WeatherData 객체는 디스플레이 객체들에게 상태가 변경될 때마다 이를 통보합니다.\n\n위와 같은 형태로 구현한 Observer를 **Push** 방식이라고 합니다. Push 방식은 주제가 옵저버에게 필요한 데이터를 **직접 전달**합니다.\n\n하지만, 이 방식은 주제가 옵저버에게 필요한 데이터를 모두 전달해야 한다는 단점이 있습니다. 옵저버가 데이터를 받을 필요가 없는 경우에도 데이터를 받게 되기 때문에, **불필요한 데이터**를 받게 됩니다.  이 때문에 만약 주제에 **새로운 데이터**가 추가된다면, 옵저버에게 영향을 주게 됩니다.\n\n예를 들어 현재 WeatherData에 새로운 데이터인 windSpeed가 추가된다면, 모든 옵저버에게 windSpeed를 전달해야 하고 옵저버에는 새로운 변수 windSpeed를 추가해야 합니다. 이는 주제와 옵저버 사이의 **느슨한 결합**을 유지하기 어렵게 만듭니다.\n\n---\n\n## Pull 방식의 옵저버 패턴\n\n이를 해결하기 위한 방법 중 하나가 **Pull** 방식의 옵저버 패턴입니다. 이 방식은 옵저버가 주제에게 필요한 데이터를 **요청**하기 때문에, 주제는 옵저버에게 **필요한 데이터**만 전달하게 됩니다.\n\n다음은 Pull 방식의 옵저버 패턴을 구현한 코드입니다.\n\n```java\n\n...\n\npublic interface Observer {\n    public void update(Subject s);\n}\n\npublic class WeatherData implements Subject {\n\n    ...\n\n    public void notifyObservers() {\n        for (int i = 0; i < observers.size(); i++) {\n            Observer observer = (Observer)observers.get(i);\n            observer.update(this);\n        }\n    }\n\n    ...\n}\n\npublic class CurrentConditionsDisplay implements Observer {\n\n    ...\n\n    public void update(Subject s) {\n        WeatherData weatherData = (WeatherData)s;\n        this.temperature = weatherData.getTemperature();\n        this.humidity = weatherData.getHumidity();\n        display();\n    }\n\n    ...\n}\n```\n\n현재 pull 방식의 옵저버 패턴은 주제가 옵저버에게 필요한 데이터를 전달하지 않고, 옵저버가 주제에게 필요한 데이터를 요청합니다. 이를 통해, 주제는 옵저버에게 필요한 데이터만 전달하게 되며, 불필요한 데이터를 전달하지 않게 됩니다.\n\npull 방식의 옵저버 패턴은 기존과 다르게, 만약 주제에 새로운 데이터가 추가되어도 옵저버에게 영향을 주지 않습니다. 이는 주제와 옵저버 사이의 느슨한 결합을 유지할 수 있게 합니다.\n\n대신, pull 방식의 옵저버 패턴은 옵저버가 주제에게 필요한 데이터를 요청하기 때문에, 옵저버가 주제에게 **종속적**이게 됩니다. 이는 옵저버가 주제가 구현한 인터페이스를 알아야 하기 때문입니다.\n\n이 때문에 일반적으로, pull 방식의 옵저버 패턴을 사용하는 것이 더 좋습니다.\n\n---\n\n## 결론\n\n옵저버 패턴은 특정 객체의 **상태**가 **변경**될 때, 이를 **관찰**하는 다수의 객체에게 이를 **통보**하는 패턴입니다. 이 패턴을 통해 주제와 옵저버 사이의 **느슨한 결합**을 유지할 수 있게 되며, 객체들을 서로 **독립적**으로 **재사용**할 수 있게 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"옵저버 패턴","subtitle":"어느새 빗물이 내 발목에 고이기 전에 알려줬어야지!","date":"2024-02-14T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-15-Factory Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-15-Factory Pattern.md","category":"디자인패턴","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 간단한 팩토리 패턴을 통한 해결\n5. 팩토리 메소드 패턴을 통한 해결\n6. 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n7. 추상 팩토리 패턴을 통한 해결\n8. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**팩토리 패턴**은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 기존에 객체를 생성하는 코드를 직접 사용하던 것과 달리, 이를 팩토리 클래스에 위임해서 객체를 생성하기 때문에 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n\nhead first design은 이에 대한 예시로 **피자 주문 시스템**을 만드는 과정을 제시해서 설명합니다. 피자 주문 시스템에서는 다양한 종류의 피자를 주문할 수 있습니다. 이런 다양한 종류의 피자를 만들 때 각각의 피자를 생성하는 코드를 직접 사용하는 것은 비효율적이고, 유연성이 떨어집니다. 이런 불편을 해소하기 위한 방법 중 하나가 **팩토리 패턴**입니다.\n\n---\n\n## 요약\n\n* 팩토리 패턴은 **객체의 생성을 캡슐화**하는 디자인 패턴입니다.\n* 객체를 생성하는 코드를 직접 사용하는 것이 아니라, 팩토리 클래스에 **위임**해서 객체를 생성합니다.\n* 이를 통해 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n* 팩토리 패턴은 객체 생성을 위임하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다.\n* 팩토리 - 피자/재료 공장, 제품 - 피자/재료\n\n---\n\n## 문제상황\n\n피자 주문 시스템을 만들고 있다고 가정해겠습니다. 기존에 피자 주문 시스템에서 사용하던 **피자 클래스**는 다음과 같습니다.\n\n```java\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    List<String> toppings = new ArrayList<>();\n\n    public String getName() {\n        return name;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        }\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    public void prepare() {\n        System.out.println(\"Preparing \" + name);\n    }\n\n    public void bake() {\n        System.out.println(\"Baking \" + name);\n    }\n\n    public void cut() {\n        System.out.println(\"Cutting \" + name);\n    }\n\n    public void box() {\n        System.out.println(\"Boxing \" + name);\n    }\n}\n...\n```\n\n위의 코드는 피자 주문 시스템에서 사용하는 피자 클래스입니다. 이 피자 클래스는 다양한 종류의 피자를 생성할 수 있습니다. 하지만 이런 식으로 **orderPizza 메소드**를 통해 **피자(인스턴스)**를 만드는 것은 **구상 클래스에 의존**하기 때문에 유연성이 떨어져서 문제가 있습니다.\n\n만약에 새로운 종류의 피자를 추가하고 싶다면 어떻게 해야 할까요? 또는 피자의 재료를 추가하거나, 기존의 피자를 수정하거나, 동일한 이름의 다양한 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n그럴 때마다 다음과 같은 방식으로 **orderPizza** 메소드를 수정해야 할 것입니다.\n\n```java\npublic Pizza orderPizza(String type) {\n    Pizza pizza = null;\n\n    if (type.equals(\"cheese\")) {\n        pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n        pizza = new GreekPizza();\n    } else if (type.equals(\"pepperoni\")) {\n        pizza = new PepperoniPizza();\n    // 새로운 3 종류의 피자 추가\n    } else if (type.equals(\"veggie\")) {\n        pizza = new VeggiePizza();\n    } else if (type.equals(\"clam\")) {\n        pizza = new ClamPizza();\n    } else if (type.equals(\"calm\")) {\n        pizza = new CalmPizza();\n    }\n\n    ...\n}\n```\n\n이 때 바뀌는 부분이 새로운 피자를 추가하는 부분이기 때문에, 이를 **캡슐화**하는 것이 좋습니다. 이런 **객체 생성** 부분을 캡슐화하는 것이 바로 **팩토리 패턴**입니다.\n\n---\n\n## 간단한 팩토리를 통한 해결\n\n**간단한 팩토리**는 **객체 생성을 전담**하는 클래스를 만들어서 객체 생성을 **위임**하는 방식입니다. 이를 통해 객체 생성을 캡슐화하고, 클라이언트 코드와 구상 클래스를 **분리**할 수 있습니다.\n\nhead first design pattern에서는 이를 디자인 패턴이 아니라 프로그래밍에서 자주 사용하는 관용구라고 설명합니다. 이는 디자인 패턴의 정의가 인터페이스 구현을 통한 객체의 행동을 캡슐화하는 것이기 때문입니다.\n\n그렇다 하더라도 간단한 팩토리를 사용해서 객체 생성을 캡슐화하는 것은 팩토리 패턴의 기본이 되는 개념이기 때문에 이를 통해 팩토리 패턴을 이해할 수 있습니다.\n\n위의 피자 주문 시스템을 간단한 팩토리를 통해 해결해보겠습니다.\n\n```java\npublic class SimplePizzaFactory {\n    public Pizza createPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        } else if (type.equals(\"veggie\")) {\n            pizza = new VeggiePizza();\n        } else if (type.equals(\"clam\")) {\n            pizza = new ClamPizza();\n        } else if (type.equals(\"calm\")) {\n            pizza = new CalmPizza();\n        }\n\n        return pizza;\n    }\n}\n\npublic class PizzaStore {\n    SimplePizzaFactory factory;\n\n    public PizzaStore(SimplePizzaFactory factory) {\n        this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = factory.createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n}\n```\n\n간단한 팩토리를 통해 객체 생성을 캡슐화했습니다. 이를 통해 피자 주문 시스템의 클라이언트 코드와 구상 클래스를 분리할 수 있습니다.\n\n단순히 객체 생성을 위임했을 뿐으로 보이지만 이를 사용하는 클라이언트가 매우 많을 수도 있고, 서브 클래스로 PizzaShopMenu, NYPizzaFactory, ChicagoPizzaFactory 등을 만들 수 있습니다.\n\n또 간단한 팩토리 클래스로 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n이런 식으로 객체 생성을 캡슐화해서 유연성을 높이는 것이 바로 **팩토리 패턴**의 기본 개념입니다.\n\n---\n\n## 팩토리 메소드 패턴을 통한 해결\n\n그런데 만약에 피자 주문 시스템을 **확장**해서 각 지역마다 다른 종류의 피자를 만들고 싶다면 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자를, 시카고 지역에서는 시카고 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n이런 경우에 **팩토리 메소드 패턴**을 사용할 수 있습니다. 기본 팩토리 패턴에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했다면, 팩토리 메소드 패턴에서는 객체 생성하는 메소드를 **추상화**해서 객체 생성을 추가적으로 캡슐화합니다.\n\n예를 들어 다음과 같이 **createPizza** 메소드를 추상화해서 팩토리 메소드 패턴을 사용할 수 있습니다.\n\n```java\npublic abstract class PizzaStore {\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    abstract Pizza createPizza(String type);\n}\n\npublic class NYPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new NYStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new NYStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new NYStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n\npublic class ChicagoPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new ChicagoStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new ChicagoStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new ChicagoStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n```\n\n이처럼 팩토리 메소드 패턴은 createPizza 메소드를 추상화해서 객체 생성을 캡슐화합니다. 이를 통해 팩토리 메소드 패턴은 객체 생성을 위임하는 과정을 추상화해서 기본 팩토리 패턴보다 더 유연하게 객체 생성을 관리할 수 있습니다.\n\n이 때문에 팩토리 메소드 패턴을 정의할 때, 객체를 생성할 때 필요한 **인터페이스**를 만든 뒤 어떤 클래스 **인스턴스**를 만들지는 **서브 클래스**에서 결정하도록 맡기게 됩니다. 이것은 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n이 때 PizzaStore를 **Creator(생산자)** 클래스, createPizza를 **팩토리 메소드**, Pizza를 **Product(제품)** 클래스라고 합니다.\n\n---\n\n## 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n\n위의 팩토리 메소드 패턴을 통해 알 수 있는 것 중 하나가 바로 **의존성 역전 원칙**입니다. 이 원칙은 모듈을 작성할 때 **추상화에 의존**하도록 만들고, **구체화에 의존**하지 않도록 하는 원칙을 말합니다. 다른 말로는, **상위 수준 모듈**은 **하위 수준 모듈**에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다고도 합니다.\n\n기존에 피자 주문 시스템에서는 PizzaStore 클래스가 구상 클래스에 의존하고 있었습니다. 이런 식으로 객체 생성을 위임하는 클래스가 구상 클래스에 의존하게 되면 유연성이 떨어지게 됩니다.\n\n그런데 팩토리 메소드 패턴을 통해 PizzaStore를 구현할 때는 이를 우선 추상화해서 객체 생성을 위임하는 클래스가 추상 클래스에 의존하도록 만들었습니다. 이를 통해 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않도록 만들었습니다.\n\n### 의존성 역전 원칙을 지키는 방법\n\n1. 변수를 사용할 때는 **구상 클래스**가 아닌 **추상 클래스**나 **인터페이스**를 사용합니다.\n2. 구상 클래스에서 **유도된 클래스**를 만들지 않습니다.\n3. 베이스 클래스에서 이미 구현된 **메소드 오버라이드**를 하지 않습니다.\n\n---\n\n## 추상 팩토리 패턴을 통한 해결\n\n여태까지 상황에서 더 나아가, 피자 주문 시스템에서 사용하는 원재료 군에 따른 **제품군**을 만들려면 기존의 방식으로는 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자와 뉴욕 원재료를, 시카고 지역에서는 시카고 피자와 시카고 원재료를 만들고 싶다면요?\n\n이런 경우에 **추상 팩토리 패턴**을 사용할 수 있습니다. **기본 팩토리 패턴**에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했고, **팩토리 메소드 패턴**에서는 객체 생성을 위임하는 메소드를 추상화해서 객체 생성을 캡슐화했습니다.\n\n추상 팩토리 패턴에서는 객체 생성을 위임하는 **클래스를 인터페이스로 추상화**해서 객체 생성을 캡슐화합니다. 이를 통해 추상 팩토리 패턴은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다. 구상 클래스는 서브 클래스에서 만듭니다.\n\n예를 들어 다음과 같이 **PizzaIngredientFactory** 인터페이스를 추상화해서 추상 팩토리 패턴을 사용할 수 있습니다.\n\n```java\npublic interface PizzaIngredientFactory {\n    public Dough createDough();\n    public Sauce createSauce();\n    public Cheese createCheese();\n    public Veggies[] createVeggies();\n    public Pepperoni createPepperoni();\n    public Clams createClam();\n}\n\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n\npublic class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n```\n\n위와 같이 추상 팩토리 패턴을 사용해서 **객체 생성을 위임**하는 클래스를 **인터페이스**로 **추상화**했습니다. 이를 통해 추상 팩토리 패턴은 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다.\n\n---\n\n## 결론\n\n팩토리 패턴은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 이는 공장에서 물건을 만드는 것처럼 클라이언트가 **팩토리 클래스에 위임**해서 객체를 생성하기 때문에, 구상 클래스와 클라이언트 코드를 분리하고 느슨한 결합을 유지해서 유연성을 높일 수 있습니다. 사용자는 물건을 만드는 공장에 요청을 할 뿐, 어떻게 만드는지는 알 필요가 없습니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화해서 사용하는 모듈은 **구상 클래스**에 의존하지 않고, **추상화된 인터페이스**에 의존하게 됩니다. 이는 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n팩토리 패턴을 구현하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다. 이를 통해 객체 생성을 위임하는 방식에 따라 객체 생성을 캡슐화하는 방법을 이해할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","date":"2024-02-15T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-16-Command Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-16-Command Pattern.md","category":"디자인패턴","title":"커맨드 패턴","subtitle":"나는 IoT를 지배할 수 있다!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 커맨드 패턴을 통한 해결\n5. 매크로 커맨드 패턴 사용하기\n6. NoCommand 패턴 사용하기\n7. 복잡한 기능 추가하기\n8. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**커맨드 패턴**은 **메소드 호출**을 객체로 **캡슐화**하는 패턴입니다. 코드를 호출한 객체는 호출되는 객체가 일을 어떻게 처리하는지 알 필요가 없습니다.\n\n이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다. 이제 작업을 요청하는 쪽과 작업을 수행하는 쪽을 **분리**할 수 있습니다.\n\nhead first design은 이에 대한 예시로 **IoT 리모컨**을 예시로 사용합니다. IoT 리모컨은 다양한 기기를 제어할 수 있는 리모컨입니다. TV, 에어컨, 전구, 창문 등 다양한 기기를 제어할 수 있어야 합니다.\n\n다양한 기기를 제어할 때 각각의 기기를 제어하는 코드를 직접 사용하는 것은 비효율적이고, 유연성이 떨어집니다. 리모콘은 기기들에 명령만 내릴 뿐 어떻게 처리하는지 모르는 것이 좋습니다.\n\n이런 불편을 해소하기 위한 방법 중 하나가 **커맨드 패턴**입니다. 커맨드 패턴을 사용하면 리모컨은 기기들에 명령만 내리고, 기기들은 명령을 받아서 처리하는 방법을 알고 있습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n---\n\n## 요약\n\n1. 커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 패턴입니다.\n2. 코드를 호출한 객체는 호출되는 객체가 일을 어떻게 처리하는지 알 필요가 없습니다.\n3. 이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n4. 커맨드 패턴은 **커맨드 객체**, **리시버 객체**, **인보커 객체**, **클라이언트 객체**로 구성됩니다.\n5. 커맨드 객체는 **실행 메소드**를 가지고 있습니다. 이 메소드는 리시버 객체의 **작업을 수행**합니다.\n6. 리시버 객체는 **실제 작업을 수행**하는 객체입니다.\n7. 인보커 객체는 **커맨드 객체를 저장**하고 **실행 메소드를 호출**합니다.\n8. 클라이언트 객체는 **커맨드 객체를 생성**하고, **인보커 객체에 전달**합니다.\n9. **매크로 커맨드 패턴**을 통해 **여러 개의 커맨드**를 묶어서 실행할 수 있습니다.\n10. 커맨드 객체 - 키기/끄기, 리시버 객체 - TV/에어컨/전구/창문, 인보커 객체 - 리모컨, 클라이언트 객체 - 사용자\n11. **큐, 로그, 스택** 등과 결합해 **취소, 다시 실행**과 같은 복잡한 기능을 추가할 수 있습니다.\n\n---\n\n## 문제상황\n\nIoT 리모컨을 만들어 달라는 요청과 함께 리모컨에서 다룰 수 있어야 하는 다양한 기기들이 주어졌습니다. 이 기기들은 다음과 같습니다.\n\n```java\npublic class TV {\n    public void on() {\n        System.out.println(\"TV를 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"TV를 끕니다.\");\n    }\n\n    public void setInputChannel(int channel) {\n        System.out.println(\"채널을 \" + channel + \"로 변경합니다.\");\n    }\n\n    public void setVolume(int volume) {\n        System.out.println(\"볼륨을 \" + volume + \"로 변경합니다.\");\n    }\n}\n\npublic class AirConditioner {\n    public void on() {\n        System.out.println(\"에어컨을 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"에어컨을 끕니다.\");\n    }\n\n    public void setTemperature(int temperature) {\n        System.out.println(\"온도를 \" + temperature + \"로 변경합니다.\");\n    }\n}\n\npublic class Light {\n    public void on() {\n        System.out.println(\"전구를 켭니다.\");\n    }\n\n    public void off() {\n        System.out.println(\"전구를 끕니다.\");\n    }\n}\n\npublic class Window {\n    public void open() {\n        System.out.println(\"창문을 엽니다.\");\n    }\n\n    public void close() {\n        System.out.println(\"창문을 닫습니다.\");\n    }\n}\n...\n```\n\n이런 다양한 클래스들이, 공통적인 인터페이스조차 존재하지 않습니다. 그런데 더 큰 문제는 앞으로도 계속해서 새로운 기기들이 추가될 것이라는 점입니다. 이런 상황에서 어떻게 리모컨을 만들 수 있을까요?\n\n---\n\n## 커맨드 패턴을 통한 해결\n\n이를 해결하기 위해 나온 것이 **커맨드 패턴**입니다. 커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 패턴입니다. 이를 통해 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n\n**식당에서 주문**을 받는 것을 예시로 들어보겠습니다. 주문을 받는 직원은 주문을 받고, 주문을 요리하는 요리사에게 주문을 전달합니다. 이때 직원은 요리사가 어떻게 요리를 하는지 알 필요가 없습니다. 요리사는 주문을 받아서 요리를 하는 방법을 알고 있습니다.\n\n이 때 **손님**은 **주문**을 하는 **직원**에게 주문을 전달하고, 직원은 **요리사**에게 주문을 전달합니다. 이때 손님은 요리사가 어떻게 요리를 하는지 알 필요가 없습니다. 요리사는 주문을 받아서 요리를 하는 방법을 알고 있습니다.\n\n그리고 이것이 바로 커맨드 패턴이 동작하는 방식입니다. **메소드 호출(음식)**을 사용할 **클라이언트(손님)**는 이를 **객체(주문)**로 **캡슐화**했기 때문에 호출되는 **객체(요리사)**가 일을 어떻게 처리하는지 알 필요가 없습니다.\n\n이를 다른 표현으로는 **클라이언트 객체, 리시버 객체, 커맨드 객체, 인보커 객체**라고도 합니다.\n\n클라이언트 객체는 커맨드 객체를 생성하고, 인보커 객체에 전달합니다. 인보커 객체는 커맨드 객체를 저장하고, 리시버 객체의 작업을 수행하는 실행 메소드를 호출합니다. 커맨드 객체는 실행 메소드를 가지고 있습니다. 이 메소드는 리시버 객체의 작업을 수행합니다. 리시버 객체는 실제 작업을 수행하는 객체입니다.\n\n이런 커맨드 객체를 리모컨에 적용하면 다음과 같이 됩니다.\n\n```java\npublic interface Command {\n    public void execute();\n}\n\npublic class TVOnCommand implements Command {\n    TV tv;\n\n    public TVOnCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.on();\n    }\n}\n\npublic class TVOffCommand implements Command {\n    TV tv;\n\n    public TVOffCommand(TV tv) {\n        this.tv = tv;\n    }\n\n    public void execute() {\n        tv.off();\n    }\n}\n\n// 에어컨, 전구, 창문에 대한 커맨드 객체들도 같은 방식으로 만들어줍니다.\n...\n\npublic class SimpleRemoteControl {\n    Command slot;\n\n    public SimpleRemoteControl() {}\n\n    public void setCommand(Command command) {\n        slot = command;\n    }\n\n    public void buttonWasPressed() {\n        slot.execute();\n    }\n}\n```\n\n위와 같이 커맨드 패턴을 사용하면 리모컨은 기기들에 명령만 내리고, 기기들은 명령을 받아서 처리하는 방법을 알고 있습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n리모콘이 커맨드를 실행하는 방법은 다음과 같습니다.\n\n```java\n\nSimpleRemoteControl remote = new SimpleRemoteControl();\n\nTV tv = new TV();\n\nTVOnCommand tvOn = new TVOnCommand(tv);\nTVOffCommand tvOff = new TVOffCommand(tv);\n\nremote.setCommand(tvOn);\nremote.buttonWasPressed(); // TV를 켭니다.\n\nremote.setCommand(tvOff);\nremote.buttonWasPressed(); // TV를 끕니다.\n```\n\n---\n\n## 매크로 커맨드 패턴 사용하기\n\n커맨드 패턴을 통해 여러 개의 커맨드를 **묶어서 실행**할 수 있습니다. 이를 **매크로 커맨드 패턴**이라고 합니다.\n\n예를 들어 더운 여름날 사용하기 위해 TV를 켜는 커맨드와 에어컨을 켜는 커맨드를 묶어서 하나의 커맨드로 만들 수 있습니다. 이렇게 하나의 커맨드로 묶어서 실행하면 TV를 켜는 커맨드와 에어컨을 켜는 커맨드를 따로 실행하는 것보다 편리합니다.\n\n구현은 다음과 같습니다.\n\n```java\npublic class MacroCommand implements Command {\n    Command[] commands;\n\n    public MacroCommand(Command[] commands) {\n        this.commands = commands;\n    }\n\n    public void execute() {\n        for (int i = 0; i < commands.length; i++) {\n            commands[i].execute();\n        }\n    }\n}\n```\n\n이렇게 하면 여러 개의 커맨드를 하나의 커맨드로 묶어서 실행할 수 있습니다.\n\n---\n\n## NoCommand 패턴 사용하기\n\n커맨드 패턴은 처음에 객체를 생성할 때 커맨드 객체를 저장하고, 실행 메소드를 호출합니다. 이때 객체를 생성하지 않았을 때의 처리를 위해 **NoCommand 패턴**을 사용할 수 있습니다. NoCommand 패턴을 사용하면 객체를 생성하지 않았을 때의 처리를 쉽게 할 수 있습니다. \n\n예를 들어 리모컨에 아무런 커맨드를 설정하지 않았을 때의 처리를 위해 다음과 같이 NoCommand 패턴을 사용할 수 있습니다.\n\n```java\npublic class NoCommand implements Command {\n    public void execute() {}\n}\n\npublic class RemoteControl {\n    Command[] onCommands;\n    Command[] offCommands;\n\n    public RemoteControl() {\n        onCommands = new Command[7];\n        offCommands = new Command[7];\n\n        Command noCommand = new NoCommand();\n        for (int i = 0; i < 7; i++) {\n            onCommands[i] = noCommand;\n            offCommands[i] = noCommand;\n        }\n    }\n}\n```\n\nNoCommand 패턴을 사용하지 않았을 경우에는 if문을 사용해서 처리해야 했을 것입니다. if (onCommand != null) { ... } else { ... }와 같이 말입니다.\n\n이런 NoCommand 객체는 일종의 **널 객체**입니다. 이 객체는 아무런 동작을 하지 않습니다. 이런 객체를 사용하면 클라이언트 객체는 커맨드 객체가 없을 때의 처리를 신경 쓰지 않아도 됩니다.\n\n---\n\n## 복잡한 기능 추가하기\n\n커맨드 패턴을 **스택, 큐, 로그** 등과 결합해서 **취소, 다시 실행**과 같은 **복잡한 기능**을 추가할 수 있습니다. 대표적으로 여러 작업을 큐에 저장해서 순서대로 실행하거나, 실행한 작업을 스택에 저장해서 취소하거나, 특정 체크 포인트 이후의 모든 행동을 로그에 기록해서 복구 시스템을 구축할 수 있습니다.\n\n---\n\n## 결론\n\n커맨드 패턴은 **메소드 호출을 객체로 캡슐화**하는 디자인 패턴입니다. 이는 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n\n**리모컨**을 예시로 들면 사람은 리모컨을 사용해서 TV를 켜고 끄고, 에어컨을 켜고 끄고, 전구를 켜고 끄고, 창문을 열고 닫습니다. 이때 사람은 TV, 에어컨, 전구, 창문이 어떻게 동작하는지 알 필요가 없습니다. 리모컨은 기기들에 명령만 내리면 되기 때문에 유연성이 높아집니다.\n\n커맨드 패턴은 **커맨드 객체**, **리시버 객체**, **인보커 객체**, **클라이언트 객체**로 구성됩니다.\n\n커맨드 객체는 **실행 메소드**를 가지고 있습니다. 리시버 객체는 실제 **작업 수행**을 하는 객체입니다. 인보커 객체는 **커맨드 객체 저장**을 하고, **실행 메소드 호출**을 합니다. 클라이언트 객체는 **커맨드 객체 생성**을 하고, **인보커 객체에 전달**합니다.\n\n커맨드 패턴을 통해 여러 개의 커맨드를 **묶어서 실행**할 수 있습니다. 이를 **매크로 커맨드 패턴**이라고 합니다. 매크로 커맨드 패턴을 통해 적은 노력으로 여러 개의 커맨드를 실행할 수 있습니다.\n\n인보커에서 커맨드 객체를 저장할 때 객체를 생성하지 않았을 때의 처리를 위해 **NoCommand 패턴**을 사용할 수 있습니다. 이런 NoCommand 객체는 일종의 **널 객체**입니다. 이 객체는 아무런 동작을 하지 않습니다. 이런 객체를 사용하면 클라이언트 객체는 커맨드 객체가 없을 때의 처리를 신경 쓰지 않아도 됩니다.\n\n커맨드 패턴을 **스택, 큐, 로그** 등과 결합해서 **취소, 작업 대기 큐, 복구 시스템** 등의 **복잡한 기능**을 추가할 수 있습니다.\n\n이처럼 커맨드 패턴을 통해 **메소드 호출**을 객체로 **캡슐화**하면 호출하는 객체와 호출되는 객체를 **느슨하게 결합**시키고, **재사용성**을 높일 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"커맨드 패턴","subtitle":"나는 IoT를 지배할 수 있다!","date":"2024-02-16T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-17-Singleton Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-17-Singleton Pattern.md","category":"디자인패턴","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 고전적인 싱글톤 패턴을 통한 해결\n5. 멀티 쓰레드 환경에서의 문제점\n6. 다양한 방법을 통한 해결 - 이중검사 락, 정적인 초기화, Enum\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스**가 **하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**해서 전역 변수처럼 사용할 수 있습니다.\n\nhead first design은 이에 대한 예시로 **초콜릿 보일러**를 예시로 사용합니다. 초콜릿 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 맛있는 초콜릿을 많이 만들기 위해 무려 **500 갤런(약 1892리터)**의 초콜릿을 만들 수 있는 것을 들였습니다.\n\n이 때문에 이 보일러를 두 개나 유지하는 것은 굉장히 비효율적입니다. 이 거대한 초콜릿 보일러 하나를 동작시키는 것도 힘들 뿐더러, 두 개 이상에서 나온 것을 받아 초코바를 만드는 것도 힘들기 때문입니다.\n\n하지만 한 개의 보일러를 **두 명이 동시에 사용**하려하면 어떤 문제가 생길 수 있을까요? 초콜릿 보일러가 가득 차 있는 상태에서 새로운 재료를 붓는다거나, 끓어넘치고 있는데 온도를 더 올려버리는 등의 문제가 생길 수 있습니다. 이런 문제를 해결하기 위해서는 초콜릿 보일러를 하나만 유지하고, 이를 **공유**해서 사용하는 것이 좋습니다.\n\n이런 식으로 싱글톤 패턴은 **리소스를 절약**하고, 객체 간의 **상태를 공유**하기 위해 사용됩니다. 대신 객체 인스턴스가 하나만 만들어지기 때문에, 이 객체 인스턴스를 공유하는 모든 객체들은 멀티 쓰레드 환경에서는 주의할 필요가 있습니다.\n\n---\n\n## 요약\n\n1. 싱글톤 패턴은 특정 클래스에 대해 **객체 인스턴스**가 **하나만** 만들어지도록 해 주는 패턴입니다.\n2. 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n3. 하나뿐인 인스턴스를 공유하기 때문에 **멀티 쓰레드 환경**에서는 주의해야 합니다.\n4. 고전적인 싱글톤 패턴은 **지연 초기화**와 **스레드 안전성**을 보장하지 않습니다.\n5. 이를 해결하기 위해 **이중검사 락**을 사용하는 방법이 있습니다.\n6. **정적인 초기화**를 사용하는 방법도 있습니다.\n7. java에서는 **Enum**을 사용하는 방법이 권장됩니다.\n\n---\n\n## 문제상황\n\n초콜릿 공장에서 초콜릿을 만드는 보일러를 만들고 있습니다. 이 보일러는 초콜릿과 우유를 받은 뒤에 끓여서 초코바를 만드는 단계로 넘겨주는 물건입니다. 이 보일러는 다음과 같이 구현되어 있습니다.\n\n```java\npublic class ChocolateBoiler {\n    private boolean empty;\n    private boolean boiled;\n\n    public ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n    public void drain() {\n        if (!isEmpty() && isBoiled()) {\n            // 끓인 우유/초콜릿을 다음 단계로 넘긴다.\n            empty = true;\n        }\n    }\n\n    public void boil() {\n        if (!isEmpty() && !isBoiled()) {\n            // 우유/초콜릿을 끓인다.\n            boiled = true;\n        }\n    }\n\n    public boolean isEmpty() {\n        return empty;\n    }\n\n    public boolean isBoiled() {\n        return boiled;\n    }\n}\n```\n\n우유나 초콜릿을 채워넣었는지 여부와 우유나 초콜릿을 끓였는지 여부를 세심하게 관리하고는 있지만, 이 **보일러가 여러 개**가 생성되어서 **동시에 사용**될 경우에는 어떻게 될까요? 차있지 않은 보일러를 끓이려고 하거나, 이미 끓인 보일러에 우유나 초콜릿을 채워넣으려고 하는 등의 문제가 생길 수도 있을 것입니다.\n\n이런 문제를 해결하기 위해서는 이 보일러를 **하나만 유지**하고, 이를 **공유**해서 사용하는 것이 좋습니다. 이것이 싱글톤 패턴의 개념입니다. 500 갤런이나 되는 거대한 보일러를 하나만 유지하되, 여기에다가 많은 직원들이 접근해서 우유나 초콜릿을 채워넣고, 끓이고, 다음 단계로 넘기는 것이죠.\n\n---\n\n## 고전적인 싱글톤 패턴을 통한 해결\n\n고전적인 싱글톤 패턴은 다음과 같이 구현됩니다.\n\n```java\npublic class ChocolateBoiler {\n    private static ChocolateBoiler uniqueInstance;\n\n    private ChocolateBoiler() {\n        empty = true;\n        boiled = false;\n    }\n\n    public static ChocolateBoiler getInstance() {\n        if (uniqueInstance == null) {\n            uniqueInstance = new ChocolateBoiler();\n        }\n        return uniqueInstance;\n    }\n    ...\n}\n```\n\n고전적인 싱글톤 패턴은 위와 같이 생성자를 **private**으로 선언하고, 유일한 객체 인스턴스를 반환하는 **getInstance** 메소드를 만들어서 객체 인스턴스를 하나만 만들도록 합니다. getInstance 메소드는 객체 인스턴스가 없을 때만 객체 인스턴스를 만들고, 객체 인스턴스가 이미 있을 때는 객체 인스턴스를 반환하도록 합니다.\n\n이렇게 하면 **객체 인스턴스가 하나**만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 인스턴스가 하나만 만들어지기 때문에 객체 간의 **상태를 공유**할 수 있습니다.\n\n---\n\n## 멀티 쓰레드 환경에서의 문제점\n\n다만 이 방법은 **멀티 쓰레드** 환경에서는 문제가 될 수 있습니다.\n\n만약 아직 객체 인스턴스가 **생성되지 않은 상태**에서 **두 개 이상의 쓰레드**가 getInstance 메소드를 호출하게 되면 무슨 일이 일어날까요? 두 개 이상의 쓰레드가 동시에 getInstance 메소드를 호출하게 되면, 두 개 이상의 객체 인스턴스가 생성될 수 있습니다.\n\n초콜릿 공장에 필요한 보일러를 주문하라는 지령서를 실수로 두 명의 직원이 받아서, 거대한 보일러가 두 개나 도착해버린 상황을 상상해 보세요. 우리 공장에는 이런 보일러를 놓을 공간도 없는데 말입니다.\n\n이런 상황을 방지하기 위해서는 멀티 쓰레드 환경에서도 **스레드 안전성**을 보장해야 합니다.\n\n이를 단순하게 해결하는 방법으로는 생성자에 **synchronized** 키워드를 사용하는 방법이 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static synchronized ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        uniqueInstance = new ChocolateBoiler();\n    }\n    return uniqueInstance;\n}\n```\n\n그런데 synchronized 키워드를 사용하면, **getInstance** 메소드를 호출할 때마다 synchronized 키워드를 사용한 **동기화**를 해야하기 때문에 **성능**이 떨어질 수 있습니다.\n\n대략적으로 **100배** 정도 성능이 떨어진다고 합니다. 이 과정이 **병목(bottleneck)** 지점이 될 경우 프로그램 성능에 크게 영향을 미칠 수 있습니다.\n\n이런 문제를 해결하기 위해서는 여러 가지 방법이 있습니다. 이 중에서는 **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다.\n\n---\n\n## 이중검사 락을 사용한 싱글톤 패턴을 통한 해결\n\n**이중검사 락(Double-Checked Locking)**을 사용하는 방법은 다음과 같이 구현됩니다.\n\n```java\npublic static ChocolateBoiler getInstance() {\n    if (uniqueInstance == null) {\n        synchronized (ChocolateBoiler.class) {\n            if (uniqueInstance == null) {\n                uniqueInstance = new ChocolateBoiler();\n            }\n        }\n    }\n    return uniqueInstance;\n}\n```\n\n이렇게 하면 getInstance 메소드를 호출할 때마다 **동기화**를 하지 않고도 **스레드 안전성**을 보장할 수 있습니다. 대부분의 경우에 uiqueInstance는 이미 null이 아닐테니까요.\n\n---\n\n## 정적인 초기화를 사용한 싱글톤 패턴을 통한 해결\n\n**정적인 초기화**를 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\nprivate static ChocolateBoiler uniqueInstance = new ChocolateBoiler();\n\npublic static ChocolateBoiler getInstance() {\n    return uniqueInstance;\n}\n```\n\n대신 이렇게 하면, 프로그램이 시작될 때 바로 객체 인스턴스가 생성되기 때문에 **지연 초기화**가 되지 않습니다. 이런 방법은 **지연 초기화**가 필요하지 않은 경우에 사용하는 것이 좋습니다.\n\n---\n\n## Enum을 사용한 싱글톤 패턴을 통한 해결\n\njava에서는 **Enum**을 사용하는 방법도 있습니다. 이 방법은 다음과 같이 구현됩니다.\n\n```java\npublic enum ChocolateBoiler {\n    INSTANCE;\n\n    private boolean empty;\n    private boolean boiled;\n\n    public void fill() {\n        if (isEmpty()) {\n            empty = false;\n            boiled = false;\n            // 우유/초콜릿을 보일러에 넣는다.\n        }\n    }\n\n...\n```\n\n위와 같은 방법은 멀티 쓰레드 환경에서 스레드 안정성을 보장하고, 고급 문법인 **직렬화**와 **리플렉션** 등의 문제도 해결할 수 있습니다. 이 때문에 java에서는 이 방법을 사용하는 것을 권장합니다.\n\n---\n\n## 결론\n\n**싱글톤 패턴**은 특정 클래스에 대해 **객체 인스턴스가 하나**만 만들어지도록 해 주는 패턴입니다. 이 패턴을 사용하면, 객체 인스턴스가 하나만 만들어지기 때문에 메모리와 같은 **자원을 절약**할 수 있고, 객체 간의 **상태를 공유**할 수 있습니다.\n\n**멀티 쓰레드 환경**에서는 주의해야 하지만, 이를 해결하기 위한 다양한 방법이 있습니다. 이 중에서는 생성자를 **synchronized**하거나, **이중검사 락**을 사용하는 방법, **정적인 초기화**를 사용하는 방법, **Enum**을 사용하는 방법 등이 있습니다. java에서는 Enum을 사용하는 방법을 권장합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"싱글톤 패턴","subtitle":"찰리네 초콜릿 보일러는 세계 유일!","date":"2024-02-17T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-18-Adapter Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-18-Adapter Pattern.md","category":"디자인패턴","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 어댑터 패턴을 통한 해결\n5. 객체 어댑터와 클래스 어댑터\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**어댑터 패턴**은 다른 인터페이스로 **기존 클래스의 인터페이스를 변환**하는 패턴입니다. 이는 **호환성 문제**를 해결할 수 있습니다. 호환성 문제는 클래스의 인터페이스가 클라이언트의 **요구사항**과 맞지 않을 때 발생합니다.\n\n이때 어댑터 패턴을 사용하면 클라이언트의 요구사항에 맞게 클래스의 인터페이스를 변환할 수 있습니다. 마치 한국 콘센트를 유럽 콘센트에 맞게 변환하는 것과 같습니다.\n\nhead first design patterns는 이에 대한 예시로 전에 사용했던 **오리**를 가져옵니다. 어쩌다보니 오리가 모자라서 **칠면조**를 사용해야 상황이 왔는데, 칠면조는 오리와는 다른 울음 소리를 내고 있습니다. 이때 칠면조의 목소리를 오리와 동일하게 변환하는 어댑터를 사용하면 칠면조를 오리로 사용할 수 있습니다.\n\n어댑터를 사용해서 기존에 사용하던 오리 코드를 수정하지 않고 칠면조를 오리로 사용하면 코드의 수정이 최소화됩니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다.\n\n어댑터 패턴 구현 방식은 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다. 클래스 어댑터는 **상속**을 통해 어댑터를 구현하고, 객체 어댑터는 **구성**을 통해 어댑터를 구현합니다.\n\n---\n\n## 요약\n\n1. 어댑터 패턴은 **클래스의 인터페이스를 다른 인터페이스로 변환**하는 패턴입니다.\n2. **호환성 문제**를 해결할 수 있습니다.\n3. 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다.\n4. 어댑티 - 칠면조, 어댑티 - 오리, 클라이언트 - 사용자\n5. 구현 방식에 따라 **클래스 어댑터**와 **객체 어댑터**로 나뉩니다.\n\n---\n\n## 문제상황\n\n동물원에서 기존에 오리만으로 이루어진 공연이 있었습니다. 그런데 어느 날 몇 마리의 오리가 아프게 되어서 공연을 할 수 없게 되었습니다. 그래서 동물원은 칠면조를 대신해서 공연을 하기로 했습니다. 그런데 오리가 \"**꽥꽥**\" 소리를 내는데 반해 칠면조는 \"**고블고블**\" 소리를 내기 때문에 공연을 할 수 없었습니다.\n\n위와 같은 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Duck {\n    public void quack();\n    public void fly();\n}\n\npublic interface Turkey {\n    public void gobble();\n    public void fly();\n}\n```\n\n이런 상황에서 칠면조를 오리로 사용하는 방법이 필요합니다. 칠면조의 \"고블고블\" 소리가 오리의 \"꽥꽥\" 소리와 동일하게 동작하도록 만드는 것이죠.\n\n---\n\n## 어댑터 패턴을 통한 해결\n\n이런 상황에서 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 어댑터 패턴을 사용하면 칠면조의 \"고블고블\" 소리를 오리의 \"꽥꽥\" 소리로 **변환**할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TurkeyAdapter implements Duck {\n    Turkey turkey;\n\n    public TurkeyAdapter(Turkey turkey) {\n        this.turkey = turkey;\n    }\n\n    public void quack() {\n        turkey.gobble();\n    }\n\n    public void fly() {\n        turkey.fly();\n    }\n}\n```\n\n이렇게 어댑터 패턴을 사용하면 칠면조를 오리로 사용할 수 있습니다. 칠면조의 \"고블고블\" 소리는 어댑터를 통해 \"꽥꽥\" 소리로 **변환**되어 공연 연출가에게 전달됩니다.\n\n이런 방식으로 어댑터 패턴을 사용하면 기존의 코드를 수정하지 않고 칠면조를 오리로 사용할 수 있습니다. 이는 **유연성**과 **재사용성**을 높일 수 있습니다. 동물원의 입장에서는 새로운 오리를 추가로 구매할 필요가 없어지고, 칠면조의 입장에서는 꽥꽥 소리를 내는 훈련을 할 필요가 없어지는 겁니다. 애초에 불가능하겠지만요.\n\n---\n\n## 객체 어댑터와 클래스 어댑터\n\n위와 같이 **인터페이스를 통해 어댑터를 구현**하는 것을 **객체 어댑터**라고 합니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 객체를 **소유**하는 것을 통해 요구되는 인터페이스를 제공합니다.\n\n또 다른 방법으로는 **다중 상속**을 통해 어댑터를 구현할 수도 있습니다. 이를 **클래스 어댑터**라고 합니다. 클래스 어댑터는 변환 대상과 변환 결과를 동시에 상속받아서 변환을 수행합니다. 오리와 칠면조를 **교배**시켜 만든 새로운 종류의 새라고 생각하시면 됩니다.\n\n클래스 어댑터를 코드로 나타내면 다음과 같습니다.\n\n```c++\nclass TurkeyAdapter : public Duck, public Turkey {\n    public:\n        void quack() {\n            gobble();\n        }\n\n        void fly() {\n            Turkey::fly();\n        }\n\n        void gobble() {\n            cout << \"Gobble gobble Quack quack\" << endl;\n        }\n}\n```\n\n---\n\n## 결론\n\n**어댑터 패턴**은 클래스의 인터페이스를 **다른 인터페이스로 변환**하는 패턴입니다. 이를 통해 **호환성 문제**를 해결하면 기존의 코드를 수정하지 않고 사용할 수 있어 **유연성**과 **재사용성**을 높일 수 있습니다. 이는 오리만으로 이루어지던 공연에 칠면조를 추가할 수 있게 되는 것과 동일한 맥락입니다.\n\n어댑터 패턴을 구현하는 방법은 **객체 어댑터**와 **클래스 어댑터**로 나눌 수 있습니다. 객체 어댑터는 인터페이스를 구현하는 클래스에서 어댑터를 통해 변환할 **객체를 소유**하는 것을 통해 요구되는 인터페이스를 제공합니다. 클래스 어댑터는 변환 대상과 변환 결과를 **동시에 상속**받아서 변환을 수행합니다. 이는 칠면조의 입에 **소리 변환기**를 달아주는 것과 칠면조와 오리를 **교배**시켜 새로운 종류의 새를 만드는 것과 비슷하게 생각하시면 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"어댑터 패턴","subtitle":"오리가 되겠다던 칠면조","date":"2024-02-18T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-19-Facade Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-19-Facade Pattern.md","category":"디자인패턴","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 파사드 패턴을 통한 해결\n5. 최소 지식 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**파사드 패턴**은 **복잡한 서브시스템을 간단하게 제공**하는 패턴입니다. 이는 간단한 인터페이스를 통해 까다로운 구현을 숨기고 사용자가 쉽게 사용할 수 있게 합니다. 이는 **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **홈시어터**를 가져옵니다. 홈시어터는 DVD 플레이어, 음향 시스템, 프로젝터 등으로 이루어져 있습니다.\n\n만약 홈시어터에서 영화 한 편을 보기 위해 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 한다면 사용자는 매번 영화를 보기 위해 많은 시간을 소비해야 합니다. 그러다보면 그냥 영화를 안 보고 말게 될 수도 있습니다.\n\n이때 파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 소위 버튼 하나만 **딸깍** 누르면 영화가 시작되는 것과 같습니다.\n\n**최소 지식 원칙**은 **객체 사이의 상호작용**을 **최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n---\n\n## 요약\n\n1. **파사드 패턴**은 복잡한 서브시스템을 **단순한 인터페이스**로 제공합니다.\n2. **복잡성을 감소**시키고 **유지보수성**을 높일 수 있습니다.\n3. 딸깍 - 파사드, DVD 플레이어/음향 시스템/프로젝터 - 서브시스템\n4. 파사드는 클라이언트와 구성 요소로 이루어진 **서브시스템을 분리**합니다.\n5. 파사드는 여러 클래스를 **하나로 감싸서 사용**할 수 있습니다.\n6. **최소 지식 원칙**은 객체 사이의 **상호작용을 최소화**한다는 원칙입니다.\n\n---\n\n## 문제상황\n\n한 영화광이 자신의 꿈이었던 자기만의 **홈 시어터**를 마침내 구축했습니다. 그런데 막상 꿈이 현실이 되고 보니, 그렇게 행복할 줄만 알았던 영화 생활은 녹록치 않았습니다.\n\n영화를 볼 때마다 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법까지 알아야 하고, 심지어 동작하지 않은 것이 있으면 그것을 해결해야 했습니다. 이러다보니 영화를 보는 것이 귀찮아지고, 결국 홈 시어터를 사용하지 않게 되었습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class DvdPlayer {\n    // DvdPlayer의 동작을 위한 메소드들\n}\n\npublic class Amplifier {\n    // Amplifier의 동작을 위한 메소드들\n}\n\npublic class Projector {\n    // Projector의 동작을 위한 메소드들\n}\n\n...\n\npublic static void main(String[] args) {\n\n    Client client = new Client();\n\n    DvdPlayer dvdPlayer = new DvdPlayer();\n    Amplifier amplifier = new Amplifier();\n    Projector projector = new Projector();\n    // ...\n    dvdPlayer.on();\n    amplifier.on();\n    projector.on();\n    // ...\n}\n```\n\n평생의 숙원이었던 홈 시어터를 포기할 수는 없기 때문에 해결하기 위한 방법을 강구하던 중 이에 대한 해결방법에 대한 제안을 듣게 되었습니다.\n\n---\n\n## 파사드 패턴을 통한 해결\n\n**파사드 패턴**을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 버튼 하나만 **딸깍** 누르면 영화를 투영할 스크린은 내려오고, 창문을 가리는 커튼이 닫히고, DVD 플레이어가 켜지고, 음향 시스템이 켜지고, 프로젝터가 켜지는 것과 같습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class HomeTheaterFacade {\n    DvdPlayer dvdPlayer;\n    Amplifier amplifier;\n    Projector projector;\n    // ...\n\n    public HomeTheaterFacade(DvdPlayer dvdPlayer, Amplifier amplifier, Projector projector, ...) {\n        this.dvdPlayer = dvdPlayer;\n        this.amplifier = amplifier;\n        this.projector = projector;\n        // ...\n    }\n\n    public void watchMovie() {\n        dvdPlayer.on();\n        amplifier.on();\n        projector.on();\n        // ...\n    }\n}\n```\n\n파사드 패턴을 사용하면 사용자는 **간단한 인터페이스**를 통해 영화를 볼 수 있습니다. 이를 통해 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하고, **여러 클래스를 하나로** 감싸서 사용할 수 있습니다.\n\n---\n\n## 최소 지식 원칙\n\n**최소 지식 원칙**은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 상호작용하는 **클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n\n최소 지식 원칙을 따르는 4개의 가이드라인은 다음과 같습니다.\n\n1. 객체 자체\n2. 메소드에 매개변수로 전달된 객매\n3. 메소드를 생성하거나 인스턴스를 만든 객체\n4. 객체에 속하는 구성 요소\n\n만이 객체와 상호작용을 하도록 한다.\n\n---\n\n## 결론\n\n**파사드 패턴**은 복잡한 서브시스템을 **간단한 인터페이스**로 제공합니다. 이를 통해 **복잡성**을 감소시키고 **유지보수성**을 높일 수 있습니다.\n\n**홈 시어터**의 예시를 통해 설명하면 이는 사용자가 버튼 하나를 **딸깍**하는 것만으로 영화를 볼 수 있게 되는 것과 같습니다. 파사드 패턴이 없었다면 사용자는 각각의 기기들을 하나하나 동작 순서부터 시작해서, 동작시키는 방법과 같은 수많은 복잡한 과정을 알아야 했을 것입니다.\n\n이런 것을 통해 파사드 패턴이 가지고 있는 **두 가지 역할**을 알 수 있습니다. 하나는 클라이언트와 구성요소로 이루어진 **서브시스템을 분리**하는 것이고, 나머지 하나는 **여러 클래스를 하나의 인터페이스로 감싸서 사용**할 수 있게 하는 것입니다.\n\n**최소 지식 원칙**을 따르는 것은 **객체 사이의 상호작용을 최소화**한다는 원칙입니다. 이는 시스템을 디자인 할 때 **상호작용하는 클래스의 수**와 **상호작용 방식**에 주의를 기울여야 한다는 뜻입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"파사드 패턴","subtitle":"이겨야 한다 '딸깍'","date":"2024-02-19T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-21-Template Method Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-21-Template Method Pattern.md","category":"디자인패턴","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 템플릿 메소드 패턴을 사용한 해결책\n5. 후크 메소드\n6. 할리우드 원칙\n7. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 일부 단계를 서브클래스로 미루는 패턴입니다. 이는 **알고리즘의 구조**를 변경하지 않고 알고리즘의 **특정 단계**를 서브클래스에서 **재정의**할 수 있게 합니다.\n\n이 과정을 통해 템플릿 메소드 패턴은 알고리즘의 **템플릿(틀)**을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\nhead first design patterns는 이에 대한 예시로 **카페인 음료 만들기**를 가져옵니다. 카페인 음료에는 커피와 홍차가 있을 수 있고, 둘은 많은 부분에서 같은 과정을 거치지만 '찻잎'과 '커피 콩'을 넣는 부분이나, '설탕과 우유'와 '레몬'을 추가하는 과정이 다릅니다.\n\n템플릿 메소드 패턴을 통해서 메소드에서 **공유**하는 부분은 상위 클래스에서 구현해 두고, **차이**가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 **후크 메소드**란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n**할리우드 원칙**은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, **의존성이 부패**하(복잡하기 꼬이)지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n\n---\n\n## 요약\n\n1. **템플릿 메소드 패턴**은 **알고리즘의 골격**을 정의하고, 알고리즘의 **일부 단계**를 서브클래스로 미루는 패턴입니다.\n2. **템플릿**을 통해 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다.\n3. **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n4. 물 끓이기 - 고정 알고리즘, 찻잎/커피 콩 넣기 - 서브클래스에서 재정의할 수 있는 부분\n5. **후크 메소드**는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n6. **할리우드 원칙**은 **의존성이 부패**하지 않도록 하는 원칙입니다.\n\n---\n\n## 문제상황\n\n기존에 커피만 판매하던 카페에서 최신 유행에 맞추어 홍차를 판매하기로 결정했습니다. 처음에는 둘의 제조법이 다르기 때문에 별개의 방식으로 관리하고 있었지만, 일을 진행하는 과정에서 과정에서 중복되는 부분이 많은데 이를 따로 관리하는 것이 비효율적이라는 생각을 하게 됐습니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    abstract void prepareRecipe(); \n    abstract void boilWater(); \n    abstract void pourInCup();\n}\n\npublic class Coffee extends CaffeineBeverage {\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        brewCoffeeGrinds();\n        pourInCup();\n        addSugarAndMilk();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void brewCoffeeGrinds() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addSugarAndMilk() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage{\n    @Override\n    void prepareRecipe() {\n        boilWater();\n        steepTeaBag();\n        pourInCup();\n        addLemon();\n    }\n\n    @Override\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void steepTeaBag() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    @Override\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n\n    void addLemon() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n---\n\n## 템플릿 메소드 패턴을 사용한 해결책\n\n현재 카페에서 커피와 홍차를 준비하는 과정에서 물 끓이기와 컵에 따르기가 중복되는 것을 볼 수 있습니다. 또 찻잎을 우리는 것과, 레몬을 추가하는 것은 커피를 우리는 것과 우유를 첨가하는 것과 비슷한 행위입니다.\n\n이런 중복성을 해소하기 위해 템플릿 메소드 패턴을 사용할 수 있습니다. 바로 prepareRecipe() 메소드를 추상화하는 것을 통해 말입니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        boilWater();\n        brew();\n        pourInCup();\n        addCondiments();\n    }\n\n    abstract void brew();\n    abstract void addCondiments();\n\n    void boilWater() {\n        System.out.println(\"물 끓이기\");\n    }\n\n    void pourInCup() {\n        System.out.println(\"컵에 따르기\");\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"커피를 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"설탕과 우유 추가하기\");\n    }\n}\n\npublic class Tea extends CaffeineBeverage {\n    void brew() {\n        System.out.println(\"찻잎을 우려내기\");\n    }\n\n    void addCondiments() {\n        System.out.println(\"레몬 추가하기\");\n    }\n}\n```\n\n기존의 prepareRecipe는 abstract로 선언돼 모든 서브클래스에서 별개로 구현해야했지만, 현재 prepareRecipe는 final로 선언돼 있어 서브클래스에서 오버라이드할 수 없습니다. 이를 통해 prepareRecipe는 고정된 알고리즘을 가지고 있습니다. 하지만 여기에 brew()와 addCondiments()는 추상 메소드로 선언돼 있어 서브클래스에서 구현해서 각자의 알고리즘을 만들 수 있습니다.\n\n이렇게 **템플릿**이라는 **골격** 내에서 **동일한 부분**을 **상위 클래스**에서 구현하고, 일부 **차이**가 나는 부분을 **서브 클래스**에서 구현하는 것을 우리는 **템플릿 메소드**라고 합니다.\n\n---\n\n## 후크 메소드\n\n위에서처럼 모든 서브 클래스마다 다르게 동작을 해야하는 경우도 있지만, 때로는 **아무 동작도 하지 않아야** 되는 경우도 있습니다. 이럴 때 사용하는 것이 바로 **후크 메소드**입니다.\n\n후크 메소드는 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n예를 들어, 커피나 홍차를 끓이는 것과 달리 우유, 설탕, 레몬을 추가하는 것은 선택사항입니다. 이럴 때 후크 메소드를 사용할 수 있습니다.\n\n```java\npublic abstract class CaffeineBeverage {\n    final void prepareRecipe() {\n        ...\n        if (customerWantsCondiments()) {\n            addCondiments();\n        }\n    }\n\n    ...\n    // 후크 메소드\n    boolean customerWantsCondiments() {\n        return true;\n    }\n}\n\npublic class Coffee extends CaffeineBeverage {\n    ...\n    // 후크 메소드 오버라이드\n    @Override\n    boolean customerWantsCondiments() {\n        String answer = getUserInput();\n        if (answer.toLowerCase().startsWith(\"y\")) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n기존에 상위 클래스에서 hooker 메소드인 customerWantsCondiments는 아무것도 하지 않습니다. 그리고 서브 클래스인 커피에서는 유저의 입력에 따라서 첨가물인 설탕과 우유를 추가할지 말지를 결정합니다.\n\n---\n\n## 할리우드 원칙\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정하는 것을 말합니다.\n\n템플릿 메소드 패턴은 이 원칙을 따르는 대표적인 패턴입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않습니다.\n\n예를 들어, 스타버즈에서 음료수를 제조하기 시작하면 커피나 홍차를 만들기 위해 물을 끓이고, 컵에 따르는 것은 상위 클래스에서 결정하고, 그 외의 것인 커피를 우려내거나 찻잎을 우려낼 때에만 서브 클래스를 불러냅니다.\n\n이런 것이 할리우드 원칙입니다. 상위 클래스에서 하위 클래스를 호출하면서, 하위 클래스에서는 상위 클래스를 호출하지 않는 것입니다. 이는 일종의 의존성 역전이라고도 할 수 있습니다.\n\n---\n\n## 결론\n\n템플릿 메소드 패턴은 알고리즘의 템플릿(틀)을 만듭니다. 템플릿이 있기 때문에 서브 클래스는 자기에 맞게 템플릿을 채워넣어 자신만의 알고리즘을 만들 수 있습니다. 이는 코드의 **재사용성**을 높이고 **유지보수성**을 높일 수 있습니다.\n\n템플릿 메소드 패턴을 통해 메소드에서 공유하는 부분은 상위 클래스에서 구현해 두고, 차이가 나는 부분은 하위에서 구현하도록 할 수 있습니다.\n\n이 때 후크 메소드란 것을 통해 기본적으로는 아무것도 하지 않는 메소드를 만들어 두고, 서브클래스에서 필요에 따라 오버라이드할 수 있게 합니다.\n\n할리우드 원칙은 \"먼저 연락하지 마세요. 저희가 연락드리겠습니다.\"라는 뜻으로, 의존성이 부패하지 않도록 하는 원칙입니다. 이를 통해 저수준 구성요소가 시스템에 접속할 수는 있지만, 언제 어떻게 그 구성 요소를 사용할지는 고수준 구성 요소가 결정합니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"템플릿 메소드 패턴","subtitle":"커피에 홍차를 섞어드셔보세요","date":"2024-02-21T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-23-Iterator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-23-Iterator Pattern.md","category":"디자인패턴","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 반복자 패턴을 사용한 해결책\n5. 단일 역할 원칙\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**반복자 패턴**은 **컬렉션**의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소**에 **접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 접근을 하는 기능을 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\nhead first design patterns는 여러 가지 **음식점 통합**을 해야하는 상황을 이야기합니다. 음식점의 종류에는 팬케이크 하우스, 디너 하우스, 카페가 있고 이들은 각각의 메뉴를 ArrayList, Array, HashMap과 같이 **다른 형태로 관리**하고 있습니다. 이런 상황에서 한 명의 웨이트리스에게 메뉴들을 읽는 다른 방법들을 다 숙지시키고 일을 맡기는 것은 비효율적이고 위험합니다.\n\n이때 반복자 객체를 통한 접근을 사용해서 문제를 해결할 수 있습니다. 웨이트리스는 개별의 객체들을 순회하는 방법들에 대해 인지할 필요 없이 이를 **캡슐화**한 **반복자 객체**를 사용해서 각각의 객체들을 순회할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다**.\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n\n---\n\n## 요약\n\n1. **반복자 패턴**은 컬렉션의 내부 구조를 노출하지 않고 컬렉션의 **모든 요소에 접근**할 수 있게 하는 패턴입니다.\n2. 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 컬렉션에서 **분리**해 반복자 객체가 책임지게 할 수 있습니다.\n3. 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n4. **단일 역할 원칙**은 \"클래스는 하나의 변경 이유만을 가져야 한다.\"라는 원칙입니다.\n\n---\n\n## 문제상황\n\n마을의 디너 하우스에서 사업 확장의 일환으로 팬케이크 하우스와 **합병**을 하기로 결정했습니다. 이 합병은, 식사는 훌륭하지만 디저트가 아쉬웠던 약점 보완을 통해 시너지 작용을 해서 더 많은 손님을 유치할 수 있으리라 기대했습니다.\n\n그런데 여기에서 일 할 웨이트리스들 간에서 불만의 목소리가 나왔습니다. \"나는 **반대쪽 식당의 메뉴판**을 읽을 수가 없는데요?\"\n\n확인해보니, 팬케이크 하우스는 **ArrayList**, 디너 하우스는 **Array**로 메뉴를 관리하고 있었습니다. 이런 상황에서 두 식당을 통합하려면 손님은 자기가 주문하려는 메뉴를 알고 있는 웨이트리스가 누구인지를 알아내든지, 웨이트리스가 두 식당의 메뉴판을 다 숙지하고 있어야 하는 문제가 발생할 것으로 예상됩니다.\n\n이런 상황을 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class MenuItem {\n    String name;\n    String description;\n    boolean isVegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean isVegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.isVegetarian = isVegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    ...\n}\n\npublic class PancakeHouseMenu {\n    ArrayList<MenuItem> menuItems;\n\n    public PancakeHouseMenu() {\n        menuItems = new ArrayList<MenuItem>();\n\n        addItem(\"K&B 팬케이크 세트\", \"스크램블드 에그와 토스트가 곁들여진 팬케이크\", true, 2.99);\n        addItem(\"레귤러 팬케이크 세트\", \"달걀 후라이와 소시지가 곁들여진 팬케이크\", false, 2.99);\n        addItem(\"블루베리 팬케이크\", \"신선한 블루베리와 시럽으로 만든 팬케이크\", true, 3.49);\n        addItem(\"와플\", \"와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.\", true, 3.59);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        menuItems.add(menuItem);\n    }\n\n    public ArrayList<MenuItem> getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class DinerMenu {\n    static final int MAX_ITEMS = 6;\n    int numberOfItems = 0;\n    MenuItem[] menuItems;\n\n    public DinerMenu() {\n        menuItems = new MenuItem[MAX_ITEMS];\n\n        addItem(\"채식주의자용 BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", true, 2.99);\n        addItem(\"BLT\", \"통밀 위에 상추, 토마토, 베이컨을 얹은 메뉴\", false, 2.99);\n        addItem(\"오늘의 스프\", \"감자 샐러드를 곁들인 오늘의 스프\", false, 3.29);\n        addItem(\"핫도그\", \"사워크라우트, 갖은 양념, 양파, 치즈가 곁들여진 핫도그\", false, 3.05);\n    }\n\n    public void addItem(String name, String description, boolean isVegetarian, double price) {\n        MenuItem menuItem = new MenuItem(name, description, isVegetarian, price);\n        if (numberOfItems >= MAX_ITEMS) {\n            System.err.println(\"죄송합니다, 메뉴가 꽉 찼습니다. 더 이상 추가할 수 없습니다.\");\n        } else {\n            menuItems[numberOfItems] = menuItem;\n            numberOfItems = numberOfItems + 1;\n        }\n    }\n\n    public MenuItem[] getMenuItems() {\n        return menuItems;\n    }\n\n    ...\n}\n\npublic class Waitress {\n    PancakeHouseMenu pancakeHouseMenu;\n    DinerMenu dinerMenu;\n\n    public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {\n        this.pancakeHouseMenu = pancakeHouseMenu;\n        this.dinerMenu = dinerMenu;\n    }\n\n    public void printMenu() {\n        ArrayList<MenuItem> breakfastItems = pancakeHouseMenu.getMenuItems();\n        MenuItem[] lunchItems = dinerMenu.getMenuItems();\n\n        System.out.println(\"아침 메뉴\");\n        for (int i = 0; i < breakfastItems.size(); i++) {\n            MenuItem menuItem = breakfastItems.get(i);\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n\n        System.out.println(\"점심 메뉴\");\n        for (int i = 0; i < lunchItems.length; i++) {\n            MenuItem menuItem = lunchItems[i];\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n위와 같은 상황을 개선하지 않으면 앞으로 더 많은 음식점을 통합하려는 목표를 가진 주인 입장에서는 심각한 걸림돌이 될 수 있습니다. 새로운 종업원을 교육하는 것도 힘들고, 주문의 절차도 복잡해지기 때문입니다.\n\n여태까지 디자인 패턴을 적용하면서 이런 문제를 해결해왔듯이, **반복**이 되면서 **변하는 부분**을 찾아내고, 이를 **캡슐화**해서 **재사용**할 수 있게 만들어야 합니다.\n\n\n---\n\n## 반복자 패턴을 사용한 해결책\n\n**반복자 패턴**을 사용하면 위와 같은 문제를 해결할 수 있습니다. 반복자 패턴은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션**의 **모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 **반복 작업**을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n비유를 통해 설명하자면 웨이트리스에게 메뉴들을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 **쪽지**를 주는 것과 같습니다. 이 쪽지는 각각의 식당에 대한 메뉴판을 순회하는 방법을 캡슐화한 반복자 객체입니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface Iterator {\n    boolean hasNext();\n    Object next();\n}\n\npublic interface Menu {\n    Iterator createIterator();\n}\n\npublic class PancakeMenuIterator implements Iterator {\n    ArrayList<MenuItem> items;\n    int position = 0;\n\n    public PancakeMenuIterator(ArrayList<MenuItem> items) {\n        this.items = items;\n    }\n\n    public Object next() {\n        MenuItem menuItem = items.get(position);\n        position = position + 1;\n        return menuItem;\n    }\n\n    public boolean hasNext() {\n        return position < items.size();\n    }\n}\n\npublic class PancakeHouseMenu implements Menu {\n    ...\n\n    public Iterator createIterator() {\n        return new PancakeHouseMenuIterator(menuItems);\n    }\n}\n\npublic class Waitress {\n    ...\n\n    public void printMenu() {\n        Iterator pancakeIterator = pancakeHouseMenu.createIterator();\n        Iterator dinerIterator = dinerMenu.createIterator();\n\n        System.out.println(\"아침 메뉴\");\n        printMenu(pancakeIterator);\n        System.out.println(\"점심 메뉴\");\n        printMenu(dinerIterator);\n    }\n\n    private void printMenu(Iterator iterator) {\n        while (iterator.hasNext()) {\n            MenuItem menuItem = (MenuItem) iterator.next();\n            System.out.println(menuItem.getName() + \", \");\n            System.out.println(menuItem.getPrice() + \" -- \");\n            System.out.println(menuItem.getDescription());\n        }\n    }\n}\n```\n\n이제 더 많은 식당들을 추가하더라도 각각의 웨이트리스들에게 새로운 메뉴판을 읽는 방법을 숙지시키는 대신, 이를 정리해 둔 쪽지를 읽는 방법을 숙지시키는 것만으로도 교육과정을 줄일 수 있습니다.\n\n---\n\n## 단일 역할 원칙\n\n**단일 역할 원칙**(Single Responsibility Principle)은 **\"클래스는 하나의 변경 이유만을 가져야 한다.\"**라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 **바뀌는 부분**의 **역할**이 **하나**이도록 하자는 원칙입니다.\n\n반복자 패턴을 사용하면 이 원칙을 지킬 수 있습니다. 웨이트리스는 메뉴판을 읽는 방법을 숙지시키는 역할만을 가지고 있고, 반복자 객체는 메뉴판을 순회하는 역할만을 가지고 있습니다. 이렇게 각각의 객체들은 하나의 역할만을 가지고 있기 때문에 단일 역할 원칙을 지킬 수 있습니다.\n\n---\n\n## 결론\n\n**반복자 패턴**은 컬렉션의 **내부 구조**를 노출하지 않고 **컬렉션의 모든 요소에 접근**할 수 있게 하는 패턴입니다. 이는 항목 내에서 반복 작업을 **반복자**로 **캡슐화**해서, 클라이언트가 컬렉션의 내부 구조에 대해 알 필요 없이 컬렉션의 항목을 **순회**할 수 있게 합니다.\n\n이는 마치 여러 가지 **다른 형태의 메뉴판**을 가지고 있는 **음식점의 메뉴**를 통합할 때, 근무할 웨이트리스에게 각각의 메뉴를 숙지하게 하는 것이 아니라 이를 **통합한 쪽지**를 주는 것과 같습니다. 이를 통해 웨이트리스는 각각의 메뉴를 숙지할 필요 없이 쪽지를 통해 메뉴를 **순회**할 수 있게 됩니다.\n\n반복자 패턴을 통해 각각의 항목에 대한 **접근**을 하는 기능을 **캡슐화**를 통해 **컬렉션에서 분리**해 반복자 객체가 책임지게 할 수 있습니다. 결과적으로 집합체 인터페이스와 구현이 간단해지고 각자에게 중요한 일만을 처리할 수 있게 됩니다.\n\n**단일 역할 원칙**(Single Responsibility Principle)은 \"**클래스는 하나의 변경 이유만을 가져야 한다.**\"라는 원칙입니다. 클래스가 여러 가지 이유로 변경될 수록 그 클래스는 여러 가지 이유로 변경될 수 있기 때문에 유지보수가 어려워집니다. 이 때문에 클래스가 바뀌는 부분의 역할이 하나이도록 하자는 원칙입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"반복자 패턴","subtitle":"저녁밥도 팬케이크도 다 단비꺼야","date":"2024-02-23T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-Composite Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-Composite Pattern.md","category":"디자인패턴","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 컴포지트 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**컴포지트 패턴**은 객체들이 복합적으로 구성된 **집합 객체**와 **단일 객체**가 있을 때, 이를 **동일하게 접근**할 수 있는 인터페이스로 구현한 뒤 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\nhead first design patterns에서는 기존의 팬케이크 식당과 디너 식당을 합병하는 상황에서 더 나아간 문제를 제시합니다. 여기에 디저트 식당을 추가로 합병한 뒤에, 이들의 메뉴를 각각 다른 시간대에 독립된 형태로 제공하는 것이 아니라 **복합적인 형태**로 제공하려면 어떻게 해야 할까요?\n\n예를 들어, 프랜차이즈의 오너가 시너지를 위해 디저트 식당을 합병한 경우를 가정해보겠습니다. 회사에서 목표로하는 것은 이 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, **기존 메뉴와 함께** 제공하는 것입니다. 디너 식당의 메뉴에 디저트 메뉴 코너를 추가하듯이 말입니다.\n\n**컴포지트 패턴**은 이런 문제에 대한 해결을 제시합니다. 기존에 반복자 패턴은 여러 다른 형태의 객체들을 단일의 반복자라는 인터페이스를 통해 순회할 수 있게 만들어 줬던 것과는 다르게, 컴포지트 패턴을 사용하려면 복합 객체와 단일 객체가 **동일한 인터페이스**를 가지고 있어야 합니다.\n\n새로운 인터페이스를 통해 컴포지트 패턴을 사용하면, 클라이언트는 개별 객체와 복합 객체를 구분하지 않고 동일하게 다룰 수 있으면서 동시에 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 요약\n\n1. **컴포지트 패턴**은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다.\n2. 클라이언트가 **개별 객체**와 **복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있게 합니다.\n3. 컴포지트 패턴을 사용하면 **복합 객체**와 **단일 객체**가 동일한 인터페이스를 가지고 있어야 합니다.\n4. 컴포지트 패턴을 통해 더 **유연**하게 객체들을 **조합**할 수 있게 됩니다.\n\n---\n\n## 문제상황\n\n성공적으로 팬케이스 하우스, 디너 하우스를 합병한 프랜차이즈의 오너는 이제 **수평적 확장**에 그치지 않고 **수직적인 확장**에 관심을 가지게 되었습니다. 그리고 그 수단은 바로 디저트 식당을 합병하는 것입니다.\n\n팬케이크 하우스와 디너 하우스의 합병은 서로가 운영하지 않는 시간대를 이용해 시너지를 내는 것이 목적이었습니다. 그러나 케이크 식당은 이와는 다르게, 기존의 메뉴와 함께 제공되어야 합니다. 이를 통해 동일 시간대에 더 많은 수익을 창출하는 것이 이번 합병의 목표입니다.\n\n위 상황을 코드로 나타내면 다음과 같습니다. 여기에 생략된 기존의 팬케이크, 디너 식당의 메뉴를 관리하는 클래스들을 반복자를 통해 작성한 코드는 [반복자 패턴 - 저녁밥도 팬케이크도 다 단비꺼야](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/02/23/Iterator-Pattern.html)를 참고해 주세요.\n\n```java\npublic class DessertMenu {\n    ArrayList<MenuItem> menuItems;\n\n    public DessertMenu() {\n        menuItems = new ArrayList<>();\n\n        addItem(\"케이크\", \"초콜릿 케이크\", true, 3.00);\n        addItem(\"케이크\", \"바닐라 케이크\", true, 3.00);\n        addItem(\"케이크\", \"딸기 케이크\", true, 3.00);\n    }\n\n    // 기타 디저트 메뉴를 구성하는 메서드들\n    ...\n}\n```\n\n문제는 위와 같은 메뉴를 관리하는 클래스를 기존의 팬케이크, 디너 식당의 메뉴에 추가하는 것이 복잡하단 것입니다.\n\n해결책 중 하나로는 디저트 메뉴의 항목을 각각 추가할 수도 있습니다. 하지만 만약에 디저트 식당에 새로운 메뉴가 추가하거나 삭제되면 이를 통합한 모든 메뉴들에 해당 작업을 실행해야 합니다. 또 만약 디저트 식당을 매각하게 돼서 메뉴를 삭제해야 한다면 이 또한 골치아픈 일이 될 것입니다.\n\n결국, 이처럼 각각이 다른 형태로 관리되는 메뉴들을 유연하게 통합하는데에는 한계가 있습니다.\n\n---\n\n## 컴포지트 패턴을 사용한 해결책\n\n우선 현재와 같이 각각의 메뉴를 관리하는 클래스들을 동일하게 **메뉴 항목**으로 취급할 수 있는 **인터페이스**를 만들어야 합니다. 이 인터페이스는 메뉴 항목이 가지는 **공통적인 특성**을 정의해야 합니다.\n\n이를 위해 MenuComponent라는 추상 클래스를 만들고, 이 클래스를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n코드로 표현하면 다음과 같습니다.\n\n```java\npublic abstract class MenuComponent {\n    public void add(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        throw new UnsupportedOperationException();\n    }\n\n    public MenuComponent getChild(int i) {\n        throw new UnsupportedOperationException();\n    }\n\n    // 기타 메서드들\n}\n```\n\nMenuComponent는 단일 메뉴와, 메뉴판이 가지는 공통적인 특성과 그렇지 않은 것이 동시에 정의돼있습니다. 이 때문에 클라이언트는 개별 메뉴와 복합 메뉴를 구분하지 않고 동일하게 다룰 수 있게 됩니다.\n\n대신 개별 메뉴인 MenuItem의 경우에는 add, remove, getChild 메서드를 사용할 수 없게 만들어야 합니다. 이를 위해 UnsupportedOperationException을 던지는 것입니다.\n\n이제 이를 상속받아 단일 메뉴 항목을 관리하는 MenuItem과 복합 메뉴 항목을 관리하는 Menu라는 클래스를 만들겠습니다.\n\n```java\npublic class MenuItem extends MenuComponent {\n    String name;\n    String description;\n    boolean vegetarian;\n    double price;\n\n    public MenuItem(String name, String description, boolean vegetarian, double price) {\n        this.name = name;\n        this.description = description;\n        this.vegetarian = vegetarian;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public boolean isVegetarian() {\n        return vegetarian;\n    }\n\n    public void print() {\n        System.out.print(\"  \" + getName());\n        if (isVegetarian()) {\n            System.out.print(\"(v)\");\n        }\n        System.out.println(\", \" + getPrice());\n        System.out.println(\"     -- \" + getDescription());\n    }\n}\n```\n\n```java\npublic class Menu extends MenuComponent {\n    ArrayList<MenuComponent> menuComponents = new ArrayList<>();\n    String name;\n    String description;\n\n    public Menu(String name, String description) {\n        this.name = name;\n        this.description = description;\n    }\n\n    public void add(MenuComponent menuComponent) {\n        menuComponents.add(menuComponent);\n    }\n\n    public void remove(MenuComponent menuComponent) {\n        menuComponents.remove(menuComponent);\n    }\n\n    public MenuComponent getChild(int i) {\n        return menuComponents.get(i);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void print() {\n        System.out.print(\"\\n\" + getName());\n        System.out.println(\", \" + getDescription());\n        System.out.println(\"---------------------\");\n\n        Iterator<MenuComponent> iterator = menuComponents.iterator();\n        while (iterator.hasNext()) {\n            MenuComponent menuComponent = iterator.next();\n            menuComponent.print();\n        }\n    }\n}\n```\n\n이제 위의 **컴포지트 패턴**을 적용한 메뉴와 메뉴판을 웨이트리스에게 제공하면, 이를 복합적으로 **통합**해서 제공하는 시스템을 구축할 수 있게 됩니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class TestMenu {\n    public static void main(String[] args) {\n        MenuComponent pancakeHouseMenu = new Menu(\"팬케이크 하우스 메뉴\", \"아침 메뉴\");\n        MenuComponent dinerMenu = new Menu(\"디너 메뉴\", \"점심 메뉴\");\n        MenuComponent dessertMenu = new Menu(\"디저트 메뉴\", \"디저트 메뉴\");\n\n        MenuComponent waitress = new Menu(\"전체 메뉴\", \"전체 메뉴\");\n\n        waitress.add(pancakeHouseMenu);\n        waitress.add(dinerMenu);\n\n        dinerMenu.add(desertMenu);\n        pancakeHouseMenu.add(desertMenu);\n\n        waitress.print();\n    }\n}\n```\n\n---\n\n## 결론\n\n**복합 객체**와 **단일 객체**를 동일하게 다루어서 **유연**하게 객체들을 **조합**하는 문제를 해결해야하는 경우가 있습니다. 이런 경우에는 양 객체에 **동일한 인터페이스**를 적용하는 **컴포지트 패턴**을 사용할 수 있습니다.\n\n컴포지트 패턴은 객체들을 **트리 구조**로 구성하여 **부분-전체 계층**을 표현하는 패턴입니다. 이를 통해 클라이언트가 **개별 객체**와 복합 객체**를 구분하지 않고 **동일**하게 다룰 수 있습니다.\n\n이는 마치 프랜차이즈 오너가 사업을 **수평적 확장**에서 **수직적 확장**으로 바꾸는 것과 같습니다. 이를 통해 새로운 메뉴들을 별개의 시간에 제공하는 것이 아니라, 기존 메뉴와 함께 제공하는 것입니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"컴포지트 패턴","subtitle":"갈 때 가더라도 디저트 한 대 쯤은 괜찮잖아?","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-27-State Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-27-State Pattern.md","category":"디자인패턴","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 상태 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다. 이는 객체의 상태를 클래스로 표현해서 **추상화**하고, 상태 객체의 동작을 통해 조작하고자 하는 객체가 **자동으로 행동**을 **변경**할 수 있도록 합니다.\n\n상태 패턴을 사용하면 객체의 관점에서는 동일한 동작을 하지만, 내부적으로는 상태에 따라 다른 동작을 하도록 할 수 있습니다. 이는 마치 객체의 **클래스가 바뀌는 것**과 같은 효과를 가져옵니다.\n\nhead first design patterns는 **동전 투입기**를 예시로 들어 상태 패턴을 설명합니다. 동전 투입기는 **동전 없음**, **동전 있음**, **동전 투입됨**과 같은 여러 가지 **조건**에 따라 동작을 달리합니다. 이것들을 **내부 변수**의 값을 통해 **조건문**으로 처리하려 할 경우 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이런 상황에서 **상태 패턴**을 사용하면 각각의 **상태**를 클래스로 **캡슐화**해서 나중에 변경해야 하는 내용을 국지화할 수 있습니다. 이를 통해 상태에 따라 객체가 알아서 행동을 바꿀 수 있도록 할 수 있습니다. 이는 마치 매 순간 동전 투입기가 **새로운 물건**으로 변신하는 것과 같은 효과를 가져옵니다.\n\n상태 전환은 State 클래스로 제어할 수도 있고, Context 클래스로 제어할 수도 있습니다.\n\n---\n\n## 요약\n\n1. **상태 패턴**은 객체의 **상태**에 따라 객체의 **행동**을 **변경**할 수 있게 하는 패턴입니다.\n2. 객체의 상태를 **클래스로 표현**하고, **내부 상태**에 따라 객체의 행동을 **알아서** 바꿀 수 있게 합니다.\n3. 상태 전환은 **State 클래스**로 제어할 수도 있고, **Context 클래스**로 제어할 수도 있습니다.\n4. Gumball Machine - Context, State - 동전 없음, 동전 있음, 동전 투입됨\n\n---\n\n## 문제상황\n\n동전을 투입하고 손잡이를 돌리면 알맹이가 나오는 껌볼 기계를 만들어 달라는 요청이 들어왔습니다. 이를 구현하기 위해서는 매 입력이 들어온 순간마다 해당 기계가 동전이 있는지, 손잡이를 돌렸는지, 알맹이가 있는지 정보를 가지고 있어야 합니다.\n\n이 정보들을 기존의 변수로 처리하려고 하면 코드가 복잡해지고, 새로운 상태가 추가될 때마다 코드를 수정해야 합니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    final static int SOLD_OUT = 0;\n    final static int NO_QUARTER = 1;\n    final static int HAS_QUARTER = 2;\n    final static int SOLD = 3;\n\n    int state = SOLD_OUT;\n\n    public GumballMachine(int count) {\n        this.count = count;\n        if (count > 0) {\n            state = NO_QUARTER;\n        }\n    }\n\n    public void insertQuarter() {\n        if (state == HAS_QUARTER) {\n            System.out.println(\"동전은 한 개만 넣어주세요.\");\n        } else if (state == NO_QUARTER) {\n            state = HAS_QUARTER;\n            System.out.println(\"동전을 넣으셨습니다.\");\n        } else if (state == SOLD_OUT) {\n            System.out.println(\"매진되었습니다.\");\n        } else if (state == SOLD) {\n            System.out.println(\"잠깐만 기다려 주세요. 알맹이가 나가고 있습니다.\");\n        }\n    }\n\n    // ejectQuarter, turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이처럼 해당 객체가 동작할 때마다 사용할 메소드들은 모든 변수들에 대해 **분기문**을 처리해야하기 때문에 가독성이 떨어지고, **새로운 명령이나 변수**가 추가될 때마다 코드를 수정해야 하기 때문에 유지보수가 어렵습니다.\n\n만약 예를 들어 동전을 돌리는 순간에 10분의 1 확률로 두 개의 알맹이가 나오는 기능을 추가하고 싶다면 어떻게 해야할까요? 이를 위해서는 수많은 경우의 수를 고려해서 코드를 수정해야 합니다.\n\n---\n\n## 상태 패턴을 사용한 해결책\n\n문제를 반대로 생각해서 메소드가 실행될 때마다 모든 상태를 분기문을 통해 확인하는 것이 아니라, **객체의 상태**를 **변경**하고 해당 상태에 따라 객체의 **행동이 정해진다**면 어떨까요? 그것이 바로 **상태 패턴**입니다.\n\n상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현하도록 한 뒤, 이들을 **통합하는 인터페이스**를 제공하는 것을 통해 상태 패턴을 구현할 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic interface State {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    GumballMachine gumballMachine;\n\n    public NoQuarterState(GumballMachine gumballMachine) {\n        this.gumballMachine = gumballMachine;\n    }\n\n    public void insertQuarter() {\n        System.out.println(\"동전을 넣으셨습니다.\");\n        gumballMachine.setState(gumballMachine.getHasQuarterState());\n    }\n\n    public void ejectQuarter() {\n        System.out.println(\"동전을 넣어주세요.\");\n    }\n\n    // turnCrank, dispense 메소드도 비슷한 방식으로 구현됩니다.\n}\n\n// HasQuarterState, SoldState, SoldOutState 클래스도 비슷한 방식으로 구현됩니다.\n```\n\n이렇게 구현한 상태 패턴을 통해 GumballMachine 클래스를 새로 구현하면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    State soldOutState;\n    State noQuarterState;\n    State hasQuarterState;\n    State soldState;\n\n    State state = soldOutState;\n    int count = 0;\n\n    public GumballMachine(int count) {\n        soldOutState = new SoldOutState(this);\n        noQuarterState = new NoQuarterState(this);\n        hasQuarterState = new HasQuarterState(this);\n        soldState = new SoldState(this);\n\n        this.count = count;\n        if (count > 0) {\n            state = noQuarterState;\n        }\n    }\n\n    public void insertQuarter() {\n        state.insertQuarter();\n    }\n\n    public void ejectQuarter() {\n        state.ejectQuarter();\n    }\n\n    public void turnCrank() {\n        state.turnCrank();\n        state.dispense();\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void releaseBall() {\n        System.out.println(\"알맹이가 나가고 있습니다.\");\n        if (count != 0) {\n            count = count - 1;\n        }\n    }\n\n    // getCount, refill 메소드도 비슷한 방식으로 구현됩니다.\n}\n```\n\n이제 각각의 상태에 대해 별도의 **클래스**로 **캡슐화**했기 때문에, Gumball은 현재 상태에 따로 인지할 필요 없이 인터페이스를 이용만 하면 됩니다. 이에 따른 **동작**은 각각의 **상태 클래스에서 정의**되어 있기 때문입니다.\n\n이는 추가적으로 상태를 추가하거나, 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 유지보수가 용이합니다.\n\n---\n\n## 결론\n\n**상태 패턴**은 객체의 **상태에 따라 객체의 행동을 변경**할 수 있게 하는 패턴입니다. 이는 객체의 **상태를 클래스로 표현**하고, 상태에 따라 **객체의 행동이 자동으로 결정**되도록 합니다. 이는 마치 객체의 클래스가 바뀌는 것과 같은 효과를 가져옵니다.\n\n상태 패턴을 통해 객체의 상태를 context가 아닌 **상태 클래스에서 관리**함으로써, context는 상태에 대해 알 필요 없이 **인터페이스를 통해 행동을 결정**할 수 있게 됩니다. 이는 유지보수가 용이하고, 새로운 상태를 추가하거나 상태의 행동을 변경할 때에도 해당 상태 클래스만 수정하면 되기 때문에 **유연한 코드**를 작성할 수 있게 됩니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"상태 패턴","subtitle":"이 기계는 당첨일수도, 아닐수도 있습니다.","date":"2024-02-27T00:00:00.000Z","categories":"디자인패턴"}},{"postName":"2024-02-28-Proxy Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-28-Proxy Pattern.md","category":"디자인패턴","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 프록시 패턴을 사용한 해결책\n5. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**프록시 패턴**은 특정 객체로의 **접근을 제어하는 대리인**을 제공하는 패턴입니다. 이는 객체의 접근을 제어함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, 객체 생성 비용을 줄이기 위해 **객체를 생성하는 시점을 미루는** 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 **원격에서 제어**하는 **Gumball Machine**을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 **GumballMonitor**라는 **프록시**를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n자바에서는 프록시 패턴을 지원하기 위한 유용한 라이브러리를 다양하게 제공합니다.\n\n---\n\n## 요약\n\n1. **프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다.\n2. 프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다.\n3. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 **착각**합니다.\n4. 프록시 패턴은 **보안**이 중요한 객체에 대한 접근을 제어하는데 사용할 수 있습니다.\n5. **원격 객체**에 대한 접근을 제어하는데 사용할 수 있습니다.\n6. 객체 **생성 비용**을 줄이기 위해 객체를 **생성하는 시점을 미루는 목적**으로 사용할 수 있습니다.\n7. Gumball Machine - 실제 객체, GumballMonitor - 프록시\n\n---\n\n## 문제상황\n\n기존 Gumball Machine을 요청한 회사에서 **원격**으로 기계별 **상태를 파악**하고 싶다는 요청을 보냈습니다. 이를 구현하기 위해서 기존의 Gumball Machine에 대한 접근을 제어하는 GumballMonitor 클래스를 만들 수 있습니다.\n\n이를 코드로 나타내면 다음과 같습니다.\n\n```java\npublic class GumballMachine {\n    int count;\n    String location;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n}\n\npublic class GumballMonitor {\n    GumballMachine machine;\n\n    public GumballMonitor(GumballMachine machine) {\n        this.machine = machine;\n    }\n\n    public void report() {\n        System.out.println(\"Gumball Machine: \" + machine.getLocation());\n        System.out.println(\"Gumball Inventory: \" + machine.getCount());\n    }\n}\n```\n\n그런데 이처럼 코드를 만들기 전에 요구 사항을 확실히 파악하는 것은 불가능에 가깝습니다. 이런 상황에서 모니터링을 기존의 코드를 수정하지 않고 추가하려면 어떻게 해야 할까요?\n\n---\n\n## 프록시 패턴을 사용한 해결책\n\n프록시 패턴을 사용하면 기존의 코드를 수정하지 않고도 모니터링을 추가할 수 있습니다. 프록시 패턴은 GumballMonitor 클래스는 그대로 두고, 원격에서 제어하는 Gumball Machine에 대한 **접근을 제어하는 프록시**를 만들어서 Gumball Machine을 제어할 수 있게 합니다.\n\n프록시는 진짜 객체를 **대신**하는 역할을 합니다. 이는 클라이언트가 진짜 객체에 직접 접근하는 것이 아니라, 프록시를 통해 접근하도록 합니다. 클라이언트는 프록시를 통해 진짜 객체에 접근하지만, 클라이언트는 이를 모르고 프록시를 진짜 객체로 착각합니다.\n\n클라이언트 객체는 원격 객체의 메소드 호출을 하는 것으로 착각하지만, 실제로는 프록시 객체의 메소드 호출을 하는 것입니다. 네트워크 통신과 같은 복잡한 작업은 프록시 객체가 처리해 줍니다.\n\n이런 프록시 보조 객체는 클라이언트 뿐 아니라 서버 쪽에서도 사용할 수 있습니다. 두 객체는 각자의 위치에서 받은 요청을 처리하고, 서로 통신을 하면서 진짜 서비스에서 클라이언트의 요청을 처리해줍니다.\n\n이를 java.rmi 패키지를 사용해서 구현하면 다음과 같습니다.\n\n```java\nimport java.rmi.*;\n\npublic interface GumballMachineRemote extends Remote {\n    public int getCount() throws RemoteException;\n    public String getLocation() throws RemoteException;\n    public State getState() throws RemoteException;\n}\n```\n\n```java\nimport java.io.*;\n\npublic interface State extends Serializable {\n    public void insertQuarter();\n    public void ejectQuarter();\n    public void turnCrank();\n    public void dispense();\n}\n\npublic class NoQuarterState implements State {\n    public static final long serialVersionUID = 2L;\n    transient GumballMachine gumballMachine;\n    // 기타 메소드\n}\n```\n\n```java\nimport java.rmi.*;\n\npublic class GumballMachine implements GumballMachineRemote {\n    int count;\n    String location;\n    State state;\n\n    public GumballMachine(String location, int count) {\n        this.location = location;\n        this.count = count;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public String getLocation() {\n        return location;\n    }\n\n    public State getState() {\n        return state;\n    }\n}\n```\n이외에 rmi 레지스트리에 등록하는 등의 작업은 생략하겠습니다.\n\n---\n\n## 결론\n\n**프록시 패턴**은 특정 객체로의 접근을 제어하는 **대리인**을 제공하는 패턴입니다. 이는 객체의 **접근을 제어**함으로써 **보안**이 중요한 객체에 대한 접근을 제어하거나, **원격 객체**에 대한 접근을 제어하거나, **객체 생성 비용**을 줄이기 위해 객체를 생성하는 시점을 미루는 등의 목적으로 사용할 수 있습니다.\n\n프록시 패턴은 **대리자**와 **실제 객체**를 나누어서 사용합니다. 이는 클라이언트가 실제 객체에 직접 접근하는 것이 아니라, 대리자를 통해 접근하도록 합니다. 클라이언트는 대리자를 통해 실제 객체에 접근하지만, 클라이언트는 이를 모르고 대리자를 실제 객체로 착각합니다.\n\nhead first design patterns는 원격에서 제어하는 Gumball Machine을 예시로 들어 프록시 패턴을 설명합니다. 원격에서 제어하는 Gumball Machine은 GumballMonitor라는 프록시를 통해 접근합니다. 이를 통해 뽑기 회사는 원격에서 기계별 상태를 확인할 수 있습니다.\n\n다만 프록시 패턴은 원격에서 제어하는 것 외에도 다양한 객체의 **접근 방식을 제한**하는데 사용할 수 있습니다. 이 부분을 각자의 요구와 개발 환경에 맞게 사용하는 것이 중요하다 할 수 있을 것입니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"프록시 패턴","subtitle":"당신이 나의 대리인인가","date":"2024-02-28T00:00:00.000Z","categories":"디자인패턴"}}],"category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"]},"__N_SSG":true}