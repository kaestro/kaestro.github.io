{"pageProps":{"postDataJson":{"postName":"2024-02-14-Decorator Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-14-Decorator Pattern.md","category":"디자인패턴","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 데코레이터 패턴을 통한 해결\n5. OCP(Open-Closed Principle)\n6. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n데코레이터 패턴은 **객체의 행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다. 이를 통해 상속을 통한 확장의 문제점을 해결할 수 있습니다.\n\nhead first design은 이에 대한 예시로 커피의 구현 기획이 변화하는 과정을 제시해서 설명합니다. 커피숍에서 판매하는 커피의 **종류**와 **첨가물**을 추가하는 것이 요구될 수 있습니다. 이런 다양한 요구사항을 상속을 통해 구현하는 것은 모든 서브 클래스를 만들어야 하는 등의 이유 때문에 불편하고, 비효율적입니다. 이런 불편을 해소하기 위한 방법 중 하나가 **데코레이터 패턴**입니다.\n\n---\n\n## 요약\n\n* 데코레이터 패턴은 객체의 **행동**을 **동적**으로 **확장**할 수 있게 해주는 디자인 패턴입니다.\n* 음료에 들어가는 **첨가물**들을 **데코레이터**로 구현합니다.\n* **서브 클래스**를 만드는 대신, **데코레이터**를 사용하면 런타임에 행동을 확장할 수 있습니다.\n\n---\n\n## 문제상황\n\n커피 샵 시스템을 만들고 있다고 가정해겠습니다. 기존에 커피 숍의 주문 시스템에서 사용하던 음료 클래스는 다음과 같습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic class Espresso extends Beverage {\n    public Espresso() {\n        description = \"에스프레소\";\n    }\n\n    public double cost() {\n        return 1.99;\n    }\n}\n\npublic class HouseBlend extends Beverage {\n    public HouseBlend() {\n        description = \"하우스 블렌드 커피\";\n    }\n\n    public double cost() {\n        return .89;\n    }\n}\n\n...\n```\n\n이런 구현 방식은 새로운 **첨가물**을 **추가**하는 것이 어렵다는 문제가 있습니다. 첨가물이란 모카나 우유와 같이 음료에 추가해서 맛을 바꾸는 것들을 말합니다. 예를 들어 모카라는 첨가물을 제공하려면 어떻게 해야할까요? 우리는 다음과 같은 class를 추가해야할 것입니다.\n\n```java\npublic class EspressoWithMocha extends Beverage {\n    ...\n}\n```\n\n만약 음료의 종류가 10가지였다면 모카를 첨가하게 될 음료에 대해 최대 10가지의 서브 클래스를 만들어야 합니다. 이는 매우 비효율적입니다.\n\n그런데 여기에 더해 모카가 아닌 새로운 첨가물이 추가된다면 어떻게 해야할까요? 심지어 모카와 함께 들어갈 수 있는 우유와 같은 첨가물이라면요? 이런 경우에는 **조합의 수**가 무수히 많아질 수 있습니다.\n\n```java\n\npublic class EspressoWithMilk extends Beverage {\n    ...\n}\n\npublic class EspressoWithMochaAndMilk extends Beverage {\n    ...\n}\n\npublic class HouseBlendWithMochaAndMilk extends Beverage {\n    ...\n}\n\n...\n\n```\n\n이런 식으로 **서브 클래스**를 만드는 것은 매우 비효율적입니다. 이를 해결하기 위해 등장한 것이 바로 **데코레이터 패턴**입니다.\n\n---\n\n## 데코레이터 패턴을 통한 해결\n\n데코레이터 패턴은 커피에 다양한 첨가물을 추가할 수 있는 상황처럼, 객체에 **다양한 추가 요소**를 **동적으로 추가**할 필요가 있을 때 사용할 수 있는 패턴입니다.\n\n데코레이터 패턴은 일종의 **투명한 래퍼**를 만드는 것과 같습니다. 이 래퍼는 자신이 감싸고 있는 객체와 같은 인터페이스를 구현합니다.\n\n데코레이터 패턴을 통해 위의 커피 숍 문제를 다음과 같이 해결할 수 있습니다.\n\n```java\npublic abstract class Beverage {\n    String description = \"제목 없음\";\n\n    public String getDescription() {\n        return description;\n    }\n\n    public abstract double cost();\n}\n\npublic abstract class CondimentDecorator extends Beverage {\n    Beverage beverage;\n    public abstract String getDescription();\n}\n```\n\n위의 데코레이터 패턴이 존재하는 상태에서 다음과 같은 서브 클래스들이 구현돼있다 가정해보겠습니다.\n\n1. **Beverage**\n    * Espresso\n    * HouseBlend\n    * DarkRoast\n\n2. **CondimentDecorator**\n    * Mocha\n    * Soy\n    * Whip\n    * Milk\n\n이제 우리는 Espresso에 Mocha와 Milk를 추가하는 것을 다음과 같이 구현할 수 있습니다.\n\n```java\nBeverage beverage = new Espresso();\nbeverage = new Mocha(beverage);\nbeverage = new Milk(beverage);\n\nSystem.out.println(beverage.getDescription() + \" $\" + beverage.cost());\n```\n\n위의 방식은 기존에 서브 클래스를 만드는 방식과는 다르게 수많은 조합을 일일이 구현할 필요가 없습니다. 또한, 런타임에 행동을 확장할 수 있게 되었습니다.\n\n---\n\n## OCP(Open-Closed Principle)\n\n이처럼 우리는 데코레이터 패턴을 통해 음료에 다양한 첨가물을 추가하더라도 새로운 행동을 추가하는 서브 클래스를 만들 필요가 없어졌습니다. 또한, 다양한 객체들을 조합할 수 있게 되었습니다.\n\n이런 식으로 객체의 행동을 **확장할 수 있으면서, 변화에는 닫혀있는 특징**을 우리는 **OCP(Open-Closed Principle)**라고 합니다.\n\n---\n\n## 결론\n\n데코레이터 패턴은 **객체의 행동을 동적으로 확장**할 수 있게 해주는 디자인 패턴입니다. 기존처럼 상속을 통해 확장을 하려할 경우에는 변화하는 부분에 대한 **캡슐화**가 어렵고, 불필요한 서브 클래스의 생성이 발생할 수 있습니다.\n\n데코레이터 패턴은 기존의 **객체를 장식(decorate)**하는 방식으로 객체의 행동을 확장합니다. 이를 통해 객체의 행동을 동적으로 확장할 수 있으면서, **OCP**를 준수할 수 있게 됩니다.\n\n대신 데코레이터 패턴을 사용하기 위해 다양한 객체를 조합하는 것은 관리하기 어려울 수 있습니다. 이를 해결하기 위해 **팩토리 패턴**과 같은 디자인 패턴을 함께 사용할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"데코레이터 패턴","subtitle":"싸구려 커피를 마시기 전에 우유를 넣으세요","date":"2024-02-14T00:00:00.000Z","categories":"디자인패턴"}},"title":"데코레이터 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"전략 패턴","category":"디자인패턴"},"next":{"title":"옵저버 패턴","category":"디자인패턴"}}},"__N_SSG":true}