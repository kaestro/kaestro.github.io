{"pageProps":{"postDataJson":{"postName":"2024-02-15-Factory Pattern","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/디자인 패턴/2024-02-15-Factory Pattern.md","category":"디자인패턴","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","content":"\n## 목차\n\n1. 개요\n2. 요약\n3. 문제상황\n4. 간단한 팩토리 패턴을 통한 해결\n5. 팩토리 메소드 패턴을 통한 해결\n6. 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n7. 추상 팩토리 패턴을 통한 해결\n8. 결론\n\n---\n\n## 개요\n\n본 글은 **head first design patterns** 책을 읽고 정리한 글입니다.\n\n**팩토리 패턴**은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 기존에 객체를 생성하는 코드를 직접 사용하던 것과 달리, 이를 팩토리 클래스에 위임해서 객체를 생성하기 때문에 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n\nhead first design은 이에 대한 예시로 **피자 주문 시스템**을 만드는 과정을 제시해서 설명합니다. 피자 주문 시스템에서는 다양한 종류의 피자를 주문할 수 있습니다. 이런 다양한 종류의 피자를 만들 때 각각의 피자를 생성하는 코드를 직접 사용하는 것은 비효율적이고, 유연성이 떨어집니다. 이런 불편을 해소하기 위한 방법 중 하나가 **팩토리 패턴**입니다.\n\n---\n\n## 요약\n\n* 팩토리 패턴은 **객체의 생성을 캡슐화**하는 디자인 패턴입니다.\n* 객체를 생성하는 코드를 직접 사용하는 것이 아니라, 팩토리 클래스에 **위임**해서 객체를 생성합니다.\n* 이를 통해 구상 클래스와 클라이언트 코드를 분리하고 **느슨한 결합**을 유지해서 유연성을 높일 수 있습니다.\n* 팩토리 패턴은 객체 생성을 위임하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다.\n* 팩토리 - 피자/재료 공장, 제품 - 피자/재료\n\n---\n\n## 문제상황\n\n피자 주문 시스템을 만들고 있다고 가정해겠습니다. 기존에 피자 주문 시스템에서 사용하던 **피자 클래스**는 다음과 같습니다.\n\n```java\npublic abstract class Pizza {\n    String name;\n    String dough;\n    String sauce;\n    List<String> toppings = new ArrayList<>();\n\n    public String getName() {\n        return name;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        }\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    public void prepare() {\n        System.out.println(\"Preparing \" + name);\n    }\n\n    public void bake() {\n        System.out.println(\"Baking \" + name);\n    }\n\n    public void cut() {\n        System.out.println(\"Cutting \" + name);\n    }\n\n    public void box() {\n        System.out.println(\"Boxing \" + name);\n    }\n}\n...\n```\n\n위의 코드는 피자 주문 시스템에서 사용하는 피자 클래스입니다. 이 피자 클래스는 다양한 종류의 피자를 생성할 수 있습니다. 하지만 이런 식으로 **orderPizza 메소드**를 통해 **피자(인스턴스)**를 만드는 것은 **구상 클래스에 의존**하기 때문에 유연성이 떨어져서 문제가 있습니다.\n\n만약에 새로운 종류의 피자를 추가하고 싶다면 어떻게 해야 할까요? 또는 피자의 재료를 추가하거나, 기존의 피자를 수정하거나, 동일한 이름의 다양한 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n그럴 때마다 다음과 같은 방식으로 **orderPizza** 메소드를 수정해야 할 것입니다.\n\n```java\npublic Pizza orderPizza(String type) {\n    Pizza pizza = null;\n\n    if (type.equals(\"cheese\")) {\n        pizza = new CheesePizza();\n    } else if (type.equals(\"greek\")) {\n        pizza = new GreekPizza();\n    } else if (type.equals(\"pepperoni\")) {\n        pizza = new PepperoniPizza();\n    // 새로운 3 종류의 피자 추가\n    } else if (type.equals(\"veggie\")) {\n        pizza = new VeggiePizza();\n    } else if (type.equals(\"clam\")) {\n        pizza = new ClamPizza();\n    } else if (type.equals(\"calm\")) {\n        pizza = new CalmPizza();\n    }\n\n    ...\n}\n```\n\n이 때 바뀌는 부분이 새로운 피자를 추가하는 부분이기 때문에, 이를 **캡슐화**하는 것이 좋습니다. 이런 **객체 생성** 부분을 캡슐화하는 것이 바로 **팩토리 패턴**입니다.\n\n---\n\n## 간단한 팩토리를 통한 해결\n\n**간단한 팩토리**는 **객체 생성을 전담**하는 클래스를 만들어서 객체 생성을 **위임**하는 방식입니다. 이를 통해 객체 생성을 캡슐화하고, 클라이언트 코드와 구상 클래스를 **분리**할 수 있습니다.\n\nhead first design pattern에서는 이를 디자인 패턴이 아니라 프로그래밍에서 자주 사용하는 관용구라고 설명합니다. 이는 디자인 패턴의 정의가 인터페이스 구현을 통한 객체의 행동을 캡슐화하는 것이기 때문입니다.\n\n그렇다 하더라도 간단한 팩토리를 사용해서 객체 생성을 캡슐화하는 것은 팩토리 패턴의 기본이 되는 개념이기 때문에 이를 통해 팩토리 패턴을 이해할 수 있습니다.\n\n위의 피자 주문 시스템을 간단한 팩토리를 통해 해결해보겠습니다.\n\n```java\npublic class SimplePizzaFactory {\n    public Pizza createPizza(String type) {\n        Pizza pizza = null;\n\n        if (type.equals(\"cheese\")) {\n            pizza = new CheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new GreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new PepperoniPizza();\n        } else if (type.equals(\"veggie\")) {\n            pizza = new VeggiePizza();\n        } else if (type.equals(\"clam\")) {\n            pizza = new ClamPizza();\n        } else if (type.equals(\"calm\")) {\n            pizza = new CalmPizza();\n        }\n\n        return pizza;\n    }\n}\n\npublic class PizzaStore {\n    SimplePizzaFactory factory;\n\n    public PizzaStore(SimplePizzaFactory factory) {\n        this.factory = factory;\n    }\n\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = factory.createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n}\n```\n\n간단한 팩토리를 통해 객체 생성을 캡슐화했습니다. 이를 통해 피자 주문 시스템의 클라이언트 코드와 구상 클래스를 분리할 수 있습니다.\n\n단순히 객체 생성을 위임했을 뿐으로 보이지만 이를 사용하는 클라이언트가 매우 많을 수도 있고, 서브 클래스로 PizzaShopMenu, NYPizzaFactory, ChicagoPizzaFactory 등을 만들 수 있습니다.\n\n또 간단한 팩토리 클래스로 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n이런 식으로 객체 생성을 캡슐화해서 유연성을 높이는 것이 바로 **팩토리 패턴**의 기본 개념입니다.\n\n---\n\n## 팩토리 메소드 패턴을 통한 해결\n\n그런데 만약에 피자 주문 시스템을 **확장**해서 각 지역마다 다른 종류의 피자를 만들고 싶다면 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자를, 시카고 지역에서는 시카고 피자를 만들고 싶다면 어떻게 해야 할까요?\n\n이런 경우에 **팩토리 메소드 패턴**을 사용할 수 있습니다. 기본 팩토리 패턴에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했다면, 팩토리 메소드 패턴에서는 객체 생성하는 메소드를 **추상화**해서 객체 생성을 추가적으로 캡슐화합니다.\n\n예를 들어 다음과 같이 **createPizza** 메소드를 추상화해서 팩토리 메소드 패턴을 사용할 수 있습니다.\n\n```java\npublic abstract class PizzaStore {\n    public Pizza orderPizza(String type) {\n        Pizza pizza;\n\n        pizza = createPizza(type);\n\n        pizza.prepare();\n        pizza.bake();\n        pizza.cut();\n        pizza.box();\n\n        return pizza;\n    }\n\n    abstract Pizza createPizza(String type);\n}\n\npublic class NYPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new NYStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new NYStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new NYStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n\npublic class ChicagoPizzaStore extends PizzaStore {\n    Pizza createPizza(String type) {\n        Pizza pizza = null;\n        if (type.equals(\"cheese\")) {\n            pizza = new ChicagoStyleCheesePizza();\n        } else if (type.equals(\"greek\")) {\n            pizza = new ChicagoStyleGreekPizza();\n        } else if (type.equals(\"pepperoni\")) {\n            pizza = new ChicagoStylePepperoniPizza();\n        }\n        return pizza;\n    }\n}\n```\n\n이처럼 팩토리 메소드 패턴은 createPizza 메소드를 추상화해서 객체 생성을 캡슐화합니다. 이를 통해 팩토리 메소드 패턴은 객체 생성을 위임하는 과정을 추상화해서 기본 팩토리 패턴보다 더 유연하게 객체 생성을 관리할 수 있습니다.\n\n이 때문에 팩토리 메소드 패턴을 정의할 때, 객체를 생성할 때 필요한 **인터페이스**를 만든 뒤 어떤 클래스 **인스턴스**를 만들지는 **서브 클래스**에서 결정하도록 맡기게 됩니다. 이것은 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n이 때 PizzaStore를 **Creator(생산자)** 클래스, createPizza를 **팩토리 메소드**, Pizza를 **Product(제품)** 클래스라고 합니다.\n\n---\n\n## 팩토리 메소드 패턴을 통해 알아보는 의존성 역전 원칙\n\n위의 팩토리 메소드 패턴을 통해 알 수 있는 것 중 하나가 바로 **의존성 역전 원칙**입니다. 이 원칙은 모듈을 작성할 때 **추상화에 의존**하도록 만들고, **구체화에 의존**하지 않도록 하는 원칙을 말합니다. 다른 말로는, **상위 수준 모듈**은 **하위 수준 모듈**에 의존해서는 안되며, 둘 다 추상화에 의존해야 한다고도 합니다.\n\n기존에 피자 주문 시스템에서는 PizzaStore 클래스가 구상 클래스에 의존하고 있었습니다. 이런 식으로 객체 생성을 위임하는 클래스가 구상 클래스에 의존하게 되면 유연성이 떨어지게 됩니다.\n\n그런데 팩토리 메소드 패턴을 통해 PizzaStore를 구현할 때는 이를 우선 추상화해서 객체 생성을 위임하는 클래스가 추상 클래스에 의존하도록 만들었습니다. 이를 통해 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않도록 만들었습니다.\n\n### 의존성 역전 원칙을 지키는 방법\n\n1. 변수를 사용할 때는 **구상 클래스**가 아닌 **추상 클래스**나 **인터페이스**를 사용합니다.\n2. 구상 클래스에서 **유도된 클래스**를 만들지 않습니다.\n3. 베이스 클래스에서 이미 구현된 **메소드 오버라이드**를 하지 않습니다.\n\n---\n\n## 추상 팩토리 패턴을 통한 해결\n\n여태까지 상황에서 더 나아가, 피자 주문 시스템에서 사용하는 원재료 군에 따른 **제품군**을 만들려면 기존의 방식으로는 어떻게 해야 할까요? 예를 들어 뉴욕 지역에서는 뉴욕 피자와 뉴욕 원재료를, 시카고 지역에서는 시카고 피자와 시카고 원재료를 만들고 싶다면요?\n\n이런 경우에 **추상 팩토리 패턴**을 사용할 수 있습니다. **기본 팩토리 패턴**에서는 객체 생성을 위임하는 클래스를 만들어서 객체 생성을 캡슐화했고, **팩토리 메소드 패턴**에서는 객체 생성을 위임하는 메소드를 추상화해서 객체 생성을 캡슐화했습니다.\n\n추상 팩토리 패턴에서는 객체 생성을 위임하는 **클래스를 인터페이스로 추상화**해서 객체 생성을 캡슐화합니다. 이를 통해 추상 팩토리 패턴은 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다. 구상 클래스는 서브 클래스에서 만듭니다.\n\n예를 들어 다음과 같이 **PizzaIngredientFactory** 인터페이스를 추상화해서 추상 팩토리 패턴을 사용할 수 있습니다.\n\n```java\npublic interface PizzaIngredientFactory {\n    public Dough createDough();\n    public Sauce createSauce();\n    public Cheese createCheese();\n    public Veggies[] createVeggies();\n    public Pepperoni createPepperoni();\n    public Clams createClam();\n}\n\npublic class NYPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n\npublic class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {\n    ...\n}\n```\n\n위와 같이 추상 팩토리 패턴을 사용해서 **객체 생성을 위임**하는 클래스를 **인터페이스**로 **추상화**했습니다. 이를 통해 추상 팩토리 패턴은 객체 생성을 위임하는 클래스가 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공할 수 있습니다.\n\n---\n\n## 결론\n\n팩토리 패턴은 **객체의 생성**을 **캡슐화**하는 디자인 패턴입니다. 이는 공장에서 물건을 만드는 것처럼 클라이언트가 **팩토리 클래스에 위임**해서 객체를 생성하기 때문에, 구상 클래스와 클라이언트 코드를 분리하고 느슨한 결합을 유지해서 유연성을 높일 수 있습니다. 사용자는 물건을 만드는 공장에 요청을 할 뿐, 어떻게 만드는지는 알 필요가 없습니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화해서 사용하는 모듈은 **구상 클래스**에 의존하지 않고, **추상화된 인터페이스**에 의존하게 됩니다. 이는 **의존성 역전 원칙**을 따르는 것을 통해 **느슨한 결합**을 유지하는 하나의 방법입니다.\n\n팩토리 패턴을 통해 객체 생성을 캡슐화하면 이를 사용하는 다양한 클라이언트에서 일일이 객체 생성 코드를 작성하지 않아도 되기 때문에 **유지보수성**이 높아집니다.\n\n팩토리 패턴을 구현하는 방식에 따라 **간단 팩토리 패턴**, **팩토리 메소드 패턴**, **추상 팩토리 패턴**으로 나뉩니다. 이를 통해 객체 생성을 위임하는 방식에 따라 객체 생성을 캡슐화하는 방법을 이해할 수 있습니다.\n","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"팩토리 패턴","subtitle":"공장에서 만든 피자는 피자가 아니라고 생각한거야?","date":"2024-02-15T00:00:00.000Z","categories":"디자인패턴"}},"title":"팩토리 패턴","category":"디자인패턴","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"옵저버 패턴","category":"디자인패턴"},"next":{"title":"커맨드 패턴","category":"디자인패턴"}}},"__N_SSG":true}