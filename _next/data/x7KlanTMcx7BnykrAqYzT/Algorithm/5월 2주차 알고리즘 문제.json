{"pageProps":{"postDataJson":{"postName":"2024-05-12-5월 2주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-12-5월 2주차 알고리즘 문제.md","category":"Algorithm","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","content":"\n### 목차\n\n- [$O(n)$으로 배열 내 요소 간 최대 차이 구하기](#on으로-배열-내-요소-간-최대-차이-구하기)\n- [필요 없는 중간과정 생략하기](#필요-없는-중간과정-생략하기)\n- [3개의 distinct한 subarray를 구하는 방법](#3개의-distinct한-subarray를-구하는-방법)\n\n---\n\n## $O(n)$으로 배열 내 요소 간 최대 차이 구하기\n\n- [문제 링크](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/24a72bfdc9ebdb777c0887f068e034b4a5994eea)\n\n- 문제 요약\n  - int array가 주어졌을 때, i < j이고 A[i] < A[j]인 경우에 A[j] - A[i]의 최대값을 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - Time Complexity: $O(n^2)$\n    - i < j이고 A[i] < A[j]인 경우에 A[j] - A[i]의 최대값을 구하라는 것은 A[j] - A[i]의 최대값을 구하라는 것과 같다.\n    - 따라서, A[j] - A[i]의 최대값을 구하기 위해 이중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n  - 개선 풀이\n    - Time Complexity: $O(n)$\n    - A[j] > A[i]인 경우에는 기존의 max값과 비교하여 최대값을 갱신하면 된다.\n    - 그렇지 않을 경우에는 i를 j로 갱신한다.\n\n```python\ndef maxDifference(self, nums: List[int]) -> int:\n    max_diff = -1\n    min_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] > min_val:\n            max_diff = max(max_diff, nums[i] - min_val)\n        else:\n            min_val = nums[i]\n    return max_diff\n```\n\n---\n\n## 필요 없는 중간과정 생략하기\n\n- [문제 링크](https://leetcode.com/problems/most-visited-sector-in-a-circular-track/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/258ed1fa5264557b7b557ca3fa64681ea666ffd2)\n\n- 문제 요약\n  - n개의 섹터가 있는 원형 트랙이 주어졌을 때, 1번 섹터부터 n번 섹터까지 순서대로 방문한 횟수를 구하라.\n- 풀이 요약\n  - 기존 풀이\n    - n번째 섹터까지 방문한 횟수를 구하기 위해 n번째 섹터까지의 방문 횟수를 구하고, n번째 섹터까지의 방문 횟수를 구하는 과정을 반복한다.\n  - 개선 풀이\n    - 어차피 한 바퀴를 돌 경우에 모든 섹터의 방문 횟수는 동일하다.\n    - 따라서 1번 섹터부터 n번 섹터까지의 방문 횟수를 구하는 것은 필요 없는 중간과정이다.\n    - 이 때문에 처음과 끝만 보면 된다.\n\n```python\ndef mostVisited(self, n: int, rounds: List[int]) -> List[int]:\n    start, end = rounds[0], rounds[-1]\n    if start <= end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(1, end + 1)) + list(range(start, n + 1))\n```\n\n---\n\n## 3개의 distinct한 subarray를 구하는 방법\n\n- [문제 링크](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/23a38f7e9cdb25411befaf5abec233e44adec5a6)\n\n- 문제 요약\n  - int array가 주어졌을 때, 3개의 distinct한 subarray를 구하고 각 subarray의 합이 최소가 되도록 하라.\n  - subarray는 연속된 요소들의 집합이다.\n- 풀이 요약\n  - Time Complexity: $O(n^2)$\n  - 3개의 subarray를 구하기 위해 2중 for문을 사용하여 모든 경우의 수를 비교하면 된다.\n\n```go\nfunc minCost(nums []int) int {\n    n := len(nums)\n\n    minCost := math.MaxInt32\n    for i := 1; i < n - 1; i++ {\n        for j := i + 1; j < n; j++ {\n            cost := nums[0] + nums[i] + nums[j]\n            minCost = min(minCost, cost)\n        }\n    }\n    return minCost\n}\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 2주차 알고리즘 문제","subtitle":"과연 중간 과정은 꼭 필요할까?","date":"2024-05-12T00:00:00.000Z","categories":"Algorithm"}},"title":"5월 2주차 알고리즘 문제","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"5월 1주차 알고리즘 문제","category":"Algorithm"},"next":{"title":"Dynamic Programming","category":"Algorithm"}}},"__N_SSG":true}