{"pageProps":{"postDataJson":{"postName":"2024-05-05-5월 1주차 알고리즘 문제","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/Algorithm/Weekly Algorithms/2024-05-05-5월 1주차 알고리즘 문제.md","category":"Algorithm","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","content":"\n### 목차\n\n- [두 수가 교차하는 경우의 수를 다루는 방법](#두-수가-교차하는-경우의-수를-다루는-방법)\n\n---\n\n## 두 수가 교차하는 경우의 수를 다루는 방법\n\n- [문제 링크](https://leetcode.com/problems/semi-ordered-permutation/description/)\n- [내 풀이](https://github.com/kaestro/algorithms_v3/commit/eb87856177f2836c0da339976e9473f63910c9dc)\n\n- 문제 요약\n  - Semi-Ordered Permutation이란, 처음이 가장 작은 수이고 가장 마지막이 가장 큰 수이며, 중간에는 어떤 수든 나타날 수 있는 순열이다.\n  - 순열이 주어졌을때 인접한 두 수를 swap하여 Semi-Ordered Permutation을 만드는 최소 교환 횟수를 구하라.\n- 풀이 요약\n  - 가장 작은 수가 1에 도착하는 횟수 + 가장 큰 수가 n에 도착하는 횟수를 구하면 된다.\n  - **이 때 두 수가 교차하는 경우 1을 빼주면 된다.**\n\n```python\ndef semiOrderedPermutation(self, A: List[int]) -> int:\n    n = len(A)\n    i, j = A.index(1), A.index(n)\n    return i + n - 1 - j - (i > j)\n```\n","layout":"mathjax","recommended":false,"data":{"layout":"mathjax","classes":"wide","title":"5월 1주차 알고리즘 문제","subtitle":"두 수가 교차하는 경우의 수를 다루는 방법","date":"2024-05-05T00:00:00.000Z","categories":"Algorithm"}},"title":"5월 1주차 알고리즘 문제","category":"Algorithm","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"4월 5주차 알고리즘 문제","category":"Algorithm"},"next":{"title":"5월 2주차 알고리즘 문제","category":"Algorithm"}}},"__N_SSG":true}