{"pageProps":{"postDataJson":{"postName":"2024-03-19-Chat Application review(5)","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발일지/Chat Application 개발일지/2024-03-19-Chat Application review(5).md","category":"개발일지","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","content":"\n## 목차\n\n1. **느낀 점**\n2. **진행 내용**\n3. **문제 및 해결 방법**\n\n---\n\n## 느낀 점\n\n* **기술 스택**을 선택할 때, **명확한 기준**을 통한 비교를 할 필요성을 체감\n* 당장 수요에 맞는 **가벼운 기술**을 선택하되, 규모가 커질 것을 대비하여 **확장성**을 고려해야 함.\n* **MVP**(Minimum Viable Product)를 정의 내리고 이를 기준으로 기존 **기술 스택 선택**이 **타당성**을 검토해야 함.\n* **결론**:\n  * **MVP**: postgresql, redis, rabbitMQ, golang - gin\n  * **확장**: mysql, memcached, kafka, mongodb\n\n---\n\n## 진행 내용\n\n* **설계도**에서 서비스별 사용하기로 한 **기술스택**에 대한 대안 검토\n  * [**설계도 링크**](https://github.com/kaestro/ChatApplication/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EB%8F%84)\n\n---\n\n## 문제 및 해결 방법\n\n### [1] **기술 스택** 선택에 대한 명백한 **근거** 부족\n\n* 기술 스택 선택에 대한 **명백한 근거**가 부족.\n* 현재 기술 스택의 **장단점**을 명확히 파악하지 못하고 있음.\n* 단순히 **유명하고 핫하기 때문**에 선택한 경우가 많음.\n* 기술 스택의 **장점**을 **활용**하지 못하고 있음.\n* 이에 따라 **이미 사용 가능한 기술**을 충분히 활용하지 못하고 있음.\n* **프로젝트가 진행**되기보다 새로운 기술을 학습하는 데 더 많은 시간을 할애하고 있음.\n\n### [1] 해결 방법\n\n* 모듈 혹은 서비스 별로 사용되는 **기술스택**의 **대안**을 조사하고, 이에 대한 **비교**를 통해 명확한 기준을 세움.\n\n* **웹서버**\n  * 현재 사용중인 기술 스택: **golang - gin**\n  * **대안**: node.js - express, java - spring boot, python - fast api\n  * **기존 기술** 선택 이유: golang이 가진 **웹서버 성능** 및 **동시성 처리**에 대한 장점.\n  * 의문점\n    * 다른 기술 스택에 비해 **golang**은 어떤 점에서 **동시성 처리**에 더 유리하다고 말할 수 있는가?\n      * **[Golang은 진정 동시성을 처리하는 데 유리한가?](https://kaestro.github.io/%EA%B0%9C%EB%B0%9C%EC%9D%B4%EC%95%BC%EA%B8%B0/2024/03/19/Golang%EC%9D%80-%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%B4-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%97%90%EC%84%9C-%EC%9C%A0%EB%A6%AC%ED%95%9C%EA%B0%80.html)**\n* **데이터베이스**\n  * 현재 사용중인 기술 스택: **postgresql**\n  * 대안: **mysql**\n  * **기존 기술** 선택 이유: 사용 **경험**이 있음\n  * 조사 결과 PostgreSQL은 mySQL에 비해 **복잡한 동작**을 필요로 할 때 사용하는 기술 스택으로 알려져 있다.\n    * **<https://www.integrate.io/ko/blog/postgresql-vs-mysql-which-one-is-better-for-your-use-case-ko/>**\n  * 팀원들도 mysql에 경험이 더 많은 편이므로, **mysql로 이전**하도록 생각하고 있다.\n* **NoSQL**\n  * 현재 사용중인 기술 스택: **mongodb**\n  * 대안: 유저 정보 저장에 사용하는 **SQL 데이터베이스**에서의 통합\n  * 기존 기술 **선택 이유**: **문서형 데이터베이스**로서 가지는 장점이 있다는 점.\n  * **문제점**\n    * 그 장점이 뭔지 모름\n    * 문서형 데이터베이스가 무엇인지도 잘 모름\n  * **mongoDB**의 장점\n    * **데이터 형태**에 구애를 덜 받으므로 **이모티콘**과 같은 string 외 **다양한 데이터**를 처리하는 데에 용이하다\n    * **채팅 방 단위**로 데이터를 구현시에 **기존 데이터**를 **신규 입장자**에게 제공하기 유리하다\n  * **RDBMS**의 장점\n    * string만 사용할 경우 table과 로직을 통해서 **기초적인 채팅**을 **빠르게 구현**할 수 있다.\n  * **선택**: **RDBMS**(mysql/postgresql) 중에 하나로 **채팅의 interface**를 구현하고, **string에 한정**한 뒤 방 입장시에 **접속 이전 데이터**를 제공하지 않는 방향으로 **mvp**를 구성한 뒤에 기능을 **확장**하는 과정에서 **mongoDB** 도입을 고려한다.\n  * **추가**적인 mongoDB 및 문서형 데이터베이스에 대한 **연구** 필요\n* **세션**\n  * 현재 사용중인 기술 스택: **redis**\n  * 대안: **memcached**, 세션이 아닌 **토큰**(JWT 등)을 사용\n  * 기존 기술 **선택 이유**\n    * 사용해 본 적이 있는 기술 스택\n    * 유명해서 자료를 구하는 것이 용이\n  * 참고 자료\n    * [**Redis vs Memcached**](https://velog.io/@sileeee/Redis-vs-Memcached)\n    * [**Session storage로 적합한 데이터 베이스는 무엇일까? (Redis vs Memcached)**](https://1-7171771.tistory.com/127)\n    * [**Memcached vs Redis: Choose Your In-Memory Cache**](https://kinsta.com/blog/memcached-vs-redis/)\n  * **Memcached**\n    * 장점\n      * 적은 **메모리 사용량** - 적은 메타 데이터\n      * 안정적인 **응답 시간**\n      * **데이터 변경이 적은 경우** 메모리 파편화가 적음\n      * **수평적 확장**이 쉬움 - **multi-threading** 지원\n    * 단점\n      * 적은 **데이터 타입**과 **API**\n      * **데이터 변경이 잦은 경우**에 파편화가 많이 발생\n  * **Redis**\n    * 장점\n      * 다양한 **데이터 타입**과 **기능**\n      * 많은 사용자\n      * **디스크**에 저장 가능\n      * **Key**에 저장할 수 있는 **데이터의 크기**가 큼\n      * **pub/sub**을 지원해서 **메시지 큐**로도 사용 가능\n    * 단점\n      * **메모리 사용량**이 많음(실제 필요량보다 **2배** 가까이 사용하는 구조)\n      * 트래픽이 많은 경우 **응답 시간**이 불안정 - **발생 가능성 낮음**\n  * **선택**\n    * **MVP**의 관점에서 더 빠르게 시작할 수 있는 것은 Redis이다. 이는 **기능 및 데이터 타입**을 여럿 이미 구현돼 있기 때문이다.\n    * 트래픽이 많은 경우에 응답 시간이 얼마나 불안정해지는지 **측정**할 방법을 마련해두고, 그에 따라 **Memcached**로 전환할지 여부를 결정한다.\n    * Redis를 사용하면 다른 기술 스택 없이 **메시지 큐**를 처리할 수 있을 지도 모름\n* **메시지 큐**\n  * 현재 **사용 예정**이었던 기술 스택: **kafka**\n  * 대안: **RabbitMQ**, **ActiveMQ**\n  * 기존 기술 **선택 이유**\n    * 메시지 큐 기술들 중 가장 **유명**해서.\n  * 추가적으로 따로 글을 파서 고민해봐야 할 듯\n  * **참고 자료**\n    * **<https://gwonbookcase.tistory.com/49>**\n    * **<https://www.cloudamqp.com/blog/activemq-vs-rabbitmq-an-indepth-comparison.html>**\n  * **kafka**의 장점\n    * **분산 처리 기능**을 가장 잘 활용할 수 있음.\n    * 메모리가 아니라 **파일 시스템**을 이용한다.\n    * **TPS**가 높고 **대용량 실시간 로그 처리**에 유리하다\n    * broker가 **push**하는 것이 아니라 **pull**하는 방식\n  * **activeMQ** vs **rabbitMQ**\n    * rabbitMQ가 **더 다양한 프로토콜**을 지원하고, activeMQ는 **java**에 더 특화된 모양이라 이 부분은 연구 필요\n  * **선택**\n    * **RabbitMQ**로 MVP를 구현하고, **확장성**이 필요할 경우 **Kafka**로 전환하는 방향으로 진행한다.\n    * RabbitMQ가 kafka에 비해 보다 기능이 **간단**하고 **빠르게 구현**할 수 있을 것으로 예상되기 때문\n","layout":"series","recommended":false,"data":{"layout":"series","series":"Chat Application 개발일지","seriesIndex":5,"classes":"wide","title":"ChatApplication Review(5)","subtitle":"기술 스택에 대한 점검","date":"2024-03-19T00:00:00.000Z","categories":"개발일지"}},"title":"ChatApplication Review(5)","category":"개발일지","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"ChatApplication Review(4)","category":"개발일지"},"next":{"title":"ChatApplication Review(6)","category":"개발일지"}}},"__N_SSG":true}