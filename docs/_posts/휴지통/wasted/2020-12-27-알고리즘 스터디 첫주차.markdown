---
layout: default
title:  "알고리즘 스터디 2주차!"
categories: Legacy
date:   2020-12-28 20:20:23 +0900
published: false
---

지난번에 취준생이라 하셨던 한 분은 단톡방을 나가면서 스터디를 그만두게 되셨고, codeforce round round #692의 Div.2를 가지고 스터디를 진행했다.


## 같이 푼 문제

나는 A, B 두 문제만 해결했고 A, C를 해결해 오신 분도 있고 A, D를 해결해오신 분도 있었다.

### D

D 문제는 sequence가 있을 때 01, 10 형태로 만들 수 있는 모든 subsequence에 점수를 매길 때, 우리에게 0과 1, ?로 이루어진 sequence가 있을 경우 가장 높은? 낮은? 점수를 계산하는 것이었다.

이 문제를 어떻게 접근하는지, dp일 수 있겠다는 생각 정도만 하고 감을 못 잡았는데, 이제 와 보니 첫번째로는 완벽한 sequence가 주어졌을 때 점수를 계산할 방법부터 출발해야 했던 것 같다. 그리고 dean님께서 이야기하신 팁은 **subsequence가 나온다면 dp일 가능성이 높다**라는 것.

그 관점에서 앞에서부터 0의 개수를 세고, 1의 개수를 세놓은 값을 저장한 다음, 다음의 값이 1이거나 0일 때 그 값을 키우면서 점수를 계산하면 된다는 것. 이 다음에 ?에 대해서는 greedy가 아닐까하는 추측을 하셨다.


### B

B 문제는 나는 풀었고, 민기님이셨던가? 못 풀어 오셨었는데, 그 이유는 c style array를 initialize할 때 0으로 명시해두지 않으면 서버에 있는 compiler가 그것을 초기화해주지 않았기 때문이다.

visual studio의 compiler는 이를 0으로 맞춰주지만, 테스트 환경에서는 memory 안의 dummy값을 불러들인 것으로 보인다.

### C

C 문제는 굉장히 재밌는 문제였다. 이름도 peaceful rooks 아닌가. 룩을 처음에 체스판 위에 서로 공격할 수 없는 위치에 두고, 이들이 대각선 위에 올라갈 때까지 필요한 최소의 움직임 수를 계산하는 것이었다.

나도 아이디어는 떠올렸는데, 이를 코드로 만들려면 어떻게 해야하는지를 생각을 못 했었다. 그런데 cycle을 detection하는 거라면 결국 dfs, 혹은 union find를 통한 disjoint set을 구하는 것 말고 무엇이 있겠는가!

또 나는 dfs를 사용할 때 2차원 배열을 사용해야한다는 생각에 겁먹어 문제를 해결하지 못했는데, 이 문제는 가로 세로의 좌표만 필요하다는 생각으로 1차원 배열을 두 개 사용해서 문제를 해결하시는 것이 너무 멋있었다.


## 향후 방향성

백기선씨의 알고리즘 스터디 잘 하려면 어떻게 해요?라는 영상을 보고, 스터디의 구체적인 목표가 필요하다는 생각을 했다. 내가 선택한 목표는 google kickstart.

google kickstart는 구글이 정기적으로 주최하는 알고리즘 대횐데, 찾아보니 꾸준히 상위권에 올라가면 면접 기회도 주어진다는 모양이더라. 다음에 있을 kickstart는 3월이기 때문에 3개월 정도 기간을 잡고 스터디를 진행하면 좋을 거라는 생각이 들었다.

그리고 이번에 합류하셨던 분께서도 감사하게도 함께 해주시겠다는 이야기를 해주셨다

## 오늘 있을 일

오늘은 드디어 컴투스 최종 면접을 보러 가는날이다. 잘 보고 돌아와서 붙었다는 이야기도 포스팅할 수 있으면 좋겠다.