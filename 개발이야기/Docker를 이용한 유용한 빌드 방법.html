<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9d2484721dfb0fa3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d2484721dfb0fa3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d837742cb9035689.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d837742cb9035689.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-35b92941fc8726f9.js" defer=""></script><script src="/_next/static/chunks/framework-381da54bc5986544.js" defer=""></script><script src="/_next/static/chunks/main-d08cdb1c11d062c5.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6411096b10c6b62.js" defer=""></script><script src="/_next/static/chunks/441-45d334119e93ce4f.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bcategory%5D/%5Btitle%5D-54be7db8139f8b64.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_buildManifest.js" defer=""></script><script src="/_next/static/x7KlanTMcx7BnykrAqYzT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><header class="page-header"><h1 class="project-name">Docker를 이용한 유용한 빌드 방법</h1><h1 class="project-subtitle">멀티 스테이지 빌드</h1></header><main id="content" class="main-content"><div><aside id="category-list" aria-label="Category List"><h2>Categories</h2><ul><li><a href="/ETC">ETC</a></li><li><a href="/개발이야기">개발이야기</a></li><li><a href="/개발일지">개발일지</a></li><li><a href="/디자인패턴">디자인패턴</a></li><li><a href="/Algorithm">Algorithm</a></li><li><a href="/서평">서평</a></li><li><a href="/WeeklyPosts">WeeklyPosts</a></li><li><a href="/신변잡기">신변잡기</a></li><li><a href="/게임이야기">게임이야기</a></li></ul></aside><div><p>해당 내용은 <a target="_self" href="https://github.com/sixeyed/diamol" title="null">쿠버네티스 교과서 부록</a>의 내용을 참고하여 작성하였습니다.</p>
<hr>

      <h2 id="멀티-스테이지-빌드란">
        <a name="멀티-스테이지-빌드란" class="anchor" href="#멀티-스테이지-빌드란">
          <span class="header-link"></span>
        </a>
        멀티 스테이지 빌드란
      </h2><p>Docker에서 <strong>멀티 스테이지 빌드</strong>는 여러개의 <strong>FROM 명령어</strong>를 사용하여 <strong>여러개의 이미지</strong>를 생성하는 방법입니다. 이를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다.</p>
<p>다음 두 빌드 dockerfile을 비교해보겠습니다.</p>
<hr>

      <h2 id="예시">
        <a name="예시" class="anchor" href="#예시">
          <span class="header-link"></span>
        </a>
        예시
      </h2>
      <h3 id="단일-스테이지-빌드">
        <a name="단일-스테이지-빌드" class="anchor" href="#단일-스테이지-빌드">
          <span class="header-link"></span>
        </a>
        단일 스테이지 빌드
      </h3><pre><code class="language-dockerfile">FROM diamol/golang 

WORKDIR web
COPY index.html .
COPY main.go .

RUN go build -o /web/server
RUN chmod +x /web/server

CMD [&quot;/web/server&quot;]
ENV USER=sixeyed
EXPOSE 80
</code></pre>

      <h3 id="멀티-스테이지-빌드">
        <a name="멀티-스테이지-빌드" class="anchor" href="#멀티-스테이지-빌드">
          <span class="header-link"></span>
        </a>
        멀티 스테이지 빌드
      </h3><pre><code class="language-dockerfile">FROM diamol/golang AS builder

COPY main.go .
RUN go build -o /server
RUN chmod +x /server

#app
FROM diamol/base

EXPOSE 80
CMD [&quot;/web/server&quot;]
ENV USER=&quot;sixeyed&quot;

WORKDIR web
COPY --from=builder /server .
COPY index.html .
</code></pre>
<p>둘은 동일한 go로 작성된 웹 서버를 빌드하는 dockerfile입니다. 하지만 두번째 dockerfile은 <strong>멀티 스테이지 빌드</strong>를 사용하여 빌드 <strong>프로세스를 단순화하고 이미지 크기를 줄였습니다.</strong> 해당 방법을 통해 대략 5.2GB의 크기였던 기존의 이미지는 260MB 수준으로 줄어들게 됩니다.</p>
<p>처음으로 멀티 스테이지가 적용된 부분은 처음에 <strong>FROM diamol/golang AS builder</strong> 부분으로 여기에서 빌드를 수행했습니다.</p>
<p>그 다음으로 멀티 스테이지가 적용된 부분은 <strong>FROM diamol/base</strong> 부분으로 여기에서 빌드가 완성된 실행 파일만을 web 디렉토리에 복사하여 사용했습니다.</p>
<hr>

      <h2 id="결과">
        <a name="결과" class="anchor" href="#결과">
          <span class="header-link"></span>
        </a>
        결과
      </h2><p>Docker의 <strong>멀티 스테이지 빌드</strong>를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다. 또 불필요한 파일이 제거됐기 때문에 <strong>공격 표면</strong>이 줄어들어 <strong>보안도 강화</strong>됐습니다.</p>
</div><div style="display:flex;flex-direction:column;gap:1em"><div><a href="/개발이야기/시스템 설계 방법">이전 포스트: <!-- -->시스템 설계 방법</a></div><div style="text-align:right"><a href="/개발이야기/동시성(Concurrency)과 Golang">다음 포스트: <!-- -->동시성(Concurrency)과 Golang</a></div></div><div><button id="go-home" class="home-button-container">Home</button></div><div><button type="button" id="go-top" class="scroll-top" aria-label="top"></button></div><div><button type="button" id="go-bottom" class="scroll-bottom" aria-label="bottom"></button></div></div><hr/></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postDataJson":{"postName":"2024-03-13-Docker - 멀티 스테이지 빌드","fullPath":"/home/runner/work/kaestro.github.io/kaestro.github.io/_posts/개발/개발이야기/2024-03-13-Docker - 멀티 스테이지 빌드.md","category":"개발이야기","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","content":"\n해당 내용은 [쿠버네티스 교과서 부록](https://github.com/sixeyed/diamol)의 내용을 참고하여 작성하였습니다.\n\n---\n\n## 멀티 스테이지 빌드란\n\nDocker에서 **멀티 스테이지 빌드**는 여러개의 **FROM 명령어**를 사용하여 **여러개의 이미지**를 생성하는 방법입니다. 이를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다.\n\n다음 두 빌드 dockerfile을 비교해보겠습니다.\n\n---\n\n## 예시\n\n### 단일 스테이지 빌드\n\n```dockerfile\nFROM diamol/golang \n\nWORKDIR web\nCOPY index.html .\nCOPY main.go .\n\nRUN go build -o /web/server\nRUN chmod +x /web/server\n\nCMD [\"/web/server\"]\nENV USER=sixeyed\nEXPOSE 80\n```\n\n\n### 멀티 스테이지 빌드\n```dockerfile\nFROM diamol/golang AS builder\n\nCOPY main.go .\nRUN go build -o /server\nRUN chmod +x /server\n\n#app\nFROM diamol/base\n\nEXPOSE 80\nCMD [\"/web/server\"]\nENV USER=\"sixeyed\"\n\nWORKDIR web\nCOPY --from=builder /server .\nCOPY index.html .\n```\n\n둘은 동일한 go로 작성된 웹 서버를 빌드하는 dockerfile입니다. 하지만 두번째 dockerfile은 **멀티 스테이지 빌드**를 사용하여 빌드 **프로세스를 단순화하고 이미지 크기를 줄였습니다.** 해당 방법을 통해 대략 5.2GB의 크기였던 기존의 이미지는 260MB 수준으로 줄어들게 됩니다.\n\n처음으로 멀티 스테이지가 적용된 부분은 처음에 **FROM diamol/golang AS builder** 부분으로 여기에서 빌드를 수행했습니다.\n\n그 다음으로 멀티 스테이지가 적용된 부분은 **FROM diamol/base** 부분으로 여기에서 빌드가 완성된 실행 파일만을 web 디렉토리에 복사하여 사용했습니다.\n\n---\n\n## 결과\n\nDocker의 **멀티 스테이지 빌드**를 통해 빌드 프로세스를 단순화하고 이미지 크기를 줄일 수 있습니다. 또 불필요한 파일이 제거됐기 때문에 **공격 표면**이 줄어들어 **보안도 강화**됐습니다.","layout":"default","recommended":false,"data":{"layout":"default","classes":"wide","title":"Docker를 이용한 유용한 빌드 방법","subtitle":"멀티 스테이지 빌드","date":"2024-03-13T00:00:00.000Z","categories":"개발이야기"}},"title":"Docker를 이용한 유용한 빌드 방법","category":"개발이야기","categories":["ETC","개발이야기","개발일지","디자인패턴","Algorithm","서평","WeeklyPosts","신변잡기","게임이야기"],"adjacentPosts":{"prev":{"title":"시스템 설계 방법","category":"개발이야기"},"next":{"title":"동시성(Concurrency)과 Golang","category":"개발이야기"}}},"__N_SSG":true},"page":"/[category]/[title]","query":{"category":"개발이야기","title":"Docker를 이용한 유용한 빌드 방법"},"buildId":"x7KlanTMcx7BnykrAqYzT","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>